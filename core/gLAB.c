/****************************************************************************
   Copyright & License:
   ====================
   
   Copyright 2009 - 2024 gAGE/UPC & ESA
   
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
   
   http://www.apache.org/licenses/LICENSE-2.0
   
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 ***************************************************************************/

/****************************************************************************
 * Copyright: gAGE/UPC & ESA
 * Project: EDUNAV GNSS Lab Tool 
 * Supervisor: Jaume Sanz Subirana (group of Astronomy and GEomatics - gAGE/UPC)
 * Author: Pere Ramos-Bosch (group of Astronomy and GEomatics - gAGE/UPC)
 * Curator: Adria Rovira-Garcia ( gAGE/UPC )
 * Developers: Deimos Ibanez Segura ( gAGE/UPC )
 *             Jesus Romero Sanchez ( gAGE/UPC )
 *          glab.gage @ upc.edu
 * File: gLAB.c
 * Code Management Tool File Version: 6.0  Revision: 0
 * Date: 2024/11/22
 ***************************************************************************/

/****************************************************************************
 * MODULE DESCRIPTION
 *
 * Name: gLAB
 * Language: C
 *
 * Purpose:
 *  The purpose of this module is to create the main executable and parse all the
 *  command-line options
 *
 * Function:
 *  This class is in charge of organising the rest of the modules, creating the 
 *  chain process, and to parse all the command-line options.
 *
 * Dependencies:
 *  dataHandling, input, preprocessing, model, filter, output
 *
 * Files modified:
 *  None
 *
 * Files read:
 *  None
 *
 * Resources usage:
 *  See Design Document
 ****************************************************************************/

/****************************
 *       RELEASE_HISTORY
 * -------------
 *          gLAB v1.3.1
 * Release: 2010/01/22
 * Change Log: First public version
 * -------------
 *          gLAB v1.3.2
 * Release: 2010/02/02
 * Change Log: Corrected problem with the Orbit comparison
 *             Exported SATDIFF, SATSTAT and SATSTATTOT printing to output module
 *             For orbit comparison mode, it can now disconnect the satellite phase centre
 *             For orbit comparison mode, when satellite phase centre correction is active,
 *                  it will now require an ANTEX or Constellation file
 *             Included SHOWPRODUCT mode
 *             Added --output parameter
 *             Enhanced parsing of antenna in ANTEX file
 *             Included show product mode
 *             '-input:SP3' parameter can now be provided as '-input:sp3'
 *             Corrected some typos in the help
 *             Changed '-output' to '-output:file'
 *             Included the '--output:file' option to redirect to stdout 
 *             Changed the message help to be consistent with the new updates
 *             minArcLength changed from 3 to 4 to be sure that the Li cycle-slip detector 
 *                  has properly worked
 *             Included DCB data sources
 *             Forward/Backward processing included
 *             SATSTAT message will now provide the GNSS system it refers to
 *             '-pre:setrectype' option is added to force a specific receiver type
 * -------------
 *          gLAB v1.4.0
 * Release: 2010/06/21
 * Change Log: '-pre:flexibleC1P1' option is added to allow flexible handling of C1 and P1
 *             '-pre:prealign' option to set/unset carrier-phase prealignment
 *             Cycle-slip detector changed to specify when it does not have enough measurements
 *             Added a check to see if the RINEX observation file has times inside the products
 *                  file provided
 * -------------
 *          gLAB v1.4.1
 * Release: 2010/07/09
 * Change Log: No changes in this file.
 * -------------
 *          gLAB v1.4.2
 * Release: 2010/07/31
 * Change Log: No changes in this file.
 * -------------
 *          gLAB v1.4.3
 * Release: 2010/08/31
 * Change Log: Maximum number of filter iterations added.
 * --------------
 *          gLAB v1.4.4
 * Release: 2010/09/22
 * Change Log: Included new DCB management parsing options.
 * -------------
 *          gLAB v1.4.5
 * Release: 2010/10/31
 * Change Log: Tropospheric correction '-model:trop' option is extended to '-model:trop' to activate/deactivate
 *             '-model:trop:nominal <nominal>' to select the nominal used '-model:trop:mapping <mapping>' to 
 *             select which mapping is used. This permits cross combinations among mappings and nominals.
 *             Default precise orbit interpolation degree changed from 9 to 10.
 *             Filter 'inf' value for clock and coordinates noise process and initial covariance substituted
 *                  to real floating quantities. SIGMA_INF splitted into different SIGMA_INF_DR and SIGMA_INF_DT.
 * -----------
 *          gLAB v2.0.0
 * Release: 2012/12/31
 * Change Log: gLAB version released together with the Educational Book:
 *             "GNSS Data Processing" (Vol. 1 and Vol. 2). ESA TM-23.
 *             Authors: J. Sanz Subirana, J.M. Juan Zornoza and M. Hernandez-Pajares
 *             ISBN: 978-92-9221-885-0 (two volumes)
 *             ISSN: 1013-7076
 *             December 2012.
 *
 *             SATSEL debugging message included in the help messages.
 * -----------
 *          gLAB v2.2.0
 * Release: 2014/09/22
 * Change Log: Added input parameters and options for BeiDou, IONEX, Fast-PPP and NeQuick ionosphere models.
 *         Added input parameters and options for Galileo troposphere model.
 *         Added input parameters and options for IONEX and Fast-PPP DCBs.
 *         Added input parameters and options for using standard deviation data from IONEX or FPPP.
 *         Added the capability to gather the full path of gLAB's executable (platform dependent).
 *          This is necessary because Galileo and NeQuick models require data files, and these files will
 *          be searched in the folders ./model_files/TropoGal or ./model_files/NeQuick, 
 *          where ./ is the directory of gLAB's executable (which may be different
 *          from the current user's directory).
 *         Added code for displaying correctly spanish characters.
 *         Help message has been updated with the new parameters.
 * -----------
 *          gLAB v2.2.1
 * Release: 2014/12/23
 * Change Log: No changes in this file.
 * -----------
 *          gLAB v2.2.2
 * Release: 2015/03/02
 * Change Log: Locale selection eliminated in order to avoid problems with number (depending on the locale, 
 *               printf may use a comma instead of a dot for decimal separator)
 * -----------
 *          gLAB v2.2.3
 * Release: 2015/05/28
 * Change Log: Added parameter to select the correction of satellite phase variations.
 *             Added parameter to select the correction of receiver phase variations.
 *             Modified storage of antenna structure (before only saved the antenna phase center values).
 * -----------
 *          gLAB v2.2.4
 * Release: 2015/07/01
 * Change Log: gLAB version is now printed at the beginning of the INFO field.
 * -----------
 *          gLAB v2.2.5
 * Release: 2015/10/20
 * Change Log: Fixed incorrect backward processing when reading an observation file with Linux file ending in Windows.
 *             Added protection against buffer overflow in input parameters.
 * -----------
 *          gLAB v2.2.6
 * Release: 2015/11/25
 * Change Log: No changes in this file.
 * -----------
 *          gLAB v2.2.7
 * Release: 2016/03/01
 * Change Log: No changes in this file.
 * -----------
 *          gLAB v2.2.8
 * Release: 2016/04/12
 * Change Log: No changes in this file.
 * -----------
 *          gLAB v3.0.0
 * Release: 2016/09/05 
 * Change Log: Added SBAS processing.
 *             Added functions to add user-defined error to raw measurements.
 *             Configuration file now accepts paths and filenames with spaces.
 *             Modified structure definitions for handling cycle-slip and large SP3 files variables.
 *             Added check for time span in compareOrbits and showProduct functions (in some cases the broadcast files has data from many different days ago).
 * -----------
 *          gLAB v3.1.0
 * Release: 2016/09/26
 * Change Log: Added '-model:brdctranstime' input parameter.
 *             Added 'calculateRINEX' and 'calculateUSER' options for '-pre:setrecpos' input parameter.
 *             Added '-model:initcoordnpa' input parameter for SBAS.
 *             Slightly modified main loop to enable model recomputation after entering Kalman function.
 *             Updated 'MESSAGES FORMAT' help.
 * -----------
 *          gLAB v3.1.1
 * Release: 2016/10/21
 * Change Log: LLI cycle-slip detector is now enabled by default in PPP.
 *             L1C1 cycle-slip detector is now disabled by default in SPP.
 *             Transmission time of broadcast navigation messages check is now disabled by default in SBAS processing.
 *             Fixed wrong order of MEAS prints in SBAS mode.
 *             Parameter '-pre:cs:l1c1:init' is now shown in the help message.
 * -----------
 *          gLAB v4.0.0
 * Release: 2017/03/03
 * Change Log: Added DGNSS processing.
 *             Added DGNSS converter.
 *             Added SBAS plots mode.
 *             Added computation of SBAS summary when navigating with SBAS corrections, INFO message is active and receiver position is fixed.
 *             Added option to start computing SBAS summary and Stanford-ESA values at the beginning of the next day.
 *             Added option to generate a KML file from the output.
 *             Added option to generate a KML file from the output with height 0 (KML with the ground projection).
 *             Added options for adding timestamps in KML file. The timestamps can be decimated and also write at certain time regions (defined by the user).
 *             Added options to generate a SP3 file from the output.
 *             Added check for smoothing options. If number of smoothing options is given but not the carrier phase measurement
 *               to smooth with (or viceversa), it will show an error instead of continuing without any smoothing.
 *             Added option to disable check for pseudorange jumps.
 *             Added options for Stanford-ESA LOI (Loss of Integrity) data file (for its filename and the thresholds)
 *             Added parameter '-model:maintaingeo' for SBAS GEO switching.
 *             Added options for setting to zero SBAS corrections, sigmas and degradation terms.
 *             Added check for number of entries in SP3 header. If it is incorrect, it will print an error instead of crashing
 *               or showing incorrect values.
 *             Added check for number of entries in IONEX header. If it is incorrect, it will print an error instead of crashing
 *               or showing incorrect values.
 *             Added option to skip epoch or change processing mode when GDOP is over a given threshold.
 *             Added check for the number of measurements entered for the filter, to ensure they are not greater than the maximum.
 *             Added check for options '-input:sp3', '-input:orb' and '-input:clk'. When 'input:sp3' parameter is given along with
 *               'input:orb' or '-input:clk', it will show an ERROR message instead of just using the sp3 file for orbits and clocks.
 *             Added options for maximum data gap check between samples when using precise orbits and clocks.
 *             Added option to allow adding the user defined error after the preprocessing.
 *             When a SINEX file is given, the receiver position will automatically switch to SINEX mode (no need to put the
 *                '-pre:setrecpos SINEX' parameter like in previous versions).
 *             When a ionosphere file is given (with '-input:klb' or '-input:bds' or '-input:neq' or '-input:inx' or '-input:fppp' or
 *                '-input:sbasiono' it will automatically use the corresponding ionosphere model (no need to put the 'model:iono' parameter
 *                as in previous versions).
 *             Show products and compare orbit mode have been greatly improved. Now it is possible show or compare concatenated products files, and
 *               also to compare a concatenated file with a non concatenated file for a single day (this is useful to see the Runge interpolation effect
 *               with precise orbits).
 *             In navigation, show or compare orbits modes, if there is a SP3 concatenated file, gLAB will always try to have in memory orbits and clocks 
 *               from the three days (the previous day, the current day and the following day) in order to avoid Runge interpolation effect.
 *             Changed extension of generated Stanford-ESA files. Now by default they will have a ".txt" extension.
 *             Changed inital aproxPositionError for SINEX coordinates from 1 decimeter to 1 centimeter.
 *             When IONEX or F-PPP DCB source is selected, if no dcb file is given, it will use DCB data from the IONEX/F-PPP file
 *              for ionosphere data respectively (if DCB data is available from these files).
 *             When receiver position is set to 'calculateUSER' or 'calculateRINEX', initial coordinates no longer need to be 
 *              over the Earth Surface.
 *             Fixed a bug which made not to save DCB data when it was read from RINEX file with the option '-input:dcb'.
 *             Fixed MEAS message not being printed in the right order in SBAS mode.
 *             Fixed messages for deprecated options not being printed to output file when '-output:file' option was used.
 *             Fixed a bug reading user defined receiver coordinates when receiver position was set to 'calculateUSER'.
 *             Fixed a bug reading SNR threshold from parameters.
 *             MEAS message will be printed by default in 'SHOWINPUT' mode (when only an observation file is given).
 *             In SHOWINPUT mode (print only observation data), RINEX station coordinates will not be checked for consistency (as they are not used).
 *             Stanford-ESA initialization is now done outside of SBAS, so it can be used in normal SPP mode (only one measurement used by the filter).
 *             Transmission time of message check in broadcast ephemerides selection is disabled by default in PPP mode. 
 *             Taken out degree sign from output messages to avoid text encoding problems.
 *             Updated help messages.
 *             All input options are now case insensitive.
 *             Windows compiled gLAB executable is now optimized (built with '-O3' gcc option) and has the gAGE icon embedded.
 * -----------
 *          gLAB v4.1.0
 * Release: 2017/04/07
 * Change Log: Added parameter '-filter:prefitoutliers:median 'for prefit outlier detector by computing the difference from the median
 *               of the prefits.
 *             Added parameter '-filter:prefitoutliers:abs 'for prefit outlier detector by computing the difference from the absolute
 *               values of the prefits.
 *             Added 'RTCMRinexRover', 'RTCMUSER', 'RTCMUserbaseline', 'RTCMUserRinexRover' and 'RTCMRefRoverUSER' receiver position modes.
 *               'RTCMRinexRover' is for computing the solution error with respect to the coordinates from Rover RINEX file.
 *               'RTCMUSER' is for computing the solution error with respect to the user defined coordinates.
 *               'RTCMUserbaseline', 'RTCMUserRinexRover' and 'RTCMRefRoverUSER' are equivalent to 'RTCMbaseline', 'RTCMRinexRover' and 'RTCMUSER' but
 *                 reference station coordinates are user defined. These last three modes only work when reference station data is from a RINEX file.
 *             Added check for valid receiver position user setting. In SPP/PPP/SBAS it will show an error instead of continuing in 'calculate' mode,
 *               and in DGNSS it will show an error instead of continuing in SPP mode.
 *             If user forced NPA processing mode in parameters, gLAB will now enter the function to update values for SBAS summary, but all the values
 *               will be referred to NPA solution instead of PA.               
 *             Fixed bug where sometimes gLAB would crash or show an incorrect error message (depending if it were  in comparison or navigation mode)
 *               when an invalid RTCM file was given.
 *             Fixed reference station time synchronization bug when the Rover had a data rate of 1 second and its timestamps were not integer seconds.
 *             When comparing orbits with two SP3 or SP3+CLK files, gLAB will compute the max data gap for each precise product file instead of using 
 *               the value computed from the first precise product file read in both files.
 *             Updated help messages with new parameters and info about prefit outlier detection.
 * -----------
 *          gLAB v4.2.0
 * Release: 2017/05/22
 * Change Log:   Added option '-output:kml:refsta' for adding (or not) the reference station(s) used in DGNSS mode in 
 *                 the output KML files (default on).
 *               Added options '-model:nomt10' and '-model:nomt2728' to disable messages type 10, 27 and 28 for SBAS.
 *               Added option '-model:sbasmaritime' for SBAS maritime mode (which is a shortcut for providing
 *                 parameters '-model:nomt10' and '-model:nomt2728'.
 *               gLAB will now create all directories recursively (if needed) when opening an output file for writing.
 *               Decimation can be now a decimal number, with a maximum resolution of 0.0001 seconds (10000 Hz).
 *               Use of Klobuchar iono when SBAS iono is not available during the solution convergence is now also
 *                 permitted in receiver position modes 'calculateRINEX' or 'calculateUSER'.
 *               Added warning message when computing SBAS availability maps in order to advise user for the long
 *                 computation time needed (with default options it is around 2 hours).
 *               Added check of initial coordinates when receiver positioning is set to 'calculateRINEX' or
 *                 'calculateUSER'. If coordinates are (0,0,0), in the case of 'calculateRINEX' a warning will be
 *                 shown informing that these coordinates are invalid and that (6378137,0,0) will be used instead.
 *                 In the case of 'calculateUSER', an error will be shown.
 *               Fixed crash when SBAS iono was selected, Klobuchar iono was allowed during receiver convergence
 *                 and no navigation or Klobuchar file had been provided.
 *               Updated help messages.
 * -----------
 *          gLAB v5.0.0
 * Release: 2017/06/30
 * Change Log:   Added parameter '-pre:cs:l1c1:unconcheck:th' for L1C1 consistency check threshold.
 *               Added GEO switching in SBAS Availability maps (therefore, now it can do SBAS availability
 *                  maps with different SBAS providers in the same run).
 *               Added parameter '-sbasplots:hourlymaps' for writing hourly SBAS availability maps.
 *               Added parameter '-sbasplots:plotarea'. This parameter is a shorter way to provide the same values 
 *                 as in '-sbasplots:minlon' '-sbasplots:maxlon', '-sbasplots:minlat' and '-sbasplots:maxlat' parameters.
 *               Added parameter '-sbasplots:exclusionarea' for excluding areas in the SBAS availability maps processing.
 *                 This parameter can be passed as many times as exclusion areas needed to be defined.
 *                 This parameter will exclude all points which are inside any area defined with this parameter.
 *               Added parameter '-sbasplots:inclusionarea' for including areas in the SBAS availability maps processing.
 *                 This parameter can be passed as many times as exclusion areas needed to be defined.
 *                 This parameter will exclude all coordinates that are not inside any area defined with this parameter.
 *                 If parameter '-sbasplots:exclusionarea' is also provided, for a coordinate to be processed, it must be
 *                 inside any inclusion area and outside of all exclusion areas.
 *               Added parameter '-rtcmv2conversioninfo', which shows detailed info of the output files
 *                 generated when converting a RTCM v2.x file.
 *               Added parameter '-pre:cs:bw:siginit' for setting the initial sigma in the 
 *                 Melbourne-Wubbenna cycle-slip detector.
 *               When receiver position is set to 'RTCMUserBaseline', initial coordinates from rover will be
 *                 from the reference station coordinates instead of the Earth's surface.
 *               Changed parameter name from '-model:geoadqtime' to '-model:geoacqtime' (but the old name is
 *                 still accepted).
 *               Help parameters ('-help', '-examples', '-config', '-messages',  '-usererrorfile', '-sigmamultipathfile' 
 *                and '-rtcmv2conversioninfo') now also work with a double slash '--'.
 *               In Windows, now gLAB will have the 64 bit or 32 bit version depending on the OS version.
 *               Updated help messages.
 * -----------
 *          gLAB v5.1.0
 * Release: 2017/11/24
 * Change Log:   Added MAC support.
 *               Added progress bar in command line. In Linux, it will automatically disable if process 
 *                 is started in the background or moved to background or standard output is piped or
 *                 standard input is not a terminal. In Windows, it will automatically disabled if
 *                 standard input or output is not a terminal (In Windows and Mac it is not possible
 *                 to distinguish between output redirection to file or piped), but it is possible to
 *                 force the appearance of the progress bar with the parameter '-print:progress'. 
 *                 It can also be disabled by the user with parameter '--print:progress'.
 *               Added '-pre:starttime' and '-pre:endtime' for setting first and last epoch to be
 *                 processed of the observation file respectively. Four date formats supported:
 *                 'YYYYMMDD HH:MM:SS', 'YYYY/MM/DD HH:MM:SS', 'YYYY/DoY SoD' and 'GPSWeek SoW'.
 *               Added hidden parameter '-pre:guiprogress'. This parameter is given by the GUI to
 *                 the gLAB core in order to make the latter print the progress in a suitable format
 *                 to be read by the GUI.
 *               Added parameters '-dateconv:calendar', '-dateconv:doy', '-dateconv:gpsweek' and
 *                 '-dateconv:mjdn' for date conversion mode.
 *               Added parameters '-coordconv:cartesian', '-coordconv:geodetic' and 
 *                 '-coordconv:spherical' for coordinate conversion mode.
 *               Added parameter '-sbassummary:starttime' to allow a user defined start time
 *                 of the SBAS summary (if user also wants to set an end time, set the last
 *                 epoch to be processed with parameter '-pre:endtime').
 *               Added parameters '-output:sp3:dgnssonly' and '--output:sp3:dgnssonly' to enable
 *                 or disable writing SPP solution to output SP3 file in DGNSS mode.
 *               Added parameter '-input:refpos' for reading an input reference position file.
 *                 Input reference file can be a columnar text file, a SP3 file or a RTKlib
 *                 output file.
 *               Added parameter '-referenceposfile' for a description of the input reference file.
 *               Added parameter '-output:refpos' for writing an output reference position file.
 *               Added parameters '-output:refpos:doy', '-output:refpos:gpsweek' and 
 *                 '-output:refpos:caltime' to write the timestamps in "Year DoY SoD", or 
 *                 "GPSWeek/SoW" or "YYYY/MM/DD HH:MM:SS.zzz" formats respectively.
 *               Added parameters '-output:refpos:geodetic' and '--output:refpos:geodetic' to set or unset
 *                 to write the coordinates in geodetic system instead of cartesian mode.
 *               Added parameters '-output:refpos:dgnssonly' and '--output:refpos:dgnssonly' to enable
 *                 or disable writing SPP solution to output reference position file in DGNSS mode.
 *               Added parameter '--print:none'. It has the same effect as '-print:none'.
 *               Added parameter '-model:tropo'. It has the same effect as '-model:trop'.
 *               Added 'SetRef', 'calculateRef', 'calculateRINEXRef', 'calculateUSERRef',
 *                 'DGNSSRoverUSERRef' and 'DGNSSUserRoverRef' receiver positioning modes. This modes
 *                 are for using a reference file with the rover position.
 *               Added 'DGNSSRoverUSERGeod', 'DGNSSUserRoverRefGeod', 'DGNSSUserGeodbaseline', 
 *                 'DGNSSUserGeodRinexRover', 'DGNSSRefGeodRoverUSERGeod', 'DGNSSRefCarRoverUSERGeod'
 *                  and 'DGNSSRefGeodRoverUSERCar' receiver positioning modes for supporting
 *                  geodetic coordinates. Internally, it will convert the coordinates to cartesian
 *                  and switch to the equivalent cartesian mode.
 *               Added compilation date and time next to the "gLAB version" line.
 *               Added INFO message when SNR mask is disabled.
 *               Added INFO message about KML Timestamp options.
 *               Added INFO message for selected KML timestamp regions.
 *               Added INFO message for selected inclusion and exclusion areas in SBAS plots mode.
 *               Added INFO message with user defined geodetic coordinates (when provided).
 *               Changed SBAS and DGNSS defaults for Data Gap, SNR and N-consecutive. In both modes,
 *             	SNR mask is set to 33 dbHz, Data Gap to 10 seconds and N-consecutive is disabled.
 *               Changed parameters name from 'RTCMbaseline', 'RTCMRinexRover', 'RTCMRoverUSER',
 *                 'RTCMUserbaseline', 'RTCMUserRinexRover' and 'RTCMRefRoverUSER' to 'DGNSSbaseline',
 *                 'DGNSSRinexRover', 'DGNSSRoverUSER', 'DGNSSUserbaseline', 'DGNSSUserRinexRover'
 *                 and 'DGNSSRefRoverUSER' respectively. The old names can still be used in order to
 *                 maintain compatibility with older versions.
 *               Changed default standard deviation from 1 to 5 metres for single frequency code, from
 *                 1 to 3 metres for PC and from 0.01 to 0.03 metres for LC.
 *               If troposphere model is disabled, gLAB will automatically disable computation of wet
 *                 troposhere residual in the filter.
 *               In RTCM conversion mode, gLAB will automatically replace output files instead of exiting.
 *               Improved gLAB detection of executable directory detection for Mac compatibility.
 *               If receiver antenna phase center is set by user, then receiver antenna phase center
 *                 variation correction will be automatically disabled (previously it appeared as
 *                 enabled in the INFO messages, but during the modelled it was skipped).
 *               In orbit comparison or orbit show mode, gLAB will not always show the end time of
 *                 the comparison regardless of the number of concatenations of the input files
 *                 (previously it was not shown if file had more than three days concatenated).
 *               Tweaked the code to remove the different compiler warnings when compiling with flags 
 *                 '-pedantic', '-Wall' and '-std=gnu99' (without using the '-O' flag). In each
 *                 platform, the compiler issued different warnings.
 *               Fixed bug that made gLAB discard all satellites with reason "Arc too short"
 *                 even though the arc was very large.
 *               Fixed crash in SBAS plot mode when hourly maps were enabled and continuity risk
 *                 maps were disabled.
 *               Fixed bug incorrectly reading values for parameter '-output:kml:tstamprange' when
 *                 it was provided through a configuration file.
 *               Fixed bug that made the KML time ranges to be duplicated or triplicated in memory
 *                 due to user options are read several times.
 *               Fixed bug that made inclusion and exclusion areas for SBAS maps to be duplicated 
 *                 or triplicated in memory due to user options are read several times (in order to 
 *                 override defaults) This will slightly reduce SBAS maps computation time with 
 *                 maps including inclusion or exclusion areas.
 *               Fixed solution not converging in receiver positioning modes 'calculateRINEX' and
 *                 'calculateUser' when the initial position was very far from the real position.
 *                 This was due to gLAB believed initial coordinates were always close to the real ones,
 *                 therefore, satellite elevation filtering was enabled since the beginning instead
 *                 of waiting for the solution to converge for enabling this filter.
 *               Fixed bug not computing Stanford-ESA when SBAS summary was not enabled.
 *               Updated help messages.
 * -----------
 *          gLAB v5.1.1
 * Release: 2017/12/22
 * Change Log:   Added "Add User to RINEX" mode. In this mode, gLAB reads an observation file, an user added
 *                 error file and writes the a RINEX observation file with the same data but with the user 
 *                 added error in the measurements.
 *               Changed receiver ARP correction default option in SBAS and DGNSS. Now it will be enabled by
 *                 default in SBAS and DGNSS modes (before it was disabled).
 *               Changed detection method for detecting if standard output is piped. This method works in
 *                 Windows, Linux and Mac. This allows gLAB to behave the same way in Linux and Mac when
 *                 detecting if standard output is piped or if process is in background (in order to hide
 *                 the progress bar). In Windows, it cannot detect if process is run in background, so if
 *                 output is a pipe or is not a terminal by default it will hide the progress bar.
 *               Fixed DGNSS corrections not being updated during one epoch when a new header was found in
 *                 the rover observation file (only when rover file is concatenated). This ocurred only in the
 *                 first epoch after the new header.
 *               Updated help messages.
 * -----------
 *          gLAB v5.1.2
 * Release: 2018/01/12
 * Change Log:   Added OpenMP preprocessor directives for multithread processing for the modelling section and
 *                 for SBAS maps mode (gLAB needs to be rebuild with '-fopenmp' in order to enable multithreading).
 *               Added parameter '-numthreads' in order to set the maximum number of threads in multithread
 *                 processing. If this parameter is not set, it will use as many threads as available CPU.
 *                 (gLAB needs to be rebuild with '-fopenmp' in order to enable multithreading).
 *               If gLAB is build with multithreading, the INFO message with the gLAB version will show that
 *                 multithreading is enabled.
 *               Changed progress bar in SBAS plots mode. Now it will also show the current epoch and epochs
 *                 left in HH:MM:SS format.
 *               Progress bar in SBAS plots mode will now appear with 0.0% progress when the process starts.
 *                 Before it didn't appear until progress had advanced to 0.1%, which could take some long
 *                 time and therefore make the user think that the gLAB was not working.
 *               Updated help messages.
 * -----------
 *          gLAB v5.1.3
 * Release: 2018/01/19
 * Change Log:   Added a INFO message with the list of SBAS GEO satellites excluded (for SBAS plots mode).
 *               Concatenated IONEX files are now supported, for both ionsphere data and DCB data.
 *               Improved handling of concatenated files for Klobuchar/BeiDou ionosphere parameters. Now it will only read
 *                 new parameters from next day when the observation file changes day. Before it could read them when
 *                 the observation file changed day or when the broadcast orbits had expired.
 *               Changed OpenMP directives "#pragma omp critical" to "#pragma omp atomic". Atomic statements are faster
 *                 as they require less overhead, they don't block other threads operations (except for the current atomic
 *                 one) and do not require to be named in order to distinguish between the atomic sections (unnamed critical
 *                 sections block all threads accessing any unnamed critical section).
 *               Fixed bug that made gLAB show an error message and exit in positioning mode when a concatenated RINEX
 *                 navigation file was read.
 * -----------
 *          gLAB v5.2.0
 * Release: 2018/03/09
 * Change Log:   Added option '-model:maxurabrdc' for setting a maximum value for URA in the broadcast message.
 *               Added option '-model:udreithreshold' for setting a maximum value for UDREI in SBAS fast correction messages.
 *               Added option '-model:sigfltnomt10offset' for changing the offset added to fast and slow corrections sigma
 *                 when SBAS message type 10 is not used.
 *               Added option '-filter:fixedweightsat' for setting a custom fixed weight for each satellite.
 *               Added option '-filter:sinelevweightsat' for setting a weight dependent on the inverse of the elevation.
 *               Added option '-filter:sinelevweightsat' for setting a weight dependent on the inverse of the elevation for
 *                 each satellite.
 *               Added option '-filter:snrweight' for setting a weight dependent on the SNR.
 *               Added option '-filter:snrweightsat' for setting a weight dependent on the SNR for each satellite.
 *               Added option '-filter:snrelevweight' for setting a weight dependent on the inverse of the elevation and the SNR.
 *               Added option '-filter:snrelevweightsat' for setting a weight dependent on the inverse of the elevation and the SNR
 *                 for each satellite.
 *               Added the option to set the constant value of all filter weight to the URA value provided in the brodcast navigation
 *                 message. To set, instead of providing a fixed value, provide the text 'URA'.
 *               Added option '-filter:snrweight:comb' for setting how to compute the SNR value for combinations.
 *               Added option '-filter:snrweight:combsat' for setting how to compute the SNR value for combinations for each satellite.
 *               Added option '-filter:sbasdgnssweightmode' for setting how to compute the weight in SBAS and DGNSS modes.
 *               Added option '-filter:sbasdgnssweightmodesat' for setting how to compute the weight in SBAS and DGNSS modes for each satellite.
 *               Added option '-print:summary'. This make the summary no more being tied to '-print:info' option. Furthermore, the summary
 *                 will be also printed even if receiver position is not fixed (but error percentiles values will not be computed).
 *               Added messages (in command line only) at the start of the processing indicating which file is reading.
 *               Options '-pre:sat' and  -pre:snrsel' now accepts a range of satellites.
 *               Option '-pre:sat' now accepts an optional '+' or '-' sign to indicate whether to select or unselect the listed
 *                 satellite.
 *               All options for setting the filter weights now accept measurement number '0'. This value sets the given weight to all
 *                 measurements in the filter.
 *               Changed exit code of gLAB after correct execution from '1' to '0' in order to match linux standards.
 *               User defined SNR threshold now accepts decimal values.
 *               gLAB can now read configuration files with comments (starting with '#' symbol) next to the parameters.
 *               Removed units in GDOP parameter (GDOP is adimensional).
 *               If gLAB finishes processing and no epochs were processed, but no error will occur, gLAB will reenable the cursor before exiting if
 *                 progress is being printed.
 *               Fixed bug that made not to add a hash ('#') in the first line of a sigma multipath file, a reference file and a user defined error
 *                 file (the line with the gLAB version).
 *               Updated help messages.
 * -----------
 *          gLAB v5.3.0
 * Release: 2018/06/08
 * Change Log:   Added validity check for user provided inclusion area coordinates in SBAS plots mode.
 *               Added parameters '-filter:maxhdop' and '-filter:maxpdop' for setting a maximum HDOP or PDOP.
 *               Added parameter '-filter:hdoporpdop' for setting a combined threshold of HDOP or PDOP. When
 *                 setting this parameter and HDOP and PDOP thresholds are set, a valid epoch will be any that
 *                 is under any of the two thresholds (HDOP or PDOP) instead of both.
 *               Added parameters '-sbasplots:hdopplot', '-sbasplots:pdopplot', '-sbasplots:gdopplot' and
 *                 '-output:sbascombdopplots' for computing SBAS HDOP, PDOP and GDOP plots or all of them in the 
 *                 DOP combined file.
 *               Added parameter '-sbasplots:doppercentile' for enabling computation of DOP percentiles in DOP maps.
 *               Added parameters '-output:sbashdopplots', '-output:sbaspdopplots', '-output:sbasgdopplots' and
 *                 for setting output filenames for HDOP, PDOP and GDOP maps.
 *               Added parameter '-summary:windowsizemar' for setting the fixed window size for SBAS maritime 
 *                 continuity risk.
 *               Added parameter '-summary:stationnetworkname' for setting a station network name in the summary.
 *                 This is useful for doing station network maps.
 *               Added parameter '-sbasplots:windowsizemar' for setting the window size for computing continuity risk 
 *                 using the SBAS maritime formula.
 *               Added parameter '-sbasplots:noriskmarplot' for not computing continuity risk using the
 *                 formula from SBAS maritime.
 *               Added parameter '-output:sbasriskmarplots' for setting the output filename for continuity risk
 *                 mask with SBAS maritime formula.
 *               Added parameter '-output:kml:egm96geoid' for adding the height from the EGM96 geoid model to the
 *                 output coordinates in the KML file.
 *               Added progress message 'RINEX data processing finished. Computing Summary...' when epochs processing
 *                 is finished and the summary values are being computed.
 *               Added INFO message in SBAS plots mode for Continuity risk window size (for both sliding and fixed).
 *               Added INFO message in SBAS plots mode when the hourly maps are disabled.
 *               Changed parameter name from '-model:satellitehealth' to '-model:sathealth', although the old format
 *                 is still accepted.
 *               Klobuchar ionosphere model is now allowed in SBAS plots mode.
 *               Fixed a crash when user forced NPA mode in SBAS plots mode.
 *               Fixed a crash when converting RTCM3 files to RINEX.
 *               Fixed deprecated warning messages being printed in the standard output instead of the output file.
 * -----------
 *          gLAB v5.4.0
 * Release: 2018/11/16
 * Change Log:   Added option '-print:progressalways' for forcing gLAB to printing the progress bar to
 *                 the terminal even if the output is piped or gLAB is not able to detect if output is
 *                 a terminal or not. By default, gLAB disables the progress bar if the starndard
 *                 output is piped, to avoid potentially messing up the input of the next command (for
 *                 instance, a pipe to 'less' or 'more' commmands). For other cases (for example,
 *                 piping to an 'awk' or 'grep' command), it is safe to print the progress bar, as
 *                 when the standard output is not a terminal, gLAB reopens it in a different file
 *                 descriptor, therefore output prints and progress bar are not mixed.
 *               Added option '-sbasplotsinfo' (also accepted as '-sbasmapsinfo') for showing a new
 *                 manual section about the necessary files for computing SBAS maps and the scripts
 *                 for joining the output of multiple SBAS maps output files into a single file.
 *               Added option '-model:selectbestgeo' for SBAS mode to make gLAB compute the SBAS model
 *                 with all GEO available and select then the one with smallest protection levels.
 *               Added check in SBAS plots mode for start epoch of navigation messages. If they start
 *                 two days before the current day or earlier, a warning message will be shown,
 *                 as this means that the navigation file is from another day or there are
 *                 navigation messages from previous dates or the transmission time of the
 *                 navigation messages are incorrect.
 *               Added check in SBAS plots mode for start epoch of navigation messages. If it does not 
 *                 start at least 2 hours before the current processing day, a warning message will be
 *                 printed. Not adding this 2 hours may do that navigation messages are missing at the 
 *                 start of the day.
 *               Added check in SBAS plots mode for end epoch of navigation messages. If it does not 
 *                 end at least 2 hours after the current processing day, a warning message will be 
 *                 printed. Not adding this 2 hours may do that navigation messages are missing at the 
 *                 end of the day.
 *               Added check in SBAS plots for DOP percentiles options. If user sets the option to compute
 *                 the DOP percentiles (option '-sbasplots:doppercentile') but did not enable any DOP map
 *                 (such as HDOP, PDOP or GDOP), an error message will be shown and gLAB will exit.
 *                 Previously, in this case an INFO message was printed stating that DOP percentile
 *                 computation had been enabled, but no DOP percentiles were computed.
 *               Added INFO message in SBAS plots mode stating that navigation data files available usually
 *                 have missing navigation messages and that the user should create one from several sources.
 *               Added INFO message in SBAS plots mode about the multithread version of gLAB, which
 *                 can significantly reduce computation time.
 *               Added INFO message in processing mode and SBAS plots mode stating if message type 0
 *                 is ignored or not.
 *               Added INFO message in processing mode and SBAS plots mode stating if message type 0
 *                 is read as type 2 message.
 *               Added INFO messages in SBAS plots mode with the timeouts of the SBAS messages.
 *               Command line help now have a blank line between each option in order to ease readibility.
 *               If option '-numthreads' is provided to the gLAB version compiled without multithreading,
 *                 it will now show an error message stating that it is not the multithread version,
 *                 instead of showing an "unknown option" error.
 *               In SBAS plots mode, if with one GEO the geometry matrix is singular or the protection levels
 *                 are over the alarm limits, if GEO switching is enabled, instead of skipping the epoch, it
 *                 will try another GEO.
 *               INFO message with window size in SBAS plots mode now show the unit of the window size (seconds).
 *               Disabled satellite navigation message health check flag by default in SBAS mode.
 *                 According to MOPS, SBAS can override the health flag.
 *               Fixed bug that made to incorrectly save user provided filter weights when option 
 *                 '-filter:snrelevweightsat' was used.
 *               Fixed several warnings which appeared when compiling with gcc7.
 *               Fixed bug in SBAS plots mode that made to try to create an empty SBAS discontinuity file 
 *                 when the continuity risk map was disabled. This made gLAB to exit with the following
 *                 error message: "ERROR Opening output file [] for SBAS solution discontinuities".
 *               Fixed global variables 'printbufferMODEL', 'printbufferSBASCORR', 'printbufferSBASVAR',
 *                 'printbufferSBASIONO' and 'printbufferSBASUNSEL' declared as local global variables 
 *                 (in file 'gLAB.c') instead of using the ones declared in file 'output.c'.
 *               Parameter description and help messages now indicate that all input or output time tags
 *                 are in GPS time.
 *               Updated help messages.
 * -----------
 *          gLAB v5.4.1
 * Release: 2019/02/15
 * Change Log:   Changed default GEO PRN to use in SBAS. It will now select by default
 *                 the GEO with highest elevation (except in SBAS plots mode, which still
 *                 is the first GEO read).
 *               Changed default time between switches (or switching cooltime) in SBAS
 *                 from 20 seconds to 0 seconds (no limit of changes in an epoch).
 *               Fixed warning '-Wimplicit-fallthrough'.
 * -----------
 *          gLAB v5.4.2
 * Release: 2019/03/08
 * Change Log:   Added parameters '-model:khpa', '-model:kvpa', '-model:khnpa' and
 *                 '-model:kvnpa' for changing the values of Kh and Kv factors used
 *                 for computing the protection levels.
 *               Added INFO messages in SBAS plots mode for Kh and Kv values.
 *               Added INFO messages in SBAS plots mode for SBAS receiver type used.
 *               Added INFO message in SBAS plots mode when Klobuchar model or no
 *                 ionosphere model is used.
 *               Added INFO messages in SBAS plots mode for the cases that a specific
 *                 sigma or correction is disabled. These messages already appeared
 *                 in SBAS processing mode, so now they appear in both modes.
 *               Added INFO message in SBAS plots mode with the list of SBAS GEO
 *                 satellites available in the SBAS data file and not excluded by the user.
 *               If any of the HDOP, PDOP or GDOP filters is disabled in SBAS processing
 *                 mode, it will print an INFO message stating that it is OFF, instead of 
 *                 not printing anything.
 *               Changed INFO messages in SBAS plots mode for SBAS messages timeouts.
 *                 If any of these messages are disabled (such as MT10), instead of
 *                 appearing its timeout, it will print "Message disabled".
 *               Changed parameter '-model:sigmpath'. Now it accepts an optional
 *                 third argument for setting the value dividing the elevation
 *                 inside the exponential (in previous versions it was fixed to '10').
 *                 This third argument is optional for maintaining compatibility with
 *                 previous versions.
 *               Fixed INFO messages about DOP filters appearing twice in SBAS plots
 *                 mode (before and after the timeouts messages).
 *               Fixed last positions in latitude and longitude not being computed and
 *                 plotted in SBAS plots mode when the step was below 1. It was due to
 *                 precision errors in the tenth decimal when comparing the maximum
 *                 latitude/longitude value with the current latitude/longitude value.
 *               Fixed buffer overflow when there were too many deprecated options
 *                 provided by parameter.
 *               Updated help messages.
 * -----------
 *          gLAB v5.4.3
 * Release: 2019/03/20
 * Change Log: No changes in this file.
 * -----------
 *          gLAB v5.4.4
 * Release: 2019/05/10
 * Change Log:   Added check for minimum arc length in L1-C1, BW and LI cycle-slip detectors.
 *               gLAB is now compiled with flag "-fno-stack-protector". This flag
 *                 prevents the compiler to add code for checking for stack
 *                 smashing at the return of most of the functions. As gLAB already
 *                 has checks to prevent buffer overflow, it is not necessary this
 *                 checks. With this flag, the processing time gets reduced around 7%.
 *               Fixed wrong initialization of continuity risk values. This made to
 *                 account for an additional (false) discontinuity in the computed
 *                 continuity risk in the SBAS summary when the start of the SBAS
 *                 summary did not match with the start of the RINEX observation
 *                 file. This bug did not affect SBAS plots continuity risk
 *                 computation.
 * -----------
 *          gLAB v5.5.0
 * Release: 2020/11/13
 * Change Log:   Fixed bug that made to ignore SBAS satellite corrections that were not processed the first
 *                or the last one when option select best GEO was enabled.
 * -----------
 *          gLAB v5.5.1
 * Release: 2020/12/11
 * Change Log: No changes in this file.
 * -----------
 *          gLAB v6.0.0
 * Release: 2024/11/22
 * Change Log:   Added multi-constellation support (Galileo, GLONASS, GEO, BDS, QZSS and IRNSS).
 *               Added multi-frequency support (all RINEX frequencies).
 *               Added SBAS DFMC processing.
 *               Added FAQ to gLAB, accesible with parameter '-faq'.
 *               Added autocomplete bash script (printed with option '-autofillscript'), which when
 *                  installed (following instructions in the header of the script), it will 
 *                  allow bash autocompletion of gLAB's parameters and fixed strings arguments.
 *               Added capability to read multiple navigation files (up to one per constellation)
 *                 for navigation messages.
 *               Added option '-input:antrec' for reading up to two additional ANTEX files for
 *                 receiver antenna phase center data.
 *               Added option '-input:antsatblock' for reading an ANTEX file for satellite block and
 *                 SVN, but not for any antenna data (e.g. for use in SPP/SBAS/DGNSS modes).
 *               Added option '-input:navhealth' for PPP for reading navigation files (up to one
 *                 per constellation) for checking satellite health status.
 *               Added option '-input:navglo' for reading a navigation file for GLONASS frequency offsets.
 *               Added option '-pre:setrectypedgnss' to set the GPS receiver type for the reference station
 *                 in DGNSS mode.
 *               Added option '-input:sbasdfmc' to provide SBAS DFMC data files.
 *               Added option '-pre:smoothauto' for automatic measurement selection for smoothing.
 *               Added option '-pre;minsnrsel' to set a minimum SNR per satellite.
 *               Added options '-pre:maxsnr' and '-pre:maxsnrsel' to set a maximum SNR threshold (global or
 *                 per satellite).
 *               Added options '-pre:cs:sf:freq', '-pre:cs:sf:freqlist', '-pre:cs:sf:freqdgnss', 
 *                 '-pre:cs:sf:freqlistdgnss', '-pre:cs:sf:meas', '-pre:cs:sf:measlist', '-pre:cs:sf:measdgnss'
 *                 and '-pre:cs:sf:measlistdgnss' for setting the frequencies and measurements in rover and
 *                 reference station for Single Frequency cycle-slip detector.
 *               Added options '-pre:cs:sf:freq', '-pre:cs:sf:freqlist', '-pre:cs:sf:freqdgnss', 
 *                 '-pre:cs:li:freqlistdgnss', '-pre:cs:li:meas', '-pre:cs:li:measlist', '-pre:cs:li:measdgnss'
 *                 and '-pre:cs:li:measlistdgnss' for setting the frequencies and measurements in rover and
 *                 reference station for Geometry-Free cycle-slip detector.
 *               Added options '-pre:cs:mw:freq', '-pre:cs:mw:freqlist', '-pre:cs:mw:freqdgnss', 
 *                 '-pre:cs:mw:freqlistdgnss', '-pre:cs:mw:meas', '-pre:cs:mw:measlist', '-pre:cs:mw:measdgnss'
 *                 and '-pre:cs:mw:measlistdgnss' for setting the frequencies and measurements in rover and
 *                 reference station for Melbourne-Wubbena cycle-slip detector.
 *               Added options '-pre:cs:igf:freq', '-pre:cs:igf:freqlist', '-pre:cs:igf:freqdgnss', 
 *                 '-pre:cs:igf:freqlistdgnss', '-pre:cs:igf:meas', '-pre:cs:igf:measlist', '-pre:cs:igf:measdgnss'
 *                 and '-pre:cs:igf:measlistdgnss' for setting the frequencies and measurements in rover and
 *                 reference station for Iono-Geometry-Free cycle-slip detector.
 *               Added options '-pre:cs:nooutliers', '-pre:cs:li:nooutliers', '-pre:cs:mw:nooutliers' and
 *                 '-pre:cs:igf:nooutliers' for not declaring outliers in LI, MW and IGF cycle-slip detectors.
 *               Added options '-pre:cs:noautofill', '-pre:cs:sf:noautofill', '-pre:cs:li:noautofill'
 *                 '-pre:mw:mw:noautofill' and '-pre:cs:igf:noautofill' to disable auto-filling of measurements
 *                 in cycle-slip detectors.
 *               Added options '-pre:freqorder', '-pre:measorder', '-pre:measorderlist', '-pre:measorderdgnss'
 *                 and 'pre:measorderlistdgnss' to set the frequency and measurement priority order. Tthe
 *                 frequency option apply to both rover and reference station, while the measurement options
 *                 are separate for rover and refererence station.
 *               Added options '-pre:meassel:pairedmeas' and '-pre:meassel:pairedmeasdgnss' to force gLAB to
 *                 select only codes and carrier phases with the same attribute for the rover and the reference
 *                 station.
 *               Added option '-pre:meassel:noblocktypeunsel' to disabling removing measurements not available
 *                 in a given satellite block from the measurement priority list.
 *               Added option '-pre:intseconds' to ignore decimals in the seconds read in the timestamp of the
 *                 RINEX observation file.
 *               Added options '-model:dcb:sf:gps:isc:l1ca', '-model:dcb:sf:gps:isc:l1cp',
 *                 '-model:dcb:sf:gps:isc:l1cd', '-model:dcb:sf:gps:isc:l2c', '-model:dcb:sf:gps:isc:l5i5',
 *                 '-model:dcb:sf:gps:isc:l5q5', 'model:dcb:sf:gps:isc:all', '-model:dcb:sf:gps:all' for
 *                 managing GPS single frequency DCBs.
 *               Added options '-model:dcb:sf:gal:e1e5a', '-model:dcb:sf:gal:e1e5b' and '-model:dcb:sf:gal:all'
 *                 for managing Galileo single frequency DCBs.
 *               Added options '-model:dcb:sf:glo:p1p2' and '-model:dcb:sf:glo:all' for managing GLONASS 
 *                 single frequency DCBs.
 *               Added options '-model:dcb:sf:bds:b2b6', '-model:dcb:sf:bds:b7b6', '-model:dcb:sf:bds:sp3'
 *                 and '-model:dcb:sf:bds:all' for managing BDS single frequency DCBs.
 *               Added options '-model:dcb:sf:qzs:c1c', '-model:dcb:sf:qzs:isc:l2c', '-model:dcb:sf:qzs:isc:l5i5',
 *                 '-model:dcb:sf:qzs:isc:l5q5', '-model:dcb:sf:qzs:isc:all' and '-model:dcb:sf:qzs:all' for
 *                 managing QZSS single frequency DCBs.
 *               Added options '-model:dcb:sf:irn:c9c5' and '-model:dcb:sf:irn:all' for managing IRNSS single 
 *                 frequency DCBs.
 *               Added options '-model:dcb:sf:isc:all' for '-model:dcb:sf:all' all constellations single
 *                 frequency DCBs.
 *               Added options '-model:dcb:df:gps', '-model:dcb:df:bds', '-model:dcb:df:qzs' and -model:dcb:df:all'
 *                 for managing GPS, BDS, QZSS and all constellations dual frequency DCBs.
 *               Added option '-model:allowmarginal' to allow usage of satellites in marginal state.
 *               Added options '-model:skipunhealthymarg' and '-model:skipunhealthy' to skip reading and saving
 *                 unhealthy and marginal or only unhealty navigation messages.
 *               Added option '-model:globrdcintstep' for changing the Runge-Kutta interpolation step.
 *               Added option '-model:brdcpreferagetime' to set the preferred maximum age time of a 
 *                 navigation message.
 *               Added option '-model:brdc:gps', '-model:brdc:gal', '-model:brdc:bds' and '-model:brdc:qzss' to
 *                 set the broadcast navigation message types to be used for GPS, Galileo, BDS and QZSS.
 *               Added option '-model:allfilemeas' to make gLAB model all measurement in the RINEX observation
 *                 file (to match behaviour in v5).
 *               Added option '-model:sbassignalflighttime' to set the flight time of the SBAS message.
 *               Added options '-model:sbasdfmc:mt37v04', '-model:sbasdfmc:mt3940v04', '-model:sbasdfmc:mt42v07'
 *                 '-model:sbasdfmc:mt47v04' for reading SBAS DFMC messages with legacy versions of ED-259.
 *               Added options '-model:sbasdfmc:cer', '-model:sbasdfmc:ccovariance', '-model:sbasdfmc:icorr',
 *                 '-model:sbasdfmc:ccorr', '-model:sbasdfmc:rcorr', '-model:sbasdfmc:dfrei',
 *                 '-model:sbasdfmc:dfreilist', '-model:sbasdfmc:deltarcorr', '-model:sbasdfmc:deltadfre',
 *                 '-model:sbasdfmc:sigmaui', '-model:sbasdfmc:sigmatropo' and '-model:sbasdfmc:sigmpathfactor'
 *                 for managing SBAS DFMC corrections.
 *               Added option '-model:sbasdfmc:anymeas' to allow using measurements different from C1C-L1C and
 *                 C5Q-L5Q in SBAS DFMC.
 *               Added option '-model:sbasdfmc:austestbed' for processing data from the first Australian 
 *                 SBAS DFMC test bed.
 *               Added option '-filter:noambiguities' for processing carrier phase measurements as non
 *                 ambiguous measurements.
 *               Added option '-filter:gloifb' for estimating the GLONASS inter frequency bias (experimental).
 *               Added option '-filter:recwindup' for estimating the receiver wind-up (experimental).
 *               Added option '-filter:combtype' to select which type of measurements to auto fill (single
 *                 frequency, dual frequency or graphic combination).
 *               Added options '-filter:refclkorder', '-filter:refclkonlyorder' and '-filter:nochangerefclk' 
 *                 to set the reference clock constellation and behaviour..  
 *               Added options '-filter:dr:randomwalk', '-filter:clk:randomwalk' and '-filter:iscb:randomwalk'
 *                 to set random walk behaviour in coordinates, clock and ISCB.
 *               Added options '-filter:phi:gloifb', '-filter:q:gloifb' and '-filter:p0:gloifb' to set the
 *                 Phi, Q and Po of GLONASS IFB.
 *               Added options '-filter:phi:recwindup', '-filter:q:recwindup' and '-filter:p0:recwindup' to 
 *                 set the Phi, Q and Po of receiver wind-up.
 *               Added options '-filter:q:clk:ns', '-filter:q:iscb:ns', '-filter:p0:clk:ns' and 
 *                 '-filter:p0:iscb:ns' to set clock and ISCB Q and P0 values in nanoseconds.
 *               Added option '-filter:stfdesa:maxsat' to set the maximum number of satellites in a Stanford-ESA
 *                 combination to compute its error and protection levels values.
 *               Added options '-print:sfcsdata', '-print:mwcsdata', '-print:licsdata' and '-print:igfcsdata'
 *                 for printing the new messages containing internal computations of the cycle-slip detectors.
 *               Added options '-print:meas:snr', '-print:meas:doppler' and -print:meas:lli' for printing
 *                 SNR, Doppler and LLI values for each measurement in MEAS message.
 *               Added option '-print:meas:select' and '-print:meas:selectlist' for selecting which measurements
 *                 to print in MEAS messages.
 *               Added option '-print:prefit:unsel' to print unselected satellites in PREFIT message.
 *               Added options '-print:sbasdfmccor', '-print:sbasdfmcvar' and '-print:sbasdfmcunsel' to print
 *                 new SBASDFMCCORR, SBASDFMCVAR and SBASDFMCUNSEL messages.
 *               Added option '-print:pa' as a shorter alias of option of '-print:progressalways'.
 *               Added option '-print:v5format' for printing output messages in legacy V5 format.
 *               Added option '-print:clkns' for printing receiver clock offset and inter-system clock biases
 *                 in nanoseconds instead of metres.
 *               Added options '-summary:formalerrorhor', '-summary:formalerrorver', '-summary:formalerror3d',
 *                 '-summary:poserrorhor', '-summary:poserrorver', '-summary:poserror3d', '-summary:errorhor',
 *                 '-summary:errorver', '-summary:error3d', '-summary:errorhv3d',
 *                 '-summary:formalerrorperiodhor', '-summary:formalerrorperiodver',
 *                 '-summary:formalerrorperiod3d', '-summary:poserrorperiodhor' ,'-summary:poserrorperiodver',
 *                 '-summary:poserrorperiod3d', '-summary:errorperiodhor', '-summary:errorperiodver',
 *                 '-summary:errorperiod3d', '-summary:errorperiodhv3d' for setting the thresholds in the
 *                 computatution of the convergence time in PPP mode form the statistical summary.
 *               Added option '-sbasplots:mingeoelev' to set the elevation mask in SBAS maps for the GEO
 *                 providing the corrections.
 *               Added option '-sbasplots:usegeosat' for using GEO satellites for ranging in SBAS Maps mode.
 *               Added gLAB processing flow diagram in the gLAB command line help and in the manual.
 *               Changed SNR option names from '-pre:snr' and '-pre:snrsel' to '-pre:minsnr' and
 *                 '-pre:minsnrsel' respectively.
 *               Changed GPS DCB option names from '-model:dcb:p1c1' and '-model:dcb:p1p2' to
 *                 '-model:dcb:sf:gps:p1c1' and '-model:dcb:sf:gps:p1p2' respectively.
 *               Changed SBAS 1F input file option name from '-input:sbas' to '-input:sbas1f'.
 *               Changed all Melbourne-Wubbena options and variable names from 'BW' to 'MW'.
 *               Changed precise clock interpolation default to 1 (previously it was 0).
 *               Changed default decimation value to 0 (previously it was 300 seconds).
 *               Filter options '-filter:select', '-filter:fixedweight', '-filter:fixedweightsat',
 *                 '-filter:elevweight', '-filter:elevweightsat', '-filter:sinelevweight',
 *                 '-filter:sinelevweightsat', '-filter:snrweight', '-filter:snrweightsat',
 *                 '-filter:snrelevweight', '-filter:snrelevweightsat', '-filter:snrweight:comb,
 *                 '-filter:snrweight:combsat' and '-filter:sbasdgnssweightmodesat' arguments allow
 *                 per satellite selection.
 *               Option '-pre:sat' now can select or unselect satellites of all constellations.
 *               If a P1-C1 DCB is provided, it will automatically set P1-C1 DCB mode to "strict",
 *                 that is, it will use the file. Before, option "-model:dcb:p1c1 strict" had to
 *                 be provided by user in order to use the P1-C1 DCB file.
 *               Option -'numthreads' is now ignored instead of showing an error when using the 
 *                 non-multithreaded gLAB.
 *               Option '-pre:starttime' and '-pre:endtime' for setting start and end processing time now
 *                 also work in Show Orbits and Compare Orbits modes.
 *               When a GPS receiver type is provided, now the reference station will be also be set with
 *                 the its adequate receiver type (before it was always fixed to 'unknown').
 *               All options whose arguments format have changed in version 6 still support the v5 argument
 *                 format. They can be provided either way, as gLAB will automatically detect which version
 *                 format is used. For the options regarding satellite selection, if v5 format is used, then
 *                 they will be applied for GPS only (as in v5).
 *               Fixed all warnings appearing when enabling "-Wall" flag when compiling the core.
 *               Fixed buffer overflow warnings appearing since gcc 8.
 *               Fixed compilation errors ocurring since gcc 10.
 *               Dropped support for 32 bits versions of gLAB (xcept for ARMVv7), although the core will
 *                 still be able to be compiled in a 32 bit system (with the same Makefile as 
 *                 in 64 bit version).
 * -----------
 *       END_RELEASE_HISTORY
 *****************************/

#if defined __WIN32__
 	//This is to allow %lld, %llu and %n format specifiers in printf with MinGW
	#define __USE_MINGW_ANSI_STDIO  1
#endif


/* System modules */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>
#include <time.h>
#if !defined __WIN32__
	#include <signal.h>
#endif
#if defined _OPENMP
	#include <omp.h>
#endif


/* External classes */
#include "input.h"
#include "preprocessing.h"
#include "model.h"
#include "filter.h"
#include "dataHandling.h"
#include "output.h"

#if defined __WIN32__
 	//Windows.h used for GetProcessTimes function, which retrieves time spent by process
 	//The windows include has to be added at the end otherwise compilation fails
	#include <windows.h>
#else
 	//Library "sys/resource.h" does not exist in Windows/resource.h
	#include <sys/resource.h>
#endif

/* Internal types, constants and data */
#define VERSION "6.0.0"

#if defined __WIN32__ 
	#define GLABPROGRAMEXECUTABLE "gLAB.exe" 
#elif defined __APPLE__
	#define GLABPROGRAMEXECUTABLE "./gLAB_mac" 
#else
	#define GLABPROGRAMEXECUTABLE "./gLAB_linux" 
#endif

#if !defined __WIN32__

	void sigIntSignal (int sig);
	void sigStpSignal (int sig);
	void sigContSignal (int sig);
	void sigPipeSignal (int sig);

	//Global variable for pid (used for signals and directory handling)
	pid_t	pid;

	//Global variables to disable/enable cursor in terminal when receving SIGNALS
	FILE 	*StdoutStream;
	char 	enableCursor[20];
	char 	disableCursor[20];

	//Define SIGINT handling function (Ctrl+C)
	void sigIntSignal (int sig) {
		(void)(sig);//To avoid warning: unused parameter ‘sig’ 
		if (enableCursor[0]!='\0' && StdoutStream!=NULL) {
			fprintf(StdoutStream,"%s\n",enableCursor);
			fflush_function(StdoutStream);
		}
	    exit(-1);
	}
	//Define SIGTSTP handling function (Ctrl+Z) (Do not confuse with SIGSTOP signal, which cannot be blocked)
	void sigStpSignal (int sig) {
		(void)(sig);//To avoid warning: unused parameter ‘sig’ 
		if (enableCursor[0]!='\0' && StdoutStream!=NULL) {
			fprintf(StdoutStream,"%70s%s","",enableCursor);
			fflush_function(StdoutStream);
		}
	    kill(pid,SIGSTOP);
	}
	//Define SIGCONT handling function
	void sigContSignal (int sig) {
		(void)(sig);//To avoid warning: unused parameter ‘sig’ 
		pid_t	fg;

		//Check if standard input is from a terminal (interactive). If it isn't, probably
		//or process in the background or from an automatic process. Disable progress bar
		if (!isatty(fileno(stdin))) {
			if (printProgress==1) {
				printProgressWasDisabled=1;
			}
			printProgress=0;
		} else {
			fg=tcgetpgrp(STDIN_FILENO);
			if (fg==-1) {
				//Stdin is a pipe. Disable progress print
				printProgress=0;
				if (printProgress==1) {
					printProgressWasDisabled=1;
				}
			} else if (fg!=getpgrp()) {
				//We are in the background. Disable progress print
				if (printProgress==1) {
					printProgressWasDisabled=1;
				}
				printProgress=0;
			} else {
				//We are in the foreground again. Disable cursor
				if (printProgressWasDisabled==1) {
					printProgress=1;
				}
				if (disableCursor[0]!='\0' && StdoutStream!=NULL && printProgress==1) {
					fprintf(StdoutStream,"%s",disableCursor);
					fflush_function(StdoutStream);
				}
			}
		}
	}

	//Define SIGPIPE handling function
	void sigPipeSignal (int sig) {
		(void)(sig);//To avoid warning: unused parameter ‘sig’ 
		//Enable cursor
		if (enableCursor[0]!='\0' && StdoutStream!=NULL) {
			fprintf(StdoutStream,"%s\n",enableCursor);
			fflush_function(StdoutStream);
		}
		//Exit, as gLAB can not write to stdout any more
		exit(-1);
	}
#endif



// Enumerator for Navigation kinematics
enum NK {
	NKND,
	NKstatic,
	NKkinematic,
	NKrandomWalk
};

// Enumerator for Navigation mode
enum NM {
	NMND=0,
	NMppp=1,
	NMstandalone=2
};

// Enumerator for Navigation measurements
enum NT {
	NTND,
	NTpseudorange,
	NTcarrierphase
};

// Struct for support options
typedef struct {
	enum	NK					navKinematics;
	enum	NM					navMode;
	enum	NT					navObservables;
	enum	IonoModel			ionoModel;
	enum	TropModelNominal	tropNominal; 
	enum	TropModelMapping	tropMapping;
	enum	GPSP1C1DCBModel		GPSp1c1DCBModel;
	enum	GenericDCBModel		GPSp1p2DCBModel;
	enum 	GenericDCBModel		GPSISCl1caDCBModel;
	enum 	GenericDCBModel		GPSISCl1cpDCBModel;
	enum 	GenericDCBModel		GPSISCl1cdDCBModel;
	enum 	GenericDCBModel		GPSISCl2cDCBModel;
	enum 	GenericDCBModel		GPSISCl5i5DCBModel;
	enum 	GenericDCBModel		GPSISCl5q5DCBModel;
	enum 	GenericDCBModel		GALe1e5aDCBModel;
	enum 	GenericDCBModel		GALe1e5bDCBModel;
	enum 	GenericDCBModel		GLOp1p2DCBModel;
	enum 	GenericDCBModel		BDSb1b6DCBModel;
	enum 	GenericDCBModel		BDSb2b6DCBModel;
	enum 	GenericDCBModel		BDSb5b6DCBModel;
	enum 	GenericDCBModel		BDSb7b6DCBModel;
	enum 	GenericDCBModel		BDSSP3DCBModel;
	enum 	GenericDCBModel		BDSISCb1cdDCBModel;
	enum 	GenericDCBModel		BDSISCb2adDCBModel;
	enum 	GenericDCBModel		QZSc1cDCBModel;
	enum 	GenericDCBModel		QZSISCl1cpDCBModel;
	enum 	GenericDCBModel		QZSISCl1cdDCBModel;
	enum 	GenericDCBModel		QZSISCl2cDCBModel;
	enum 	GenericDCBModel		QZSISCl5i5DCBModel;
	enum 	GenericDCBModel		QZSISCl5q5DCBModel;
	enum 	GenericDCBModel		IRNc9c5DCBModel;
	enum 	OSBDCBModel    		OSBdcbModel;
	enum 	DSBDCBModel			DSBdcbModel;
	enum	GenericDCBModel		DualFreqDCBModel[MAX_GNSS];
	int							smoothAuto;
	int							estimateTroposphere;
	int							troposphericCorrection;
	int							satelliteHealth;
	int							allowMarginal;
	int							anySmoothOptionSetByUser;
	char						cfgFile[MAX_INPUT_LINE];
	char						obsFile[MAX_INPUT_LINE];
	char						navFile[MAX_NAV_FILES][MAX_INPUT_LINE];
	char						glonavFile[MAX_INPUT_LINE];
	char						navHealthFile[MAX_NAV_FILES][MAX_INPUT_LINE];
	int							numNav;
	int							numNavHealth;
	char						SP3File[MAX_SP3_FILES][MAX_INPUT_LINE];
	int							numSP3;
	char						orbFile[MAX_SP3_FILES][MAX_INPUT_LINE];
	int							numOrb;
	char						clkFile[MAX_SP3_FILES][MAX_INPUT_LINE];
	int							numClk;
	char						conFile[MAX_INPUT_LINE];
	char						outFile[MAX_INPUT_LINE];
	char						kmlFile[MAX_INPUT_LINE];
	char						kml0File[MAX_INPUT_LINE];
	char						SP3OutputFile[MAX_INPUT_LINE];
	char						RefPosOutputFile[MAX_INPUT_LINE];
	char						antFile[MAX_INPUT_LINE];
	char						antrecFile[MAX_RECV_ANTEX_FILES][MAX_INPUT_LINE];
	int							numAntRec;
	char						antsatblockFile[MAX_INPUT_LINE];
	char						klbFile[MAX_INPUT_LINE];
	char						beiFile[MAX_INPUT_LINE];
	char						inxFile[MAX_INPUT_LINE];
	char						GalFile[MAX_INPUT_LINE];
	char						fppFile[MAX_INPUT_LINE];
	char						neqFile[MAX_INPUT_LINE];
	char						tgdFile[MAX_DCB_FILE_SOURCES][MAX_INPUT_LINE];
	char						recFile[MAX_INPUT_LINE];
	char						snxFile[MAX_INPUT_LINE];
	char						sbasFile[MAX_INPUT_LINE];
	char						sbasAvailplotsFile[MAX_INPUT_LINE+50];					//The +50 is to avoid buffer overflow warning
	char						sbasAvailplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasRiskplotsFile[MAX_INPUT_LINE+50];
	char						sbasRiskplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasRiskMarplotsFile[MAX_INPUT_LINE+50];
	char						sbasRiskMarplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasDiscontinuityFile[MAX_INPUT_LINE+50];
	char						sbasDiscontinuityFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasIonoplotsFile[MAX_INPUT_LINE+50];
	char						sbasIonoplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasHDOPplotsFile[MAX_INPUT_LINE+50];
	char						sbasHDOPplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasPDOPplotsFile[MAX_INPUT_LINE+50];
	char						sbasPDOPplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasGDOPplotsFile[MAX_INPUT_LINE+50];
	char						sbasGDOPplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						sbasCombDOPplotsFile[MAX_INPUT_LINE+50];
	char						sbasCombDOPplotsFileNoExtension[MAX_INPUT_LINE+50];
	char						rnxFile[MAX_INPUT_LINE+50];
	char						dataASCIIFile[MAX_INPUT_LINE+50];
	char						antennaASCIIFile[MAX_INPUT_LINE+50];
	char						dgnssFile[MAX_INPUT_LINE];
	char						rtcmFile[MAX_INPUT_LINE];
	char						rtcm2File[MAX_INPUT_LINE];
	char						rtcm3File[MAX_INPUT_LINE];
	char						stanfordESAFile[MAX_INPUT_LINE+50];
	char						stanfordESALOIFile[MAX_INPUT_LINE+50];
	char						SBASIONOFile[MAX_INPUT_LINE];
	char						sigmamultipathFile[MAX_INPUT_LINE];
	char						addederrorFile[MAX_INPUT_LINE];
	char						posReferenceFile[MAX_INPUT_LINE];
	char						BRDCTypesList[MAX_GNSS][MAX_INPUT_LINE];
	int							numTGD;
	int							numP1C1DCB;
	int							numP1P2DCB;
	int							numSINEXBIASOSB;
	int							numSINEXBIASDSB;
	int							numP1P2RINEX;
	int							numP1P2IONEX;
	int							numP1P2FPPP;
	int							csPos;
	int							csAllPosOn;
	int							csAllPosOff;
	int							csLLI;
	int							csLLIPosOn;
	int							csLLIPosOff;
	int							csLI;
	int							csLIPosOn;
	int							csLIPosOff;
	int							csMW;
	int							csMWPosOn;
	int							csMWPosOff;
	int							csSF;
	int							csSFPosOn;
	int							csSFPosOff;
	int							csIGF;
	int							csIGFPosOn;
	int							csIGFPosOff;
	int							sbas1FfileProvided;
	int							sbasDFMCfileProvided;
	int							totalFilterMeasurements;
	int							numsmoothWith;
	int							numcsSFtext[NUM_OBSRINEX];
	int							numcsMWtext[NUM_OBSRINEX];
	int							numcsLItext[NUM_OBSRINEX];
	int							numcsIGFtext[NUM_OBSRINEX];
	int							numcsSFfreqtext[NUM_OBSRINEX];
	int							numcsMWfreqtext[NUM_OBSRINEX];
	int							numcsLIfreqtext[NUM_OBSRINEX];
	int							numcsIGFfreqtext[NUM_OBSRINEX];
	int							numweightText;
	int							numweightTextComb;
	int							numweightTextMode;
	char						numprintMeastext;
	char						**measFilterText[NUM_OBSRINEX];
	char						**smoothMeasFilterText[NUM_OBSRINEX];
	char						**smoothWithMeasFilterText[NUM_OBSRINEX];
	char						**measDopplerText[NUM_OBSRINEX];
	char						**measTableText[NUM_OBSRINEX];
	char						**csSFtext[NUM_OBSRINEX];
	char						**csMWtext[NUM_OBSRINEX];
	char						**csLItext[NUM_OBSRINEX];
	char						**csIGFtext[NUM_OBSRINEX];
	char						**csSFfreqtext[NUM_OBSRINEX];
	char						**csMWfreqtext[NUM_OBSRINEX];
	char						**csLIfreqtext[NUM_OBSRINEX];
	char						**csIGFfreqtext[NUM_OBSRINEX];
	char						**weightText;
	char						**weightTextSat;
	char						**weightTextComb;
	char						**weightTextCombSat;
	char						**weightTextMode;
	char						**weightTextModeSat;
	char						**printMeastext;
	char						**recPhaseCenterParam;
	char						**IFRefMeas;
	int							numMeasFilterText[NUM_OBSRINEX];
	int							numSmoothMeasFilterText[NUM_OBSRINEX];
	int							numMeasDopplerText[NUM_OBSRINEX];
	int							numMeasTableText[NUM_OBSRINEX];
	int							userFilterMeas[NUM_OBSRINEX];
	int							userFilterSmoothMeas[NUM_OBSRINEX];
	int							userMeasOrderList[NUM_OBSRINEX];
	int							userDopplerMeas[NUM_OBSRINEX];
	int							numRecPhaseCenterParam;
	int							numIFRefMeas;
	
	enum CombineWeightsMode		*CombineWeightMode;  // Vector containing how to combine the weights
	enum SNRWeightComb			*SNRweightComb; // Vector containing how to get the SNR when a weight with SNR is used
	enum WeightMode				*weightMode;	// Vector containing the type of weight applied to each satellite and measurement
	double 						**SNRweightCombVal; // Vector containing the factors for combining the SNR
	double						**WeightConstantsValues;	// Vector containing the constants to compute the weights of the measurements

	double						filterParams[3][MAX_PAR];
	// filterParams is the data for Phi, Q and P0, the first dimension of the matrix
	// accounts for: 0->Phi,  1->Q  and  2->P0. To access it: PHI_PAR, Q_PAR and P0_PAR
	// The second dimension accounts for the unknown types, in particular, to access it
	// it should be used: DR_UNK, DT_UNK, TROP_UNK and BIAS_UNK
	int							discardEclipsedSatellites;
	enum ReceiverType			setRecType[NUM_OBSRINEX];
	double						stfdesaxmax;
	double						stfdesaymax;
	double						stfdesaxres;
	double						stfdesayres;
	char						deprecatedMessages[MAX_MESSAGE_STR];	//String to save WARNING for deprecated options
	int							disableCursor;
	int							UserSetPrintProgress;
	int							UserForcedPrintProgress;

	int							NoIonoPlot;
	enum SBASdataModes			SBAScorrections;
} TSupportOptions;

/**************************************
 * Declarations of internal operations
 **************************************/

void initSupportOptions (TSupportOptions *sopt);
void showHelp (void);
void showExamples (void);
void showConfig (void);
void showMessages (void);
void showMessagesv5 (void);
void showsigmamultipathfile (void);
void showusererrorfile (void);
void showRTCMv2ConversionInfo (void);
void showReferencePositionFileInfo (void);
void showSBASPlotsInfo (void);
void showFAQ (void);
void showBashAutoCompleteScript(void);
int checkIfNextParameter(char *str);
void parseSatellitelist (char *str, int endtype, int *removeMeas, int *lastCharac, int *GNSSused, int *PRNused, TOptions *options);
void parseMeasurements (enum parseMeasType mode, int staType, int roundMode, TSupportOptions *sopt, TOptions *options);
int parseOption (TSupportOptions *sopt, TOptions *options, char *argv[]);
int parseAllOptions (TSupportOptions *sopt,TOptions *options, int argc, char *argv[]);
void removeExtension (char* mystr,char *retstr);
void getRTCMpath (char* mystr,char *retstr);
int processOptions (TSupportOptions *sopt, TOptions *options);
void setAutomaticSmoothing (TOptions *options);
void setDefaultMeasurements (TEpoch *epoch, TEpoch *epochDGNSS, TConstellation *constellation, TSupportOptions *sopt, TOptions *options);
int readConfig (FILE *fd, TSupportOptions *sopt, TOptions *options);
int checkConfigFile (TSupportOptions *sopt, TOptions *options);
void freeInputMeasString (TSupportOptions *sopt);
void compareOrbits (TGNSSproducts **products, TGNSSproducts **pastProducts, TGNSSproducts **nextProducts, FILE **fdRNXnav, int *retRNXnav, double *rinexNavVersion, FILE **fdSP3, int *retSP3, FILE **fdSP3o, int *retSP3o, FILE **fdCLK, int *retCLK, double *OrbitsMaxDistance, double *OrbitsToTMaxDistance, double *ClocksMaxDistance, double *ClocksToTMaxDistance, TConstellation *constellation, TTime startTime, TTime endTime, TTime endTimePercentage, double numberEpochs, int startTimeFromNav, TOptions *options, TSupportOptions *sopt);
void showProduct (TGNSSproducts *products, TGNSSproducts *pastProducts, TGNSSproducts *nextProducts, FILE *fdRNXnav, int retRNXnav, double rinexNavVersion, FILE *fdSP3, int retSP3, FILE *fdSP3o, int retSP3o, FILE *fdCLK, int retCLK, TConstellation *constellation, TTime startTime, TTime endTime, TTime endTimePercentage, double numberEpochs, TConstellation *constellationPrint, TOptions *options, TSupportOptions *sopt);
void productsProcessing (TOptions *options, TSupportOptions *sopt, TConstellation *constellation, TConstellation *constellationPrint);
void AddUserError2RINEX (char *ObsFilename, char *UserErrorFilename, char *gloNavFile, char *OutputObsFile, TEpoch *epoch, TUserError *UserError, TOptions *options);


/*****************************************************************************
 * Name        : initSupportOptions
 * Description : Initialises support options
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TSupportOptions  *sopt          IO N/A  TSupportOptions structure to initialise
 *****************************************************************************/
void initSupportOptions (TSupportOptions *sopt) {
	int	i,j;

	sopt->navKinematics = NKND;
	sopt->navMode = NMND;
	sopt->navObservables = NTND;
	sopt->cfgFile[0] = '\0';
	sopt->obsFile[0] = '\0';
	sopt->conFile[0] = '\0';
	sopt->recFile[0] = '\0';
	sopt->snxFile[0] = '\0';
	sopt->glonavFile[0] = '\0';
	for(i=0;i<MAX_SP3_FILES;i++) {
		sopt->SP3File[i][0] = '\0';
		sopt->orbFile[i][0] = '\0';
		sopt->clkFile[i][0] = '\0';
	}
	for(i=0;i<MAX_NAV_FILES;i++) {
		sopt->navFile[i][0] = '\0';
		sopt->navHealthFile[i][0] = '\0';
	}
	for (i=0;i<MAX_DCB_FILE_SOURCES;i++) {
		sopt->tgdFile[i][0] = '\0';
	}
	sopt->numNav = 0;
	sopt->numNavHealth = 0;
	sopt->numSP3 = 0;
	sopt->numOrb = 0;
	sopt->numClk = 0;
	sopt->numTGD = 0;
	sopt->numAntRec = 0;
	sopt->numP1C1DCB = 0;
	sopt->numP1P2DCB = 0;
	sopt->numSINEXBIASOSB = 0;
	sopt->numSINEXBIASDSB = 0;
	sopt->numP1P2RINEX = 0;
	sopt->numP1P2IONEX = 0;
	sopt->numP1P2FPPP = 0;
	sopt->outFile[0] = '\0';
	sopt->kmlFile[0] = '\0';
	sopt->kml0File[0] = '\0';
	sopt->SP3OutputFile[0] = '\0';
	sopt->RefPosOutputFile[0] = '\0';
	sopt->antFile[0]= '\0';
	for (i=0;i<MAX_RECV_ANTEX_FILES;i++) {
		sopt->antrecFile[i][0]= '\0';
	}
	sopt->antsatblockFile[0] = '\0';
	sopt->klbFile[0] = '\0';
	sopt->beiFile[0] = '\0';
	sopt->fppFile[0] = '\0';
	sopt->neqFile[0] = '\0';
	sopt->inxFile[0] = '\0';
	sopt->GalFile[0] = '\0';
	sopt->sbasFile[0] = '\0';
	sopt->sbasAvailplotsFile[0] = '\0';
	sopt->sbasAvailplotsFileNoExtension[0] = '\0';
	sopt->sbasRiskplotsFile[0] = '\0';
	sopt->sbasRiskplotsFileNoExtension[0] = '\0';
	sopt->sbasRiskMarplotsFile[0] = '\0';
	sopt->sbasRiskMarplotsFileNoExtension[0] = '\0';
	sopt->sbasDiscontinuityFile[0] = '\0';
	sopt->sbasDiscontinuityFileNoExtension[0] = '\0';
	sopt->sbasIonoplotsFile[0] = '\0';
	sopt->sbasIonoplotsFileNoExtension[0] = '\0';
	sopt->sbasHDOPplotsFile[0]='\0';
	sopt->sbasHDOPplotsFileNoExtension[0]='\0';
	sopt->sbasPDOPplotsFile[0]='\0';
	sopt->sbasPDOPplotsFileNoExtension[0]='\0';
	sopt->sbasGDOPplotsFile[0]='\0';
	sopt->sbasGDOPplotsFileNoExtension[0]='\0';
	sopt->sbasCombDOPplotsFile[0]='\0';
	sopt->sbasCombDOPplotsFileNoExtension[0]='\0';
	sopt->rnxFile[0] = '\0';
	sopt->dataASCIIFile[0] = '\0';
	sopt->antennaASCIIFile[0] = '\0';
	sopt->dgnssFile[0] = '\0';
	sopt->rtcmFile[0] = '\0';
	sopt->rtcm2File[0] = '\0';
	sopt->rtcm3File[0] = '\0';
	sopt->stanfordESAFile[0] = '\0';
	sopt->stanfordESALOIFile[0] = '\0';
	sopt->SBASIONOFile[0]='\0';
	sopt->sigmamultipathFile[0]='\0';
	sopt->addederrorFile[0]='\0';
	sopt->posReferenceFile[0]='\0';
	for(i=0;i<MAX_GNSS;i++) {
		sopt->BRDCTypesList[i][0]='\0';
	}
	sopt->satelliteHealth=-1;
	sopt->allowMarginal=-1;
	sopt->anySmoothOptionSetByUser=0;
	sopt->ionoModel = UNKNOWN_IM;
	sopt->troposphericCorrection = -1;
	sopt->tropNominal = UNKNOWN_TMNominal; 
	sopt->tropMapping = UNKNOWN_TMMapping;
	sopt->GPSp1c1DCBModel = GPSp1c1UNKNOWN;
	sopt->GPSp1p2DCBModel = DCBUNKNOWN;
	sopt->GPSISCl1caDCBModel = DCBUNKNOWN;
	sopt->GPSISCl1cpDCBModel = DCBUNKNOWN;
	sopt->GPSISCl1cdDCBModel = DCBUNKNOWN;
	sopt->GPSISCl2cDCBModel = DCBUNKNOWN;
	sopt->GPSISCl5i5DCBModel = DCBUNKNOWN;
	sopt->GPSISCl5q5DCBModel = DCBUNKNOWN;
	sopt->GALe1e5aDCBModel = DCBUNKNOWN;
	sopt->GALe1e5bDCBModel = DCBUNKNOWN;
	sopt->GLOp1p2DCBModel = DCBUNKNOWN;
	sopt->BDSb1b6DCBModel = DCBUNKNOWN;
	sopt->BDSb2b6DCBModel = DCBUNKNOWN;
	sopt->BDSb5b6DCBModel = DCBUNKNOWN;
	sopt->BDSb7b6DCBModel = DCBUNKNOWN;
	sopt->BDSSP3DCBModel= DCBUNKNOWN;
	sopt->BDSISCb1cdDCBModel = DCBUNKNOWN;
	sopt->BDSISCb2adDCBModel = DCBUNKNOWN;
	sopt->QZSc1cDCBModel = DCBUNKNOWN;
	sopt->QZSISCl1cpDCBModel = DCBUNKNOWN;
	sopt->QZSISCl1cdDCBModel = DCBUNKNOWN;
	sopt->QZSISCl2cDCBModel = DCBUNKNOWN;
	sopt->QZSISCl5i5DCBModel = DCBUNKNOWN;
	sopt->QZSISCl5q5DCBModel = DCBUNKNOWN;
	sopt->IRNc9c5DCBModel = DCBUNKNOWN;
	sopt->OSBdcbModel = OSBUNKNOWN;
	sopt->DSBdcbModel = DSBUNKNOWN;
	sopt->DualFreqDCBModel[GPS] = DCBUNKNOWN;
	sopt->DualFreqDCBModel[Galileo] = DCBUNKNOWN;
	sopt->DualFreqDCBModel[GLONASS] = DCBUNKNOWN;
	sopt->DualFreqDCBModel[GEO] = DCBUNKNOWN;
	sopt->DualFreqDCBModel[BDS] = DCBUNKNOWN;
	sopt->DualFreqDCBModel[QZSS] = DCBUNKNOWN;
	sopt->DualFreqDCBModel[IRNSS] = DCBUNKNOWN;
	sopt->csLI = -1;
	sopt->csMW = -1;
	sopt->csSF = -1;
	sopt->csLLI = -1;
	sopt->csIGF = -1;
	sopt->csPos = 0;
	sopt->csAllPosOn  = -1;
	sopt->csAllPosOff = -1;
	sopt->csLIPosOn   = -1;
	sopt->csLIPosOff  = -1;
	sopt->csMWPosOn   = -1;
	sopt->csMWPosOff  = -1;
	sopt->csLLIPosOn  = -1;
	sopt->csLLIPosOff = -1;
	sopt->csSFPosOn   = -1;
	sopt->csSFPosOff  = -1;
	sopt->csIGFPosOn  = -1;
	sopt->csIGFPosOff = -1;
	sopt->smoothAuto = 0;
	sopt->estimateTroposphere = -1;
	sopt->totalFilterMeasurements = -1;
	sopt->discardEclipsedSatellites = -1;
	sopt->stfdesaxmax = 50;
	sopt->stfdesaymax = 50;
	sopt->stfdesaxres = 0.1;
	sopt->stfdesayres = 0.1;
	sopt->numsmoothWith = 0;

	for(i=0;i<NUM_OBSRINEX;i++) {
		sopt->numMeasFilterText[i]=0;
		sopt->numSmoothMeasFilterText[i]=0;
		sopt->numMeasTableText[i]=0;
		sopt->numMeasDopplerText[i]=0;
		sopt->numcsSFtext[i]=0;
		sopt->numcsMWtext[i]=0;
		sopt->numcsLItext[i]=0;
		sopt->numcsIGFtext[i]=0;
		sopt->numcsSFfreqtext[i]=0;
		sopt->numcsMWfreqtext[i]=0;
		sopt->numcsLIfreqtext[i]=0;
		sopt->numcsIGFfreqtext[i]=0;
		sopt->userFilterMeas[i]=0;
		sopt->userFilterSmoothMeas[i]=0;
		sopt->userMeasOrderList[i]=0;
		sopt->userDopplerMeas[i]=0;
		sopt->measFilterText[i]=NULL;
		sopt->measDopplerText[i]=NULL;
		sopt->smoothMeasFilterText[i]=NULL;
		sopt->smoothWithMeasFilterText[i]=NULL;
		sopt->csSFtext[i]=NULL;
		sopt->csMWtext[i]=NULL;
		sopt->csLItext[i]=NULL;
		sopt->csIGFtext[i]=NULL;
		sopt->csSFfreqtext[i]=NULL;
		sopt->csMWfreqtext[i]=NULL;
		sopt->csLIfreqtext[i]=NULL;
		sopt->csIGFfreqtext[i]=NULL;
		sopt->measTableText[i]=NULL;
	}
	sopt->sbas1FfileProvided=0;
	sopt->sbasDFMCfileProvided=0;
	sopt->numweightText=0;
	sopt->numweightTextComb=0;
	sopt->numweightTextMode=0;
	sopt->numprintMeastext=0;
	sopt->weightText=NULL;
	sopt->weightTextSat=NULL;
	sopt->weightTextComb=NULL;
	sopt->weightTextCombSat=NULL;
	sopt->weightTextMode=NULL;
	sopt->weightTextModeSat=NULL;
	sopt->printMeastext=NULL;
	sopt->CombineWeightMode=NULL;
	sopt->weightMode=NULL;
	sopt->SNRweightComb=NULL;
	sopt->SNRweightCombVal=NULL;
	sopt->WeightConstantsValues=NULL;

	for (i=0;i<3;i++) {
		for (j=0;j<MAX_PAR;j++) {
			sopt->filterParams[i][j] = -1;
		}
	}

	sopt->recPhaseCenterParam=NULL;
	sopt->numRecPhaseCenterParam=0;
	
	sopt->IFRefMeas=NULL;
	sopt->numIFRefMeas=0;

	sopt->setRecType[ROVERPOS] = rtNA;
	sopt->setRecType[REFSTAPOS] = rtNA;
	sopt->deprecatedMessages[0] = '\0';
	sopt->disableCursor=1;
	sopt->UserSetPrintProgress=0;
	sopt->UserForcedPrintProgress=0;

	sopt->NoIonoPlot=-1;
	sopt->SBAScorrections=NoSBASdata;
}

/*****************************************************************************
 * Name        : showHelp
 * Description : Shows the program help in the standard output
 * Parameters  : None
 *****************************************************************************/
void showHelp () {

	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("GNSS LABORATORY. Tool to analyse GNSS data\n\n");
	printf("Supervisor:\n");
	printf("    Jaume Sanz Subirana     group of Astronomy and GEomatics (gAGE/UPC)\n\n");
	printf("Maintainer:\n");
	printf("    Deimos Ibanez Segura    group of Astronomy and GEomatics (gAGE/UPC)\n\n");
	printf("Developers:\n");
	printf("    Pere Ramos-Bosch        group of Astronomy and GEomatics (gAGE/UPC)\n\n");
	printf("    Deimos Ibanez Segura    group of Astronomy and GEomatics (gAGE/UPC)\n\n");
	printf("    Adria Rovira-Garcia     group of Astronomy and GEomatics (gAGE/UPC)\n\n");
	printf("    Jesus Romero Sanchez    group of Astronomy and GEomatics (gAGE/UPC)\n\n");
	printf("                            Please send any bugs/comments to:  glab.gage @ upc.edu   \n\n");
	printf("Website:\n");
	printf("    www.gage.es/gLAB\n\n");     
	printf("Usage:\n");
	printf("    gLAB [options]\n\n");
	printf("Options (all options are case insensitive):\n\n");
	printf("    -help                   Shows this help\n\n");
	printf("    -messages               Shows the fields of each output message (see below, 'VERBOSE OPTIONS')\n\n");
	printf("    -messagesv5             Shows the fields of each output message with v5 format (used only when option '-print:v5format' is enabled)\n\n");
	printf("    -examples               Shows some examples to call the program\n\n");
	printf("    -faq                    Shows a FAQ (Frequently Asked Questions)\n\n");
	printf("    -autofillscript         Shows a bash script for enabling autofilling gLAB options with a Bash terminal.\n");
	printf("                              Read the comments on top of the script for instructions on how to install it.\n\n");
	printf("    -config                 Shows some info on the configuration file\n\n");
	printf("    -usererrorfile          Shows an example of user-defined error configuration file\n\n");
	printf("    -sigmamultipathfile     Shows an example of user multipath model configuration file\n\n");
	printf("    -rtcmv2conversioninfo   Shows detailed information of the text files generated from a RTCM v2.x conversion\n\n");
	printf("    -referenceposfile       Shows an example of reference position file\n\n");
	printf("    -sbasplotsinfo          Shows detailed info on how to generate SBAS maps\n");
	#if defined _OPENMP
		printf("\n    -numthreads <num>     Sets the number of parallel threads to be used in the processing (multithread is only\n");
		printf("                             used in the cycle-slip detection and modelling sections). Multi-thread is only\n");
		printf("                             available if gLAB is compiled with '-fopenmp' flag (OpenMP threads)\n"); 
	#endif
	printf("\n  INPUT OPTIONS\n\n");
	printf("    -input:cfg <file>       Sets the input configuration file\n\n");
	printf("    -input:obs <file>       Sets the input RINEX observation file\n\n");
	printf("    -input:nav <file> [...] Sets the input RINEX navigation message files. Up to %d files may be provided (one per constellation)\n\n",MAX_GNSS);
	printf("                                  If two RINEX navigation files are provided and no observation file is given, gLAB will enter in orbit comparison mode\n");
	printf("                                  If one RINEX navigation file is provided and one SP3 file is provided file and no observation file is given,\n");
	printf("                                    gLAB will enter in orbit comparison mode\n\n");
	printf("    -input:navglo <file>    Sets the input RINEX navigation message file for reading GLONASS frequency offset\n\n");
	printf("    -input:navhealth <file> [...] Sets the input RINEX navigation message files for reading satellite health (only when using precise products)\n");
	printf("                                   Up to %d files may be provided (one per constellation)\n\n",MAX_GNSS);
	printf("    -input:sp3 <file> [<file>]  Sets the input SP3 orbits and clocks file.\n");
	printf("                                  If two SP3 files are provided and no observation file is given, gLAB will enter in orbit comparison mode\n\n");
	printf("    -input:orb <file> [<file>]  Sets the input SP3 orbits (only reads the satellite coordinates, but not the clocks)\n");
	printf("                                  If two SP3 files are provided and no observation file is given, gLAB will enter in orbit comparison mode\n\n");
	printf("    -input:clk <file>       Sets the input clock file. The number of clock files must match the number of\n");
	printf("                                  SP3 files provided with option '-input:orb'\n\n");
	printf("    -input:con <file>       Sets the input constellation status file (default GPSConstellationStatus.txt)\n\n");
	printf("    -input:ant <file>       Sets the input ANTEX satellite/receiver antenna data file\n\n");
	printf("    -input:antrec <file> [<file>]   Sets the input ANTEX receiver antenna data file. If this file contains data for\n");
	printf("                               satellites, this data will be skipped. Up to two receiver ANTEX files may be provided.\n");
	printf("                               If a receiver read with this ANTEX had been also read with the ANTEX provided with\n");
	printf("                               parameter '-input:ant', the data will be overwritten with the last data read.\n");
	printf("                               Up to two receiver ANTEX files may be provided\n\n");
	printf("    -input:antsatblock <file>   Sets the input ANTEX file for reading the satellites block type (e.g. GPS BLOCK II-A, II-R, etc.)\n");
	printf("                                With the satellite block type, gLAB can know which measurements has available each\n");
	printf("                                 satellite (e.g. which GPS satellites have  or do not have L5 frequency), and thus auto remove\n");
	printf("                                 all unavailable measurements of the satellite from the priority list.\n");
	printf("                                The typical use case for this option is when the user sets, for instance, in the filter, the\n");
	printf("                                 option '-filter:select G0-PC15 G0-PC12 G0-LC15 G0-LC12', which is a typical PPP with three\n");
	printf("                                 frequencies. Without an ANTEX file (provided with parameter '-input:ant' or '-input:antsatblock'\n");
	printf("                                 all GPS satellites with no L5 measurements would be discarded, as it will be detected that there\n");
	printf("                                 are measurements missing (L5 ones) for cycle-slip and the filter. With the ANTEX file, all L5\n");
	printf("                                 measurements will be removed (in cycle-slips and filter) in all satellites without L5, and therefore\n");
	printf("                                 gLAB will use L1,L2,L5 measurements in satellites with L5 and only L1,L2 in satellites without L5.\n");
	printf("                                If '-input:ant' parameter is provided, there is no need to provide this parameter (as satellite blocks\n");
	printf("                                 can be read from '-input:ant' ANTEX file), unless the user wants to use an ANTEX file different from the\n");
	printf("                                one provided in '-input:ant' parameter.\n\n");
	printf("    -input:klb <file>       Sets the input RINEX navigation file for Klobuchar corrections, if this parameter\n");
	printf("                             is avoided, it is used the -input:nav file\n\n");
	printf("    -input:bds <file>       Sets the input RINEX navigation file for BeiDou corrections, if this parameter\n");
	printf("                             is avoided, it is used the -input:nav file\n\n");
	printf("    -input:inx  <file>      Sets the input IONEX file for ionospheric corrections\n\n");
	printf("    -input:fppp <file>      Sets the input FPPP file for ionospheric corrections\n\n");
	printf("    -input:neq  <file>      Sets the input RINEX navigation file for NeQuick corrections, if this parameter\n");
	printf("                             is avoided, it is used the -input:nav file\n\n");
	printf("    -input:sbasiono <file>  Sets the input RINEX-B or EMS SBAS file for ionospheric corrections\n\n");
	printf("    -input:dcb <file> [...] Sets the input DCB source from a .DCB file, a RINEX navigation file, a IONEX file or a FPPP file.\n");
	printf("                             If more than one file is given for the same model, the last one will be used \n\n");
	printf("    -input:rec <file>       Sets the input GPS receiver types file (default GPS_Receiver_Types) for DCB usage\n\n");
	printf("    -input:snx <file>       Sets the input SINEX file for receiver position\n\n");
	printf("    -input:sbas1f <file>    Sets the SBAS data file (RINEX-B v2.11 or EMS). Activates SBAS 1F processing mode\n\n");
	printf("    -input:sbasdfmc <file>  Sets the SBAS data file (RINEX-B v2.11 or EMS). Activates SBAS DFMC processing mode\n\n");
	printf("    -input:dgnss <file>     Sets the input RINEX observation file of the Reference Station for DGNSS\n\n");
	printf("    -input:rtcm <file>      Sets the input RTCM binary file, gLAB will automatically detect the RTCM version\n\n");
	printf("    -input:rtcm2 <file>     Sets the input RTCM v2.x binary file\n\n");
	printf("    -input:rtcm3 <file>     Sets the input RTCM v3.x binary file\n\n");
	printf("    -input:rtcm:initdate <date>     Sets the date when the record of the binary file RTCM began (YYYYMMDD), required only\n");
	printf("                                      when processing or converting RTCM v2.x and RTCM v3.x\n\n");
	printf("    -input:rtcm:inithour <hour>     Sets the hour in GPST, when the record of the binary file RTCM began (HH 24-hour format),\n");
	printf("                                      required when processing or converting RTCM v2.x\n\n");
	printf("    -input:sigmpath  <file> Sets the data file for user sigma multipath model for SBAS (execute 'gLAB -sigmamultipathfile' for details)\n\n");
	printf("    -input:usererror <file> Sets the data file for adding user defined error signal to raw measurements (execute 'gLAB -usererrorfile' for details)\n\n");
	printf("    -input:refpos    <file> Sets the reference position file. It can be a SP3 or a columnar text file (execute 'gLAB -referencefile' for details)\n");
	printf("                             This option will set receiver positioning mode to 'calculate' if non set. See '-pre:setrecpos' option below for details\n\n");
	printf("    The use of '-input:nav' file will preconfigure the parameters to work in the Standard Point Positioning (SPP).\n\n");
	printf("    The use of '-input:sp3'/'-input:orb'/'-input:clk' will preconfigure the parameters to work in the Precise Point\n");
	printf("      Positioning (PPP) approach. All the values can be overridden by specifying the parameters. See below for more details\n");
	printf("      on which are the defaults for each mode.\n\n");
	printf("    The use of '-input:sbas1f' will preconfigure the parameters to work in SBAS 1 Frequency mode.\n\n");
	printf("    The use of '-input:sbasdfmc' will preconfigure the parameters to work in SBAS DFMC mode.\n\n");
	printf("    The use of any '-input:rtcm' without a '-input:obs' will result into converting the input RTCM to its corresponding output.\n");
	printf("\n  PREPROCESSING OPTIONS   (use -pre:... to activate, --pre:... to deactivate, when applicable)\n\n");
	printf("    -pre:starttime <date>   Set the start time (in GPS time) for processing data. The following date formats are accepted:\n");
	printf("                              YYYYMMDD HH:MM:SS (HH in 24 hour format)\n");
	printf("                              YYYY/MM/DD HH:MM:SS (HH in 24 hour format)\n");
	printf("                              YYYY/DoY SoD\n");
	printf("                              GPSWeek SoW\n\n");
	printf("    -pre:endtime <date>     Set the end time (in GPS time) for processing data. See '-pre:starttime' option above for date formats\n\n");
	printf("    -pre:dec #              # = number              Decimate input data by # seconds [default 0 for SPP/PPP/DGNSS, 1 for SBAS]\n");
	printf("                              Maximum resolution is 4 decimals digits.\n");
	printf("                              If # is 0, all epochs are processed.\n");
	printf("                            In product comparison mode (see below, in 'WORK MODES'), it sets the time step of the comparisons\n\n");
	printf("    -pre:sat [+-]g[g]#[-#][.#[-#]][,[+-]g[g]#[-#][.#[-#]]] [...]\n");
	printf("                            Include/exclude satellites from processing in a comma separated list\n");
	printf("                            [+-]     =  Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                         If no symbol is provided, the default behaviour is to unselect satellites\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                                        If character is '0', all satellites from all constellations will be selected or unselected\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number (If #=0, all satellites of the selected GNSS constellation will be unselected)\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                        of satellites (of the same constellation)\n\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                        with a dot ('.')\n");
	printf("    -pre:geoexclude #[,#..] [...] Exclude GEO satellite for SBAS. Data from this GEO will be ignored for SBAS corrections\n");
	printf("                            # = PRN number\n");
	printf("                            [,#..] Optionally, a list of GEO can be provided by separating the numbers with commas (',')\n\n");
	printf("    -pre:geosel #           Select GEO satellite for SBAS corrections\n");
	printf("                            # = 0 => Use data from all GEO (all GEO mixed)\n");
	printf("                            # = 1 => Use GEO from the first line of SBAS data read [default in SBAS maps mode]\n");
	printf("                            # = 2 => Use the GEO with highest elevation [default in SBAS processing mode]\n");
	printf("                            %3d <= # <= %3d => Use the GEO with the given PRN\n\n",MINGEOPRN,MAXGEOPRN);
	printf("    -pre:minsnr             Set a minimum SNR (Signal to Noise Ratio) value for using a satellite.\n");
	printf("                            The SNR is read from the observation file. [default on in SBAS and DGNSS]\n");
	printf("                            If no SNR is present in the observation file, no deselection is done. The default threshold is 33 dBHz\n\n");
	printf("    -pre:minsnrsel g[g]#[-#][.#[-#]] <val> [#[.#.#]][-<meas1>[-<meas2>]] [g[g]#[-#][.#[-#]] <val> [#[.#.#]][-<meas1>[-<meas2>]]] [...]\n");  
	printf("                               Set a minimum SNR threshold for a given satellite. If this option is given, SNR deselection will be activated\n");
	printf("                            g     = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]   = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #     = PRN number. If #=0, then the threshold will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]  = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                      of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                        with a dot ('.')\n");
	printf("                            <val> = Value for SNR threshold in dBHz. This value is compared to the SNR obtained from the RINEX file in all code,\n");
	printf("                                     carrier phase and Doppler measurements. If no SNR value is present in the RINEX file, this value will be omitted.\n");
	printf("                            [#[.#.#]][-<meas1>[-<meas2>]] = Optionally, the user can set a list of frequencies or measurements (or both)\n");
	printf("                                     where to apply this threshold. If a frequency is given, all measurements from that frequency will have\n");
	printf("                                     the threshold applied. If no frequency or measurement is given, it will be applied to all measurements.\n");
	printf("                                     Any number of frequencies or measurements can be given, as long as frequencies are grouped and separated\n");
	printf("                                     by dots, and separated from measurements with a dash ('-'). Each measurement given has to be separated\n");
	printf("                                     with a dash ('-'). The list of frequencies may be given in any position, not necessarily before the\n");
	printf("                                     measurements or after the measurements.\n");
	printf("                                     If a measurement is provided (code, carrier phase or Doppler), the threshold will be applied to code,\n");
	printf("                                     carrier phase and Doppler measurements of the same type (for instance C1C, L1C and D1C), as in the RINEX\n");
	printf("                                     observation file these measurements share the SNR value.\n");
	printf("                            Sample: '-pre:minsnrsel G0 33' Set a threshold of 33 dbHz to all GPS measurements.\n");
	printf("                                    '-pre:minsnrsel GE0 33 1.5' Set a threshold of 33 dbHz to all GPS and Galileo satellites in measurements in frequencies 1 and 5.\n");
	printf("                                    '-pre:minsnrsel GR0 33 C1C-C5I' Set a threshold of 33 dbHz to all GPS and GLONASS satellites in measurements C1C and C5I.\n");
	printf("                                    '-pre:minsnrsel CJ0 33 2.7-C1C-C5I' Set a threshold of 33 dbHz to all BeiDou and QZSS satellites in measurements C1C and C5I\n");
	printf("                                                                         BeiDou and QZSS satellites in measurements in frequencies 2 and 7.\n");
	printf("                                    '-pre:minsnrsel GE0 33 1.5 C0 34' Set a threshold of 33 dbHz to all GPS and Galileo satellites in measurements in frequencies 1 and 5\n");
	printf("                                                                       and a threshold of 34 dbHz to all BeiDou satellites and measurements.\n\n");
	printf("    -pre:maxsnr             Set a maximum SNR (Signal to Noise Ratio) value for using a satellite. Discarding satellites with high SNR can be\n");
	printf("                            useful for filtering satellites under spoofing. The SNR is read from the observation file. [default off]\n");
	printf("                            If no SNR is present in the observation file, no deselection is done. The default threshold is 54 dBHz\n\n");
	printf("    -pre:maxsnrsel g[g]#[-#][.#[-#]] <val> [#[.#.#]][-<meas1>[-<meas2>]] [g[g]#[-#][.#[-#]] <val> [#[.#.#]][-<meas1>[-<meas2>]]] [...]\n");  
	printf("                               Set a maximum SNR threshold for a given satellite. If this option is given, SNR deselection will be activated\n");
	printf("                            g     = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]   = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #     = PRN number. If #=0, then the threshold will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]  = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                      of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                        with a dot ('.')\n");
	printf("                            <val> = Value for SNR threshold in dBHz. This value is compared to the SNR obtained from the RINEX file in all code,\n");
	printf("                                     carrier phase and Doppler measurements. If no SNR value is present in the RINEX file, this value will be omitted.\n");
	printf("                            [#[.#.#]][-<meas1>[-<meas2>]] = Optionally, the user can set a list of frequencies or measurements (or both)\n");
	printf("                                     where to apply this threshold. If a frequency is given, all measurements from that frequency will have\n");
	printf("                                     the threshold applied. If no frequency or measurement is given, it will be applied to all measurements.\n");
	printf("                                     Any number of frequencies or measurements can be given, as long as frequencies are grouped and separated\n");
	printf("                                     by dots, and separated from measurements with a dash ('-'). Each measurement given has to be separated\n");
	printf("                                     with a dash ('-'). The list of frequencies may be given in any position, not necessarily before the\n");
	printf("                                     measurements or after the measurements.\n");
	printf("                                     If a measurement is provided (code, carrier phase or Doppler), the threshold will be applied to code,\n");
	printf("                                     carrier phase and Doppler measurements of the same type (for instance C1C, L1C and D1C), as in the RINEX\n");
	printf("                                     observation file these measurements share the SNR value.\n");
	printf("                            Sample: '-pre:maxsnrsel G0 60' Set a threshold of 60 dbHz to all GPS measurements\n");
	printf("                                    '-pre:maxsnrsel GE0 60 1.5' Set a threshold of 60 dbHz to all GPS and Galileo satellites in measurements in frequencies 1 and 5\n");
	printf("                                    '-pre:maxsnrsel GR0 60 C1C-C5I' Set a threshold of 60 dbHz to all GPS and GLONASS satellites in measurements C1C and C5I\n");
	printf("                                    '-pre:maxsnrsel CJ0 60 2.7-C1C-C5I' Set a threshold of 60 dbHz to all BeiDou and QZSS satellites in measurements C1C and C5I\n");
	printf("                                                                       BeiDou and QZSS satellites in measurements in frequencies 2 and 7\n");
	printf("                                    '-pre:maxsnrsel GE0 60 1.5 C0 64' Set a threshold of 60 dbHz to all GPS and Galileo satellites in measurements in frequencies 1 and 5\n");
	printf("                                                                       and a threshold of 64 dbHz to all BeiDou satellites and measurements\n\n");
	printf("    -pre:elevation <val>    Elevation mask. Satellites below this threshold will be discarded (in degrees) [default 5]\n\n");
	printf("    -pre:eclipse            Discard satellites under Earth eclipse [default: enabled for PPP, disabled for SPP]\n\n");
	printf("    -pre:availf [+-]g[g]#[-#][.#[-#]]-#[,g[g]#[-#][.#[-#]]-#] [...]\n");
	printf("                            Mark frequencies available [default all]\n");
	printf("                            [+-]  =  Optional symbols for adding to current list (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                       If no symbol is provided, the behaviour is to remove all frequencies (from the selected satellites)\n");
	printf("                                        and enable only the frequencies provided in the argument of the parameter.\n");
	printf("                            g     = Character determining GNSS constellation (G->GPS)\n");
	printf("                            [g]   = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #     = PRN number. If #=0, then the threshold will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]  = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                                      of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                        with a dot ('.')\n");
	printf("                            #    = frequencies available. More than one frequency can be provided\n");
	printf("                            Sample: '-pre:availf G0-12'        Frequencies 1 and 2 of GPS available for all satellites\n");
	printf("                                    '-pre:availf G10-20-1'     Frequency 1 of GPS available, 2 and 5 unavailable for PRNs 10 to 20\n");
	printf("                                    '-pre:availf G9.8.11-13-1' Frequency 1 of GPS available, 2 and 5 unavailable for PRNs 8,9,11,12,13\n");
	printf("                                    '-pre:availf -RG0-2'       Remove frequency 2 from the available frequencies (leave the rest untouched) for all GPS and GLONASS satellites\n\n");
	printf("    -pre:smooth <val>       Number of epochs of smoothing [default 0 (disabled) for non SBAS processing, default 100 for SBAS processing]\n\n");
	printf("    -pre:smoothauto         Enable automatic selection of measurements for smoothing [default off]\n");
	printf("                              This option will auto disable if option '-pre:smoothmeas' to avoid interferring in user selected smoothing.\n");
	printf("                              The criteria to select the measurement to smooth with is to use the same measurement or combination and frequency(ies)\n");
	printf("                              as the code measurement to be smoothed but with carrier phase measurements. Smoothing time will be set to 100 epochs if none set.\n");
	printf("    -pre:smoothmeas <filtermeas> <smoothWith> [ <filtermeas> <smoothWith> ...]\n");
	printf("                               Smooth the filter measurement <filtermeas> with <smoothWith> carrier phase measurement or combination\n");
	printf("                             <filtermeas> = Set the filter measurement in the same way as in parameter '-filter:select'\n");
	printf("                             <smoothWith> = Measurent to smooth with. If it is a combination, the measurements for building the\n");
	printf("                                              combination may be specified afterwards.\n");
	printf("                               Sample: '-pre:smoothMeas G0-C1P L1P'\n");
	printf("                                       '-pre:smoothMeas G0-C1P L1P E0-C5X L5X -E15-C5X L5X'\n");
	printf("                                       '-pre:smoothMeas G0-PC12 LC12 G12-PC15 LC15-L1X-L5X'\n");
	printf("                                       '-pre:smoothMeas G0-SIF1224 LC17-L1X-L7X'\n");
	printf("                                       '-pre:smoothMeas G0-C5X SIF1268-L1X-L2I-L6Q-L8D'\n\n");
	printf("    -pre:smoothmeasdgnss <filtermeas> <smoothWith> [ <filtermeas> <smoothWith> ...]\n");
	printf("                               Same as '-pre:smoothmeas' but applied to the reference station instead of the rover\n\n");
	printf("    -pre:smoothmin       <val>    Number of epochs of continuous code smoothing in the rover before steady-state operation [default 0 for non SBAS processing, 360 for SBAS processing]\n");
	printf("                                     Satellites will be excluded until reaching this steady-state\n\n");
	printf("    -pre:dgnss:smoothmin <val>    Number of epochs of continuous code smoothing in the reference station before steady-state operation [default 360]\n");
	printf("                                     Satellites will be excluded until reaching this steady-state\n\n");
	printf("    -pre:dgnss:excludeSmoothingConvergenceUser      Exclude satellites during the smoothing convergence in the User Station [default off]\n\n");
	printf("    --pre:dgnss:excludeSmoothingConvergenceUser     Do not exclude satellites during the smoothing convergence in the User Station\n\n");
	printf("    -pre:dgnss:excludeSmoothingConvergenceRef       Exclude satellites during the smoothing convergence in the Reference Station,\n");
	printf("                                                     it will be effective if at least one cycle-slip detector is activated [default on]\n\n");
	printf("    --pre:dgnss:excludeSmoothingConvergenceRef      Do not exclude satellites during the smoothing convergence in the Reference Station\n\n");
	printf("    -pre:refpos:deg <val>   Set the interpolation degree for the reference position values [default 0]\n\n");
	printf("    -pre:setrecpos <val>    <val> = RINEX           Set the user receiver a priori position as the one specified in the RINEX observation file [default]\n");
	printf("                                                     RINEX position will be used for modelling and for NEU error.\n\n");
	printf("                            <val> = SINEX           Set the user receiver a priori position to be read from a SINEX file (to be\n");
	printf("                                                     specified by the '-input:snx' parameter)\n\n");
	printf("                                                     SINEX position will be used for modelling and for NEU error.\n");
	printf("                            <val> = <x> <y> <z>      \n\n");
	printf("                            <val> = Set <x> <y> <z>  Specify the receiver a priori position in metres\n");
	printf("                                                     Sample: '-pre:setrecpos 4789032.7143 176594.9690 4195013.2268'\n");
	printf("                                                     Specified position will be used for modelling and for NEU error.\n");
	printf("                                                     In show Products mode, specified position will be used to compute satellite elevation and azimuth.\n\n");
	printf("                            <val> = SetGeod <Lon> <Lat> <Height> Same as 'SetGeod', but the initial coordinates are given in\n");
	printf("                                                                 geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                                 [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = SetRef          Read reference position for each epoch from reference position file\n");
	printf("                                                     Specified position will be used for modelling and for NEU error.\n");
	printf("                                                     See parameters '-referenceposfile', '-input:refpos' and '-pre:refpos:deg' for help on the reference file\n\n");
	printf("                            <val> = calculate       The user receiver a priori position will be calculated by the program and used for modelling,\n"); 
	printf("                                                     starting from (%d,0,0).\n",(int)EARTH_RADIUS);
	printf("                                                     This is especially useful when processing moving receivers (trajectories)\n");
	printf("                                                     or when the approximate receiver position is not known. With this option\n");
	printf("                                                     activated, the differential fields of the OUTPUT message will be zero\n\n");
	printf("                            <val> = calculateRef    Same as 'calculate', but instead of printing (0,0,0) in the output NEU error,\n");
	printf("                                                     it will compute the NEU error using the coordinates from the reference file.\n");
	printf("                                                     See parameters '-referenceposfile', '-input:refpos' and '-pre:refpos:deg' for help on the reference file\n\n");
	printf("                            <val> = calculateRINEX  Same as calculate, but the initial coordinates will be the one read in the RINEX observation header.\n");
	printf("                                                     If RINEX coordinates are are (0,0,0), then Earth's surface will be used as initial coordinates\n\n");
	printf("                            <val> = calculateRINEXRef Same as 'calculateRINEX', but instead of printing (0,0,0) in the output NEU error,\n");
	printf("                                                        it will compute the NEU error using the coordinates from the reference file.\n");
	printf("                                                        See parameters '-referenceposfile', '-input:refpos' and '-pre:refpos:deg' for help on the reference file\n\n");
	printf("                            <val> = calculateUSER <x> <y> <z>  Same as 'calculate', but the initial coordinates will be the one\n");
	printf("                                                                given by the user in this parameter (in metres)\n\n");
	printf("                            <val> = calculateUSERGeod <Lon> <Lat> <Height>  Same as 'calculateUser', but the initial coordinates are given in\n");
	printf("                                                                geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                                [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = calculateUSERRef <x> <y> <z> Same as 'calculateUSER', but instead of printing (0,0,0) in the output NEU error,\n");
	printf("                                                                 it will compute the NEU error using the coordinates from the reference file. See\n");
	printf("                                                                 parameters '-referenceposfile', '-input:refpos' and '-pre:refpos:deg' for help on the reference file\n\n");
	printf("                            <val> = calculateUSERGeodRef <Lon> <Lat> <Height>  Same as 'calculateUSERRef', but the initial coordinates are given in\n");
	printf("                                                                geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                                [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSbaseline    The user receiver (rover) a priori position will be calculated by the program as in option 'calculate',\n");
	printf("                                                     but the differential fields in the OUTPUT message will computed against the reference antenna position\n");
	printf("                                                     (baseline vector from user to reference station), and the reference station coordinates will be\n");
	printf("                                                     read from RINEX or RTCM input file.\n\n");
	printf("                            <val> = DGNSSRinexRover  Same as 'DGNSSbaseline', but instead of comparing with the reference station, it will compare the user\n");
	printf("                                                     receiver (rover) coordinates with the coordinates read from the rover RINEX observation file\n\n");
	printf("                            <val> = DGNSSRoverUSER <RoverX> <RoverY> <RoverZ>\n");
	printf("                                                     	  Same as 'DGNSSbaseline', but instead of comparing with the reference station, it will compare the user\n");
	printf("                                                           receiver (rover) with the position given in this parameter\n\n");
	printf("                            <val> = DGNSSRoverUSERGeod <RoverLon> <RoverLat> <RoverHeight>\n");
	printf("                                                          Same as 'DGNSSRoverUSER', but the rover coordinates are given in\n");
	printf("                                                          geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSRoverUSERRef     Same as 'DGNSSbaseline', but instead of comparing with the reference station, it will compare the user\n");
	printf("                                                           receiver (rover) solution with the position given by the reference file.\n");
	printf("                                                           See parameters '-referenceposfile', '-input:refpos' and '-pre:refpos:deg' for help on the reference file\n\n");
	printf("                            <val> = DGNSSUserRoverRef <RefX> <RefY> <RefZ>\n");
	printf("                                                          Same as 'DGNSSRoverUSERRef', but the reference station coordinates will be provided in this parameter\n");
	printf("                                                           (this mode only works when computing DGNSS with a RINEX file)\n\n");
	printf("                            <val> = DGNSSUserGeodRoverRef <RefLon> <RefLat> <RefHeight>\n");
	printf("                                                          Same as 'DGNSSUserRoverRef', but the reference station coordinates are given in\n");
	printf("                                                          geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSUserbaseline <RefX> <RefY> <RefZ>\n");
	printf("                                                          Same as 'DGNSSbaseline', but the reference station coordinates will be provided in this parameter\n");
	printf("                                                           (this mode only works when computing DGNSS with a RINEX file)\n\n");
	printf("                            <val> = DGNSSUserGeodbaseline <RefLon> <RefLat> <RefHeight>\n");
	printf("                                                          Same as 'DGNSSUserbaseline', but the reference station coordinates are given in\n");
	printf("                                                          geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSUserRinexRover <RefX> <RefY> <RefZ>\n");
	printf("                                                          Same as 'DGNSSRinexRover', but the reference station coordinates will be provided in this parameter\n");
	printf("                                                           (this mode only works when computing DGNSS with a RINEX file)\n\n");
	printf("                            <val> = DGNSSUserGeodRinexRover <RefLon> <RefLat> <RefHeight>\n");
	printf("                                                          Same as 'DGNSSUserRinexRover', but the reference station coordinates are given in\n");
	printf("                                                          geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSRefRoverUSER <RefX> <RefY> <RefZ> <RoverX> <RoverY> <RoverZ>\n");
	printf("                                                          Same as 'DGNSSRoverUSER', but the reference station coordinates will be provided in this parameter\n");
	printf("                                                           (this mode only works when computing DGNSS with a RINEX file)\n\n");
	printf("                            <val> = DGNSSRefGeodRoverUSERGeod <RefLon> <RefLat> <RefHeight> <RoverLon> <RoverLat> <RoverHeight>\n");
	printf("                                                          Same as 'DGNSSRefRoverUSER', but the rover and reference station coordinates are given in\n");
	printf("                                                          geodetic coordinates. Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSRefCarRoverUSERGeod <RefX> <RefY> <RefX> <RoverLon> <RoverLat> <RoverHeight>\n");
	printf("                                                          Same as 'DGNSSRefRoverUSER', but the rover coordinates are given in\n");
	printf("                                                          geodetic coordinates and the reference station in cartesian coordinates.\n"); 
	printf("                                                          Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("                            <val> = DGNSSRefGeodRoverUSERCar <RefLon> <RefLat> <RefHeight> <RoverX> <RoverY> <RoverZ>\n");
	printf("                                                          Same as 'DGNSSRefRoverUSER', but the reference station coordinates are given in\n");
	printf("                                                          geodetic coordinates and the rover in cartesian coordinates.\n"); 
	printf("                                                          Longitude and latitude are given in degrees, within the ranges\n");
	printf("                                                          [-180..180] and [-90..90] respectively. The height is given in metres\n\n");
	printf("    -pre:setrectype <val>   <val> = gpsrt           Set the receiver type as the one specified in the GPS_Receiver_Types\n");
	printf("                                                     file (provided by '-input:rec') [default if '-input:rec' provided]\n");
	printf("                            <val> = 0               Set the receiver type as 'Unknown' [default]\n");
	printf("                            <val> = 1               Set the receiver type as 'Cross-correlated'\n");
	printf("                                                     In this mode, P2 will be corrected with the DCB of P1-C1\n");
	printf("                            <val> = 2               Set the receiver type as 'No P1'\n");
	printf("                                                     In this mode, C1 will be used instead of P1\n");
	printf("                            <val> = 3               Set the receiver type as 'Consistent measurements'\n\n");
	printf("    -pre:setrectypedgnss  <val>   Same as '-pre:setrectype', but applied to the reference station\n\n");
	printf("    -pre:prealign           Prealign carrier phase measurements with its corresponding pseudorange [default on]\n\n");
	printf("    -pre:checkcodejumps     Check for pseudorange jumps and adjust the phase accordingly. See 'Notes for preprocessing' below [default on]\n\n");
	printf("    --pre:checkcodejumps    Do not check for pseudorange jumps\n\n");
	printf("    -pre:cs:datagap <val>   Data gap. Maximum period of time, without measurements, allowed before declaring cycle-slip (in seconds)\n");
	printf("                            	[default 40 in SPP/PPP, 10 in SBAS and DGNSS]\n");
	printf("                              Note: If data gap value is equal or smaller than RINEX observation file data rate, two cases can occur:\n");
	printf("                                      - If data gap has not been set by the user, it will automatically adjust to RINEX observation data rate\n");
	printf("                                      - If data gap has been set by the user, all measurements will be discarded as in every epoch there will be a data gap\n\n");
	printf("    -pre:cs:lli             Use Loss of Lock Indicator for cycle-slip detection [default off]\n\n");
	printf("    --pre:cs:lli            Do not use Loss of Lock Indicator for cycle-slip detection [default off]\n\n");
	printf("    -pre:cs:ncon            Use N-consecutive epochs for cycle-slip detection [default on in SPP and PPP]\n\n");
	printf("    --pre:cs:ncon           Do not use N-consecutive epochs for cycle-slip detection [default off in SBAS and DGNSS}\n\n");
	printf("    -pre:cs:ncon:min <val>  After a short data gap (i.e., shorter than the value set in '-pre:cs:datagap' with default of 40 seconds)\n");
	printf("                             discard the first <val> epochs. NOTE: If sampling interval is greater than 15 seconds, gLAB will\n");
	printf("                             automatically disable this option [default 2]\n\n");
	printf("    -pre:cs:li              Use the carrier phase geometry-free combination (LI) for cycle-slip detection (2 frequencies) [default in PPP]\n\n");
	printf("    --pre:cs:li             Do not use carrier phase geometry-free combination (LI) for cycle-slip detection (2 frequencies) [default in SPP]\n");
	printf("                            Li combination is a slow varying function which only has ambiguity and ionosphere\n");
	printf("                            Each epoch and satellite an expected LI value is computed and compared against the\n");
	printf("                            measured one, if this difference is above a certain threshold, a cycle-slip is marked.\n");
	printf("                            This threshold is (max + (min-max)*exp(-dt/t)), being dt the time between epochs\n\n");
	printf("    -pre:cs:li:freq  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] [[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] ...]\n");
	printf("                                   Set the list of frequency combinations (per satellite) where to run the LI cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select frequencies\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <freq1><freq2>[.<freq1><freq2>]   = List of frequency combinations. Each frequency pair must be separated by a dot.\n");
	printf("                                        Frequencies provided will be checked against measurements provided in '-pre:cs:li:meas' parameter,\n");
	printf("                                         and if the frequencies are already in any of the measurements given in '-pre:cs:li:meas', these\n");
	printf("                                         frequencies will be omitted in order to avoid duplication\n");
	printf("                               Sample: '-pre:cs:li:freq G0-12.25.15'\n");
	printf("                                       '-pre:cs:li:freq E1-36-15.57.78 R0-12.23'\n\n");
	printf("    -pre:cs:li:freqlist  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>][,[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>],...]\n");
	printf("                                   Same as '-pre:cs:li:freq', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:li:freq G0-12.25.15'\n");
	printf("                                       '-pre:cs:li:freq E1-36-15.57.78 R0-12.23'\n");
	printf("                               Measurements for cycle-slip detection will be automatically selected if not defined with '-pre:cs:li:meas'.\n\n");
	printf("    -pre:cs:li:freqdgnss  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] [[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] ...]\n");
	printf("                                   Same as '-pre:cs:li:freq', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:li:freqlistdgnss  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>][,[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>],...]\n");
	printf("                                   Same as '-pre:cs:li:freqlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:li:meas [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Set the list of combinations (per satellite) where to run the LI cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <meas1>-<meas2>   Set the pair of measurements to use for the LI cycle-slip detector. Each pair of measurements\n");
	printf("                                 must a be a two carrier phases (in any order) from different frequencies or from same frequency but from\n");
	printf("                                 different signals (for instance L2C and L2W). It can be set as many pair of measurements as desired\n");
	printf("                                 (independently if the measurement is used in the filter or not). Measurements may be from any\n");
	printf("                                 frequency (there can be as many frequencies as desired) and there can be also several pairs of\n");
	printf("                                 measurements sharing frequencies.\n");
	printf("                               Sample: '-pre:cs:li:meas G0-L1P-L2P'\n");
	printf("                                       '-pre:cs:li:meas G1-10-L1P-L1L R0-L1C-L2C'\n\n");
	printf("    -pre:cs:li:measlist [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Same as '-pre:cs:li:meas', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:li:measlist G0-L1P-L2P'\n");
	printf("                                       '-pre:cs:li:measlist G1-10-L1C-L5X,R0-L1C-L2C'\n\n");
	printf("    -pre:cs:li:measdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Same as '-pre:cs:li:meas', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:li:measlistdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Same as '-pre:cs:li:measlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:li:maxjump <val> Maximum jump threshold (in metres) between two consecutive measured LI values [default 1]\n\n");
	printf("    -pre:cs:li:max <val>     Maximum threshold (in metres) between estimated and measured LI values [default 0.08]\n\n");
	printf("    -pre:cs:li:t0 <val>      Time constant (in seconds) to set the threshold between maximum and minimum [default 60]\n\n");
	printf("    -pre:cs:li:samples <val> Minimum number of epochs needed to fit the second-degree polynomial [default 7]\n\n");
	printf("    -pre:cs:li:nooutliers    Disable outlier declaration in LI cycle-slip detector [default off]\n");
	printf("                              An outlier is declared the first time the LI detectors triggers. The sample is discarded and waits for the next epoch.\n");
	printf("                              If the detector triggers again, a cycle-slip is declared, otherwise the arc continues (but the outlier sample is discarded).\n");
	printf("                              When this option is enabled, when the LI detector triggers for the first time, a cycle-slip will declared.\n\n");
	printf("    -pre:cs:mw               Use Melbourne-Wubbena (MW) for cycle-slip detection (2 frequencies) [default in PPP]\n\n");
	printf("    --pre:cs:mw              Do not use Melbourne-Wubbenna (MW) for cycle-slip detection (2 frequencies) [default in SPP]\n");
	printf("                             MW combination is a mixed combination between carrier phase and pseudoranges.\n");
	printf("                             This combination is free of ionosphere and geometry, thence constant, but\n");
	printf("                             has a high noise (due to the pseudorange measurements used). If this noise is\n");
	printf("                             low enough, it is straightforward to detect cycle-slips, but in noisy environments\n");
	printf("                             MW is not able to detect cycle-slips. The algorithm using MW computes the mean and\n");
	printf("                             the standard deviation of the last epochs in order to obtain an estimated value\n"); 
	printf("                             and the noise level of the combination. The estimated value is compared against the\n");
	printf("                             measured value, and the noise level is used for the threshold of this difference.\n");
	printf("                             Difference must be lower than standard deviation multiplied by a number (k-factor).\n");
	printf("                             This threshold has minimum (min) and maximum (max) saturation values.\n\n");
	printf("    -pre:cs:mw:freq  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] [[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] ...]\n");
	printf("                                   Set the list of frequency combinations (per satellite) where to run the MW cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select frequencies\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <freq1><freq2>[.<freq1><freq2>]   = List of frequency combinations. Each frequency pair must be separated by a dot\n");
	printf("                                        Frequencies provided will be checked against measurements provided in '-pre:cs:mw:meas' parameter,\n");
	printf("                                         and if the frequencies are already in any of the measurements given in '-pre:cs:mw:meas', these\n");
	printf("                                         frequencies will be omitted in order to avoid duplication\n");
	printf("                               Sample: '-pre:cs:mw:freq G0-12.25.15'\n");
	printf("                                       '-pre:cs:mw:freq E1-36-15.57.78 R0-12.23'\n");
	printf("                               Measurements for cycle-slip detection will be automatically selected if not defined with '-pre:cs:mw:meas'.\n\n");
	printf("    -pre:cs:mw:freqlist  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>][,[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>],...]\n");
	printf("                                   Same as '-pre:cs:mw:freq', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:mw:freq G0-12.25.15'\n");
	printf("                                       '-pre:cs:mw:freq E1-36-15.57.78 R0-12.23'\n\n");
	printf("    -pre:cs:mw:freqdgnss  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] [[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>] ...]\n");
	printf("                                   Same as '-pre:cs:mw:freq', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:mw:freqlistdgnss  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>][,[+-]g[g]#[-#][.#[-#]]-<freq1><freq2>[.<freq1><freq2>],...]\n");
	printf("                                   Same as '-pre:cs:mw:freqlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:mw:meas [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Set the list of combinations (per satellite) where to run the Melbourne-Wubbena cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <meas1>-<meas2>-<meas3>-<meas4>   Set the two pair of measurements to use for the Melbourne-Wubbena cycle-slip detector\n");
	printf("                                 The four measurements must be a pair of pseudoranges and a pair carrier phases (in any order) from different\n");
	printf("                                 different signals (for instance L2C and L2W). It can be set as many pair of measurements as desired\n");
	printf("                                 frequencies. (independently if the measurement is used in the filter or not). Measurements may be from any\n");
	printf("                                 frequency (there can be as many frequencies as desired) and there can be also several groups of\n");
	printf("                                 measurements sharing frequencies.\n");
	printf("                               Sample: '-pre:cs:mw:meas G0-C1P-C2P-L1P-L2P'\n");
	printf("                                       '-pre:cs:mw:meas G1-10-C1C-L1C-C5X-L5X R0-L1C-L2C-C1C-C2C'\n\n");
	printf("    -pre:cs:mw:measlist [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Same as '-pre:cs:mw:meas', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:mw:measlist G0-C1P-C2P-L1P-L2P'\n");
	printf("                                       '-pre:cs:mw:measlist G1-10-C1C-L1C-C5X-L5X,R0-L1C-L2C-C1C-C2C'\n\n");
	printf("    -pre:cs:mw:measdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Same as '-pre:cs:mw:meas', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:mw:measlistdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Same as '-pre:cs:mw:measlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:mw:siginit <val>     Initial standard deviation (in metres) to use in MW after a cycle-slip [default 2]\n\n");
	printf("    -pre:cs:mw:sigmin <val>      Minimum threshold (in metres) between estimated and measured MW values in relation to its standard deviation [default 0.8]\n\n");
	printf("    -pre:cs:mw:timewindow <val>  Number of epochs to compute the mobile mean over the Hatch filter [default 300]\n\n");
	printf("    -pre:cs:mw:kfactor <val>     Relation between estimated and measured MW values in relation to its standard deviation [default 5]\n\n");
	printf("    -pre:cs:mw:samples <val>     Minimum number of epochs needed to stabilize the mean and sigma in the MW cycle-slip detector [default 2]\n\n");
	printf("    -pre:cs:mw:nooutliers     Disable outlier declaration in MW cycle-slip detector [default off]\n");
	printf("                              An outlier is declared the first time the MW detectors triggers. The sample is discarded and waits for the next epoch.\n");
	printf("                              If the detector triggers again, a cycle-slip is declared, otherwise the arc continues (but the outlier sample is discarded).\n");
	printf("                              When this option is enabled, when the MW detector triggers for the first time, a cycle-slip will declared.\n\n");
	printf("    -pre:cs:sf                 Use the Phase-Code combination for single frequency cycle-slip detection [default in SBAS 1F/DGNSS]\n\n");
	printf("    --pre:cs:sf                Do not use the Phase-Code combination for single frequency cycle-slip detection [default in SPP/PPP/SBAS DFMC]\n\n");
	printf("    -pre:cs:sf:freq  [+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>] [[+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>] ...]\n");
	printf("                                   Set the list of frequencies (per satellite) where to run the single frequency cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select frequencies\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <freq>[.<freq>]   = List of frequencies. Each frequency must be separated by a dot \n");
	printf("                                        Frequency provided will be checked against measurements provided in '-pre:cs:sf:meas' parameter,\n");
	printf("                                         and if the frequency is already in any of the measurements given in '-pre:cs:sf:meas', this\n");
	printf("                                         frequency will be omitted in order to avoid duplication\n");
	printf("                               Sample: '-pre:cs:sf:freq G0-1.2.5'\n");
	printf("                                       '-pre:cs:sf:freq E1-36-1.5.7.8 R0-1.2'\n");
	printf("                               Measurements for cycle-slip detection will be automatically selected if not defined with '-pre:cs:sf:meas'.\n\n");
	printf("    -pre:cs:sf:freqlist  [+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>][,[+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>],...]\n");
	printf("                                   Same as '-pre:cs:sf:freq', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:sf:freqlist G0-1.2.5'\n");
	printf("                                       '-pre:cs:sf:freqlist E1-36-1.5.7.8,R0-1.2'\n\n");
	printf("    -pre:cs:sf:freqdgnss  [+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>] [[+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>] ...]\n");
	printf("                                   Same as '-pre:cs:sf:freq', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:sf:freqlistdgnss  [+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>][,[+-]g[g]#[-#][.#[-#]]-<freq>[.<freq>],...]\n");
	printf("                                   Same as '-pre:cs:sf:freqlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:sf:meas [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Set the list of combinations (per satellite) where to run the single frequency cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <meas1>-<meas2>   Set the pair of measurements to use for the single frequency cycle-slip detector. Each pair of measurements\n");
	printf("                                 must a be a pseudorange and a carrier phase (in any order) from the same frequency. It can be set as many pair\n");
	printf("                                 of measurements as desired (independently if the measurement is used in the filter or not). Measurements may be\n");
	printf("                                 from any frequency (there can be as many frequencies as desired) and there can be also several pairs of\n");
	printf("                                 measurements sharing frequencies.\n");
	printf("                               Sample: '-pre:cs:sf:meas G0-L1P-C1P'\n");
	printf("                                       '-pre:cs:sf:meas G1-10-L2P-C2P R0-L2C-C2C'\n\n");
	printf("    -pre:cs:sf:measlist [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Same as '-pre:cs:sf:meas', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:sf:measlist G0-L1P-C1P'\n");
	printf("                                       '-pre:cs:sf:measlist G1-10-L2P-C2P,R0-L2C-C2C'\n\n");
	printf("    -pre:cs:sf:measdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Same as '-pre:cs:sf:meas', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:sf:measlistdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2> ...]\n");
	printf("                                   Same as '-pre:cs:sf:measlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:sf:unconcheck      Use the unconsistency check in single frequency cycle-slip detection (Phase-Code) [default]\n\n");
	printf("    --pre:cs:sf:unconcheck     Do not use the unconsistency check in single frequency cycle-slip detection (Phase-Code)\n\n");
	printf("    -pre:cs:sf:unconcheck:th  <val> Threshold (in metres) for the unconsistency check in single frequency cycle-slip detection (Phase-Code) [default 20]\n");
	printf("                             The single frequency cycle-slip detector averages the difference between carrier phase and pseudorange measurements\n");
	printf("                             for several epochs. This cycle-slip detection method is very useful for single-frequency receivers, as it only\n");
	printf("                             requires measurements from one frequency. As a counterpart, the ionospheric term is different for code and phase,\n");
	printf("                             thence, this combination will tend to diverge. It becomes necessary to set a smoothing window\n");
	printf("                             to limit this divergence (-pre:cs:sf:timewindow). This makes that this method becomes a bit limited\n");
	printf("                             with data rates too low. Ideally this method should be used with rates of 1 Hz.\n\n");
	printf("    -pre:cs:sf:kfactor <val>     Relation between estimated and measured Phase-Code values in relation to its standard deviation [default 5]\n\n");
	printf("    -pre:cs:sf:timewindow <val>  Number of epochs to limit the Phase-Code ionosphere divergence [default 300]\n\n");
	printf("    -pre:cs:sf:samples <val>     Minimum number of epochs needed to stabilize the mean and sigma in the single frequency cycle-slip detector [default 2]\n\n");
	printf("    -pre:cs:sf:init <val>        Initial standard deviation for the threshold calculation in the single frequency cycle-slip detector [default 3] (m)\n\n");
	printf("    -pre:cs:igf               Use triple or quadruple frequencies to build a Ionospheric and Geometry Free (IGF) combination\n");
	printf("                                for cycle-slip detection [default off]\n\n");
	printf("    --pre:cs:igf              Do not use triple or quadruple frequencies to build a Ionospheric and Geometry Free (IGF) combination\n");
	printf("                                for cycle-slip detection [default]\n\n");
	printf("    -pre:cs:igf:minnoise      Construct the Iono-Geometry combination with the formula 'M=alpha·L1+beta·L2+gamma·L3' instead of combining\n");
	printf("                                two iono-free combination. The parameters alpha, beta and gamma are computed by gLAB. If this option is enabled,\n");
	printf("                                IGF combinations can be build only with three frequencies. See below for details on Iono-Geometry combinations.\n");
	printf("                                Warning: using this method for computing the IGF combination may lead to not detect some cycle-slips.\n\n");
	printf("    -pre:cs:igf:freq  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4> [[+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4>] ...]\n");
	printf("                                   Set the list of frequency combinations (per satellite) where to run the IGF cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select frequencies\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <freq1><freq2><freq3><freq4>   = List of frequency combinations. Each frequency group must be separated by a dot\n");
	printf("                                        Frequencies provided will be checked against measurements provided in '-pre:cs:igf:meas' parameter,\n");
	printf("                                         and if the frequencies are already in any of the measurements given in '-pre:cs:igf:meas', these\n");
	printf("                                         frequencies will be omitted in order to avoid duplication\n");
	printf("                               Sample: '-pre:cs:igf:freq G0-1225'\n");
	printf("                                       '-pre:cs:igf:freq E1-36-1557.1567 R0-1223'\n");
	printf("                               Measurements for cycle-slip detection will be automatically selected if not defined with '-pre:cs:igf:meas'.\n\n");
	printf("    -pre:cs:igf:freqlist [+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4>[,[+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4>],...]\n");
	printf("                                   Same as '-pre:cs:igf:freq', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:igf:freq G0-1225'\n");
	printf("                                       '-pre:cs:igf:freq E1-36-1557.1567 R0-1223'\n\n");
	printf("    -pre:cs:igf:freqdgnss  [+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4> [[+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4>] ...]\n");
	printf("                                   Same as '-pre:cs:igf:freq', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:igf:freqlistdgnss [+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4>[,[+-]g[g]#[-#][.#[-#]]-<freq1><freq2><freq3><freq4>],...]\n");
	printf("                                   Same as '-pre:cs:igf:freqlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:igf:meas [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Set the list of combinations (per satellite) where to run the IGF cycle-slip detector.\n");
	printf("                                   Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]] = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                          with a dot ('.')\n");
	printf("                            <meas1>-<meas2>-<meas3>-<meas4>   Set the two pair of measurements to use for the IGF cycle-slip detector\n");
	printf("                                 The four measurements must be a pair of pseudoranges and a pair carrier phases (in any order) from different\n");
	printf("                                 different signals (for instance L2C and L2W). It can be set as many pair of measurements as desired\n");
	printf("                                 frequencies. (independently if the measurement is used in the filter or not). Measurements may be from any\n");
	printf("                                 frequency (there can be as many frequencies as desired) and there can be also several groups of\n");
	printf("                                 measurements sharing frequencies.\n");
	printf("                               Sample: '-pre:cs:igf:meas G0-L1P-L2P-L2P-L5P'\n");
	printf("                                       '-pre:cs:igf:meas G1-10-L1C-L1P-L2X-L5X R0-L1C-L2C-L1C-L3X'\n\n");
	printf("    -pre:cs:igf:measlist [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Same as '-pre:cs:igf:meas', but each entry separated by commas (',') instead of blank spaces.\n");
	printf("                               Sample: '-pre:cs:igf:measlist G0-L1P-L2P-L2P-L5P'\n");
	printf("                                       '-pre:cs:igf:measlist G1-10-L1C-L1P-L2X-L5X,R0-L1C-L2C-L1C-L3X'\n\n");
	printf("    -pre:cs:igf:allowcodes  Allow to enter pseudoranges in the IGF detector in options '-pre:cs:igf:meas' and '-pre:cs:igf:measlist'\n");
	printf("                              WARNING: Do not use this option for navigation, as IGF cycle-slip detection with codes will behave randomly\n");
	printf("                               This option is intended for users who want to study code-carrier incoherency, and want to print in the\n");
	printf("                               IGFCSDATA message the iono-geometry combination with pseudoranges.\n");
	printf("                               When using this option, it is recommended to set a very high threshold in IGF detector with '-pre:cs:igf:max'\n");
	printf("                                and '-pre:cs:igf:max' options.\n\n");
	printf("    -pre:cs:igf:measdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Same as '-pre:cs:igf:meas', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:igf:measlistdgnss [+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> [[+-]g[g]#[-#][.#[-#]]-<meas1>-<meas2>-<meas3>-<meas4> ...]\n");
	printf("                                   Same as '-pre:cs:igf:measlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:cs:igf:maxjump <val> Maximum jump threshold (in metres) between two consecutive measured IGF values [default 1]\n\n");
	printf("    -pre:cs:igf:max <val>     Maximum threshold  (in metres) between estimated and measured IGF values\n");
	printf("                                    [default 0.08 if option '-pre:cs:igf:minnoise' is set, otherwise 0.16]\n\n");
	printf("    -pre:cs:igf:t0 <val>      Time constant (in seconds) to set the threshold between maximum and minimum [default 60]\n\n");
	printf("    -pre:cs:igf:samples <val> Minimum number of epochs needed to fit the second-degree polynomial [default 7]\n\n");
	printf("    -pre:cs:igf:nooutliers    Disable outlier declaration in IGF cycle-slip detector [default off]\n");
	printf("                              An outlier is declared the first time the IGF detectors triggers. The sample is discarded and waits for the next epoch.\n");
	printf("                              If the detector triggers again, a cycle-slip is declared, otherwise the arc continues (but the outlier sample is discarded).\n");
	printf("                              When this option is enabled, when the IGF detector triggers for the first time, a cycle-slip will declared.\n\n");
	printf("    -pre:cs:sf:noautofill     If single frequency cycle-slip detection is enabled, and user does not set measurements or frequencies, or\n");
	printf("                                   the user selected measurements or frequencies that do not detect all frequencies of carrier phase measurements\n");
	printf("                                   used in the filter, gLAB will detect it and automatically add them to the single frequency cycle slip\n");
	printf("                                   detector. To avoid this auto measurement filling, set this option [default off]\n");
	printf("                                   If this option is set, the frequencies not checked by the SF cycle slip detector will be printed\n\n");
	printf("    -pre:cs:mw:noautofill     If Melbourne-Wubbena cycle-slip detection is enabled, and user does not set measurements or frequencies, or\n");
	printf("                                   the user selected measurements or frequencies that do not detect all frequencies of carrier phase measurements\n");
	printf("                                   used in the filter, gLAB will detect it and automatically add them to the MW cycle slip\n");
	printf("                                   detector. To avoid this auto measurement filling, set this option [default off]\n");
	printf("                                   If this option is set, the frequencies not checked by the MW cycle slip detector will be printed\n\n");
	printf("    -pre:cs:li:noautofill     If LI cycle-slip detection is enabled, and user does not set measurements or frequencies, or\n");
	printf("                                   the user selected measurements or frequencies that do not detect all frequencies of carrier phase measurements\n");
	printf("                                   used in the filter, gLAB will detect it and automatically add them to the LI cycle slip\n");
	printf("                                   detector. To avoid this auto measurement filling, set this option [default off]\n");
	printf("                                   If this option is set, the frequencies not checked by the LI cycle slip detector will be printed\n\n");
	printf("    -pre:cs:igf:noautofill    If IGF cycle-slip detection is enabled, and user does not set measurements or frequencies, or\n");
	printf("                                   the user selected measurements or frequencies that do not detect all frequencies of carrier phase measurements\n");
	printf("                                   used in the filter, gLAB will detect it and automatically add them to the IGF cycle slip\n");
	printf("                                   detector. To avoid this auto measurement filling, set this option [default off]\n");
	printf("                                   If this option is set, the frequencies not checked by the IGF cycle slip detector will be printed\n\n");
	printf("    -pre:cs:noautofill        This parameter is a shortcut for enabling parameters '-pre:cs:sf:noautofill', '-pre:cs:mw:noautofill',\n");
	printf("                                   '-pre:cs:li:noautofill' and '-pre:cs:igf:noautofill' at once [default off]\n\n");
	printf("    -pre:cs:nooutliers        Disable outlier declaration for MW, LI and IGF cycle-slip detectors [default off]\n");
	printf("                               This parameter is a shortcut for providing '-pre:cs:mw:nooutliers', '-pre:cs:li:nooutliers' and '-pre:cs:igf:nooutliers' at once.\n\n");
	printf("    -pre:allcson              Enable all cycle-slip detectors (LLI, SF, MW, LI, IGF) [default off]. This option can be useful to activate all cycle-slip detectors\n");
	printf("                                   or enable all of them except specific detectors, by disabling them after this parameter is provided.\n\n");
	printf("    -pre:allcsoff             Disable all cycle-slip detectors (LLI, SF, MW, LI, IGF) [default off]. This option can be useful to disable all cycle-slip detectors\n");
	printf("                                   or disable all of them except specific detectors, by enabling them after this parameter is provided.\n\n");
	printf("    -pre:freqorder [+-]g[g]#[-#][.#[-#]]-<freq>[<freq>...] [...]\n");
	printf("                              If filter measurements are to be automatically set (that is, user did not enter any filter measurement\n");
	printf("                                with option '-filter:select'), gLAB will add measurements using the frequencies in the order of frequency\n");
	printf("                                   priority list, which can be modified with this parameter. If any of the frequencies in this list\n");
	printf("                                   does not exist, or it is set as not available by the user (option '-pre:availf') or it is not in the\n");
	printf("                                   RINEX observation file, it will be skipped.\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements. The whole list\n");
	printf("                                      will be replaced by the list of frequencies provided by the user.\n");
	printf("                                    If unselect symbol ('-') is provided, the measurements will be removed from default list if none defined\n");
	printf("                            g           = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]         = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #           = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]        = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                            [.#[-#]]    = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                            with a dot ('.')\n");
	printf("                            <freq>      = Frequency number\n");
	printf("                             The list of frequencies is used for selecting a measurement for navigation when user has not set any.\n");
	printf("                             For instance, in SPP, gLAB adds a measurement (using the measurement priority order defined in option\n");
	printf("                               '-pre:measorder') with the frequency given by this list. gLAB will try to use the first frequency in\n");
	printf("                               the list. If the frequency does not exist, or it is set as unavailable by the user or it is not\n");
	printf("                               available in the RINEX observation file, it will be skipped and continue with the next frequency in the list.\n");
	printf("                             For PPP, gLAB follows the same procedure, but selecting two frequencies for the ionosphere-free combination.\n");
	printf("                             This frequency list order is also used when filling dual/triple frequency combinations for MW, LI and IGF\n");
	printf("                               cycle-slip detectors when the number of frequencies to be added to the detectors does not coincide with the\n");
	printf("                               number of the frequencies needed in each of these detectors\n");
	printf("                              Sample: '-pre:freqorder G0-152'\n");
	printf("                                      '-pre:freqorder GE0-15'\n");
	printf("                                      '-pre:freqorder -GR1-3-12'\n\n");
	printf("                      The default frequency order (from highest priority to lowest) is:\n\n");
	printf("                                        GPS - L1 (F1),   L2 (F2),  L5 (F5)\n\n");
	printf("                                    Galileo - E1 (F1),   E5a (F5), E6 (F6), E5b (F7), E5 (F8)\n\n");
	printf("                                    GLONASS - G1 (F1),   G2 (F2),  G3 (F3), G1a (F4), G2a (F6)\n\n");
	printf("                                        GEO - L1 (F1),   L5 (F5)\n\n");
	printf("                                     BeiDou - B1-2 (F2), B2b (F7), B3 (F6), B2a (F5), B1 (F1), B2 (F8)\n\n");
	printf("                                       QZSS - L1 (F1),   L2 (F2),  L5 (F5), L6 (F6)\n\n");
	printf("                                      IRNSS - L5 (F5),   S (F9)\n\n");
	printf("    -pre:measorder [+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...] [[+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...] ...]\n");
	printf("                                   Set the list of measurements to use in order of priority, by satellite and frequency.\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements. If selecting measurements,\n");
	printf("                                      the whole list will be replaced by the list of frequencies provided by the user.\n");
	printf("                                    If unselect symbol ('-') is set, the measurements provided will be removed from the last\n");
	printf("                                       list provided or the default list if none defined.\n");
	printf("                            g           = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]         = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #           = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]        = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                            [.#[-#]]    = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                            with a dot ('.')\n");
	printf("                            <meastype>  = Measurement type. Values can be 'C' (for pseudoranges), 'L' (for carrier phases) and\n");
	printf("                                            'D' (for Doppler) or a combination of these. For instance, to apply to both pseudoranges and\n");
	printf("                                            carrier phases, use 'LC' or 'CL'. To apply to Doppler and carrier phase measurements, use\n");   
	printf("                                            'DL' or 'LD'. To apply to Doppler and pseudoranges, use 'DC' or 'CD'. To apply to\n");
	printf("                                            pseudoranges, carrier phase measurements or Doppler, use the three letters in any order,\n");
	printf("                                            for instance, 'CLD'. This convention follows the letters used in the RINEX observation files for\n");
	printf("                                            pseudoranges, carrier phases and Doppler measurements.\n");
	printf("                            <freqs>     = List of frequencies where to apply the priority list\n");
	printf("                            <attr>  List of measurement attributes in order of priority (from highest to lowest).\n");
	printf("                             The list of attributes is used for selecting a measurement for the navigation filter when user has not set any.\n");
	printf("                             The criteria for the auto selection of measurement is to use the first measurement with the given attribute\n");
	printf("                             in the list that is available in the observation file. This selection is done independently for pseudorange and\n");
	printf("                             carrier phase, therefore, the pair of measurements (pseudoranges and carrier phase) used may be from different\n");
	printf("                             types (for instance, it could select C1W and L1C). To force using only pair of measurements from the same attribute,\n");
	printf("                             set option '-pre:meassel:pairedmeas'\n");
	printf("                               Sample: '-pre:measorder G0-C15-PWCX'\n");
	printf("                                       '-pre:measorder -G0-C15-P'\n");
	printf("                                       '-pre:measorder 0-L2-WXC GE1-10-LC23-PWCL ER12.31-CL23-PWCX'\n\n");
	printf("                      The default measurement order list (from highest priority to lowest) is:\n\n");
	printf("                                             Pseudoranges                            Carrier phases                               Doppler\n\n");
	printf("                              GPS | F1 | C1P,C1W,C1C,C1Y,C1L,C1S,C1X,C1M     | L1P,L1W,L1C,L1Y,L1L,L1S,L1X,L1M,L1N     | D1P,D1W,D1C,D1Y,D1L,D1S,D1X,D1M,D1N\n");
	printf("                              GPS | F2 | C2P,C2W,C2C,C2Y,C2L,C2S,C2X,C2D,C2M | L2P,L2W,L2C,L2Y,L2L,L2S,L2X,L2D,L2M,L2N | D2P,D2W,D2C,D2Y,D2M,D2X,D2S,D2L,D2D,D2N\n"); 
	printf("                              GPS | F5 | C5Q,C5I,C5X                         | L5Q,L5I,L5X                             | D5Q,D5I,D5X\n\n"); 
	printf("                          Galileo | F1 | C1C,C1X,C1Z,C1B,C1A                 | L1C,L1X,L1Z,L1B,L1A                     | D1C,D1X,D1Z,D1B,D1A\n"); 
	printf("                          Galileo | F5 | C5Q,C5I,C5X                         | L5Q,L5I,L5X                             | D5Q,D5I,D5X\n"); 
	printf("                          Galileo | F6 | C6C,C6X,C6Z,C6B,C6A                 | L6C,L6X,L6Z,L6B,L6A                     | D6C,D6X,D6Z,D6B,D6A\n"); 
	printf("                          Galileo | F7 | C7Q,C7I,C7X                         | L7Q,L7I,L7X                             | D7Q,D7I,D7X\n"); 
	printf("                          Galileo | F8 | C8Q,C8I,C8X                         | L8Q,L8I,L8X                             | D8Q,D8I,D8X\n\n"); 
	printf("                          GLONASS | F1 | C1P,C1C                             | L1P,L1C                                 | D1P,D1C\n"); 
	printf("                          GLONASS | F2 | C2P,C2C                             | L2P,L2C                                 | D2P,D2C\n"); 
	printf("                          GLONASS | F3 | C3Q,C3I,C3X                         | L3Q,L3I,L3X                             | D3Q,D3I,D3X\n"); 
	printf("                          GLONASS | F4 | C4A,C4B,C4X                         | L4A,L4B,L4X                             | D4A,D4B,D4X\n"); 
	printf("                          GLONASS | F6 | C6A,C6B,C6X                         | L6A,L6B,L6X                             | D6A,D6B,D6X\n\n"); 
	printf("                              GEO | F1 | C1C                                 | L1C                                     | D1C\n"); 
	printf("                              GEO | F5 | C5Q,C5I,C5X                         | L5Q,L5I,L5X                             | D5Q,D5I,D5X\n\n"); 
	printf("                           BeiDou | F1 | C1P,C1D,C1L,C1S,C1X,C1Z,C1A         | L1P,L1D,L1L,L1S,L1X,L1Z,L1A,L1N         | D1P,D1D,D1L,D1S,D1X,D1Z,D1A,D1N\n"); 
	printf("                           BeiDou | F2 | C2Q,C2I,C2X                         | L2Q,L2I,L2X                             | D2Q,D2I,D2X\n"); 
	printf("                           BeiDou | F5 | C5P,C5D,C5X                         | L5P,L5D,L5X                             | D5P,D5D,D5X\n"); 
	printf("                           BeiDou | F6 | C6Q,C6I,C6P,C6D,C6X,C6Z,C6A         | L6Q,L6I,L6P,L6D,L6X,L6Z,L6A             | D6Q,D6I,D6P,D6D,D6X,D6Z,D6A\n"); 
	printf("                           BeiDou | F7 | C7Q,C7I,C7P,C7D,C7X,C7Z             | L7Q,L7I,L7P,L7D,L7X,L7Z                 | D7Q,D7I,D7P,D7D,D7X,D7Z\n"); 
	printf("                           BeiDou | F8 | C8P,C8D,C8X                         | L8P,L8D,L8X                             | D8P,D8D,D8X\n\n"); 
	printf("                             QZSS | F1 | C1C,C1L,C1S,C1X,C1Z,C1B             | L1C,L1L,L1S,L1X,L1Z,L1B                 | D1C,D1L,D1S,D1X,D1Z,D1B\n"); 
	printf("                             QZSS | F2 | C2L,C2S,C2X                         | L2L,L2S,L2X                             | D2L,D2S,D2X\n"); 
	printf("                             QZSS | F5 | C5Q,C5I,C5P,C5D,C5X,C5Z             | L5Q,L5I,L5P,L5D,L5X,L5Z                 | D5Q,D5I,D5P,D5D,D5X,D5Z\n"); 
	printf("                             QZSS | F6 | C6L,C6S,C6X,C6E,C6Z                 | L6L,L6S,L6X,L6E,L6Z                     | D6L,D6S,D6X,D6E,D6Z\n\n"); 
	printf("                            IRNSS | F5 | C5A,C5C,C5B,C5X                     | L5A,L5C,L5B,L5X                         | D5A,D5C,D5B,D5X\n"); 
	printf("                            IRNSS | F9 | C9A,C9C,C9B,C9X                     | L9A,L9C,L9B,L9X                         | D9A,D9C,D9B,D9X\n\n"); 
	printf("                      BeiDou measurements C1A,L1A,D1A,L1N,D1N,C6A,L6A,D6A only appear on RINEX 3.04\n\n");
	printf("    -pre:measorderlist [+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...][,[+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...],...]\n");
	printf("                                   Same as '-pre:measorder', but each entry is separated by commas (',') instead of blank spaces\n");
	printf("                               Sample: '-pre:measorderlist G0-C15-PWCX'\n");
	printf("                                       '-pre:measorderlist 0-L2-XC,GE1-10-LC23-PWCL,ER12-CL23-PWCX'\n\n");
	printf("    -pre:measorderdgnss [+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...] [[+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...] ...]\n");
	printf("                                   Same as '-pre:measorder', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:measorderlistdgnss [+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...][,[+-]g[g]#[-#][.#[-#]]-<meastype><freqs>-<attr1>[<attr2><attr3>...], ...]\n");
	printf("                                   Same as '-pre:measorderlist', but it is applied to the reference station instead of the rover\n\n");
	printf("    -pre:meassel:pairedmeas   When gLAB automatically selects the measurements to be used, force to use only paired measurements for\n");
	printf("                               pseudorange and carrier phases [default disabled]\n");
	printf("                               For instance, if rover RINEX observation file version 3.X has measurements C1C, L1C and C1W, C1W pseudorange measurement\n");
	printf("                               will not be used as L1W carrier phase measurement is not available (it usually occurs with Septentrio receivers).\n");
	printf("                               For RINEX v2, this option has no effect, as C1/P1/L1 and C2/P2/L2 are never paired (there are two codes but only one phase).\n");
	printf("                               This option also has no effect for Doppler measurements.\n");
	printf("                               If this option is set and rover RINEX observation file is version 2, it will auto disable\n\n");
	printf("    -pre:meassel:pairedmeasdgnss   Same as '-pre:meassel:pairedmeas', but applied only to the reference station  [default disabled]\n\n");
	printf("    -pre:meassel:noblocktypeunsel  Do not remove measurements from priority list according to satellite block type when an ANTEX file is provided\n");
	printf("                                    either with '-input:ant' or '-input:antsatblock' (e.g. auto removing L5 from GPS satellites without this frequency).\n"); 
	printf("                                    This parameter has preference over '-input:antsatblock'.\n\n");
/*	printf("    -pre:rnx2tornx3meas   g[g]-<RINEX2_measurement>-<RINEX3_measurement> [g[g]-<RINEX2_measurement>-<RINEX3_measurement> ...]\n");
	printf("                            Set the internal conversion for RINEX 2 measurements (two characters) to RINEX 3 measurements (three characters),\n");
	printf("                               as gLAB uses (and prints) RINEX 3 measurements\n");
	printf("                            g           = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]         = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            <RINEX2_measurement>  = Two letter RINEX 2 measurement\n");
	printf("                            <RINEX3_measurement>  = Three letter RINEX 3 measurement\n");
	printf("                               Sample: '-pre:rnx2tornx3meas  G-P1-C1W'\n");
	printf("                                       '-pre:rnx2tornx3meas  G-L1-L1W GE-C5-C5Q\n\n");
	printf("                      The default RINEX 2 to RINEX 3 conversion list is:\n\n");
	printf("                                  F1          F2          F3          F4          F5          F6          F7          F8          F9\n\n");
	printf("                         GPS | C1 -> C1C | C2 -> C2C | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C1X | C8 -> C8X | C9 -> C9X\n");
	printf("                         GPS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
	printf("                         GPS | L1 -> L1C | L2 -> L2P | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L1X | L8 -> L8X | L9 -> L9X\n");
	printf("                         GPS | D1 -> D1C | D2 -> D2P | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D1X | D8 -> D8X | D9 -> D9X\n");
	printf("                         GPS | S1 -> S1C | S2 -> S2P | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S1X | S8 -> S8X | S9 -> S9X\n\n");
	printf("                     Galileo | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
	printf("                     Galileo | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
	printf("                     Galileo | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
	printf("                     Galileo | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
	printf("                     Galileo | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
	printf("                     GLONASS | C1 -> C1C | C2 -> C2C | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C3X | C8 -> C8X | C9 -> C9X\n");
	printf("                     GLONASS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C3P | P8 -> C8P | P9 -> C9P\n");
	printf("                     GLONASS | L1 -> L1C | L2 -> L2P | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L3X | L8 -> L8X | L9 -> L9X\n");
	printf("                     GLONASS | D1 -> D1C | D2 -> D2P | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D3X | D8 -> D8X | D9 -> D9X\n");
	printf("                     GLONASS | S1 -> S1C | S2 -> S2P | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S3X | S8 -> S8X | S9 -> S9X\n\n");
	printf("                         GEO | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
	printf("                         GEO | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
	printf("                         GEO | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
	printf("                         GEO | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
	printf("                         GEO | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
	printf("                      BeiDou | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
	printf("                      BeiDou | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
	printf("                      BeiDou | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
	printf("                      BeiDou | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
	printf("                      BeiDou | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
	printf("                        QZSS | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
	printf("                        QZSS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
	printf("                        QZSS | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
	printf("                        QZSS | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
	printf("                        QZSS | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
	printf("                       IRNSS | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5A | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9A\n");
	printf("                       IRNSS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
	printf("                       IRNSS | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5A | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9A\n");
	printf("                       IRNSS | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5A | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9A\n");
	printf("                       IRNSS | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5A | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9A\n\n");
	printf("                      Note that the equivalent measurement in RINEX 3 does not need to exist for a given constellation, it just has to be\n");
	printf("                        the same measurement type (code, carrier phase, Doppler or SNR) and any attribute supported in RINEX 3.04. Moreover,\n");
	printf("                        the frequency in the RINEX 2 measurement does not have to match the RINEX 3 frequency. This is allowed in order to\n");
	printf("                        support 'teqc' program extended measurements, which for instance, converts frequency 7 to the equivalente L1C signal.\n\n");*/
	printf("    -pre:usererrorafter     Add user defined error after prealigning, checking cycle-slips and smoothing [default off]\n\n");
	printf("    -pre:intseconds         Ignore decimals when reading the epoch timestamp in RINEX observation file [default off]\n");
	printf("\n  MODELLING OPTIONS   (use -model:... to activate, --model:... to deactivate)\n\n");
	printf("    -model:iono <val>       <val> = no              Do not correct ionosphere [default in PPP] (equivalent to '--model:iono')\n");
	printf("                                  = Klobuchar       Correct measurements with Klobuchar model [default in SPP]\n");
	printf("                                  = BeiDou          Correct measurements with BeiDou model\n");
	printf("                                  = IONEX           Correct measurements with IONEX file data\n");
	printf("                                  = FPPP            Correct measurements with FPPP file data\n");
	printf("                                  = NeQuick         Correct measurements with NeQuick model\n");
	printf("                                  = SBAS            Correct measurements with SBAS iono corrections (but do not apply any other SBAS correction)\n");
	printf("                            If more than one iono model option is given, the last one will be used\n\n");
	//printf("    -model:ionoRMS <val>    Maximum error in FPPP iono model correction [default 1] (m) \n\n");
	printf("    -model:trop             Correct troposphere delay [default on] \n\n");
	printf("    --model:trop            Do not correct troposphere delay \n\n");
	printf("    -model:trop:nominal <val>   <val> = Simple     Compute a simple tropospheric nominal depending on receiver's height over the sea level. [default in PPP]\n");
	printf("                                <val> = UNB3       Troposphere nominals are calculated from the receiver's height and estimates of five meteorological\n");
	printf("                                                   parameters: pressure, temperature, water vapour pressure, temperature lapse rate and water vapour lapse rate.\n");
	printf("                                                   It is adopted by SBAS systems (see RTCA-MOPS, 2006). [default in SPP]\n");
	printf("\n");
	printf("    -model:trop:mapping <val>   <val> = Simple     Compute the mapping as the obliquity factor described in Black and Eisner, 1984. This mapping\n");
	printf("                                                   only depends on satellite elevation and it is common for wet and dry components.  [default in SPP]\n");
	printf("                                <val> = Niell      Compute the mapping described in  A.E. Niell, 1996. This mapping  considers different obliquity\n");
	printf("                                                   factors for the wet and dry components [default in PPP]\n\n");
	printf("    -model:satclocks        Correct the measurements with the satellite clock offsets estimations [default on]\n\n");
	printf("    -model:relclock         Correct the measurements with the relativistic clock model [default on]\n\n");
	printf("    -model:satmovinflight   Consider satellite movement during signal flight time [default on]\n\n");
	printf("    -model:earthrotinflight Consider Earth rotation during signal flight time [default on]\n\n");
	printf("    -model:satphasecenter   Correct satellite phase centre to mass centre corrections [default on in PPP, off in SPP]\n\n");
	printf("    -model:satphasevar      Correct satellite phase centre to mass centre corrections variations with zenith angle [default off for SPP, on for PPP]\n\n");
	printf("    -model:recphasecenter <val>\n");
	printf("                            <val> = no                Do not correct antenna receiver phase centre [default in SPP]\n");
	printf("                            <val> = ANTEX             Use the ANTEX file to correct the antenna phase center [default in PPP]\n");
	printf("                            <val> = g[g]<nfreq>[<nfreq>] <val2>  [ g[g]<nfreq>[<nfreq>] <val2>]\n");
	printf("                                     Set the receiver antenna phase centre source or its dN, dE and dU components for the frequencies and constellations provided.\n");
	printf("                                     Note that when user manually selects any constellation or frequency, the non set constellations or frequencies will be set to 'ANTEX'.\n");
	printf("                                       g         = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations and frequencies\n");
	printf("                                       [g]       = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                                       <nfreq>   = Frequency number (typical for GPS, 1 and 2)\n");
	printf("                                       [<nfreq>] = More than one frequency number may be provided\n");
	printf("                                       <val2>    = ANTEX       If word 'ANTEX' (without the quotes) is provided, these frequencies will be read from the ANTEX file.\n");
	printf("                                                 = g           If a constellation letter is provided  (e.g. 'G' for GPS), then it will use the same values (including\n");
	printf("                                                                the receiver phase centre variation) as in the selected constellation. \n");
	printf("                                                 = g<nfreq>    If a constellation letter and a frequency is provided (e.g. 'G1' for GPS frequency 1) all the selected\n");
	printf("                                                                 frequencies will have the same value (including the receiver phase centre variation) as the constellation\n");
	printf("                                                                 and frequency given.\n");
	printf("                                                 = <dN> <dE> <dU>  Set the North, East and Up receiver phase centre components (in metres).\n");
	printf("                            Sample: -model:recphasecenter G1 0 0 0.11\n");
	printf("                                    -model:recphasecenter GR2 0 0 0.128\n");
	printf("                                    -model:recphasecenter E15 0 0 0.11\n");
	printf("                                    -model:recphasecenter J12 G  -> Receiver phase centre corrections (and variations) for QZSS frequencies 1 and 2 will be the same as GPS frequencies 1 and 2\n");
	printf("                                    -model:recphasecenter J12 G1 -> Receiver phase centre corrections (and variations) for QZSS frequencies 1 and 2 will be the same as GPS frequency 1\n");
	printf("                                    -model:recphasecenter 0 0 0 0 -> Set receiver phase centre corrections for all frequencies of all constellations to 0 (no ANTEX file is used)\n");
	printf("                                    -model:recphasecenter 0 0 0 0 G12 0 0 0.11 -> Set first receiver phase centre corrections for all frequencies of all constellations\n");
	printf("                                                                                    to 0 (so ANTEX file is not used) and then GPS L1 and L2 to 0 0 0.11.\n");
	printf("                                 Typical AOAD/M_T antenna phase centre correction, 11 cm and 12.8 cm in the Up component for frequencies 1 and 2\n\n");
	printf("    -model:recphasevar      Correct antenna receiver phase centre variations [default off in SPP, on in PPP]\n\n");
	printf("    -model:strictradome     When using ANTEX file to correct the receiver phase centre, this option will force a perfect match between\n\n");
	printf("                            the antenna name and radome reported in the receiver RINEX file and the ones in the ANTEX file. If this option\n");
	printf("                            is disabled, and the radome is not found, the corrections will be used considering the radome \"NONE\" [default off]\n\n");   
	printf("    -model:arp <val>        <val> = no              Do not apply any Antenna Reference Point (ARP) correction [default in SPP] (equivalent to '--model:arp')\n");
	printf("                            <val> = RINEX           Use as ARP the information on the RINEX file (field 'ANTENNA: DELTA H/E/N') [default in SBAS, DGNSS and PPP]\n");
	printf("                            <val> = <dN> <dE> <dU>  Set dN, dE, dU as the ARP\n");
	printf("                                       <dN>    = North correction [in metres]\n");
	printf("                                       <dE>    = East correction [in metres]\n");
	printf("                                       <dU>    = Up correction [in metres]\n");
	printf("                                NOTE: In DGNSS mode, if ARP correction is enabled, reference station coordinates will be always be read from reference\n");
	printf("                                       RINEX or RTCM file, while rover ARP will be read from RINEX or set from user values.\n\n");
	printf("    -model:dcb:sf:gps:p1c1  <val> GPS DCB to convert C1 to P1 or for correcting P2 measurements (depending on GPS receiver type).\n");
	printf("                                  It may be applied to C1 or P2 measurements in single frequency or dual frequency combinations.\n");
	printf("                                      <val> = no       Do not correct Differential Code Biases between P1 and C1 codes (equivalent to\n");
	printf("                                                         '--model:dcb:sf:gps:p1c1') [default]\n");
	printf("                                      <val> = strict   Correct  Differential Code Biases between P1 and C1 codes for obtaining\n");
	printf("                                                         P1 from C1 or to obtain a consistent P2 when applicable (defined by the receiver type)\n\n");
	printf("    -model:dcb:sf:gps:p1p2  <val>   GPS Differential DCB between P1 and P2 (or L1P(Y) and L2 P(Y)). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct Differential Code Biases between codes (equivalent to\n");
	printf("                                                         '--model:dcb:sf:gps:p1p2') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct Differential Code Biases between codes using TGDs from the RINEX\n");
	printf("                                                         navigation file [default in SPP, EGNOS, DGNSS]\n");
	printf("                                      <val> = DCBFILE  Correct Differential Code Biases between codes P1 and P2 from a precise CODE DCB file\n");
	printf("                                                         Identify C1 and P1 when applicable (defined by the receiver type)\n");
	printf("                                      <val> = IONEX    Correct Differential Code Biases between codes P1 and P2 using DCB from IONEX file\n");
	printf("                                      <val> = FPPP     Correct Differential Code Biases between codes P1 and P2 using DCB from FPPP file\n");
	printf("                                   NOTE: p1p2 DCB is also applied to frequency 5, as stated in the GPS ICD. Disabling this option will also\n");
	printf("                                       prevent applying the p1p2 DCB to GPS frequency 5 signals.\n\n");
	printf("    -model:dcb:sf:gps:isc:l1ca <val> GPS Inter-Signal correction between L1 C/A and L1 P(Y). To be applied in single frequency measurements\n");
	printf("                                      <val> = no       Do not apply L1C/A Inter-Signal correction (ISC) (equivalent to\n");
    printf("                                                         '--model:dcb:sf:gps:isc:l1ca') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L1C/A Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:gps:isc:l1cp <val> GPS Inter-Signal correction between L1C (P) and L1 P(Y). To be applied in single frequency measurements.\n");
	printf("                                       > <val> = no       Do not apply L1Cp Inter-Signal correction (ISC) (equivalent to\n");
    printf("                                                         '--model:dcb:sf:gps:isc:l1cp') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L1Cp Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:gps:isc:l1cd <val> GPS Inter-Signal correction between L1C (D) and L1 P(Y). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L1Cd Inter-Signal correction (ISC) (equivalent to\n");
    printf("                                                         '--model:dcb:sf:gps:isc:l1cd') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L1Cd Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:gps:isc:l2c  <val> GPS Inter-Signal correction between L2C (M) or L2C (L) and L1 P(Y). To be applied in single frequency measurements.\n");
	printf("                                 Note that L2C (M) and L2C (L) are coded in the same signal, as L2C (M) is a fraction of the whole L2C (L) code\n");
	printf("                                      <val> = no       Do not apply L2C Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:gps:isc:l2c') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L2C Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages. It is applied to C2S and C2L signals [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:gps:isc:l5i5 <val> GPS Inter-Signal correction between L5I5 and L1 P(Y). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L5I5 Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:gps:isc:l5i5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L5I5 Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:gps:isc:l5q5 <val> GPS Inter-Signal correction between L5Q5 and L1 P(Y). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L5Q5 Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:gps:isc:l5q5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L5Q5 Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:gps:isc:all   <val> <val> = no       Do not apply any Inter-Signal correction (ISC) between codes for single frequency measurements\n");
    printf("                                                         (equivalent to provide '--model:dcb:sf:gps:isc:all' or '-model:dcb:sf:gps:isc:l1ca',\n");
    printf("                                                         '-model:dcb:sf:gps:isc:l2c', '--model:dcb:sf:gps:isc:l5i5', and\n");
	printf("                                                         '--model:dcb:sf:gps:isc:l5q5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary Inter-Signal correction (ISC) (on their respective measurements)\n"); 
	printf("                                                         between codes using ISC from the CNAV RINEX navigation messages [default in SPP]\n\n");
	printf("    -model:dcb:sf:gps:all       <val> <val> = no       Do not apply any DCBs between codes in single frequency for GPS (except for P1-C1 DCB) \n");
    printf("                                                         (equivalent to provide '-model:dcb:sf:gps:p1c1', '--model:dcb:sf:gps:p1p2' and\n");
    printf("                                                         '--model:dcb:sf:gps:isc:all') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary DCB and ISC for GPS (on their respective measurements)\n"); 
	printf("                                                         between codes from RINEX navigation messages (except for P1-C1 DCB) [default in SPP]\n\n");
	printf("    -model:dcb:sf:gal:e1e5a <val>  Galileo Differential DCB between E1 and E5a frequencies. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct E1-E5a Differential Code Biases (equivalent to\n");
	printf("                                                         '--model:dcb:sf:gal:e1e5a') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct E1-E5a Differential Code Biases using BGDs from the RINEX\n");
   	printf("                                                         navigation file [default in SPP, DGNSS]\n\n");
/*	printf("                                      <val> = IONEX    Correct E1-E5a Differential Code Biases between codes using BGDs from IONEX file\n");
	printf("                                      <val> = FPPP     Correct E1-E5a Differential Code Biases between codes using BGDs from FPPP file\n\n");
*/	printf("    -model:dcb:sf:gal:e1e5b <val>  Galileo Differential DCB between E1 and E5b frequencies. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct E1-E5b Differential Code Biases (equivalent to\n");
	printf("                                                         '--model:dcb:sf:gal:e1e5b') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct E1-E5b Differential Code Biases using BGDs from the RINEX\n");
   	printf("                                                         navigation file [default in SPP, DGNSS]\n\n");
/*	printf("                                      <val> = IONEX    Correct E1-E5b Differential Code Biases between codes using BGDs from IONEX file\n");
	printf("                                      <val> = FPPP     Correct E1-E5b Differential Code Biases between codes using BGDs from FPPP file\n\n");
*/	printf("    -model:dcb:sf:gal:all       <val> <val> = no       Do not apply any DCBs between codes for Galileo for single frequency measurements (equivalent\n");
    printf("                                                         to provide '--model:dcb:sf:gal:e1e5a' and '--model:dcb:sf:gal:e1e5b') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary DCB and ISC for Galileo (on their respective measurements)\n"); 
	printf("                                                         between codes from RINEX navigation messages [default in SPP]\n\n");
	printf("    -model:dcb:sf:glo:p1p2  <val>   Glonass Differential DCB between P1 and P2 measurements. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct Differential Code Biases between C1P and C2P codes for GLONASS\n");
	printf("                                                         (equivalent to '--model:dcb:sf:glo:p1p2')\n");
	printf("                                      <val> = RINEX    Correct Differential Code Biases between codes using TGDs from the RINEX\n");
	printf("                                                         navigation file (only for RINEX navigation 3.05 or greater) [default in SPP, EGNOS, DGNSS]\n");
	printf("                                      <val> = DCBFILE  Correct Differential Code Biases between codes P1 and P2 from a precise CODE DCB file\n");
	printf("                                      <val> = IONEX    Correct Differential Code Biases between C1P and C2P codes using DCB from IONEX file\n\n");
//	printf("                                      <val> = FPPP    Correct Differential Code Biases between f1 and f2 codes using DCB from FPPP file\n");
	printf("    -model:dcb:sf:glo:all       <val> <val> = no       Do not apply any DCBs between codes for GLONASS (equivalent to provide\n");
    printf("                                                         '--model:dcb:sf:glo:p1p2') [default in PPP]\n\n");
	printf("                                      <val> = RINEX    Apply all necessary DCB for GLONASS (on their respective measurements)\n"); 
	printf("                                                         between codes from RINEX navigation messages [default in SPP, SBAS, DGNSS]\n\n");
	printf("    -model:dcb:sf:bds:b2b6 <val> BeiDou Differential DCB between B1_2-B3 (frequencies 2 and 6). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct B1_2-B3 (frequencies 2 and 6) Differential Code Biases\n");
	printf("                                                         (equivalent to '--model:dcb:sf:bds:b2b6') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct B1_2-B3 (frequencies 2 and 6) Differential Code Biases using BGDs from\n");
   	printf("                                                         the RINEX navigation file [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:bds:b7b6 <val> BeiDou Differential DCB between B2b-B3 (frequencies 7 and 6). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct B2b-B3 (frequencies 7 and 6) Differential Code Biases\n");
	printf("                                                         (equivalent to '--model:dcb:sf:bds:b7b6') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct B2b-B3 (frequencies 7 and 6) Differential Code Biases using BGDs from\n");
   	printf("                                                         the RINEX navigation file [default in SPP, DGNSS]\n\n");
/*	printf("    -model:dcb:sf:bds:b1b6 <val> BeiDou Differential DCB between B1-B3 (frequencies 1 and 6). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct B1-B3 (frequencies 1 and 6) Differential Code Biases\n");
	printf("                                                         (equivalent to '--model:dcb:sf:bds:b1b6') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct B1-B3 (frequencies 1 and 6) Differential Code Biases using BGDs from\n");
   	printf("                                                         the RINEX navigation file [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:bds:b5b6 <val> BeiDou Differential DCB between B2a-B3 (frequencies 5 and 6). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct B2a-B3 (frequencies 5 and 6) Differential Code Biases\n");
	printf("                                                         (equivalent to '--model:dcb:sf:bds:b5b6') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct B2a-B3 (frequencies 5 and 6) Differential Code Biases using BGDs from\n");
   	printf("                                                         the RINEX navigation file [default in SPP, DGNSS]\n\n");
*/	printf("    -model:dcb:sf:bds:sp3  <val> When using single frequency measurements with precise files (SP3/CLK), precise orbits and clocks are computed with\n");
	printf("                                   with B1_2-B2b iono-free combination (frequencies 2,7), but DCBs are referred to combinations with B3 signal.\n");
	printf("                                   (frequency 6). Therefore a special DCB (a combination of available DCB) has to be computed.\n");
	printf("                                   [default enabled in single frequency PPP, otherwise disabled]\n\n");
	printf("                                      <val> = no       Do not correct DCB for single frequency measurements with precise orbits and clocks\n");
	printf("                                                         [default in all modes except single frequency PPP]\n");
	printf("                                      <val> = RINEX    Correct DCB for single frequency measurements with precise orbits and clocks\n");
   	printf("                                                         reading the necessary DCBs from the RINEX navigation file [default in single frequency PPP]\n\n");
/*	printf("    -model:dcb:sf:bds:isc:b1cd <val>  BeiDou Inter-Signal correction between B1 data and B1 pilot components. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply B1Cd (frequency 1) Inter-Signal correction (ISC) between codes\n");
    printf("                                                         (equivalent to '--model:dcb:sf:bds:isc:b1cd') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply B1Cd (frequency 1) Inter-Signal correction (ISC) between codes using ISC from\n");
	printf("                                                         the CNAV RINEX navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:bds:isc:b2ad <val>  BeiDou Inter-Signal correction between B2a data and B2a pilot components. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply B2ad (frequency 5) Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:bds:isc:b2ad') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply B2ad (frequency 5) Inter-Signal correction (ISC) between codes using ISC from\n");
	printf("                                                         the CNAV RINEX navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:bds:isc:all  <val> <val> = no       Do not apply any Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         provide '-model:dcb:sf:bds:isc:b1cd' and '-model:dcb:sf:bds:isc:b2ad' [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary Inter-Signal correction (ISC) (on their respective measurements)\n"); 
	printf("                                                         between codes using ISC from the CNAV RINEX navigation messages [default in SPP]\n\n");
*/	printf("    -model:dcb:sf:bds:all      <val> <val> = no       Do not apply any DCBs between codes for BeiDou (equivalent to provide\n");
    printf("                                                         '--model:dcb:sf:bds:b2b6', '--model:dcb:sf:bds:b7b6',\n");
	printf("                                                         '--model:dcb:sf:bds:sp3' and '--model:dcb:sf:bds:isc:all' [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary DCB and ISC for BeiDou (on their respective measurements)\n"); 
	printf("                                                         between codes from RINEX navigation messages [default in SPP]\n\n");
	printf("    -model:dcb:sf:qzs:c1c      <val> QZSS Differential DCB between satellite clock and L1 C/A. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct Differential Code Biases between codes (equivalent to\n");
	printf("                                                         '--model:dcb:sf:qzs:c1c') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct Differential Code Biases between codes using TGDs from the RINEX\n");
	printf("                                                         navigation file [default in SPP, EGNOS, DGNSS]\n");
	printf("                                   NOTE: C1C DCB is also applied to frequency 5, as stated in the QZSS ICD. Disabling this option will also\n");
	printf("                                       prevent applying the C1C DCB to QZSS frequency 5 signals.\n\n");
/*	printf("    -model:dcb:sf:qzs:isc:l1cp <val> QZSS Inter-Signal correction between L1 C/A and L1C (P). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L1Cp Inter-Signal correction (ISC) (equivalent to\n");
    printf("                                                         '--model:dcb:sf:qzs:isc:l1cp') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L1Cp Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:qzs:isc:l1cd <val> QZSS Inter-Signal correction between L1 C/A and L1C (D). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L1Cd Inter-Signal correction (ISC) (equivalent to\n");
    printf("                                                         '--model:dcb:sf:qzs:isc:l1cd') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L1Cd Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
*/	printf("    -model:dcb:sf:qzs:isc:l2c  <val>  QZSS Inter-Signal correction between L1 C/A and L2C (M) or L2C (L). To be applied in single frequency measurements.\n");
	printf("                                 Note that L2C (M) and L2C (L) are coded in the same signal, as L2C (M) is a fraction of the whole L2C (L) code\n");
	printf("                                      <val> = no       Do not apply L2C Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:qzs:isc:l2c') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L2C Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages. It is applied to C2S and C2L signals [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:qzs:isc:l5i5 <val>  QZSS Inter-Signal correction between L1 C/A and L5I5. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L5I5 Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:qzs:isc:l5i5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L5I5 Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:qzs:isc:l5q5 <val>  QZSS Inter-Signal correction between L1 C/A and L5Q5. To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not apply L5Q5 Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         '--model:dcb:sf:qzs:isc:l5q5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply L5Q5 Inter-Signal correction (ISC) between codes using ISC from the CNAV RINEX\n");
	printf("                                                         navigation messages [default in SPP, DGNSS]\n\n");
	printf("    -model:dcb:sf:qzs:isc:all   <val> <val> = no       Do not apply any Inter-Signal correction (ISC) between codes (equivalent to\n");
    printf("                                                         provide '--model:dcb:sf:qzs:isc:l2c', '--model:dcb:sf:qzs:isc:l5i5' and\n");
    printf("                                                         '--model:dcb:sf:qzs:isc:l5q5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary Inter-Signal correction (ISC) (on their respective measurements)\n"); 
	printf("                                                         between codes using ISC from the CNAV RINEX navigation messages [default in SPP]\n\n");
	printf("    -model:dcb:sf:qzs:all       <val> <val> = no       Do not apply any DCBs between codes for QZSS (equivalent to provide\n");
    printf("                                                         '--model:dcb:sf:qzs:c1c' and '--model:dcb:sf:qzs:isc:all') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary DCB and ISC for QZSS (on their respective measurements)\n"); 
	printf("                                                         between codes from RINEX navigation messages [default in SPP]\n\n");
	printf("    -model:dcb:sf:irn:c9c5  <val>  IRNSS Differential DCB between S-SPS and L5-SPS (C9A - C5A). To be applied in single frequency measurements.\n");
	printf("                                      <val> = no       Do not correct Differential Code Biases between codes (equivalent to\n");
	printf("                                                         '--model:dcb:sf:irn:c9c5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct Differential Code Biases between codes using TGDs from the RINEX\n");
	printf("                                                         navigation file [default in SPP, EGNOS, DGNSS]\n\n");
	printf("    -model:dcb:sf:irn:all       <val> <val> = no       Do not apply any DCBs between codes for IRNSS (equivalent to provide\n");
    printf("                                                         '--model:dcb:sf:irn:c9c5') [default in PPP]\n");
	printf("                                      <val> = RINEX    Apply all necessary DCB for IRNSS (on their respective measurements)\n"); 
	printf("                                                         between codes from RINEX navigation messages [default in SPP]\n\n");
//	printf("    -model:dcb:sf:sinexdsb To be implemented\n");
//	printf("    -model:dcb:sf:sinexosb To be implemented\n");
	printf("    -model:dcb:sf:isc:all   <val>    Apply all ISC DCB type to all constellations for single frequency measurements.\n");
	printf("                                      This is a shorcut for providing the parameters '-model:dcb:sf:gps:isc:all', '-model:dcb:sf:bds:isc:all'\n");
	printf("                                       and '-model:dcb:sf:qzs:isc:all'.\n");
	printf("                                      <val> = no       Do not apply any Inter-Signal correction (ISC) DCB for all constellations\n");
	printf("                                                         in single frequency measurements.\n");
	printf("                                      <val> = RINEX    Apply all Inter-Signal correction (ISC) DCB for all constellations in single frequency\n"); 
	printf("                                                         measurements.\n\n");
	printf("    --model:dcb:sf:isc:all     Do not apply any ISC DCB type to any constellation for single frequency measurements. This is a\n");
	printf("                                 shorcut for providing the parameters '--model:dcb:sf:gps:isc:all', '--model:dcb:sf:bds:isc:all' and\n");
    printf("                                 '--model:dcb:sf:qzs:isc:all'\n\n");
	printf("    -model:dcb:sf:all      <val>    Apply all DCB type (ISC and non ISC, except for GPS P1-C1) to any constellation for single frequency\n");
	printf("                                     measurements. This is a shorcut for providing the parameters '-model:dcb:sf:gps:all', '-model:dcb:sf:glo:all',\n");
	printf("                                       '-model:dcb:sf:gal:all', '-model:dcb:sf:bds:all', '-model:dcb:sf:qzs:all' and '-model:dcb:sf:irn:all'.\n");
	printf("                                      <val> = no       Do not apply any DCB for all constellations in single frequency measurements.\n");
	printf("                                      <val> = RINEX    Apply all DCB for all constellations in single frequency measurements.\n\n"); 
	printf("    --model:dcb:sf:all         Do not apply any DCB type (ISC and non ISC, except for GPS P1-C1) to any constellation for single frequency\n");
   	printf("                                 measurements. This is a shorcut for providing the parameters: '--model:dcb:sf:gps:all', '--model:dcb:sf:gal:all',\n");
	printf("                                 '--model:dcb:sf:glo:all', '--model:dcb:sf:bds:all', '--model:dcb:sf:qzs:all', '--model:dcb:sf:irn:all'\n\n");
	printf("    -model:dcb:df:gps  <val>  Compute the DCBs necessary for GPS iono-free combinations different than the one used in the reference orbits and clocks\n");
	printf("                                      <val> = no       Do not correct DCB for GPS dual frequency combinations (equivalent to\n");
	printf("                                                         '--model:dcb:df:gps') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct DCBs for GPS dual frequency combinations using TGDs from the RINEX\n");
	printf("                                                         navigation file [default in SPP]\n");
	printf("                              The DCBs for dual frequency that gLAB supports for GPS are:\n");
	printf("                                IF12\n");
	printf("                                IF25\n");
	printf("                                IF15\n\n");
	printf("    -model:dcb:df:bds  <val>  Compute the DCBs necessary for BeiDou iono-free combinations different than the one used in the reference orbits and clocks\n");
	printf("                                      <val> = no       Do not correct DCB for BeiDou dual frequency combinations (equivalent to\n");
	printf("                                                         '--model:dcb:df:bds') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct DCBs for BeiDou dual frequency combinations using TGDs from the RINEX\n");
	printf("                                                         navigation file [default in SPP]\n");
	printf("                              The DCBs for dual frequency that gLAB supports for BeiDou are:\n");
	printf("                                IF27 (B1_2-B2b). Necessary for broadcast orbits only\n");
	printf("                                IF26 (B1_2-B3)\n");
	printf("                                IF67 (B3-B2b)\n\n");
	printf("    -model:dcb:df:qzs  <val>  Compute the DCBs necessary for QZSS iono-free combinations different than the one used in the reference orbits and clocks\n");
	printf("                                      <val> = no       Do not correct DCB for QZSS dual frequency combinations (equivalent to\n");
	printf("                                                         '--model:dcb:df:qzs') [default in PPP]\n");
	printf("                                      <val> = RINEX    Correct DCBs for QZSS dual frequency combinations using TGDs from the RINEX\n");
	printf("                                                         navigation file [default in SPP]\n");
	printf("                              The DCBs for dual frequency that gLAB supports for QZSS are:\n");
	printf("                                IF12\n");
	printf("                                IF25\n");
	printf("                                IF15\n\n");
	printf("    -model:dcb:df:all  <val>  Apply all dual frequency DCB for all constellations. This is a shortcut for providing the parameters:\n");
   	printf("                                 '-model:dcb:df:gps', '-model:dcb:df:bds' and '-model:dcb:df:qzs'\n");
	printf("                                      <val> = no       Do not correct DCB fordual frequency combinations in all constellations\n");
	printf("                                      <val> = RINEX    Correct DCBs for dual frequency combinations in all constellations\n");
	printf("                                                         using TGDs from the RINEX navigation file\n\n");
	printf("    --model:dcb:df:all        Do not apply any dual frequency DCB for any constellation. This is a shortcut for providing the parameters:\n");
   	printf("                                 '--model:dcb:df:gps', '--model:dcb:df:bds' and '--model:dcb:df:qzs'\n\n");
	printf("    -model:windup           Correct the wind up term for carrier phase measurements [default in PPP, off in SPP, SBAS, DGNSS]\n\n");
	printf("    -model:solidtides       Correct the Earth surface deformation due to solid tides [default in PPP, off in SPP, SBAS, DGNSS]\n\n");
	printf("    -model:relpath          Correct the path range delay term due to the gravitational gradient between receiver and transmitter\n"); 
	printf("                              [default on in PPP, off in SPP, SBAS, DGNSS]\n\n");
	printf("    -model:sathealth        Only valid when using broadcast products. Use only satellites that are healthy (i.e. not marginal or unhealthy)\n");
	printf("                              [default enabled in all modes except SBAS]\n");
	printf("                              This selection is done when looking for a navigation message for orbits or DCBs and only applies in navigation mode,\n");
	printf("                              as in show orbits or comparison modes the health is printed in the output message.\n\n");
	printf("    -model:allowmarginal    Only valid when using broadcast products. Allow using satellites with a 'Marginal' health\n");
	printf("                              status [default off if '-model:sathealth' is enabled, on if '-model:sathealth' is disabled]\n");
	printf("                              Same behaviour as option '-model:sathealth', but satellites used will be in healthy or marginal modes\n\n");
	printf("    -model:skipunhealthymarg  Only valid when using broadcast products. Skip unhealthy and marginal messages [default off]\n");
	printf("                                The difference with '-model:sathealth' is that unhealthy or marginal will not be saved in internal buffers (as if\n");
	printf("                                the unhealthy/marginal did not appear in RINEX navigation file). This option is useful when you want to check how\n");
	printf("                                the last transmitted healthy message performed until it timed-out (e.g. for fear event analysis)\n\n");
	printf("    -model:skipunhealthy      Only valid when using broadcast products. Ignore unhealthy messages [default off]\n");
	printf("                                Same behaviour as '-model:skipunhealthymarg' but only skips unhealthy messages\n\n");
	printf("    -model:brdctranstime    Only valid when using broadcast products. Check that transmission time of message is equal or before the current epoch\n");
	printf("                              of current time [default on for non SBAS processing, off for SBAS processing]\n\n");
	printf("    -model:maxurabrdc <val> Only valid when using broadcast products. Set the discard threshold for satellites which have an URA value\n");
	printf("                              equal or greater than this value (in metres) [default off]\n\n");
	printf("    -model:globrdcintstep <val>  Set the Runge-Kutta interpolation step (in seconds) when computing GLONASS orbit with broadcast products [default 30]\n");
	printf("                                 gLAB will interpolate from the initial conditions with this given step size until the distance is lower than this step size,\n");
	printf("                                  and then interpolate with the remaining step size to the desired epoch.\n\n");
	printf("    -model:brdcpreferagetime <val>  When searching for a navigation message, set the threshold (in seconds) to decide if current valid navigation message found\n");
   	printf("                                     is recent enough (with respect to navigation message ToC -Time of Clock-) to select it or to keep searching in other\n");
   	printf("                                     navigation message types (according to the navigation message priority list) for more recent messages [default 3600]\n\n");
	printf("    -model:brdc:gps  <val>  Only valid when using broadcast products. This option only applies to GPS:\n");
	printf("                            <val> = PreferLNAV   Use LNAV, CNAV and CNAV2 broadcast messages, but use LNAV whenever possible [default]\n");
	printf("                            <val> = PreferCNAV   Use LNAV, CNAV and CNAV2 broadcast messages, but use CNAV whenever possible\n");
	printf("                            <val> = PreferCNAV2  Use LNAV, CNAV and CNAV2 broadcast messages, but use CNAV2 whenever possible\n");
	printf("                            <val> = LNAV         Use only LNAV  broadcast messages.\n");
	printf("                            <val> = CNAV         Use only CNAV  broadcast messages.\n");
	printf("                            <val> = CNAV2        Use only CNAV2 broadcast messages.\n");
	printf("                            <val> = AnyCNAV      Use only CNAV or CNAV2 broadcast messages.\n");
	printf("                            <val> = <val1>,<val2>,... Set the list of broadcast messages to be used (in order of preference).\n");
	printf("                             The following modes are for orbit comparison mode only:\n");
	printf("                            <val> = LNAVvsCNAV   Use only LNAV  broadcast messages in the first file and only CNAV  on the second file.\n");
	printf("                            <val> = CNAVvsLNAV   Use only CNAV  broadcast messages in the first file and only LNAV  on the second file.\n");
	printf("                            <val> = LNAVvsCNAV2  Use only LNAV  broadcast messages in the first file and only CNAV2 on the second file.\n");
	printf("                            <val> = CNAV2vsLNAV  Use only CNAV2 broadcast messages in the first file and only LNAV  on the second file.\n");
	printf("                            <val> = CNAVvsCNAV2  Use only CNAV  broadcast messages in the first file and only CNAV2 on the second file.\n");
	printf("                            <val> = CNAV2vsCNAV  Use only CNAV2 broadcast messages in the first file and only CNAV  on the second file.\n\n");
	printf("    -model:brdc:gal  <val>  Only valid when using broadcast products. This option only applies to Galileo:\n");
	printf("                            <val> = PreferINAV   Use INAV, FNAV, CNAV and GNAV broadcast messages, but use INAV whenever possible [default]\n");
	printf("                            <val> = PreferFNAV   Use INAV, FNAV, CNAV and GNAV broadcast messages, but use FNAV whenever possible\n");
//	printf("                            <val> = PreferCNAV   Use INAV, FNAV, CNAV and GNAV broadcast messages, but use CNAV whenever possible\n");
//	printf("                            <val> = PreferGNAV   Use INAV, FNAV, CNAV and GNAV broadcast messages, but use GNAV whenever possible\n");
	printf("                            <val> = INAV         Use only INAV broadcast messages (INAV with E1 and E5b, INAV only with E1 or INAV with E5b)\n");
	printf("                            <val> = INAVE1       Use only INAV broadcast messages (with information only on E1).\n");
	printf("                            <val> = INAVE5b      Use only INAV broadcast messages (with information only on E5b).\n");
	printf("                            <val> = INAVE1E5b    Use only INAV broadcast messages (with information of E1 and E5b).\n");
	printf("                            <val> = FNAV         Use only FNAV broadcast messages.\n");
/*	printf("                            <val> = CNAV         Use only CNAV broadcast messages.\n");
	printf("                            <val> = GNAV         Use only GNAV broadcast messages.\n");
*/	printf("                            <val> = <val1>,<val2>,... Set the list of broadcast messages to be used (in order of preference).\n");
	printf("                             The following modes are for orbit comparison mode only:\n");
	printf("                            <val> = INAVvsFNAV   Use only INAV broadcast messages in the first file and only FNAV on the second file.\n");
	printf("                            <val> = FNAVvsINAV   Use only FNAV broadcast messages in the first file and only INAV on the second file.\n\n");
/*	printf("                            <val> = INAVvsCNAV   Use only INAV broadcast messages in the first file and only CNAV on the second file.\n");
	printf("                            <val> = CNAVvsINAV   Use only CNAV broadcast messages in the first file and only INAV on the second file.\n");
	printf("                            <val> = INAVvsGNAV   Use only INAV broadcast messages in the first file and only GNAV on the second file.\n");
	printf("                            <val> = GNAVvsINAV   Use only GNAV broadcast messages in the first file and only INAV on the second file.\n");
	printf("                            <val> = FNAVvsCNAV   Use only FNAV broadcast messages in the first file and only CNAV on the second file.\n");
	printf("                            <val> = CNAVvsFNAV   Use only CNAV broadcast messages in the first file and only FNAV on the second file.\n");
	printf("                            <val> = FNAVvsGNAV   Use only FNAV broadcast messages in the first file and only GNAV on the second file.\n");
	printf("                            <val> = GNAVvsFNAV   Use only GNAV broadcast messages in the first file and only FNAV on the second file.\n");
	printf("                            <val> = CNAVvsGNAV   Use only CNAV broadcast messages in the first file and only GNAV on the second file.\n");
	printf("                            <val> = GNAVvsCNAV   Use only GNAV broadcast messages in the first file and only CNAV on the second file.\n\n");
	printf("    -model:brdc:glo  <val>  Only valid when using broadcast products. This option only applies to Glonass:\n");
	printf("                            <val> = PreferFDMA   Use FDMA and CDMA broadcast messages, but use FMDA whenever possible\n");
	printf("                            <val> = PreferCDMA   Use FDMA and CDMA broadcast messages, but use CDMA whenever possible\n");
	printf("                            <val> = FDMA         Use only FDMA broadcast messages [default].\n");
	printf("                            <val> = CDMA         Use only CDMA broadcast messages.\n");
	printf("                            <val> = <val1>,<val2>,... Set the list of broadcast messages to be used (in order of preference).\n");
	printf("                             The following modes are for orbit comparison mode only:\n");
	printf("                            <val> = FDMAvsCDMA    Use only FDMA  broadcast messages in the first file and only CDMA on the second file.\n");
	printf("                            <val> = CDMAvsFDMA    Use only CDMA  broadcast messages in the first file and only FDMA on the second file.\n\n");
*/	printf("    -model:brdc:bds  <val>  Only valid when using broadcast products. This option only applies to BeiDou:\n");
	printf("                            <val> = PreferD1     Use D1, D2, CNAV1 and CNAV2 broadcast messages, but use D1    whenever possible\n");
	printf("                            <val> = PreferD2     Use D1, D2, CNAV1 and CNAV2 broadcast messages, but use D2    whenever possible\n");
	printf("                            <val> = PreferCNAV1  Use D1, D2, CNAV1 and CNAV2 broadcast messages, but use CNAV1 whenever possible\n");
	printf("                            <val> = PreferCNAV2  Use D1, D2, CNAV1 and CNAV2 broadcast messages, but use CNAV2 whenever possible\n");
	printf("                            <val> = D1           Use only D1    broadcast messages (default)\n");
	printf("                            <val> = D2           Use only D2    broadcast messages\n");
	printf("                            <val> = CNAV1        Use only CNAV1 broadcast messages\n");
	printf("                            <val> = CNAV2        Use only CNAV2 broadcast messages\n");
	printf("                            <val> = <val1>,<val2>,... Set the list of broadcast messages to be used (in order of preference).\n");
	printf("                             The following modes are for orbit comparison mode only:\n");
	printf("                            <val> = D1vsD2       Use only D1    broadcast messages in the first file and only D2    on the second file\n");
	printf("                            <val> = D2vsD1       Use only D2    broadcast messages in the first file and only D1    on the second file\n");
	printf("                            <val> = D1vsCNAV1    Use only D1    broadcast messages in the first file and only CNAV1 on the second file\n");
	printf("                            <val> = CNAV1vsD1    Use only CNAV1 broadcast messages in the first file and only D1    on the second file\n");
	printf("                            <val> = D1vsCNAV2    Use only D1    broadcast messages in the first file and only CNAV2 on the second file\n");
	printf("                            <val> = CNAV2vsD1    Use only CNAV2 broadcast messages in the first file and only D1    on the second file\n");
	printf("                            <val> = D2vsCNAV1    Use only D2    broadcast messages in the first file and only CNAV1 on the second file\n");
	printf("                            <val> = CNAV1vsD2    Use only CNAV1 broadcast messages in the first file and only D2    on the second file\n");
	printf("                            <val> = D2vsCNAV2    Use only D2    broadcast messages in the first file and only CNAV2 on the second file\n");
	printf("                            <val> = CNAV2vsD2    Use only CNAV2 broadcast messages in the first file and only D2    on the second file\n");
	printf("                            <val> = CNAV1vsCNAV2 Use only CNAV1 broadcast messages in the first file and only CNAV2 on the second file\n");
	printf("                            <val> = CNAV2vsCNAV1 Use only CNAV2 broadcast messages in the first file and only CNAV1 on the second file\n\n");
	printf("    -model:brdc:qzss <val>  Only valid when using broadcast products. This option only applies to QZSS:\n");
	printf("                            <val> = PreferLNAV   Use LNAV, CNAV and CNAV2 broadcast messages, but use LNAV whenever possible\n");
	printf("                            <val> = PreferCNAV   Use LNAV, CNAV and CNAV2 broadcast messages, but use CNAV whenever possible\n");
	printf("                            <val> = PreferCNAV2  Use LNAV, CNAV and CNAV2 broadcast messages, but use CNAV2 whenever possible\n");
	printf("                            <val> = LNAV         Use only LNAV  broadcast messages [default]\n");
	printf("                            <val> = CNAV         Use only CNAV  broadcast messages\n");
	printf("                            <val> = CNAV2        Use only CNAV2 broadcast messages\n");
	printf("                            <val> = AnyCNAV      Use only CNAV or CNAV2 broadcast messages.\n");
	printf("                            <val> = <val1>,<val2>,... Set the list of broadcast messages to be used (in order of preference).\n");
	printf("                             The following modes are for orbit comparison mode only:\n");
	printf("                            <val> = LNAVvsCNAV   Use only LNAV  broadcast messages in the first file and only CNAV  on the second file\n");
	printf("                            <val> = CNAVvsLNAV   Use only CNAV  broadcast messages in the first file and only LNAV  on the second file\n");
	printf("                            <val> = LNAVvsCNAV2  Use only LNAV  broadcast messages in the first file and only CNAV2 on the second file\n");
	printf("                            <val> = CNAV2vsLNAV  Use only CNAV2 broadcast messages in the first file and only LNAV  on the second file\n");
	printf("                            <val> = CNAVvsCNAV2  Use only CNAV  broadcast messages in the first file and only CNAV2 on the second file\n");
	printf("                            <val> = CNAV2vsCNAV  Use only CNAV2 broadcast messages in the first file and only CNAV  on the second file\n\n");
	printf("    -model:orbit:deg <val>  Precise orbit interpolation degree [default 10]\n\n");
	printf("    -model:clk:deg <val>    Precise clock interpolation degree [default 1]\n\n");
	printf("    -model:orbmaxgaps <val> Set maximum number of gaps between samples used for precise orbit interpolation [default 8]\n\n");
	printf("    -model:clkmaxgaps <val> Set maximum number of gaps between samples used for precise clock interpolation [default 2]\n\n");
	printf("    -model:orbtotmaxgaps <val> Set the maximum number of gaps between all samples used for precise orbit interpolation [default 16]\n\n");
	printf("    -model:clktotmaxgaps <val> Set the maximum number of gaps between all samples used for precise clock interpolation [default 4]\n\n");
	printf("    -model:orbprevsample    When a concatenated SP3 file is read for orbit data, if the last epoch of the previous day is the same as the first epoch\n");
	printf("                              of the current day, use the last orbit sample of the previous day instead of the first sample of the current day [default off]\n");
	printf("                              This typically occurs with samples at epoch 0h 0m. This option will only have effect if both repeated samples have valid values.\n\n");
	printf("    -model:clkprevsample    When a concatenated SP3/Clock file is read for clock data, if the last epoch of the previous day is the same as the first epoch\n");
	printf("                              of the current day, use the last orbit sample of the previous day instead of the first sample of the current day [default off]\n");
	printf("                              This typically occurs with samples at epoch 0h 0m. This option will only have effect if both repeated samples have valid values.\n\n");
	printf("    -model:allfilemeas      If this option is enabled, it will compute the model value (and print the MODEL message if enabled) for all\n");
	printf("                              measurements available in the RINEX observation. This was the behaviour in gLAB<6.0.0 [default off]\n");
	printf("                              The default mode is to model only the measurements which will be used in the filter\n");
	printf("                              In SBAS and DGNSS modes, this option will be automatically disabled\n\n");
	printf("    -model:sbasmaritime     Configure SBAS parameters for SBAS 1F maritime mode (see notes on SBAS maritime below) [default off]\n\n");
	printf("    -model:sbassignalflighttime  #   set the default signal flight time (in seconds) [default 0.12] Value ranges are from [0,0.3]\n\n");
	printf("    -model:usealarmmsgcorr  When reading an SBAS 1F message type 0, parse it as type 2, or  when reading an SBAS DFMC message type 0,\n");
   	printf("                              parse it as type 34, 35 or 36 (except if all bits are 0) [default off]\n\n");
	printf("    -model:ignoretype0      Ignore all SBAS messages type 0 [default off]\n\n");
	printf("    -model:udreithreshold # Set the UDREI threshold (from fast corrections) for discarding satellites. Satellites with UDREI equal or higher than\n");
	printf("                              this threshold will be discarded. Threshold values have to be in the range [1-13]	[default no threshold]\n\n");
	printf("    -model:sigfltnomt10offset #  When message type 10 is not available or disabled, the fast correction sigma is computed as UDRE sigma\n");
	printf("                              plus an offset of 8 metres. With this parameter the offset of 8 metres can be changed to any value (in metres)\n\n");
	printf("    -model:sbasmode <val>   Select navigation mode for SBAS processing:\n");
	printf("                            <val> = PA    Precision Approach [default]\n");
	printf("                            <val> = NPA   Non Precision Approach\n\n");
	printf("    -model:geoswitch        Enable GEO switch for SBAS processing. See 'Mode and GEO switch notes' below [default off]\n\n");
	printf("    -model:selectbestgeo    If GEO switching for SBAS processing is enabled, gLAB will compute the protection levels for all GEO\n");
	printf("                              available and will select the one with lower protection levels. [default off].\n");
	printf("                              Enabling this option will noticeably increase the computation time (especially if there are many GEOs\n");
	printf("                              in the SBAS data file), as gLAB needs to compute the SBAS modelling with each GEO, and then select the best one.\n");
	printf("                              Read section \"Selection of best GEO:\" below for details on the criteria of how the best GEO is selected.\n\n");
	printf("    -model:maintaingeo      If GEO switch for SBAS is enabled, maintain current GEO while possible independently if it is the GEO\n");
	printf("                              selected by the user or it has been selected due to a GEO switch [default on]\n\n");
	printf("    -model:geofallback      If GEO switch for SBAS is enabled, always try to return to the initial selected GEO [default off]\n\n");
	printf("    -model:sbasmodeswitch   Enable navigation mode switching (between PA and NPA) in SBAS processing [default off]\n\n");
	printf("    -model:mixedgeo         Enable the usage of mixed GEO data (messages from all GEO are treated as if there were from an unique GEO) [default off]\n\n");
	printf("    -model:initcoordnpa     In SBAS mode, if receiver coordinates are to be calculated without giving any initial condition (parameter\n");
	printf("                            -pre:setrecpos calculate), compute the first epochs using Klobuchar until the receiver coordinates have converged.\n");
	printf("                            This is useful due to the initial gLAB coordinate may do that the IPPs (Ionospheric Pierce Point) fall outside the\n");
	printf("                            SBAS region, making all satellites unavailable due to the lack of ionosphere. This option only has effect if SBAS\n");
	printf("                            mode switch is disabled and receiver coordinates are set to 'calculate' [default on]\n\n");
	printf("    -model:sbasreceiver #   Set receiver class type for SBAS (for computing variance of the airborne receiver)\n");
	printf("                            # = 0 User defined receiver model (defined with parameters '-model:sigmpath', '-model:sigdiv', '-model:signoise' and '-input:sigmpath').\n");
	printf("                                  The receiver sigmas not defined by the user (with the previous parameters) will use the default values for class 2 receiver\n");
	printf("                            # = 1 Class 1 equipment\n");
	printf("                            # = 2,3,4 Class 2,3,4 equipment (all equivalent) [default 2]\n\n");
	printf("    -model:geoacqtime #     Set the minimum time (in seconds) to consider that gLAB has received enough SBAS corrections from a GEO\n"); 
	printf("                              counting from the first message received [default %d]\n",GEOACQUISIONTIME);
	printf("                              This timer is set to ensure that we have received enough corrections from the GEO we want to switch to.\n");
	printf("                              If this timer is set too low (few seconds), it may happen that we switch to a GEO with not enough data (due to\n");
	printf("                              we are in initialization or the GEO has received an alarm message\n");
	printf("                              gLAB will not switch to any GEO before this time, except for when an alarm message is received and there is no other GEO available\n\n"); 
	printf("    -model:switchtime #     Set the minimum time (in seconds) between a GEO or mode switch and the following one [default 0]\n");
	printf("                              If this timer is set to zero, a maximum of %d switches per epoch (for both mode and GEO) will be done\n\n",MAXSWITCHPEREPOCH);
	printf("    -model:sbastmout    <n> <val> Set time out value for SBAS messages (except for fast and range rate corrections) in both modes, PA and NPA\n");
	printf("                            <n> is the message type number\n");
	printf("                            <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutpa  <n> <val> Set time out value for SBAS messages (except for fast and range rate corrections) in PA mode\n");
	printf("                            <n> is the message type number\n");
	printf("                            <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutnpa <n> <val> Set time out value for SBAS messages (except for fast and range rate corrections) in NPA mode\n");
	printf("                            <n> is the message type number\n");
	printf("                            <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutfc      <val>  Set time out value for fast corrections in both modes, PA and NPA\n");
	printf("                              <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutfcpa    <val>  Set time out value for fast corrections in PA mode\n");
	printf("                              <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutfcnpa   <val>  Set time out value for fast corrections in NPA mode\n");
	printf("                              <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutrrc     <val>  Set time out value for range rate corrections in both modes, PA and NPA\n");
	printf("                              <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutrrcpa   <val>  Set time out value for range rate corrections in PA mode\n");
	printf("                              <val> is the time out value (in seconds)\n\n");
	printf("    -model:sbastmoutrrcnpa  <val>  Set time out value for range rate corrections in NPA mode\n");
	printf("                              <val> is the time out value (in seconds)\n\n");
	printf("    -model:sigmpath <val1> <val2> [<val3>] Set parameters a,b,c for sigma multipath for SBAS (1F or DFMC) airborne receiver, being sigma=a+b*e^(-satelevation/c)\n");
	printf("                                      and satelevation in degrees.\n");
	printf("                              <val1>   a value (in metres)    [default 0.13 for class 2/3/4 receiver]\n");
	printf("                              <val2>   b value (in metres)    [default 0.53 for class 2/3/4 receiver]\n");
	printf("                              [<val3>] c value (in degrees)   [default 10 for class 2/3/4 receiver]. This argument is optional in order to\n");
	printf("                                          maintain compatibility with previous versions\n\n");
	printf("    -model:sigdiv   <val>   Set a fixed value (in metres) for sigma divergence for SBAS (1F or DFMC) airborne receiver\n\n"); 
	printf("    -model:signoise <val>   Set a fixed value (in metres) for sigma noise for SBAS (1F or DFMC) airborne receiver\n\n");
	printf("    -model:khpa     <val>   Set the Kh factor value used when computing the horizontal protection level in PA mode [default 6]\n\n");
	printf("    -model:khnpa    <val>   Set the Kh factor value used when computing the horizontal protection level in NPA mode [default 6.18]\n\n");
	printf("    -model:kvpa     <val>   Set the Kv factor value used when computing the vertical protection level in PA mode [default 5.33]\n\n");
	printf("    -model:kvnpa    <val>   Set the Kv factor value used when computing the vertical protection level in NPA mode [default 5.33]\n\n");
	printf("    -model:nofastcor        Set SBAS fast and RRC corrections values to 0 [default off]\n\n");
	printf("    -model:norrccor         Set SBAS RRC correction value to 0 [default off]\n\n");
	printf("    -model:noslowcor        Set SBAS slow corrections values to 0 [default off]\n\n");
	printf("    -model:noionocor        Set SBAS ionosphere correction value to 0 [default off]\n\n");
	printf("    -model:nofastsigma      Set SBAS fast and RRC sigmas (sigma UDRE and degradation terms) values to 0 [default off]\n\n");
	printf("    -model:nofastdeg        Set SBAS fast degradation term value to 0 [default off]\n\n");
	printf("    -model:norrcsigma       Set SBAS RRC degradation term value to 0 [default off]\n\n");
	printf("    -model:noslowsigma      Set SBAS slow correction degradation term to 0 [default off]\n\n");
	printf("    -model:noionosigma      Set SBAS ionosphere sigma to 0 [default off]\n\n");
	printf("    -model:notroposigma     Set SBAS troposphere sigma to 0 [default off]\n\n");
	printf("    -model:noenroutesigma   Set SBAS En Route Through NPA degradation term to 0 [default off]\n\n");
	printf("    -model:nodeltaudre      Set SBAS Delta UDRE factor to 1 [default off]\n\n");
	printf("    -model:nomt10           Disable use of message type 10 in all modes [default off]\n\n");
	printf("    -model:nomt2728         Disable use of messages type 27 and 28 in all modes (this is equivalent to parameter '-model:nodeltaudre') [default off]\n\n");
	printf("    -model:norrc1prc        Set RRC corrections and its degradation term to 0 when only one PRC has been received, instead of discarding the satellite\n\n");
	printf("    -model:sbasdfmc:mt37v04     When reading a SBAS DFMC message type 37, decode it using ED-259 version <=0.4 [default disabled]\n\n");
	printf("    -model:sbasdfmc:mt3940v04   When reading a SBAS DFMC message type 39/40, decode it using ED-259 version <=0.4 [default disabled]\n\n");
	printf("    -model:sbasdfmc:mt42v07	    When reading a SBAS DFMC message type 42, decode it using ED-259 version <=0.7 [default disabled]\n\n");
	printf("    -model:sbasdfmc:mt47v04	    When reading a SBAS DFMC message type 47, decode it using ED-259 version <=0.4 [default disabled]\n\n");
	printf("    -model:sbasdfmc:cer         <val>      Set the value (in metres) of Cer parameter in SBAS DFMC MT 37 [default read from MT37]\n\n");
	printf("    -model:sbasdfmc:ccovariance <val>      Set the value (unitless) of Ccovariance parameter in SBAS DFMC MT 37 [default read from MT37]\n\n");
	printf("    -model:sbasdfmc:icorr       g[g]-<val> Set the value (in seconds) of Icorr (per constellation) parameter in SBAS DFMC MT 37 [default read from MT37]\n");
	printf("                                   g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                                   [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                                   <val>    = Icorr value (in seconds)\n\n");
	printf("    -model:sbasdfmc:ccorr       g[g]-<val> Set the value (in metres) of Ccorr (per constellation) parameter in SBAS DFMC MT 37 [default read from MT37]\n");
	printf("                                   g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                                   [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                                   <val>    = Ccorr value (in metres)\n\n");
	printf("    -model:sbasdfmc:rcorr       g[g]-<val> Set the value (in metres/second) of Rcorr (per constellation) parameter in SBAS DFMC MT 37 [default read from MT37]\n");
	printf("                                   g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                                   [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                                   <val>    = Rcorr value (in metres/second)\n\n");
	printf("    -model:sbasdfmc:dfrei       <n> <val>  Set the value (in metres) for the DFREI sigma when DFREI=<n> in SBAS DFMC MT 37 [default read from MT37]\n");
	printf("                                   <n>      = DFREI value, valid values are [0..14]\n");
	printf("                                   <val>    = DFREI value (in metres)\n\n");
	printf("    -model:sbasdfmc:dfreilist <val0>,<val1>,...,<val14>\n");
	printf("                                 Set the value (in metres) for all possible DFREI values in a comma separated list.\n");
	printf("                                 The list must contain 15 values in DFREI ascending order, from DFREI=0 to DFREI=14\n");
	printf("                              Example: 0.125,0.25,0.375,0.5,0.625,0.75,1,1.25,1.5,1.75,2,2.5,3,4,10\n\n");
	printf("    -model:sbasdfmc:deltarcorr     <val>   Set the value (unitless) of Delta Rcorr parameter in SBAS DFMC MT 32 or MT39/40 [default read from MT32 or MT39/40]\n\n");
	printf("    -model:sbasdfmc:deltadfre      <val>   Set the value (unitless) of Delta DFRE instead of computing it from MT 32 or MT39/40 [default compute from MT32 or MT39/40]\n\n");
	printf("    -model:sbasdfmc:sigmauire      <val>   Set the value (in metres) of UIRE sigma instead of using MOPS formula [default use MOPS formula]\n\n");
	printf("    -model:sbasdfmc:sigmatropo     <val>   Set the value (in metres) of troposphere sigma instead of using MOPS formula [default use MOPS formula]\n\n");
	printf("    -model:sbasdfmc:sigmpathfactor <val>   Set the value (adimensional) for the factor to convert the receiver sigma multipath from single frequency to dual frequency [default 2.59]\n");
	printf("                                            This factor is to account for the noise increase in the ionosphere-free combination, as the receiver sigma multipath is computed\n");
	printf("                                            the one for SBAS 1 frequency (as described in parameter '-model:sigmpath').\n\n");
	printf("    -model:sbasdfmc:anymeas  Allow to use any measurement for processing in SBAS DFMC mode in the default measurements are not available [default off]\n");
	printf("                             In SBAS DFMC, measurements for navigation are fixed to GPS C1C-L1C, C5Q-L5Q and Galileo C1C-L1C, C5Q-L5Q. If these measurements\n");
	printf("                              are not available, gLAB by default will refuse to process in SBAS DFMC. If this option is enabled, gLAB will allow to use any\n");
	printf("                              measurement from the same frequency as substitute for the default ones. For instance, some receivers only provide the\n");
	printf("                              combined L5 measurements (C5X-L5X) for both GPS and Galileo, so it is necessary to enable this option to process data with them\n"); 
	printf("                              If this option is enabled and measurements different from the defaults are used, a bias will appear between the estimated\n");
	printf("                              SBAS DFMC corrections and the used measurments, degrading the navigation solution.\n\n");
	printf("    -model:sbasdfmc:austestbed  Configure gLAB to process Australian SBAS DFMC test bed messages, which uses messages format from SBAS DFMC MOPS 0.3.8 (March 2017) and\n");
	printf("                                sends MT0 to send MT34, MT35 and MT36. This parameter is a shortcut for providing parameters '-model:sbasdfmc:mt37v04',\n");
	printf("                                '-model:sbasdfmc:mt3940v04', '-model:sbasdfmc:mt42v07', '-model:sbasdfmc:mt47v04', '-model:usealarmmsgcorr' and\n");
	printf("                                '--model:dcb:df:gps'\n\n");
	printf("    -model:dgnss:sigmainflation   The sigma is inflated during the smoother convergence (see DGNSS notes at the end) [default on]\n\n");
	printf("    --model:dgnss:sigmainflation  Do not use the sigma inflation during the smoother convergence\n\n");
	printf("    -model:dgnss:maxage <val>     Set the maximum age value (in seconds) to stop applying DGNSS corrections [default 31]\n\n");
	printf("    -model:dgnss:maxcorrval <val> Set the maximum value for a DGNSS correction to be considered valid (in metres) [default 500]\n\n");
	printf("    -model:dgnss:measprc [+-]g[g]#[-#][.#[-#]]-<PRCmeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] [...]\n");
	printf("                            Set the measurements to use for computing the corrections in the reference station in DGNSS mode\n");
	printf("                            Measurements are set in the same way as in option '-filter:select'\n\n");
	printf("    -model:dgnss:measprclist [+-]g[g]#[-#][.#[-#]]-<PRCmeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]],...]\n");
	printf("                                Same as '-model:dgnss:measprclist', but each entry is separated by commas (',') instead of blank spaces\n\n");
	printf("     NOTE: When setting any fast, slow, ionosphere correction or their sigmas to 0, gLAB will still check all the conditions\n");
	printf("             for the current mode. For example, if gLAB is in PA mode and the '-model:nofastcor' parameter is set, then it\n");
	printf("             will search for a fast correction, and if it is available, it will set the value to 0 instead of the one\n");
	printf("             given in the SBAS message. If there is no SBAS fast correction available, the satellite will not be used.\n\n");
	printf("     NOTE: The SBAS timeouts given by the user will override the defaults stated in MOPS-D.\n");
	printf("\n  FILTERING OPTIONS\n\n");
	printf("    -filter:stepdetector    Check for jumps in measurements using the prefits residuals (only for C1C measurement) [default off]\n");
	printf("                             Use '--filter:stepdetector' to disable it\n\n");
	printf("    -filter:prefitoutliers:median  <val> Check for outliers in the prefits residuals using the median, with <val> (in metres) as the threshold [default off]\n");
	printf("                             Use '--filter:prefitoutliers:median' or '-filter:prefitoutliers:median 0' to disable it. See notes on prefit outlier detectors below\n\n");
	printf("    -filter:prefitoutliers:abs  <val> Check for outliers in the prefits residuals comparing absolute values, with  <val> (in metres) as the threshold [default off]\n");
	printf("                             Use '--filter:prefitoutliers:abs' or '-filter:prefitoutliers:abs 0' to disable it. See notes on prefit outlier detectors below\n\n");
	printf("    -filter:noambiguities    Assume carrier phase measurements are absolute measurements [default off]\n");
	printf("                              If this option is enabled, gLAB will assume that carrier phase measurements are absolute measurements (i.e. the\n");
	printf("                               ambiguity has been already been added, either by modifying the RINEX observation file or by adding it as a user defined\n");
	printf("                               error with option '-input:usererror'.\n"); 	
	printf("                               When this option is enabled, code jumps detection and carrier phase alignment will be switched off.\n"); 	
	printf("                               Furthermore, carrier phase will be used to computed signal flight time and for detection outliers in the prefit outlier detectors.\n"); 	
	printf("                               In order to use this option correctly, check in the FAQ the question 'CAN gLAB PROCESS CARRIER PHASE MEASUREMENTS AS ABSOLUTE MEASUREMENTS?'\n\n");
	printf("    -filter:trop            Estimate the troposphere of the station [default in PPP with carrier phase] ('--filter:trop' to disable it)\n\n");
	printf("    -filter:gloifb          Estimate GLONASS IFB (Inter Frequency Bias) [default off]\n");
	printf("                              This parameter is experimental and may not work correctly. The GLONASS IFB computation is based on:\n\n");
	printf("                               Sleewaegen J-M, Simsky A, De Wilde W, Boon F, Willems T (2012) Demystifying GLONASS Inter-Frequency Carrier Phase Biases.\n");
	printf("                               Inside GNSS URL https://www.insidegnss.com/auto/mayjune12-Sleewaegen.pdf\n\n");
	printf("    -filter:recwindup       Estimate the receiver wind-up [default off]\n");
	printf("                              This parameter is experimental and may not work correctly.\n\n");
	printf("    -filter:iscb g1g2-<val>  [g1g2-<val> ...] Set from which source the inter-system clock bias has to be read or to be estimated by the filter\n");
	printf("                                g1 = Reference constellation used for the receiver clock (one letter)\n");
	printf("                                g2 = Destination constellation (one letter)\n");
//	printf("                             <val> = RINEX      Read inter-system clock bias from RINEX navigation file header\n");
	printf("                             <val> = estimate   Estimate inter-system clock bias in the filter [default for all constellations]\n");
	printf("                             <val> = [u-]<number>   Set inter-system clock bias to <number>. Default unit is metres, but it can\n");
	printf("                                                     changed by adding a unit letter and a dash prior to the value. The accepted\n");
	printf("                                                     unit letters are:\n");
	printf("                                                        u = m Set input unit to metres (default)\n");	
	printf("                                                        u = s Set input unit to seconds\n");	
	printf("                                                        u = n Set input unit to nanoseconds\n");	
	printf("                               Samples:\n");
	printf("                                 -filter:iscb GE-estimate\n");
	printf("                                 -filter:iscb GR-1.55\n");
	printf("                                 -filter:iscb GR-m-1.55\n");
	printf("                                 -filter:iscb EC-s-6.24e-9\n");
	printf("                                 -filter:iscb RC-n-6.5\n\n");
	printf("    -filter:nav <nav>       <nav> = static          Process supposing a static receiver [default in PPP]\n");
	printf("                                  = kinematic       Process supposing a moving receiver [default in SPP/SBAS/DGNSS]\n");
	printf("                                  = randomwalk      Process supposing a slowly moving receiver (default assumes less than 30 Km/h)\n\n");
	printf("    -filter:meastype <meastype>  \n");
	printf("                            <meastype> = pseudorange    Use only pseudorange (or smoothed pseudorange) for positioning [default in SPP/SBAS/DGNSS]\n");
	printf("                                       = carrierphase   Use pseudorange and carrier phase for positioning [default in PPP]\n\n");
	printf("    -filter:combtype <combtype>  Set the measurement combination types (single or dual frequency combinations) to be used when gLAB sets\n");
	printf("                                  the default combinations to use (i.e. the user does not provide any measurement for the filter\n");
	printf("                                  with parameter '-filter:select'). This option only applies for SPP and PPP modes.\n");
	printf("                            <combtype> = auto           gLAB decides which combinations to use (single frequency for SPP, dual frequency in PPP) [default]\n");
	printf("                                       = singlefreq     Use single  frequency measurements in the filter [default in SPP]\n");
	printf("                                       = dualfreq       Use dual    frequency measurements in the filter [default in PPP]\n");
	printf("                                       = graphic        Use graphic combination measurements in the filter\n\n");
	printf("    -filter:select [+-]g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] [...]\n");
	printf("                                Set the measurements or combinations to be used in the filter.\n");
	printf("                                Each entry must be separated by a blank space (' ')\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
    printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]]    = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                            with a dot ('.')\n");
	printf("                            <filtermeas>   Set the measurement or combination to be used in the filter\n");
	printf("                                 For single measurement and user selected measurement, the measurement name must be provided (in RINEX 2 or 3 format).\n");
	printf("                                 For single measurement and the measurement to be selected by gLAB: \n");
	printf("                                        Set value 'Pseudorange' or 'Code' (case insensitive), a hyphen ('-') and the frequency number to use,\n");
	printf("                                     OR set value 'Phase' or 'Carrierphase' (case insensitive), a hyphen ('-') and the frequency number to use.\n");
	printf("                                 For dual/triple/quadruple combinations, the combination name with its frequencies must be given.\n");
	printf("                            [<meas1>-<meas2>[-<meas3>-<meas4>]] If measurement is a combination, optionally set the measurements to use.\n");
	printf("                                        For dual frequency combinations, two measurements are needed. For triple or quadruple frequency\n");
    printf("                                        combinations, four measurements are needed.\n");
	printf("                                        If measurements are not set, they will be automatically selected using the measurement list (see\n");
	printf("                                        parameter '-pre:measorderlist'). \n");
	printf("                                        In the case of dual, triple or quadruple measurements, if user does not set the measurements, the type\n");
	printf("                                        of measurements (pseudorange or carrier phase) to use is undefined. The user can set by appending\n");
	printf("                                        '-code' or '-pseudorange' (for pseudorange) or '-phase' or '-carrierphase' (for carrier phase). For\n");
	printf("                                        setting pseudorange and carrierphase at once (in two different measurements), use the word '-codephase'\n");
	printf("                                        or '-phasecode'. All arguments are case insensitive. If not set, gLAB will assume that the type to be used\n");
	printf("                                        is a carrier phase.\n");
	printf("                            [...]  User can set multiple filter measurements\n");
	printf("                               Sample: '-filter:select G0-L1P ER0-auto'\n");
	printf("                                       '-filter:select G0-Code-1 GE0-Phase-5'\n");
	printf("                                       '-filter:select G0-G1 G0-G1-C1C-L1C E0-G5'\n");
	printf("                                       '-filter:select GE0-IF12-CodePhase'\n");
	printf("                                       '-filter:select G0-L1P -G1-L1P +G1-L1C'\n");
	printf("                                       '-filter:select GR0-IF12-code EJ0-IF15-code REC1-10-IF12-code REC1-10-IF12-phase'\n");
	printf("                                       '-filter:select GR0-PC12 EJ0-PC15 REC1-10-PC12'\n");
	printf("                                       '-filter:select 0-IF15-C1X-C5X 0-IF15-L1X-L5X'\n");
	printf("            NOTES:\n"); 
	printf("             - To set a graphic combination, use the letter 'G' plus the frequency. To set also the measurements, add them after the frequency between dashes.\n");
    printf("                 Example: '-filter:select G0-G1 G0-E1-C1C-L1C E0-G5'\n\n"); 
	printf("             - To set a ionospheric-free combination, use the letters 'IF' plus the frequencies and type or the measurements.\n");
    printf("                 Example: '-filter:select G0-IF12-code E0-IF15-phase R0-IF12-codephase C0-IF15-C1C-C5Q C0-IF15-L1C-L5Q'\n"); 
    printf("                Note that for ionospheric-free combination, letters 'PC' and 'LC' can also be used (the former for code and the latter for carrier phase)\n");
    printf("                 Example: '-filter:select G0-PC12 E0-LC15 R0-PC12 R0-LC12 C0-PC15-C1C-C5Q C0-LC15-L1C-L5Q'\n\n"); 
	printf("             - For triple/quadruple frequency combinations, the first two frequencies are used for building one dual frequency combination,\n");
	printf("                and next two frequencies are used for building the second dual frequency combination.\n\n");
	printf("             - For dual/triple/quadruple frequency combinations, gLAB will internally reorder the frequency number in order to match its\n");
	printf("                internal order for the combination (in the output messages it will be printed with its internal order). In quadruple\n");
	printf("                combinations, the internal frequency reordering does respect the pair of frequencies used for making the combinations.\n\n");
	printf("             - In gLAB versions 5 and below, this parameter had the following format:\n");
	printf("                          -filter:select <num> <meas1> <meas2> ...\n");
	printf("                     This old format is deprecated, but it is still supported for compatibility with previous versions\n\n");
	printf("    -filter:selectlist [+-]g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]][,...]\n");
	printf("                                Same as '-filter:select', but each entry is separated by commas (',') instead of blank spaces\n");
	printf("                               Sample: '-filter:selectlist G0-L1P'\n");
	printf("                                       '-filter:selectlist G0-L1P,-G1-L1P,+G1-L1C'\n");
	printf("                                       '-filter:selectlist G0-IF12-code,E0-IF15-code,R1-10-IF12-code'\n");
	printf("                                       '-filter:selectlist G0-PC12,E0-PC15,R1-10-PC12'\n");
	printf("                                       '-filter:selectlist I10-IF15-C1X-C5X,R1-13-IF15-L1X-L5X'\n\n");
	printf("    -filter:fixedweight g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <a> [...]\n");
	printf("                                Apply the specified standard deviation to the filter measurement <filtermeas>, to be used as weight in the filter.\n");
	printf("                                Filter measurement must be specified the same way as in parameters '-filter:select' or '-filter:selectlist'\n");
	printf("                            std = a\n");
	printf("                            <a>    = URA  Use the URA value from the broadcast message (not valid in PPP)\n");
	printf("                                   = #    Value for the standard deviation of the measurement (metres)\n");
	printf("                            [...]  User can set multiple times a filter measurement and a <a> value\n");
	printf("                            The filter shall apply as weight = 1/(<a>^2)\n");
	printf("                            Sample: '-filter:fixedweight G0-C1P 2'     Set 2 metres of standard deviation to measurement C1P in filter\n");
	printf("                                    '-filter:fixedweight GE0-L1P 0.01' Set 1 centimetre of standard deviation to measurement L1P in filter\n");
	printf("                            Defaults: PPP:         Pseudorange -> 3m  Carrierphase -> 0.03m\n");
	printf("                                      SPP:         Pseudorange -> 1m  Carrierphase -> 0.10m\n\n");
	printf("    -filter:elevweight g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <a> <b> <c> [...]\n");
	printf("                                Apply the specified standard deviation to the filter measurement <filtermeas>, to be used as weight in the filter.\n");
	printf("                                Filter measurement must be specified the same way as in parameters '-filter:select' or '-filter:selectlist'\n");
	printf("                            std = a + b * e^(-elevation/c)\n");
	printf("                            <a>    = URA  Use the URA value from the broadcast message (not valid in PPP)\n");
	printf("                                   = #    Value for minimum standard deviation of the measurement [weight at elevation 90 degrees] (metres)\n");
	printf("                            <b>    Multiplier to e [standard deviation at elevation 0 degrees] (metres)\n");
	printf("                            <c>    Elevation constant (degrees)\n");
	printf("                            [...]  User can set multiple times a filter measurement and a <a>, <b>, and <c> values\n");
	printf("                            The filter shall apply as weight = 1/(std^2)\n");
	printf("                            Sample (default values): '-filter:elevweight G0-C1P 0.13 0.53 10' Apply to C1P measurement in all GPS satellites the standard deviation: 0.13+0.53*e^(-elevation/10)\n");
	printf("                            Note: '-filter:elevweight G0-C1P x 0 y' equals to '-filter:fixedweight G0-C1P x'\n\n");
	printf("    -filter:sinelevweight g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <a> <b> [...]\n");
	printf("                                Apply the specified standard deviation to the filter measurement <filtermeas>, to be used as weight in the filter.\n");
	printf("                                Filter measurement must be specified the same way as in parameters '-filter:select' or '-filter:selectlist'\n");
	printf("                            std^2 = a + b/((sin(elevation))^2)\n");
	printf("                            <a>    = URA  Use the URA value from the broadcast message (not valid in PPP)\n");
	printf("                                   = #    Value for minimum variance of the measurement (m^2)\n");
	printf("                            <b>    Multiplier to fraction (m^2)\n");
	printf("                            [...]  User can set multiple times a filter measurement and a <a> and <b> values\n");
	printf("                            The filter shall apply as weight = 1/(std^2)\n");
	printf("                            Sample (default values): '-filter:sinelevweight G3-C1P 0 1' Apply to C1P measurement in satellite GPS 3 the variance: 0+1/((sin(elevation))^2)\n\n");
	printf("    -filter:snrweight g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <a> <b> [...]\n");
	printf("                                Apply the specified standard deviation to the filter measurement <filtermeas>, to be used as weight in the filter.\n");
	printf("                                Filter measurement must be specified the same way as in parameters '-filter:select' or '-filter:selectlist'\n");
	printf("                            std^2 = a + b * 10^(-SNR/10)\n");
	printf("                            <a>    = URA  Use the URA value from the broadcast message (not valid in PPP)\n");
	printf("                                   = #    Value for minimum variance of the measurement [weight at max SNR] (m^2)\n");
	printf("                            <b>    Multiplier to exponential [variance at SNR 0 dBHz] (m^2*Hz)\n");
	printf("                            [...]  User can set multiple times a filter measurement and a <a> and <b> values\n");
	printf("                            The filter shall apply as weight = 1/(std^2)\n");
	printf("                            Sample (default L1): '-filter:snrweight G0-C1C 0 0.244'   Apply to C1C measurement in all GPS satellites the variance: 0+0.244*10^(-SNR/10)\n");
	printf("                            Sample (default L2): '-filter:snrweight G3-L2P 0.88E-6 0.77E-3'   Apply to L2P measurement in satellite GPS 3 the variance: 0.88E-6+0.77E-3*10^(-SNR/10)\n\n");
	printf("    -filter:snrelevweight g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <a> <b> [...]\n");
	printf("                                Apply the specified standard deviation to the filter measurement <filtermeas>, to be used as weight in the filter.\n");
	printf("                                Filter measurement must be specified the same way as in parameters '-filter:select' or '-filter:selectlist'\n");
	printf("                            std^2 = a + b * 10^(-SNR/10)/((sin(elevation)^2)\n");
	printf("                            <a>    = URA  Use the URA value from the broadcast message (not valid in PPP)\n");
	printf("                                   = #    Value for minimum variance of the measurement [weight at max SNR] (m^2)\n");
	printf("                            <b>    Multiplier to exponential [variance at SNR 0 dBHz] (m^2*Hz)\n");
	printf("                            [...]  User can set multiple times a filter measurement and a <a> and <b> values\n");
	printf("                            The filter shall apply as weight = 1/(std^2)\n");
	printf("                            Sample: '-filter:snrelevweight G0-L1C 0 1'   Apply to L1C measurement in all GPS satellites the variance: 0 + 1*10^(-SNR/10)/((sin(elevation))^2)\n\n");
	printf("    -filter:snrweight:comb  g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <val> [...]\n");
	printf("                              When the weight is computed using any method involving the SNR (options '-filter:snrweight' or '-filter:snrelevweight),\n");
	printf("                                   when computing the weight for combinations, select how to get the SNR value (being 'i' the index for the first frequency,\n");
	printf("                                   'j', the index for the second, 'k' for the index third and 'l' the index for the fourth):\n");
    printf("                               <val> = SNRi    For a combination with 2 frequencies (ij) or 4 frequencies (ijkl), use SNR from measurement of frequency i\n");
    printf("                               <val> = SNRj    For a combination with 2 frequencies (ij) or 4 frequencies (ijkl), use SNR from measurement of frequency j\n");
    printf("                               <val> = SNRk    For a combination with 4 frequencies (ijkl), use SNR from measurement of frequency k\n");
    printf("                               <val> = SNRl    For a combination with 4 frequencies (ijkl), use SNR from measurement of frequency l\n");
    printf("                               <val> = MaxSNR  Use the highest SNR of the measurements used in the combination\n");
    printf("                               <val> = MinSNR  Use the lowest SNR of the measurements used in the combination\n");
    printf("                               <val> = MeanSNR Use the mean SNR value of the two measurements used in the combination [default]\n");
    printf("                               0 <= <val> <= 1 If <val> is a number between [0,1], combine the SNR with the following formula:\n");
	printf("                                                 SNR = SNRi*<val> + SNRj*(1-<val>)\n");
	printf("                                              This combination only works for dual frequency combinations\n");
    printf("                               <val> = <val1>-<val2>-<val3>-<val4>\n"); 
	printf("                                           Set the values for combining the SNR in a triple or quadruple frequency combinations. The order\n");
	printf("                                           of the frequencies must be the same as the one given in the measurement name in the previous\n");
	printf("                                           value of this parameter. The SNR will be combined with the following formula:\n");
	printf("                                                 SNR = SNRi*<val1> + SNRj*<val2> + SNRk*<val3> + SNRl*<val4>\n");
	printf("                                           Values <val1>, <val2>, <val3> and <val4> must all be between [0-1], and  that the sum of the\n");
	printf("                                             four values must be equal to one (<val1> + <val2> + <val3> + <val4> = 1)\n");
	printf("                               [...]  User can set multiple times a filter measurement and <val> value\n");
	printf("                            Sample: '-filter:snrweight:comb G0-LC12 SNRi'  In combination LC12 (carrier phase iono free combination) in all GPS satellites, the SNR\n");
	printf("                                                                             of the combination must be computed as the value of the measurement used for frequency 1.\n");
	printf("                NOTES: - For a dual frequency combination with frequencies 'i' and 'j', 'i' is always the smallest frequency number and 'j' the highest,\n");
	printf("                           except for frequency '0', which will be always the highest (it it treated as frequency number '10').\n");
	printf("                           For example, for combination PC12, i=1 and j=2. For combination LC10, i=1,j=0\n");
	printf("                       - For a triple or quadruple frequency combination, for instance, combination SIF1234, ijkl values would correspond to\n");
	printf("                            i=1, j=2, k=3, l=4\n\n");
	printf("    -filter:sbasdgnssweightmode g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] <val> [...]\n");
	printf("                               In SBAS and DGNSS modes, select how the provided sigma is combined with the user selected weight\n");
	printf("                                           computation mode (with options '-filter:fixedweight', '-filter:elevweight', '-filter:sinelevweight',\n");
	printf("                                           '-filter:snrweight' and '-filter:snrelevweight')\n");
	printf("                              <val>  = ComputedOnly     Use only the variance computed with SBAS or DGNSS corrections [default if user does not select a weight method]\n"); 
	printf("                              <val>  = ComputedPlusUser Use the variance computed with SBAS or DGNSS corrections plus the sigma computed with the user selected weight method\n"); 
	printf("                              <val>  = UserOnly         Use only the variance computed with the user selected weight method [default if user selects a weight method]\n"); 
	printf("                               [...]  User can set multiple times a filter measurement and <val> value\n");
	printf("                            Sample: '-filter:sbasdgnssweightmode G0-C1C ComputedPlusUser'  Apply to C1C measurement in all GPS satellites the variance computed by SBAS and\n");
	printf("                                                                                             the one set by user (with any of the parameters to set types of weight shown above)\n\n");
/*	printf("    -filter:velocity        Compute the velocity of the rover. If options '-filter:dopplermeas' or '-filter:dopplermeaslist'\n");
	printf("                              are not set, Doppler measurements will be automatically selected [default off]\n\n");
	printf("    -filter:dopplermeas [+-]g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]] [...]\n");
	printf("                                Set the Doppler measurements or combinations to be used for computing the velocity.\n");
	printf("                                Measurements are provided the same way as in '-filter:select' parameter (including\n");
	printf("                                 the combinations), except for instead of using 'code' or 'phase' words for auto\n");
	printf("                                 selection of code or phase measurements, the word 'doppler' has to be used for\n");
	printf("                                 auto selection of Doppler measurements.\n");
	printf("                               Sample: '-filter:doppler G0-D1P'\n");
	printf("                                       '-filter:doppler G0-Doppler-1'\n");
	printf("                                       '-filter:doppler G0-D1P -G1-D1P +G1-D1C'\n");
	printf("                                       '-filter:doppler GR0-PC12 EJ0-PC15 REC1-10-PC12'\n");
	printf("                                       '-filter:doppler 0-PC15-D1X-D5X 0-LC15-D1X-D5X'\n");
	printf("                                       '-filter:doppler G0-SIF1215 EJ0-SIF1556-doppler C9-17-SIF1268-D1X-D2I-D6Q-D8D'\n\n");
	printf("    -filter:dopplermeaslist [+-]g[g]#[-#][.#[-#]]-<filtermeas>-[<meas1>-<meas2>[-<meas3>-<meas4>]][,...]\n");
	printf("                                Same as '-filter:doppler', but each entry is separated by commas (',') instead of blank spaces\n");
	printf("                               Sample: '-filter:dopplerlist G0-D1P'\n");
	printf("                                       '-filter:dopplerlist G0-Doppler-1'\n");
	printf("                                       '-filter:dopplerlist G0-D1P,-G1-D1P,+G1-D1C'\n");
	printf("                                       '-filter:dopplerlist GR0-PC12,EJ0-PC15,REC1-10-PC12'\n");
	printf("                                       '-filter:dopplerlist 0-PC15-D1X-D5X,0-LC15-D1X-D5X'\n");
	printf("                                       '-filter:dopplerlist G0-SIF1215,EJ0-SIF1556-doppler,C9-17-SIF1268-D1X-D2I-D6Q-D8D'\n\n");
*/	printf("    -filter:refclkorder  g[g...]  Set the preference list of GNSS constellations (using the constellation character) used as the reference clock [default GERCJIS]\n");
	printf("                             The list can have a maximum of %d constellations (one letter each). If constellations provided are less than\n",MAX_GNSS);
	printf("                             the maximum, it will fill the remaining gaps with the remaining constellation in the same order as the default one.\n");
	printf("                             Note that independently of this option, gLAB always uses its internal timestamp (epoch being processed) in GPS time.\n");
	printf("                               Sample: '-filter:refclkorder EG'\n\n");
	printf("                        The default constellation order to use for reference clock is: GPS, Galileo, GLONASS, BDS, QZSS, IRNSS, GEO\n\n");
	printf("    -filter:refclkonlyorder  g[g...]  Same as '-filter:refclkorder' option, but the only available GNSS constellations to be used for the reference clock will be\n");
	printf("                                          those constellations provided by the user in this parameter\n");
	printf("                                  Sample: '-filter:refclkonlyorder EG'\n\n");
	printf("    -filter:nochangerefclk      If the reference GNSS constellation used (by default the first constellation in parameter '-filter:refclkorder') for the clock is not\n");
	printf("                                  available in a given epoch, skip the epoch instead of changing the reference constellation [default disabled]\n\n"); 
	printf("    -filter:sigmaiono           Use standard deviation data from IONEX or F-PPP file or SBAS if these iono models are used [default on] ('--filter:sigmaiono' to disable it)\n");
	printf("                                  The IONEX or F-PPP file sigma will be added to the computed satellite standard deviation\n\n");
	printf("    -filter:dr:randomwalk       Estimate user coordinates as a random walk. When this option is enabled, units in '-filter:q:dr' option is in m^2/s [default disabled]\n\n");
	printf("    -filter:clk:randomwalk      Estimate receiver clock as a random walk. When this option is enabled, units in '-filter:q:clk' option is in m^2/d [default disabled]\n\n");
	printf("    -filter:iscb:randomwalk     Estimate inter system clock biases as a random walk. When this option is enabled, units in '-filter:q:iscb' option is in m^2/d [default disabled]\n\n");
	printf("    -filter:phi:dr <val>        Specify the Phi value for position unknowns [defaults static: 1 randomwalk: 1 kinematic: 0]\n\n");
	printf("    -filter:phi:clk <val>       Specify the Phi value for clock unknown [defaults static: 0 randomwalk: 1 kinematic: 0]\n\n");
	printf("    -filter:phi:iscb <val>      Specify the Phi value for inter-constellation clock bias unknowns [defaults SPP/SBAS/DGNSS: 0 PPP/randomwalk: 1]\n\n");
	printf("    -filter:phi:trop <val>      Specify the Phi value for troposphere unknown [default 1]\n\n");
	printf("    -filter:phi:amb <val>       Specify the Phi value for ambiguity unknowns [default 1]\n\n");
	printf("    -filter:phi:gloifb <val>    Specify the Phi value for GLONASS IFB (Inter Frequency Bias) unknown [default 1]\n\n");
	printf("    -filter:phi:recwindup <val> Specify the Phi value for receiver wind-up unknown [default 1]\n\n");
	printf("    -filter:q:dr <val>          Specify the Q noise value for position unknowns [defaults static: 0 m^2 randomwalk: 70 m^2/s kinematic: 1e8 m^2]\n\n");
	printf("    -filter:q:clk <val>         Specify the Q noise value for clock unknown in metres squared [default 9e10 m^2 or 9 m^2/d if option '-filter:clk:randomwalk' is set]\n\n");
	printf("    -filter:q:clk:ns <val>      Specify the Q noise value for clock unknown in nanoseconds squared [default 1e12 ns^2 or 100 ns^2/d if option '-filter:clk:randomwalk' is set]\n\n");
	printf("    -filter:q:iscb <val>        Specify the Q noise value for inter-constellation clock bias unknowns in metres squared\n");
	printf("                                    [default 9e10 m^2 or 9 m^2/d if option '-filter:iscb:randomwalk' is set]\n\n");
	printf("    -filter:q:iscb:ns <val>     Specify the Q noise value for inter-constellation clock bias unknowns in nanoseconds squared\n");
	printf("                                    [default 1e12 ns^2 or 100 ns^2/d if option '-filter:iscb:randomwalk' is set]\n\n");
	printf("    -filter:q:trop <val>        Specify the Q noise variation value for troposphere unknown [default 1e-4] (m^2/h)\n\n");
	printf("    -filter:q:amb <val>         Specify the Q noise value for ambiguity unknowns [default 0] (m^2)\n\n");
	printf("    -filter:q:gloifb <val>      Specify the Q noise value for GLONASS IFB (Inter Frequency Bias) unknown [default 0] (m^2)\n\n");
	printf("    -filter:q:recwindup <val>   Specify the Q noise value for receiver wind-up unknown [default 1] (m^2/s)\n\n");
	printf("    -filter:p0:dr <val>         Specify the P0 initial value for position unknowns [default 1e8] (m^2)\n\n");
	printf("    -filter:p0:clk <val>        Specify the P0 initial value for clock unknown in metres squared [default 9e10] (m^2)\n\n");
	printf("    -filter:p0:clk:ns <val>     Specify the P0 initial value for clock unknown in nanoseconds squared [default 1e12] (ns^2)\n\n");
	printf("    -filter:p0:iscb <val>       Specify the P0 initial value for inter-constellation clock bias unknowns in metres squared [default 9e10] (m^2)\n\n");
	printf("    -filter:p0:iscb:ns <val>    Specify the P0 initial value for inter-constellation clock bias unknowns in nanoseconds squared [default 1e12] (ns^2)\n\n");
	printf("    -filter:p0:trop <val>       Specify the P0 initial value for troposphere unknown [default 0.25] (m^2)\n\n");
	printf("    -filter:p0:amb <val>        Specify the P0 initial value for ambiguity unknowns (for prealigned carrier phases) [default 400] (m^2)\n\n");
	printf("    -filter:p0:gloifb <val>     Specify the P0 initial value for GLONASS IFB (Inter Frequency Bias) unknown [default 5] (m^2)\n\n");
	printf("    -filter:p0:recwindup <val>  Specify the P0 initial value for receiver wind-up unknown [default 100] (m^2)\n\n");
	printf("    -filter:backward            Specify that the filter does a backward processing after the forward one is finished. This means that it\n");
	printf("                                 processes the data backwards. The \"turn point\" is defined as the latest point where orbits and clocks\n");
	printf("                                 are available or when the observation RINEX ends (whatever is first) ('--filter:backward' to disable it)\n");
	printf("                                 [default disabled]\n\n");
	printf("    -filter:maxhdop <val>       Set the HDOP threshold which will make gLAB do the following when the threshold is exceeded:\n");
	printf("                                 In SPP/PPP:   Skip the epoch [default disabled]\n");
	printf("                                 In SBAS:	It will try to switch mode or GEO (if allowed), otherwise it will skip the epoch\n");
	printf("                                            [default disabled in SBAS aviation mode, 4.0 in maritime SBAS mode]\n");
	printf("                                 In DGNSS: Switch from DGNSS to SPP [default 30.0]\n\n");
	printf("    -filter:maxpdop <val>       Set the PDOP threshold which will make gLAB do the following when the threshold is exceeded:\n");
	printf("                                 In SPP/PPP:   Skip the epoch [default disabled]\n");
	printf("                                 In SBAS:	It will try to switch mode or GEO (if allowed), otherwise it will skip the epoch\n");
	printf("                                            [default disabled in SBAS aviation mode, 6.0 in maritime SBAS mode]\n");
	printf("                                 In DGNSS: Switch from DGNSS to SPP [default 30.0]\n\n");
	printf("    -filter:hdoporpdop          If HDOP and PDOP thresholds are enabled, set the option to only need to fulfill one the two\n");
	printf("                                 requirements (HDOP or PDOP) instead of both (i.e. HDOP and PDOP conditions are ORed -logical OR-)\n");
	printf("                                 [default disabled in all modes except in maritime SBAS mode]\n\n");
	printf("    -filter:maxgdop <val>       Set the GDOP threshold which will make gLAB do the following when the threshold is exceeded:\n");
	printf("                                  In SPP:   Skip the epoch [default disabled]\n");
	printf("                                 In PPP:   Skip the epoch [default 30.0]\n");
	printf("                                 In SBAS:	It will try to switch mode or GEO (if allowed), otherwise it will skip the epoch [default disabled]\n");
	printf("                                 In DGNSS: Switch from DGNSS to SPP [default 30.0]\n");
	printf("                                 Use '--filter:maxgdop' to disable it\n\n");
	printf("    -filter:stfdesa             Compute values for Stanford-ESA plot (only for SPP, SBAS and DGNSS) [default disabled]\n");
	printf("                                 The output data is written in a separate file (which has to be processed with graph.py). See parameter '-output:stfdesa'\n\n");
	printf("    -filter:stfdesaloi          If Stanford-ESA computation is enabled, write to file all geometries which produce an integrity ratio equal or higher\n");
	printf("                                 than the horizontal or vertical thresholds (any of them). See parameter '-output:stfdesaloi' [default enabled]\n\n");
	printf("    -filter:stfdesa:xmax <val>  Set the maximum value for the horizontal axis (error axis, in metres) for Stanford-ESA plot [default 50]\n\n");
	printf("    -filter:stfdesa:ymax <val>  Set the maximum value for the vertical axis (protection level axis, in metres) for Stanford-ESA plot [default 50]\n\n");
	printf("    -filter:stfdesa:xres <val>  Set the horizontal resolution (error axis, in metres) for Stanford-ESA plot [default 0.1]\n\n");
	printf("    -filter:stfdesa:yres <val>  Set the vertical resolution (protection level axis, in metres) for Stanford-ESA plot [default 0.1]\n\n");
	printf("    -filter:stfdesa:hwir <val>  Set the horizontal integrity ratio threshold for which the geometry info will be written to file [default 0.7]\n");
	printf("                                  See parameters '-filter:stfdesaloi' and '-output:stfdesaloi' for more details.\n\n");  
	printf("    -filter:stfdesa:vwir <val>  Set the vertical integrity ratio threshold for which the geometry info will be written to file [default 0.7]\n");
	printf("                                  See parameters '-filter:stfdesaloi' and '-output:stfdesaloi' for more details.\n");  
	printf("    -filter:stfdesa:maxsat <val> Set the maximum number of satellites to be used during the Stanford-ESA combination [default 999999]\n");
	printf("                                  This parameter allows to skip computation of combinations with many satellites, which will not have\n");
	printf("                                  problems if all their subsets behave correctly. This filter may be necessary if too many satellites\n");
	printf("                                  are in view, as the number of combinations will increase exponentially. Minimum value for parameter is 4.\n");
	printf("\n  OUTPUT OPTIONS\n\n");
	printf("    -output:file <file>     Sets the output file [default stdout]\n\n");
	printf("    --output:file           Sets the output to stdout [default]\n\n");
	printf("    -output:kml  <file>     Generate a KML file to be opened with Google Earth [default off]\n\n");
	printf("    -output:kml0 <file>     Generate a KML file with all height set to 0 (ground projection) to be opened with Google Earth [default off]\n\n");
	printf("    -output:kml:egm96geoid  Add geoid height from EGM96 model (used by Google Earth). Use '--output:kml:egm96geoid' to disable it. [default on]\n\n");
	printf("    -output:kml:refsta      Add reference stations in KML file (in DGNSS mode only). Use '--output:kml:refsta' to disable it. [default on]\n\n");
	printf("    -output:kml:tstamp      Add time stamp in KML file (in GPS time) [default off]\n\n");
    printf("    -output:kml:tstampdec   Decimation (in seconds) for time stamps in KML files [default 30]\n\n");
    printf("    -output:kml:tstamprange <val1> <val2>  Set a time range for time stamps. Only during this time range KML timestamps will be written [default off]\n");
	printf("                              <val1>  Start epoch (in seconds of day of GPS time). If \"-\" is given, it will be interpreted as the beginning of the file.\n");
	printf("                              <val2>  Start epoch (in seconds of day of GPS time). If \"-\" is given, it will be interpreted as the end of the file.\n");
	printf("                                 If the observation file spans for more than one day, add an offset of 86400 seconds to the start or end epoch.\n");
	printf("                                 To set multiple ranges, set this parameter as many times as the number of ranges needed (one for each range).\n");
	printf("                                 This parameter is combinable with '-output:kml:tstampdec' option\n\n");
	printf("    -output:sp3  <file>     Generate a SP3 file with the computed coordinates [default off]\n\n");
	printf("    -output:sp3:letter <val> Constellation letter to be written in the SP3 [default 'L']\n\n");
	printf("    -output:sp3:prn  <val>  PRN number to be written in the SP3 [default '9']\n\n");
	printf("    -output:sp3:dgnssonly    In DGNSS mode, do not write SPP solutions in the output SP3 file [default on]\n\n");
	printf("    --output:sp3:dgnssonly   In DGNSS mode, write SPP solutions in the output SP3 file [default off]\n\n");
	printf("    -output:refpos  <file>  Generate a columnar text file with the computed coordinates [default off]\n\n");
	printf("    -output:refpos:doy      Write timestamp (in GPS time) as 'Year DoY SoD' in the output reference position text file [default on]\n\n");
	printf("    -output:refpos:gpsweek  Write timestamp (in GPS time)as 'GPSWeek SoW' in the output reference position text file [default off]\n\n");
	printf("    -output:refpos:caltime  Write timestamp (in GPS time) as 'Year/Month/Day HH:MM:SS.zzz' in the output reference position text file [default off]\n\n");
	printf("    -output:refpos:geodetic Write solution in WGS84 geodetic coordinates (Lon, Lat, Height), instead of WGS84 cartesian coordinates (X, Y, Z) [default off]\n");
	printf("                              The output coordinates of the reference do not include the EGM96 geoid height model.\n\n");
	printf("    -output:refpos:dgnssonly  In DGNSS mode, do not write SPP solutions in the output reference position text file [default on]\n\n");
	printf("    --output:refpos:dgnssonly In DGNSS mode, write SPP solutions in the output reference position text file [default off]\n\n");
	printf("    -output:rinex <file>    Sets the RINEX observation output file name. In conversion mode, if this option is not specified, the default output filename\n");
	printf("                              will be <ssssddd0.YYo>, where 'ssss' are the first 4 characters of the filename, 'ddd' is the day of year with three digits\n");
	printf("                              and 'YY' is the last two digits of the year (from the RTCM file)\n");
	printf("                              In Add user error to RINEX mode, if this option is not specified, the default output filename will be <obsfilename>_usererror>\n\n");
	printf("    -output:rinexversion <val>      <val> = 2  Generates a RINEX v2.11 from the binary file RTCM v3.x\n");
	printf("                                    <val> = 3  Generates a RINEX v3.00 from the binary file RTCM v3.x [default]\n\n");
	printf("    -output:corrections <file>    Sets the ASCII Plain Text output file name for the corrections when converting RTCM v2 files\n\n");
	printf("    -output:antenna <file>        Sets the ASCII Plain Text output file name for the antenna information when converting RTCM v2 files\n\n");
	printf("    -output:satvel <val>    <val> = inertial  Prints the inertial velocity in the messages where satellite velocity is given\n");
	printf("                            <val> = ITRF (ECEF)  Prints the ECEF velocity in the messages where satellite velocity is given [default]\n\n");
	printf("    -output:rinexb          Generate a RINEX-B file from the SBAS data (only for SBAS) [default off]\n\n");
	printf("    -output:ems             Generate a EMS file from the SBAS data (only for SBAS) [default off]\n\n");
	printf("    -output:pegasus         Generate Pegasus file format from the SBAS data (only for SBAS 1F). See notes on Pegasus format below. [default off]\n\n");
	printf("    -output:pegstrictrinex  When generating a RINEX-H file for Pegasus, follow the RINEX 2.11 rules for transmission time,\n");
	printf("                            health flag and URA (only active if -output:pegasus has been set) [default off]\n\n");
	printf("    -output:pegspace        Set the field separator in Pegasus files to space character (' ') instead of a semicolon (';') [default off]\n\n");
	printf("    -output:pegfilealign    Print Pegasus files with all columns aligned [default off]\n\n");
	printf("    -output:sbasdir <name>  Set the directory where to write the output SBAS files ('.' for current directory) [default \"SBAS\"]\n\n");
	printf("    -output:stfdesa <file>  Set the filename where to write the output data for Stanford-ESA plots [default \"observationfilename_stdESA.txt\"]\n");
	printf("                            The output file is a columnar text file to be processed with graph program (with '--sf' parameter) for generating the Stanford-ESA plots\n");
	printf("                            The first line of the output file contains, in this order the resolution in X axis (error), resolution in Y axis (protection level),\n");
	printf("                              maximum value in X axis and maximum value in Y axis. All the values are in metres.\n");
	printf("                            From the second line until then end, each line contains, in this order, the X coordinate, Y coordinate (both in metres), the number of\n");
	printf("                              points in the horizontal component in that coordinate and the number of points in the vertical component in that coordinate.\n");
	printf("                            See an example of the generated figures with graph program in the SBAS manual (file gLAB_SBAS_SUM.pdf)\n");
	printf("                            Setting this option enables Stanford-ESA computation.\n\n");
	printf("    -output:stfdesaloi <file> Set the filename where to write the geometries of Stanford-ESA whose integrity ratio are over the horizontal or vertical\n");
	printf("                                integrity ratio (any of them). [default \"observationfilename_stdESA_LOI.txt\"]\n");
	printf("                                This option sets enables the following parameter automatically: '-filter:stfdesaloi'.\n\n");
	printf("    -onlyconvert            Convert EMS or RINEX-B file to RINEX-B, EMS or Pegasus and exit without processing any GNSS data [default off]\n\n");
	printf("    Incorrect messages from RINEX-B or EMS files are messages which grant any of these conditions:\n");
	printf("      CRC mismatch, invalid header, unknown message type, invalid time of applicability (time is over 86400 seconds)\n\n");
	printf("    In case of not setting '-output:rinex', '-output:corrections' and/or '-output:antenna' gLAB will set automatically a name for the output file[s].\n");
	printf("      These previous options are effective only if an RTCM file is converted. Therefore, there will be no RTCM converted files if the input RTCM file is processed\n\n");
	printf("    NOTE: A KML with a 1 second rate data and 1 second timestamp rate may be too big for Google Earth\n");
	printf("\n  VERBOSE OPTIONS   (use -print:... to activate, --print:... to deactivate)\n\n");
	printf("    -print:info             Print INFO messages [default on]\n\n");
	printf("    -print:cycleslips       Print CS messages [default off]\n\n");
	printf("    -print:cs               Equivalent to parameter '-print:cycleslips'\n\n");
	printf("    -print:sfcsdata         Print SFCSDATA messages [default off]\n\n");
	printf("    -print:mwcsdata         Print MWCSDATA messages [default off]\n\n");
	printf("    -print:licsdata         Print LICSDATA messages [default off]\n\n");
	printf("    -print:igfcsdata        Print IGFCSDATA messages [default off]\n\n");
	printf("    -print:allcsdata        Print SFCSDATA, MWCSDATA and LICSDATA messages [default off]\n\n");
	printf("    -print:input            Print INPUT messages. INPUT messages are deprecated [default off]\n\n");
	printf("    -print:meas             Print MEAS messages. By default prints all measurements except Doppler and LLI flags [default off]\n\n");
	printf("    -print:meas:snr         Print SNR measurement in MEAS messages [default on]\n\n");
	printf("    -print:meas:doppler     Print Doppler measurement in MEAS messages [default off]\n\n");
	printf("    -print:meas:lli         Print LLI flag in MEAS messages [default off]\n\n");
	printf("    -print:meas:select   [+-]g[g]#[-#][.#[-#]]-<meas1>[-<meas2>...] [[+-]g[g]#[-#][.#[-#]]-<meas1>[-<meas2>...] ...]\n");
	printf("                          Select the measurements to print in MEAS message by constellation and satellite.\n");
	printf("                          Each entry must be separated by a blank space (' ').\n");
	printf("                          This options overrides any other 'print:meas:' option or default. If any satellite\n");
	printf("                           is not set by these option, it will use the default values or the ones set with 'print:meas:' options.\n");
	printf("                          Measurements to be printed can be pseudoranges, carrier phases, SNR, Doppler and LLI flags.\n");
	printf("                          Repeated measurements for one satellite will be silently skipped.\n");
	printf("                          For SNR, it is available as a measurement, it will use this value. Otherwise, if SNR\n");
	printf("                            is only available as a flag, it will print the SNR from the flag (converted to decimal).\n");
	printf("                          To print LLI flag, use the name 'LLI' plus the frequency and attribute of the measurement.\n");
	printf("                            [+-]   Optional symbols for selecting (with a plus '+') or unselecting (with a minus '-')\n");
	printf("                                    If no symbol is provided, the default behaviour is to select measurements\n");
	printf("                            g        = Character determining GNSS constellation (G->GPS). If g=0, apply it to all constellations\n");
	printf("                            [g]      = More than one character for GNSS constellation may be provided, so multiple GNSS can be selected at once\n");
	printf("                            #        = PRN number. If #=0, then the detector will be applied to all satellites of the selected GNSS constellation\n");
	printf("                            [-#]     = Optionally, a minus sign ('-') and a second PRN number can be provided in order to set a range\n"); 
	printf("                                          of satellites (of the same constellation)\n");
	printf("                            [.#[-#]]    = Optionally, more than one satellite PRN or satellite range can be given, by separating each value\n");
	printf("                                            with a dot ('.')\n");
	printf("                            <meas1>   Set the measurement(s) to print in MEAS message\n");
	printf("                          Example:\n");
	printf("                             -print:meas:select G0-C1C-L1C-LLI1C-D1C-S1C\n");
	printf("                             -print:meas:select G10-32-C1C-L1C-C2L-S2L E0-C1C-C5C\n\n");
	printf("    -print:meas:selectlist   g[g]#[-#][.#[-#]]-<meas1>[-<meas2>...][,g[g]#[-#][.#[-#]]-<meas1>[-<meas2>...],...]\n");
	printf("                          Same as '-print:meas:select' but separated by commas instead of spaces\n");
	printf("                             -print:meas:selectlist G0-C1C-L1C-LLI1C-D1C-S1C\n");
	printf("                             -print:meas:selectlist G10-32-C1C-L1C-C2L-S2L,E0-C1C-C5C\n\n");
	printf("    -print:model            Print MODEL messages [default off]\n\n");
	printf("    -print:sat              Print EPOCHSAT messages [default off]\n\n");
	printf("    -print:epochsat         Equivalent to parameter '-print:sat'\n\n");
	printf("    -print:sateliites       Equivalent to parameter '-print:sat'\n\n");
	printf("    -print:prefit           Print PREFIT messages [default off]\n\n");
	printf("    -print:prefit:unsel     Print unselected measurements in PREFIT messages [default off]\n\n");
	printf("    -print:postfit          Print POSTFIT messages [default off]\n\n");
	printf("    -print:filter           Print FILTER messages [default off]\n\n");
	printf("    -print:output           Print OUTPUT messages [default on]\n\n");
	printf("    -print:satdiff          Print SATDIFF messages in comparison mode (see below) [default on]\n\n");
	printf("    -print:satstat          Print SATSTAT messages in comparison mode (see below) [default on]\n\n");
	printf("    -print:satstattot       Print SATSTATTOT messages in comparison mode (see below) [default on]\n\n");
	printf("    -print:satpvt           Print SATPVT messages in show product mode (see below) [default on]\n\n");
	printf("    -print:satsel           Print satellite selection information [default off]\n\n");
	printf("    -print:sbascor          Print SBASCORR messages (only for SBAS 1F) [default off]\n\n");
	printf("    -print:sbascorr         Equivalent to parameter '-print:sbascor'\n\n");
	printf("    -print:sbasvar          Print SBASVAR messages (only for SBAS 1F) [default off]\n\n");
	printf("    -print:sbasiono         Print SBASIONO messages (only for SBAS 1F) [default off]\n\n");
	printf("    -print:sbasunsel        Print SBASUNSEL messages (only for SBAS 1F) [default off]\n\n");
	printf("    -print:sbasdfmccor      Print SBASDFMCCORR messages (only for SBAS DFMC) [default off]\n\n");
	printf("    -print:sbasdfmccorr     Equivalent to parameter '-print:sbasdfmccor'\n\n");
	printf("    -print:sbasdfmcvar      Print SBASDFMCVAR messages (only for SBAS DFMC) [default off]\n\n");
	printf("    -print:sbasdfmcunsel    Print SBASDFMCUNSEL messages (only for SBAS DFMC) [default off]\n\n");
	printf("    -print:sbasunused       Print messages from discarded satellites due to SBAS GEO switch (only for SBAS 1F and DFMC) [default off]\n");
	printf("                                  The discarded messages are MODEL, SBASCORR, SBASVAR, SBASIONO and SBASUNSEL, but only the ones\n");
	printf("                                  selected from user parameters will be printed. Also, an asterisk '*' will be added at the end\n");
	printf("                                  of the first field to indicate that it is a discarded measurement\n\n");
	printf("    -print:sbasout          Print SBASOUT messages (only for SBAS 1F and DFMC) [default on]\n\n");
	printf("    -print:usererror        Print user added error to raw measurements [default on]\n\n");
	printf("    -print:dgnss            Print DGNSS global information (only for DGNSS) [default on]\n\n");
	printf("    -print:dgnssunused      Print messages from discarded satellites due to DOP switch (from DGNSS to SPP) [default off]\n");
	printf("                                  An asterisk '*' will be added at the end of the first field to indicate that it is a discarded measurement\n\n");
	printf("    -print:summary          Print a summary at the end of the files with the statistics of the processing [default on]\n\n");
	printf("    -print:sumonly          Print only summary (disables all other output prints)\n\n");
	printf("    -print:progress         Print to terminal the current epoch being processed [default on]\n\n");
	printf("    -print:progressalways   Print to terminal the current epoch being processed even if standard output is piped [default off]\n\n");
	printf("    -print:pa               Same as '-print:progressalways', but with a shorter name [default off]\n\n");
	printf("    -print:all              Print all messages\n\n");
	printf("    -print:none             Do not print anything, except the progress bar ('--print:none' is also accepted)\n");
	printf("                            More information on print messages can be seen with the '-messages' option\n\n");
	printf("    -print:v5format         Print all output messages in the format of gLAB versions lower than 6.0.0 (before multiconstellation)\n");
	printf("                             The INFO messages (except for the summary) are not affected by this option\n\n");
	printf("    -print:clkns            Print the receiver clock offset (in FILTER and OUTPUT messages) and the inter-system clock biases (in MODEL and\n");
	printf("                             FILTER messages) in nanoseconds instead of metres [default off]\n");
	printf("\n  SUMMARY OPTIONS\n\n");
	printf("      When processing in SPP/PPP/SBAS/DGNSS modes, if summary is enabled a statistical summary will be printed\n");
	printf("        at the end of the output file. If receiver position is not fixed, error percentiles messages will not be shown\n");
	printf("        The options for generating this summary are:\n\n");
	printf("    -summary:percentile  <val>  Sets the value for computing the error percentile [default 95]\n\n"); 
	printf("    -summary:waitfordaystart    If the observation file starts at %d hours or later, gLAB will assume that from the first epoch\n",HOURSPREVDAYCONVERGENCE);
	printf("                                     until epoch 23 hours 59 minutes 59 seconds are given just to fill the messages buffer and wait for\n");
	printf("                                     the smoothing and filter to converge, and the following epochs from the next day are the ones of interest.\n");
	printf("                                     During this convergence period, Stanford-ESA values will not be computed and they will not be taken into\n");
	printf("                                     account for the summary. This option is useful to avoid high error epoch in the summary\n");
	printf("                                     during the convergence time. [default on]\n");
	printf("                                    This option can be disabled with '--summary:waitfordaystart'\n");
	printf("                                    This option will have no effect if '-summary:starttime' is set\n\n");
	printf("    -summary:starttime <date>  Set the first epoch (in GPS time) to be used in the summary. See parameter '-pre:starttime' for details on date format\n\n");
	printf("    -summary:stationnetworkname <name> Sets the station network name to be printed in the last line of summary. This is useful for doing\n");
	printf("                                         stations maps with each station network having different marker type, colour or size\n");
   	printf("                                         with the graphical tool (after merging the last line of the summary of several processed\n");
	printf("                                         stations in a single file) [default 'Other']\n\n");
	printf("      NOTE: The last line of the summary contains all the values of the previous lines along with the station coordinates.\n");
	printf("            	This line is useful for plotting world maps with data from each station.\n\n");
	printf("      NOTE: An example of a summary can be seen executing gLAB with '-messages' parameter\n");
	printf("\n   ADDITIONAL SUMMARY OPTIONS FOR PPP\n");
	printf("      In PPP mode, there are additional options for the summary:\n\n");
	printf("    -summary:formalerrorhor <val>  Sets the threshold (in metres) for the horizontal formal error to consider the filter converged [default 0.2]\n\n");
	printf("    -summary:formalerrorver <val>  Sets the threshold (in metres) for the vertical formal error to consider the filter converged [default 0.4]\n\n");
	printf("    -summary:formalerror3d  <val>  Sets the threshold (in metres) for the 3D formal error to consider the filter converged [default 0.4]\n\n");
	printf("    -summary:poserrorhor    <val>  Sets the threshold (in metres) for the horizontal positioning error to consider the solution converged [default 0.2]\n\n");
	printf("    -summary:poserrorver    <val>  Sets the threshold (in metres) for the vertical positioning error to consider the solution converged [default 0.4]\n\n");
	printf("    -summary:poserror3d     <val>  Sets the threshold (in metres) for the 3D positioning error to consider the solution converged [default 0.4]\n\n");
	printf("    -summary:errorhor       <val>  Sets the threshold (in metres) for the horizontal for both formal and positioning error to consider the solution converged.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:formalerrorhor' and '-summary:poserrorhor' parameters\n\n");
	printf("    -summary:errorver       <val>  Sets the threshold (in metres) for the vertical for both formal and positioning error to consider the solution converged.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:formalerrorver' and '-summary:poserrorver' parameters\n\n");
	printf("    -summary:error3d        <val>  Sets the threshold (in metres) for the 3D for both formal and positioning error to consider the solution converged.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:formalerror3d' and '-summary:poserror3d' parameters\n\n");
	printf("    -summary:errorhv3d      <val>  Sets the threshold (in metres) for all the components for both formal and positioning error to consider the solution converged.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:errorhor', '-summary:errorver' and '-summary:error3d' parameters\n\n");
	printf("    -summary:formalerrorperiodhor  <val>  Sets the continuous time period (in seconds) for the horizontal formal error to be under the threshold [default 300]\n\n");
	printf("    -summary:formalerrorperiodver  <val>  Sets the continuous time period (in seconds) for the vertical formal error to be under the threshold [default 300]\n\n");
	printf("    -summary:formalerrorperiod3d   <val>  Sets the continuous time period (in seconds) for the 3D formal error to be under the threshold [default 300]\n\n");
	printf("    -summary:poserrorperiodhor     <val>  Sets the continuous time period (in seconds) for the horizontal positioning error to be under the threshold [default 300]\n\n");
	printf("    -summary:poserrorperiodver     <val>  Sets the continuous time period (in seconds) for the vertical positioning error to be under the threshold [default 300]\n\n");
	printf("    -summary:poserrorperiod3d      <val>  Sets the continuous time period (in seconds) for the 3D positioning error to be under the threshold [default 300]\n\n");
	printf("    -summary:errorperiodhor        <val>  Sets the continuous time period (in seconds) for horizontal for both the formal and positioning error to be under the threshold.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:formalerrorperiodhor' and '-summary:poserrorperiodhor' parameters\n\n");
	printf("    -summary:errorperiodver        <val>  Sets the continuous time period (in seconds) for vertical for both the formal and positioning error to be under the threshold.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:formalerrorperiodver' and '-summary:poserrorperiodver' parameters\n\n");
	printf("    -summary:errorperiod3d         <val>  Sets the continuous time period (in seconds) for 3D for both the formal and positioning error to be under the threshold.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:formalerrorperiod3d' and '-summary:poserrorperiod3d' parameters\n\n");
	printf("    -summary:errorperiodhv3d       <val>  Sets the continuous time period (in seconds) for all the components for both the formal and positioning error to be under the threshold.\n");
	printf("                                     This parameter is a shortcut for providing '-summary:errorperiodhor', '-summary:errorperiodver' and '-summary:errorperiod3d' parameters\n");
	printf("\n   ADDITIONAL SUMMARY OPTIONS FOR SBAS\n");
	printf("      In SBAS mode, there are additional options for the summary:\n\n");
	printf("    -summary:hal           <val>  Sets the Horizontal Alarm Limit (in metres) for computing availability and continuity risk [default 40]\n\n");
	printf("    -summary:val           <val>  Sets the Vertical Alarm Limit (in metres) for computing availability and continuity risk [default 50]\n\n");
	printf("    -summary:windowsize    <val>  Sets the sliding window size (in epochs) for computing the continuity risk [default 15 for aviation, 900 for maritime]\n\n");
	printf("    -summary:windowsizemar <val>  Sets the fixed window size (in epochs) for computing the continuity risk for maritime\n");
	printf("                                    [default 15 for aviation, 900 for maritime]\n\n");
	printf("      NOTE: The computation of the continuity risk takes into account the sampling rate and data gaps in the observation file.\n");
	printf("\n  SBAS PLOTS OPTIONS\n\n");
	printf("      This mode is activated when only a navigation file and a SBAS file are given (see description below in WORK MODES).\n"); 
	printf("      The following options are specific for this mode:\n\n");
	printf("    -sbasplots:minlat    <val> Sets the minimum latitude (in degrees) for the SBAS plots. The minimum resolution is 0.01 [default 25.0]\n\n");
	printf("    -sbasplots:maxlat    <val> Sets the maximum latitude (in degrees) for the SBAS plots. The minimum resolution is 0.01 [default 70.0]\n\n");
	printf("    -sbasplots:minlon    <val> Sets the minimum longitude (in degrees) for the SBAS plots. The minimum resolution is 0.01 [default -30.0]\n\n");
	printf("    -sbasplots:maxlon    <val> Sets the maximum longitude (in degrees) for the SBAS plots. The minimum resolution is 0.01 [default 40.0]\n\n");
	printf("    -sbasplots:plotarea  <minlon> <maxlon> <minlat> <maxlat>\n");
	printf("                               This parameter is a shorter way to provide the same values as in '-sbasplots:minlon' '-sbasplots:maxlon',\n"); 
	printf("                                 '-sbasplots:minlat' and '-sbasplots:maxlat' parameters.\n\n");
	printf("    -sbasplots:recheight <val> Sets the receiver height (in metres) [default 0 (over the WGS84 geoid)]\n\n");
	printf("    -sbasplots:hal       <val> Sets the Horizontal Alarm Limit (in metres) for computing the Availability plots [default 40]\n\n");    
	printf("    -sbasplots:val       <val> Sets the Vertical   Alarm Limit (in metres) for computing the Availability plots [default 50]\n\n");    
	printf("    -sbasplots:availstep <val> Sets the resolution (in degrees) for both longitude and latitude for Availability\n");
	printf("                                 and Continuity Risk maps. The minimum resolution is 0.01 [default 1.0]\n\n");
	printf("    -sbasplots:availtimestep <val>  Sets the time step (in seconds) for availability plot [default 1]\n\n");
	printf("    -sbasplots:ionostep  <val> Sets the resolution (in degrees) for both longitude and latitude for Ionosphere\n");
	printf("                                 Corrections Availability map. The minimum resolution is 0.01 [default 0.3]\n\n");
	printf("    -sbasplots:ionotimestep  <val>  Sets the time step (in seconds) for ionosphere availability plot [default 300]\n\n");
	printf("    -sbasplots:windowsize    <val>  Sets the sliding window size (in seconds) for computing the continuity risk [default 15 for aviation, 900 for maritime]\n\n");
	printf("    -sbasplots:windowsizemar <val>  Sets the sliding window size (in seconds) for computing the continuity risk with maritime rules\n");
	printf("                                       [default 15 for aviation, 900 for maritime]\n\n");
	printf("    -output:sbasavailplots   <file> Sets the output file for the SBAS Availability plots data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASAvailPlots_sbasfilename.txt\"]\n\n");
	printf("    -output:sbasriskplots    <file> Sets the output file for the SBAS Continuity Risk plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASRiskPlots_sbasfilename.txt\"]\n\n");
	printf("    -output:sbasriskmarplots <file> Sets the output file for the SBAS Continuity Risk (maritime mode) plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASRiskMarPlots_sbasfilename.txt\"]\n\n");
	printf("    -output:sbasionoplots    <file> Sets the output file for the SBAS Ionosphere availability plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASIonoPlots_sbasfilename.txt\"]\n\n"); 
	printf("    -output:sbasriskdisc     <file> Sets the output file for the list of SBAS solution discontinuities found during the computation of SBAS Continuity Risk plot.\n");
	printf("                                 The output file is a columnar text file [default \"SBASRiskDisc_sbasfilename.txt\"]\n\n"); 
	printf("    -output:sbashdopplots    <file> Sets the output file for the SBAS HDOP plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASHDOPPlots_sbasfilename.txt\"]\n\n"); 
	printf("    -output:sbaspdopplots    <file> Sets the output file for the SBAS PDOP plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASPDOPPlots_sbasfilename.txt\"]\n\n"); 
	printf("    -output:sbasgdopplots    <file> Sets the output file for the SBAS GDOP plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASGDOPPlots_sbasfilename.txt\"]\n\n"); 
	printf("    -output:sbascombdopplots <file> Sets the output file for the combined SBAS HDOP, PDOP and GDOP plot data. The output file is a\n");
	printf("                                 columnar text file to be processed by graph program (with '--sbas' parameter) [default \"SBASCombDOPPlots_sbasfilename.txt\"]\n\n"); 
	printf("    -sbasplots:hourlymaps      Print the hourly availability maps. The files will have the same name as the daily maps, but with '_HHh' added\n");
	printf("                                 before the file extension (being HH the hour with two digits)\n\n");
	printf("    -sbasplots:noavailplot     Do not compute the SBAS Availability and Continuity Risk plots [default off]\n\n");
	printf("    -sbasplots:noriskplot      Do not compute the SBAS Continuity Risk plot [default off]\n\n");
	printf("    -sbasplots:noriskmarplot   Do not compute the SBAS Continuity Risk for maritime plot [default off]\n\n");
	printf("    -sbasplots:noionoplot      Do not compute the SBAS Ionosphere corrections availability plot [default off]\n\n");
	printf("    -sbasplots:noionomodel     Do not use SBAS ionosphere during the computation of Availability and Continuity Risk plot [default off]\n");
	printf("                                 This parameter is equivalent to '-model:iono no'\n\n");
	printf("    -sbasplots:hdopplot        Compute SBAS HDOP plots. This option is automatically set if '-output:sbashdopplots' is set. [default off]\n");
	printf("                                 In order to do HDOP plots, SBAS Availability plots must be enabled.\n\n");
	printf("    -sbasplots:pdopplot        Compute SBAS PDOP plots. This option is automatically set if '-output:sbaspdopplots' is set. [default off]\n");
	printf("                                 In order to do PDOP plots, SBAS Availability plots must be enabled.\n\n");
	printf("    -sbasplots:gdopplot        Compute SBAS GDOP plots. This option is automatically set if '-output:sbasgdopplots' is set. [default off]\n");
	printf("                                 In order to do GDOP plots, SBAS Availability plots must be enabled.\n\n");
	printf("    -sbasplots:combdopplot     Compute combined SBAS DOP file with HDOP, PDOP and GDOP plots. This option is automatically set if\n");
	printf("                                 '-output:sbascombdopplots' is set. [default off]\n\n");
	printf("    -sbasplots:doppercentile   Enable computation of DOP percentile for DOP maps. Warning: Each DOP map requires around 1GB of memory\n");
	printf("                                 (with the default map size) [default off]\n\n");
	printf("    -sbasplots:percentile    <val>  Sets the value for computing the percentile in DOP maps [default 95]\n"); 
	printf("                                     In order to do combined HDOP, PDOP and GDOP plots, SBAS Availability plots must be enabled.\n\n");
	printf("    -sbasplots:exclusionarea <minlon> <maxlon> <minlat> <maxlat> [<minlon> <maxlon> <minlat> <maxlat> ...]\n");
	printf("                               Set a square area where SBAS availability and SBAS iono availability will be set to 0 (the area is skipped during computation)\n"); 
	printf("                                 This is useful when processing large areas (e.g. areas with multiple SBAS and want to exclude the sea between them)\n");
	printf("                                 The user can set any number of exclusion area by providing this parameter as many times as necessary\n");
	printf("                                 The area must be given with these four values (in this order): minimum longitude, maximum longitude,\n");
	printf("                                 minimum latitude, maximum latitude. The four values must be in degrees, with the longitude between -180\n");
	printf("                                 and 180 degrees, and the latitude between -90 and 90 degrees\n\n");
	printf("    -sbasplots:inclusionarea <minlon> <maxlon> <minlat> <maxlat> [<minlon> <maxlon> <minlat> <maxlat> ...]\n");
	printf("                               Set a square area where SBAS availability and SBAS iono availability will be computed (the rest is skipped). This area must be\n"); 
	printf("                                 inside the region defined by parameters '-sbasplots:minlon', '-sbasplots:maxlon', '-sbasplots:minlat' and '-sbasplots:maxlat'.\n");
	printf("                                 The user can set any number of inclusion area by providing this parameter as many times as necessary\n");
	printf("                                 The area must be given with these four values (in this order): minimum longitude, maximum longitude,\n");
	printf("                                 minimum latitude, maximum latitude. The four values must be in degrees, with the longitude between -180\n");
	printf("                                 and 180 degrees, and the latitude between -90 and 90 degrees\n\n");
	printf("    -sbasplots:mingeoelev    <val>  Set the elevation mask (in degrees) for the GEO providing the corrections [default 5]\n");
	printf("                                     The elevation angle for GEO ensures that GEO corrections are only used where the GEO is visible (GEO footprint)\n");
	printf("                                     Use '--sbasplots:mingeoelev' to disable it.\n\n"); 
	printf("    -sbasplots:usegeosat     Use GEO SBAS satellites for ranging when computing Availability maps [default off]\n\n");
	printf("   If both inclusion and exclusion areas are provided, then an area which is processed must be inside of any inclusion area and outside of any exclusion area.\n");
	printf("   The default region defined in gLAB corresponds to EGNOS coverage area.\n");
	printf("   The available output messages in this mode are INFO [default on], SBASIONO [default off] and SBASUNSEL [default off]\n");
	printf("   Most of the options applied for normal SBAS processing can also be applied for this mode, except for those which apply to measurement corrections (due to\n");
	printf("     there are none in this mode) and the option to use Klobuchar while solution converges ('-model:initcoordNPA') as we consider we are always in strict PA mode.\n\n");
	printf("   An example of the generated figures with graph program is in the SBAS manual (file gLAB_SBAS_SUM.pdf)\n");
	printf("\n  DATE CONVERSION OPTIONS\n\n");
	printf("      This mode is for converting a date format (in GPS time) to all other GNSS date formats and exit.\n");
	printf("      The accepted date formats are: YYYY/MM/DD HH:MM:SS.zzz ('zzz' are milliseconds), Year/DoY/SoD, GPSWeek/SoW, MJDN/SoD (MJDN is Modified Julian Day Number)\n");
	printf("      Minimum accepted date is 1980/01/06 (YYYY/MM/DD) or 1980/006 (Year/DoY) or 0/0 (GPSWeek/SoW) or 44244/0 (MJDN/SoD)\n");
	printf("      This mode is activated when any of the following parameter is provided:\n\n");
	printf("    -dateconv:calendar <year> <month_number> <day> <hour> <minute> <seconds>\n");
	printf("               <year> has to be equal or greater than 1980, <hour> is in 24 hour format and <seconds> can have decimal values.\n\n");
	printf("    -dateconv:doy <year> <DoY> <SoD>\n");
	printf("               <year> has to be equal or greater than 1980, <DoY> is in range 1 to 366.\n\n");
	printf("    -dateconv:gpsweek <GPSWeek> <SoW>\n\n");
	printf("    -dateconv:mjdn <MJDN> <SoD>\n");
	printf("               <MJDN> must be equal or greater than 44244.\n\n");
	printf("\n  COORDINATE CONVERSION OPTIONS\n\n");
	printf("      This mode is for converting a coordinate system to all supported coordinate systems (cartesian, geodetic -or ellipsoidal- and spherical) and exit.\n");
	printf("      This mode is activated when any of the following parameters is provided:\n\n");
	printf("    -coordconv:cartesian <x> <y> <z>\n");
	printf("               X, Y and Z coordinates unit is metres.\n\n");
	printf("    -coordconv:geodetic <lon> <lat> <height>\n");
	printf("               Longitude is in degrees (range [-180..180]), latitude is in degrees (range [-90..90]) and height is in metres.\n\n");
	printf("    -coordconv:spherical <lon> <lat> <radius>\n");
	printf("               Longitude is in degrees (range [-180..180]), latitude is in degrees (range [-90..90]) and radius is in metres.\n\n");
	printf("\n  WORK MODES\n\n");
	printf("    gLAB can work in nine different modes:\n");
	printf("        - Positioning Mode: 'Standard' mode, where all the processing is done, and a solution for a\n");
	printf("                       receiver is provided as OUTPUT messages. The minimum parameters required for this\n");
	printf("                       mode are an input observation file ('-input:obs') and orbit and clock products\n");
	printf("                       ('-input:nav', '-input:sp3' or '-input:orb'/'-input:clk'). Using precise products\n");
	printf("                       will also require the use of an ANTEX file ('-input:ant'). For SBAS processing, an\n");
	printf("                       additional input SBAS file ('-input:sbas1f') is needed. For DGNSS processing, an\n");
	printf("                       additional input file ('-input:dgnss' or '-input:rtcm') is needed\n\n");
	printf("        - Show Input Mode: This mode only reads an input RINEX observation file and print its measurements.\n");
	printf("                       The parameter required for this mode is '-input:obs', and specifically, no orbit and\n");
	printf("                       clock products should be provided (if provided, gLAB will switch to Positioning Mode)\n\n"); 
	printf("        - Product Comparison Mode: This mode reads and compares two different sources of orbit and clock products.\n");
	printf("                       In order to use this mode, '-input:obs' must be avoided, and two different orbit and clock\n");
	printf("                       products should be provided. This mode outputs the SATDIFF, SATSTAT and STASTATTOT messages\n\n");
	printf("        - Show Product Mode: This mode reads a single source of orbit and clock products.\n");
	printf("                       In order to use this mode, '-input:obs' must be avoided, and a single orbit and clock\n");
	printf("                       product should be provided. This mode output SAT messages\n\n"); 
	printf("        - Convert mode: Only for SBAS. If the parameter '-onlyconvert' is given, gLAB will just generate a RINEX-B 2.11 or EMS\n");
	printf("                       or Pegasus files (depending on the parameters) and it will not process any GNSS data.\n");
	printf("                       The minimum parameters for this mode are an SBAS file ('-input:sbas1f'), the '-onlyconvert' parameter\n");
	printf("                       and an output file format ('-output:rinexb', '-output:ems', '-output:pegasus')\n\n");
	printf("        - SBAS Plots Mode: This mode is activated when only a navigation file and a SBAS file are given. In this mode,\n");
	printf("                       three plots are computed: SBAS Availability, SBAS Continuity Risk and SBAS Ionosphere Corrections Availability.\n");
	printf("                       The three plots are computed in PA mode in the delimited (squared) region and resolution during one day (the Availability and\n");
	printf("                       Continuity Risk are computed at a one second rate, while the Ionosphere Corrections Availability is computed at a 300 seconds rate by default).\n");
	printf("                       For the three plots the values are computed for a Fault-Free receiver (no data gaps, no cycle-slips).\n");
	printf("                       For SBAS Availability plots, an epoch at a given latitude and longitude and height (by default is the WGS84 geoid level -0 metres-)\n");
	printf("                         is considered to be available when both the Horizontal and Vertical Protection Levels are below their respective alarm limits.\n");
	printf("                       For SBAS Continuity Risk plot, it is computed the probability of having a discontinuity (i.e. no SBAS PA solution) during the\n");
	printf("                         next 15 seconds (i.e. using a sliding window of 15 seconds) in aviation mode. In maritime processing, it is followed the\n");
	printf("                         IMO (International Maritime Organization) resolution A.1046 (27), which states that there will be only one discontinuity\n");
	printf("                         every 15 minutes, so each discontinuity will affect the previous 15 minutes (even if two consecutive discontinuity events\n");
	printf("                         occur in less than 15 minutes). See notes for SBAS maritime below.\n");
	printf("                       For SBAS Ionosphere Corrections Availability plot, each coordinate in the map is considered as a pierce point at 350 km height,\n");
	printf("                         and it is considered as available when a SBAS ionosphere can be computed at the given pierce point.\n");
	printf("                       The minimum parameters to activate this mode are the input navigation file ('-input:nav') and the input SBAS message file ('-input:sbas1f').\n");
	printf("                       The output files have to be processed with graph program (with '--sbas' parameter) in order to generate the plots.\n");
	printf("                       The available output messages in this mode are INFO [default on], SBASIONO [default off] and SBASUNSEL [default off].\n");
	printf("                       NOTE: With the default configuration, the computation time is around 2 hours. Increasing resolution or map size\n");
	printf("                              will significantly increase computation time.\n\n");
	printf("        - Add User Error to RINEX: This mode reads a RINEX observation file, a user added error file and creates a new RINEX observation file\n");
	printf("                       with the same header, version and number of measurements, but the measurements have the user error added into them.\n");
	printf("                       This mode is enabled by providing only and observation file and a user added error file with the parameters\n");
	printf("                       '-input:obs' and '-input:usererror'\n");
	printf("                       Optionally, a GLONASS navigation file may be provided (with parameter '-input:navglo') for reading frequency offsets.\n\n");
	printf("        - Date Conversion: When '-dateconv:calendar' or '-dateconv:doy' or '-dateconv:gpsweek' or '-dateconv:mjdn' are provided, gLAB will read the date\n");
	printf("                       from user input and convert it to all other date formats, print them in screen and exit.\n\n");  
	printf("        - Coordinate Conversion: When '-coordconv:cartesian' or '-coordconv:geodetic' or '-coordconv:spherical' are provided, gLAB will read the coordinates\n");
	printf("                       from user input and convert it to all other coordinate systems, print them in screen and exit.\n");  
	printf("\n  gLAB PROCESSING DIAGRAM\n\n");
	printf("     Below is provided a diagram of gLAB internal processing workflow (in Positioning Mode), along with important notes in each step:\n\n");
	printf("            +-------------------------+\n");
	printf("            | 1      Read input       |  Measurement priority list (shared by filter and cycle-slip detectors) is updated or replaced according to user input.\n");
	printf("            |        parameters       |  Any repeated cycle-slip or filter measurement provided by the user is silently removed.\n");
	printf("            +-------------------------+\n");
	printf("                         |\n");
	printf("                         |\n");
	printf("                         V\n");
	printf("            +-------------------------+\n");
	printf("            | 2      Read input       |  Basic navigation data validation check is done when reading (e.g. fields not being zero, GPS IODC and IODE matching, etc).\n");
	printf("            |          SP3/CLK        |  If navigation file is concatenated, gLAB reads until a header is found. The following set of data will be read when the\n");
	printf("            |          ANTEX          |    day of the observation file changes. Up to two navigation days of data (two data sets read) are held in memory.\n");
	printf("            |           DCB           |  If SP3 or CLK files are concatenated, up to three days will be read at once (so it has data in memory for the previous,\n");
	printf("            |        Navigation       |    current and next days) in order to avoid orbit interpolation errors at the beginning and at the end of the day.\n");
	printf("            |          files          |    If more data is available, a new day will be read each time the day of the observation file changes.\n");
	printf("            +-------------------------+\n");
	printf("                         |\n");
	printf("       ----------------->|\n");
	printf("       |                 V\n");
	printf("       |    +-------------------------+\n");
	printf("       |    | 3     Read RINEX        |  All single and double frequency DCBs whose navigation message type is not available will be automatically disabled.\n");
	printf("       |    |    observation header   |\n");  
	printf("       |    +-------------------------+\n");
	printf("       |                 |\n");
	printf("       |                 |\n");
	printf("       |                 V\n");
	printf("       |    +-------------------------+\n");
	printf("       |    | 4                       |  Update measurement priority list with the available measurement in the RINEX observation header file.\n");
	printf("       |    |                         |  If an ANTEX was provided, gLAB will look for the satellite block type for each PRN and unselect all measurements not\n");
	printf("       |    |                         |    available in that block type (e.g. GPS BLOCK IIRM do not have L5 frequency).\n");
	printf("       |    |           Set           |  If user did not select measurements in the filter or cycle-slips, thee default measurements (depending on processing mode)\n");
	printf("       |    |                         |    will be set. This check is only done the first time this function is called.\n");
	printf("       |    |          global         |  If user selected measurements for the filter or cycle-slips, unselect all measurements which are not in priority list,\n");
	printf("       |    |                         |     or it is not a defined frequency or it is not available in the RINEX observation header.\n");
	printf("       |    |       configuration     |  By default, gLAB will add to each enabled cycle-slip detectors all frequencies with carrier phase measurements set in\n");
	printf("       |    |                         |    the filter. This check is only done the first time this function is called.\n");
	printf("       |    |                         |  All DCBs used in single and double frequency processing whose navigation message type is not available will be automatically disabled.\n");   
	printf("       |    |                         |  Starting from the second iteration of this function (following a second header in the RINEX observation), unselect all measurements\n");
	printf("       |    |                         |    previously selected which are not available anymore and reselect previous unselected measurements if they become available.\n");
	printf("       |    +-------------------------+\n");
	printf("       |                 |\n");
	printf("  -----+---------------->|\n");
	printf("  |    |                 V\n");
	printf("  |    |    +-------------------------+\n");
	printf("  |    |    | 5        Read           |  Unknown constellations will be converted to GPS (to allow experimental tests).\n");
	printf("  |    |    |       observation       |  PRN values check is done to avoid invalid PRN values (e.g. errors in file) make gLAB crash or behave incorrectly.\n");
	printf("  |    |    |          epoch          |  If an event epoch occurs including a line with 'APPROX POSITION XYZ', the a priori position (if used) will be updated.\n");
	printf("  |    |    +-------------------------+\n");
	printf("  |    |                 |\n");
	printf("  |    |                 |\n");
	printf("  |    |                 V\n");
	printf("  |    |                 ^\n");
	printf("  |    |                / \\\n");
	printf("  |    |               /   \\\n");
	printf("  |    |       YES    /Header\n");
	printf("  |    |_____________/       \\\n");
	printf("  |                  \\       /\n");
	printf("  |                   \\found?\n");
	printf("  |                    \\   /\n");
	printf("  |                     \\ /\n");
	printf("  |                      V\n");
	printf("  |                   NO |\n");
	printf("  |                      |\n");
	printf("  |                      V\n");
	printf("  |                      ^\n");
	printf("  |                     / \\\n");
	printf("  |                    /   \\\n");
	printf("  |              NO  Measurements\n");
	printf("  |     _____________/       \\\n");
	printf("  |    |             \\       /\n");
	printf("  |    |             unselected?\n");
	printf("  |    |               \\   /\n");
	printf("  |    |                \\ /\n");
	printf("  |    |                 V\n");
	printf("  |    |             YES |\n");
	printf("  |    |                 |\n");
	printf("  |    |                 V\n");
	printf("  |    |    +-------------------------+\n");
	printf("  |    |    | 6                       | Selection is done per every satellite, per frequency and per measurement type (code, phase) in both cycle-slip detectors and the filter.\n");
	printf("  |    |    |                         | By default, gLAB will add all filter carrier phase measurements to each enabled cycle-slip detector.\n");
	printf("  |    |    |                         | Internal lists with measurement info ordered according to any function needs (i.e. SNR list, modelling list, etc.)\n");
	printf("  |    |    |                         |   for greatly reducing processing time (as these lists are built once), but in turn, it has high memory consumption\n");
	printf("  |    |    |          Select         |   due to these lists are in a per satellite basis.\n");  
	printf("  |    |    |                         | If DGNSS mode with RINEX file is used, the process is repeated for the RINEX reference observation file.\n");
	printf("  |    |    |                         | The criteria for measurement selection is:\n");
	printf("  |    |    |       measurements      |   - If no measurement is available, unselect measurement.\n");
	printf("  |    |    |                         |   - If only one measurement is available, select it regardless there is data in the observation file or not.\n");
	printf("  |    |    |                         |   - If multiple measurements are available, loop through the measurement priority list until a measurement with\n");
	printf("  |    |    |                         |       data in the observation file is found. If no measurement has data, selection is postponed to the next epoch.\n");
	printf("  |    |    |                         |       When selecting measurements for the cycle-slips, measurements selected in the filter will be prioritized.\n");
	printf("  |    |    +-------------------------+\n");
	printf("  |    |                 |\n");
	printf("  |    ----------------->|\n");
	printf("  |                      |\n");
	printf("  |         +-------------------------+\n");
	printf("  |         | 7                       |  Prealign carrier phase measurements (if enabled)\n");
	printf("  |         |        Preprocess       |  If any of the measurements used in cycle-slip detectors and the filter are not available in the current epoch, unselect satellite.\n");
	printf("  |         |                         |  If any of the measurements used in cycle-slip detectors and the filter do not meet SNR requirements, unselect satellite.\n");
	printf("  |         |          data           |  If any cycle-slip detector detects a cycle-slip, a cycle-slip will be declared in all frequencies of the satellite.\n");
	printf("  |         |                         |  Compute code smoothing measurements.\n");
	printf("  |         +-------------------------+\n");
	printf("  |                      |\n");
	printf("  |                      |\n");
	printf("  |                      V\n");
	printf("  |         +-------------------------+\n");
	printf("  |         | 8                       |  Compute all modelling terms (geometric distance, ionosphere, troposphere, DCBs, etc.)\n");
	printf("  |         |       Model data        |  In SBAS mode, if after modelling there are not enough available satellites and GEO or mode switching is enabled, change mode or GEO and repeat modelling.\n");
	printf("  |         |                         |  In DGNSS, if after modelling there are not enough available satellites, it will switch to SPP mode and repeat modelling.\n");
	printf("  |         +-------------------------+\n");
	printf("  |                      |\n");
	printf("  |                      |\n");
	printf("  |                      V\n");
	printf("  |         +-------------------------+\n");
	printf("  |         | 9  Compute navigation   |\n");
	printf("  |         |     solution using      |  If the constellation used as reference clock is not available, the next constellation available in the reference clock priority list will be used.\n");
	printf("  |         |      Kalman filter      |\n");
	printf("  |         +-------------------------+\n");
	printf("  |                      |\n");
	printf("  |                      |\n");
	printf("  |                      V\n");
    printf("  |         +-------------------------+\n");
    printf("  |         | 10  Update summary      |\n");
    printf("  |         |          data           |\n");
    printf("  |         +-------------------------+\n");	
	printf("  |                      |\n");
	printf("  |                      |\n");
	printf("  |                      V\n");
	printf("  |                      ^\n");
	printf("  |                     / \\\n");
	printf("  |                    /   \\\n");
	printf("  |            YES    /Epochs\n");
	printf("  |__________________/       \\\n");
	printf("                     \\       /\n");
	printf("                     remaining?\n");
	printf("                       \\   /\n");
	printf("                        \\ /\n");
	printf("                         V\n");
	printf("                      NO |\n");
	printf("                         |\n");
	printf("                         V\n");
    printf("            +-------------------------+\n");
    printf("            | 11      Compute         |\n");
    printf("            |         summary         |\n");
    printf("            +-------------------------+\n\n");	
	printf("\n  NOTES FOR PEGASUS OUTPUT FORMAT\n\n");
	printf("     Pegasus is a GNSS data processing tool from Eurocontrol. Pegasus does not read the RINEX-B or EMS SBAS files, it converts them to columnar text\n");
	printf("       files and later processes with these text files. Each text file contains one message type -except for fast correction messages, which are all\n");
	printf("       grouped in the same file; and the GEO navigation data, which is RINEX 2 format.\n");
	printf("       Each columnar text file has a header line with the name of each value, and the values are printed in decimal format.\n");
	printf("       A full explanation of the Pegasus format can be found in appendixes I.5-I.16 in their ICD at http://www.icao.int/Meetings/AMC/MA/2004/GNSS/icd.pdf\n");
	printf("\n  NOTES FOR PREPROCESSING\n\n");
	printf("     Pseudorange Jumps:\n");
	printf("       Some receivers, after updating the clock, they adjust the code but not the carrier phase measurement, producing a jump in the code\n");
	printf("         but not in the carrier phase. Therefore, code and carrier phase are not consistent (the difference between code and\n");
	printf("         carrier phase is not continuous). If the carrier phase is not adjusted, it will be detected as a cycle-slip.\n");
	printf("\n  NOTES FOR SBAS PROCESSING\n\n");
	printf("    When processing with SBAS corrections, gLAB will use MOPS-D standard values and configuration by default.\n");
	printf("    Most of these parameters and configuration can be modified by the user, regardless if these parameters are MOPS compliant or not.\n");
	printf("    The specific SBAS parameters that can be modified by the user are:\n");
	printf("        Smoothing:       Can be disabled or changed the number of epochs [default 100 epochs]\n");
	printf("        Steady-state:    Can be disabled or changed the number of epochs [default 360 epochs]\n");
	printf("        Ionosphere:      Any ionosphere model available in gLAB (e.g. IONEX) can be applied instead of the SBAS ionosphere model.\n");
	printf("        Time outs:       Time outs for all corrections can be user defined\n");
	printf("        Mode switch:     Switching from PA to NPA can be enabled or disabled [default disabled]\n");
	printf("        GEO switch:      GEO switching can be enabled or disabled [default disabled]. Furthermore, after a GEO switch,\n");
	printf("                         the user can decide if to stay in the new GEO or try to fall-back to the initial GEO when possible.\n");
	printf("        Decimation:      gLAB can process at any data rate. In order to keep integrity of results with 1Hz SBAS data rate,\n");
	printf("                            messages will be read every second, and special events will be handled every second.\n");
	printf("                            The special events are: receive an alarm message or an UDREI>=14, miss 4 consecutive messages\n");
	printf("                            or receive 4 consecutive messages with wrong CRC. Decimation is useful for studying slow\n");
	printf("                            varying corrections, such as long term corrections or ionosphere.\n");
	printf("        Navigation:      Both kinematic and static navigation mode can be selected. Default is kinematic.\n");
	printf("\n    Mode and GEO switch notes:\n");
	printf("      If both mode and GEO switch are enabled, GEO switch is tried first always, as switching GEO keeps PA mode.\n");
	printf("      If option '-model:geofallback' is enabled, gLAB will try to switch to the first GEO used in processing after\n");
	printf("        the time between switches (defined by parameter '-model:switchtime') after a GEO switch occurs.\n");
	printf("      If option '-model:maintaingeo' is enabled gLAB will maintain the current GEO (independently if it was selected\n");
	printf("        by the user or by a GEO switch) during all the processing while it can provide a PA solution.\n");
	printf("      If both options '-model:maintaingeo' and '-model:geofallback' are enabled, '-model:geofallback' option behaviour will prevail.\n");
	printf("      If both options '-model:maintaingeo' and '-model:geofallback' are disabled, after a GEO switch, gLAB will try to switch\n");
	printf("        to the previous GEO independently if it was the first one used or not. If there are only two GEOs available (and the use of mixed GEO\n");
	printf("        data is disabled), this behaviour is equivalent as in the '-model:geofallback' option, due to the previous GEO will be always the first GEO used.\n");
	printf("\n    Selection of best GEO:\n");
	printf("      When option '-model:selectbestgeo' is enabled, gLAB will compute in each epoch the full SBAS model and the protection levels with\n");
	printf("        all the GEOs available, and then select the best GEO according to the following criteria:\n");
	printf("           1 - Select the GEOs which have PA solution with protection levels under the alarm limits, and from these ones, select\n");
	printf("                 the GEO whose sum of the horizontal and vertical protection levels is smaller.\n\n");
	printf("           2 - If no GEOs had PA solution with protection levels under the alarm limits, select the GEOs with PA solution\n");
	printf("                 and then select the GEO whose sum of the horizontal and vertical protection levels is smaller.\n\n");
	printf("           3 - If no GEOs had PA solution, select the GEOs with NPA solution and then select the GEO whose sum of the\n"); 
    printf("                 horizontal and vertical protection levels is smaller.\n\n");
	printf("      This option will noticeably increase computation load, especially if there are many GEOs in the SBAS data file.\n");
	printf("      If INFO messages are enabled (option '-print:info'), an INFO message with the epoch, GEO PRN and its protection levels will\n");
	printf("        be printed for each iteration that provided a solution. The unselected iteration will have a '(Not selected)' text to indicate\n");
	printf("        that it was not selected. The selected iteration will be printed last, with the text '(Selected)'.\n");
	printf("      If option '-print:sbasunused' is enabled, the 'MODEL', 'SBASCORR', 'SBASVAR', 'SBASUNSEL' and 'SATSEL' messages for each discarded\n");
	printf("        iteration will be printed. All messages from discarded iterations will have an '*' next to message name to indicate it was discarded.\n");
	printf("        The iterations without solution will be printed first, and the last ones printed will be the iterations discarded but had solution.\n");
	printf("      If selection of best GEO is set, the options '-model:geoswitch' will be automatically set. Moreover, option '-model:switchtime'\n");
	printf("        must be set to 0 (if not set, it will be automatically set to 0), as in an epoch multiple GEO changes will be done, and also\n");
	printf("         option '' must be disabled.\n");
	printf("\n    SBAS Maritime mode:\n");
	printf("      Maritime mode is a special configuration for SBAS. In this configuration, message type 10 (degradation parameters), type 27 (service message)\n");
	printf("        and type 28 (clock ephemeris covariance matrix) are not used. Therefore, the sigma of fast and long term corrections is computed with the\n");
	printf("        following formula:\n\n");
	printf("                      Sigmaflt = SigmaUDRE + 8 (all units are in metres)\n\n");
	printf("      Alarm limits in maritime mode are not used (in gLAB alarm limits cannot be disabled, so they are set to 100Km), and a filter for\n");
	printf("        HDOP (Horizontal Dilution of Precision) and PDOP (Position Dilution of Precision). A valid epoch must have a HDOP<4 or a PDOP<6 (it only\n");
	printf("        needs to fulfil one of these two conditions).\n");
	printf("      Furthermore, for maritime mode, another mode for computing the continuity risk is used. Instead of a sliding windows of 15 seconds, it is used\n");
	printf("        a fixed window of 15 minutes (900 seconds). That is, every time a discontinuity event occurs, it will affect the previous 15 minutes, independently\n");
	printf("        if there had been a discontinuity within the previous 15 minutes (where as in aviation mode, each discontinuity only affects\n");
	printf("        the last seconds until the previous discontinuity -up to the window size-). This is an optimistic computation of the continuity risk, but\n");
	printf("        maritime mode has more relaxed requirements, as seen above. If desired, the user can change the size of the 15 minutes window to any value.\n");
	printf("        The disadvantages of this mode of continuity risk computation are that if several discontinuities occur in a time span smaller than the\n");
	printf("        window size (which usually happens in the SBAS coverage border), then epochs with discontinuities may be counted more than one, which may\n");
	printf("        do that the continuity risk ends up being greater than 1 (this effect can be mitigated by using large time spans). The other disadvantage is that\n");
	printf("        if some discontinuities occur but each of them have a duration larger than the window size, the total continuity risk will be much smaller compared\n");
	printf("        to the aviation continuity risk, as only the epochs of the size of the window will be counted for the discontinuity, but the other epochs in a\n");
	printf("        discontinuity but greater than the window will not be counted. This effect is also maximized as the continuity risk is computed using the\n");
	printf("        number of epochs processed, not the number of epochs with solution in PA mode.\n");
	printf("        The formula to compute the maritime continuity risk is:\n\n");
	printf("              Maritime Continuity Risk = CTI/MTBF = Window_Size/(NumEpochsProcessed/NumDiscontinuities) = Window_Size*NumDiscontinuities/NumEpochsProcessed\n\n");
	printf("          Where:\n");
	printf("           CTF: Continuity Time Interval, which is the window size\n");
	printf("           MTBF: Mean Time Between Failures, which is computed as the total epochs processed divided by the number of discontinuities\n\n");
	printf("        This formula is from IALA (International Association of Marine Aids to Navigation and Lighthouse Authorities), available in the following document:\n");
	printf("           http://www.iala-aism.org/product/performance-and-monitoring-of-dgnss-services-in-the-frequency-band-283-5-325khz-1112/\n");
	printf("      Maritime mode is configured with parameter '-model:sbasmaritime', which is a shortcut for providing these parameters: '-model:nomt10',\n");
	printf("         '-model:nomt2728', '-model:geoswitch', '-filter:maxhdop 4', '-filter:maxpdop 6', '-filter:hdoporpdop', '-summary:hal 100000',\n");
	printf("         '-summary:val 100000', '-summary:windowsize 900' and '-summary:windowsizemar 900'.\n");
	printf("         Furthermore, parameter '-model:sbasmaritime' will also set maritime options in SBAS plots mode.\n");
	printf("\n  NOTES FOR DOP MAPS:\n\n");
	printf("      When computing the mean and percentile in DOP maps, since version 5.4.0, only the epochs whose protection levels are below the\n");
	printf("         alarm limits are used. In version 5.3.0, any epoch with solution, independently of the protection levels, was always taken\n");
	printf("         into account for the mean and percentile computation. In this case, if an epoch had a very big DOP (e.g. more than 1 million),\n");
	printf("         this value (a clear outlier) would totally bias the mean value to a higher value.\n");
	printf("\n  NOTES FOR SBAS PLOTS:\n\n");
	printf("      See option '-sbasplotsinfo' for detailed help on how to generate SBAS plots.\n");
	printf("\n  NOTES FOR PREFIT OUTLIER DETECTION\n\n");
	printf("      There are two prefit outlier detectors in gLAB:\n");
	printf("       - Prefit outlier detector comparing against the median (by default disabled):\n");
	printf("          The procedure for this detector is:\n");
    printf("           Compute the median of all prefits\n");
    printf("           For each satellite:\n");
    printf("              Compute absolute value of the difference between the prefit and the median\n");
    printf("              If the difference is higher than the threshold, unselect the satellite\n\n");
	printf("       - Prefit outlier detector comparing the absolute values (by default disabled):\n");
	printf("          The procedure for this detector is:\n");
    printf("           For each satellite available:\n");
    printf("             Compute the absolute value of its prefit (ReferencePrefit)\n");
    printf("             Set a range for all other satellite prefits defined as:\n"); 
    printf("                Range=[abs(ReferencePrefit)-threshold,abs(ReferencePrefit)+threshold]\n");
    printf("                For each satellite (except the reference one):\n");
    printf("                  Check if prefits are inside the range\n");
    printf("                If half or more of the satellites are invalid, then the current satellite is an outlier\n");
    printf("                Else discard the satellites with prefits outside the range.\n\n");
	printf("       If receiver position is fixed, gLAB will allow the outlier detector to discard all satellites in the current epoch.\n\n");
	printf("       If receiver position is not fixed, if more than half of the available satellites are discarded, then, the prefit outlier detector\n");
	printf("          will not discard any satellite, as it will assume that the solution still has to converge.\n\n");
	printf("       A recommended value for the thresholds of the prefit outlier detectors is 30 metres\n");
	printf("\n  NOTES FOR DGNSS PROCESSING\n\n");
	printf("    Sigma inflation: During the transient period until the smoother converges, the measurement noise sigma is inflated according\n");
	printf("                     to the next equation:\n");
	printf("                       Sigma_inflat= f(n)/f(Nstdy) * sigma\n");
	printf("                            n<N    f(n)=sqrt(1/n)\n");
	printf("                            n>=N   f(n)=sqrt(1/(2*N-1)*(1+((N-1)/N)^(2*(n-N)+1)))\n");
	printf("                          where:\n");
	printf("                            n:     number of processed samples\n");
	printf("                            N:     number of samples of the smoothing window\n");
	printf("	                        Nstdy: number of samples when reaching the steady state: In gLAB, Nstdy=(int)(3.6*N)\n");
	printf("	                  For instance, with 1 second sampling rate and N=100, the stationary state (Nstdy) is assumed to be reached after 360 seconds\n");
}

/*****************************************************************************
 * Name        : showExamples
 * Description : Shows the program examples in the standard output
 * Parameters  : None
 *****************************************************************************/
void showExamples () {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("GNSS LABORATORY. Tool to analyse GNSS data\n");
	printf("Write '%s -help' for help on the options\n\n",GLABPROGRAMEXECUTABLE);
	printf("Usage:\n");
	printf("    %s [options]\n\n",GLABPROGRAMEXECUTABLE);
	printf("Examples:\n");
	printf("    o Typical PPP:\n");
	printf("        %s -input:obs madr2000.06o -input:sp3 igs13843.sp3 -input:ant igs_pre1400.atx -filter:meas carrierphase -filter:nav static\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Same as before using the defaults:\n");
	printf("        %s -input:obs madr2000.06o -input:sp3 igs13843.sp3 -input:ant igs_pre1400.atx\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Typical SPP with all constellations:\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Typical SPP with GPS and Galileo only (two ways):\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -pre:sat 0,+GE0\n",GLABPROGRAMEXECUTABLE);
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -pre:sat -RSJCI0\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o SPP using GPS only, with L1 in all satellites except for PRNs 1,3,5,6,7,8 and 9, which will use L5 (two possible ways):\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -filter:select G2.4.10-32-code-1 G1.3.5-9-code-5\n",GLABPROGRAMEXECUTABLE);
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -filter:select G0-code-1 -G1.3.5-9-code-1 G1.3.5-9-code-5\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o SPP using smoothed code in frequency 1 for GPS, Galileo, GLONASS, QZSS, in frequency 2 for Beidou and frequency 5 for IRNSS and GEO disabled:\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -pre:sat -S0 -filter:select GERJ0-code-1 C0-code-2 I0-code-5 -pre:smoothmeas GERJ0-code-1 phase-1 C0-code-2 phase-2 I0-code-5 phase-5\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o PPP in static mode with pseudorange only decimating to 900 seconds:\n");
	printf("        %s -input:obs madr2000.06o -input:sp3 igs13843.sp3 -input:ant igs_pre1400.atx -filter:meas pseudorange -filter:nav static -pre:dec 900\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Typical PPP without INFO messages:\n");
	printf("        %s -input:obs madr2000.06o -input:sp3 igs13843.sp3 -input:ant igs_pre1400.atx --print:info\n\n",GLABPROGRAMEXECUTABLE); 
	printf("    o Typical PPP with some verbose options:\n");
	printf("        %s -input:obs madr2000.06o -input:sp3 igs13843.sp3 -input:ant igs_pre1400.atx -print:none -print:cycleslips -print:model -print:satellites\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o PPP using ionosphere-free code and phase combinations with frequencies 15 for for GPS, Galileo, QZSS, frequencies 12 for GLONASS, frequencies 27 in Beidou and frequencies 59 for IRNSS:\n");
	printf("        %s -input:obs madr2000.06o -input:sp3 igs13843.sp3 -input:ant igs_pre1400.atx -pre:sat -S0 -filter:select GRJ0-PC15 GER0-LC15 R0-PC12 R0-LC12 C0-PC27 C0-LC27 I0-PC59 I0-LC59\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Typical standalone using standard ionospheric model (Klobuchar) and not using it\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -filter:nav kinematic\n",GLABPROGRAMEXECUTABLE);
	printf("        %s -model:iono no -input:obs madr2000.06o -input:nav brdc2000.06n -filter:nav kinematic\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Typical standalone using SBAS 1F ionosphere (without any other SBAS correction)\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -input:sbasiono M1202000.06b -model:iono SBAS\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Standard SBAS 1F processing:\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -input:sbas1f M1202000.06b\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Standard SBAS 1F processing with file conversion to Pegasus format:\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -input:sbas1f M1202000.06b -output:pegasus\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Standard SBAS DFMC processing with one navigation file (including GPS and Galileo):\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06p -input:sbasdfmc M1202000.06b\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Standard SBAS DFMC processing with two navigation files (for GPS and Galileo):\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n brdc2000.06l -input:sbasdfmc M1202000.06b\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Standard SBAS DFMC processing with one navigation file (including GPS and Galileo) for Autralian SBAS DFMC testbed:\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06p -input:sbasdfmc M1202000.06b -model:sbasdfmc:austestbed\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Standard DGNSS processing:\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n -input:rtcm rtcm2000.06rtcm2 -input:rtcm:initdate 20060718 -input:rtcm:inithour 00\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Convert RINEX-B file to ems and Pegasus format and exit without processing:\n");
	printf("        %s -input:sbas1f M1202000.06b -output:ems -output:pegasus -onlyconvert\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Convert EMS file to Pegasus format (with columns aligned and the output files in current directory) and exit without processing:\n");
	printf("        %s -input:sbas1f M1202000.ems -output:pegasus -output:pegfilealign -output:sbasdir \".\" -onlyconvert\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Convert RTCM file to plain text ASCII or RINEX format:\n");
	printf("        %s -input:rtcm rtcm2000.06rtcm2 -input:rtcm:initdate 20060718 -input:rtcm:inithour 00\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Save output to a file:\n");
	printf("        %s [options] > outputfile\n",GLABPROGRAMEXECUTABLE);
	printf("        %s [options] -output:file outputfile\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Print only INPUT messages without any decimation, do not process (no -input:sp3 nor -input:nav nor -input:orb/-input:clk):\n");
	printf("        %s -input:obs madr2000.06o -pre:dec 0 -print:none -print:input\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Compute SBAS 1F plots with the default configuration (EGNOS region):\n");
	printf("        %s -input:nav brdc2000.06n -input:sbas1f M1202000.06b\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Compute SBAS 1F plots specifying the region and output file:\n");
	printf("        %s -input:nav brdc2000.06n -input:sbas1f M1202000.06b -sbasplots:minlat 25 -sbasplots:maxlat 70 -sbasplots:minlon -30 -sbasplots:maxlon 40 -output:sbasplots SBASplots_120_200_2016\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Compute SBAS 1F plots specifying the resolution, vertical and horizontal alarm limits and resolution for availability and ionosphere plots:\n");
	printf("        %s -input:nav brdc2000.06n -input:sbas1f M1202000.06b -sbasplots:hal 30 -sbasplots:val 35 -sbasplots:availstep 1 -sbasplots:ionostep 1\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Compute SBAS DFMC plots with the default configuration (EGNOS region):\n");
	printf("        %s -input:nav brdc2000.06p -input:sbasdfmc M1202000.06b\n\n",GLABPROGRAMEXECUTABLE);
	printf("    o Add user error to RINEX file:\n");
	printf("        %s -input:obs madr2000.06o -input:usererror added_error_file.txt > Observation_RINEX_with_added_error.txt\n",GLABPROGRAMEXECUTABLE);

}

/*****************************************************************************
 * Name        : showConfig
 * Description : Shows information on the config file
 * Parameters  : None
 *****************************************************************************/
void showConfig () {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("GNSS LABORATORY. Tool to analyse GNSS data\n");
	printf("Write 'gLAB -help' for help on the options\n");
	printf("Usage:\n");
	printf("    gLAB [options]\n");
	printf("\n  CONFIG FILE\n\n");
	printf("    - The config file can be specified by the '-input:cfg <file>' command-line parameter. This file is an alternative\n");
	printf("       way to configure the behaviour of the tool. In case that there are parameters in the config file and in the\n");
	printf("       command-line arguments, the command-line parameters will have priority over the config file ones.\n\n");
	printf("    - The order to read the parameters is:\n\n");
	printf("           o Check if the '-input:cfg' parameter exist in the command-line arguments\n");
	printf("           o If it exists, parse config file parameters\n");
	printf("           o Parse command-line parameters\n\n");
	printf("    - The config file is basically a mirror of the command-line parameters. The only difference is that in the configuration\n");
	printf("       file only one parameter is provided by line.\n");
	printf("       For example, for the parameters '-input:obs upc42000_10s.06o' and '-filter:select G0-PC12 G0-LC12', the config file shall be:\n\n");
	printf("           -input:obs upc42000_10s.06o\n");
	printf("           -filter:select G0-PC12 G0-LC12\n\n");
	printf("    - There can be any number of spaces between parameters and the arguments. For instance, the example above can also be written as:\n\n");
	printf("           -input:obs     upc42000_10s.06o\n");
	printf("             -filter:select              G0-PC12 G0-LC12\n\n");
	printf("    - Arguments of parameters which contain filenames (with or without pathes) can contain spaces in their filenames. If there is only one\n");
	printf("        argument (one file), it is optional to write the filename between quotes (single or double). If there are multiple arguments or files\n");
	printf("        and the filenames have spaces, it is compulsory to set them between quotes (single or double), as otherwise it would be impossible to\n");
	printf("        disguish a space character being part of the filename or being a separator between arguments. Furthermore, it is possible to add the\n");
	printf("        quote character inside the filename, by preceeding it with a backslash ('\\'). The delimiter quotes will be removed from the\n");
	printf("        filename internally in gLAB.\n\n");
	printf("    - All lines beginning with the hash symbol ('#') in the config file shall be interpreted as a comment, and ignored in the parsing process.\n\n");
	printf("    - Blank lines are ignored.\n\n");
	printf("    - Comments -starting with the hash symbol ('#')- next to the options are allowed (since version 5.2.0). There is no need to set a\n");
	printf("       space character between the end of the parameter or argument and the hash symbol ('#').\n");
	printf("\n  SAMPLE CONFIG FILE\n\n");
	printf("        # INPUT\n");
	printf("        -input:obs madr2000.06o\n");
	printf("        -input:nav brdc2000.06n \"Glo Nav file 200.06g\"\n");
	printf("        -input:antsatblock igs_pre1400.atx\n\n");
	printf("        # PREPROCESS\n");
	printf("        -pre:elevation 5 \n\n");
	printf("        # FILTER\n");
	printf("        -filter:prefitoutliers:median 30#Set the prefit outlier detector threshold to 30 metres\n\n");
	printf("        # OUTPUT\n");
	printf("        -print:all  #This parameter enables all output messages\n\n");
	printf("    This config file is equivalent to the following command line execution:\n\n");
	printf("        %s -input:obs madr2000.06o -input:nav brdc2000.06n \"Glo Nav file 200.06g\" -input:antsatblock igs_pre1400.atx -pre:elevation 5 -filter:prefitoutliers:median 30 -print:all\n",GLABPROGRAMEXECUTABLE);
}

/*****************************************************************************
 * Name        : showMessages
 * Description : Shows the fields of each output message
 * Parameters  : None
 *****************************************************************************/
void showMessages () {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("GNSS LABORATORY. Tool to analyse GNSS data\n");
	printf("Write 'gLAB -help' for help on the options\n");
	printf("Usage:\n");
	printf("    gLAB [options]\n");
	printf("\n  MESSAGES FORMAT\n");
	printf("    INFO\n");
	printf("        INFO messages are shown at several points in the program and provide information on the\n");
	printf("          program configuration, events and problems it may encounter, which are:\n\n"); 
	printf("             At the start of the file, showing information about gLAB configuration.\n"); 
	printf("             An inconsistent clock update on the receiver.\n"); 
	printf("             A data gap in the RINEX observation file.\n"); 
	printf("             A change in the a priori receiver coordinates (only when receiver coordinates are computed by gLAB).\n");
	printf("             The new position to be used from the reference position file (only when a reference file is provided).\n");
	printf("             No solution was computed, along with the reason for not being able to compute the\n");
	printf("                solution (not enough satellites available, singular geometry matrix or DOP too high).\n"); 
	printf("             In SBAS processing, the elevation of each GEO and the one selected (if GEO selection with highest\n");
	printf("                elevation is enabled).\n");
	printf("             In SBAS processing, a GEO or mode switch.\n"); 
	printf("             In SBAS processing, if option '-mode:selectbestgeo' is enabled, in each epoch, for each GEO which a\n");
	printf("               solution can be computed, the GEO PRN, its protection levels and a message if the GEO was selected is\n"); 
	printf("               printed. The selected GEO will be always the last one.\n");  
	printf("             In DGNSS processing, a switch from DGNSS to SPP solution mode.\n"); 
	printf("             In DGNSS processing, a data gap in the reference station RINEX observation file.\n"); 
	printf("\n    USERADDEDERROR [only when user-defined error file is given]\n");
	printf("        User-defined error added to measurements before cycle-slip detection and smoothing.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'USERADDEDERROR'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GPS week\n");
	printf("        Field 7:  Time of week\n");
	printf("        Field 8:  GNSS System\n");
	printf("        Field 9:  PRN satellite identifier\n");
	printf("        Field 10: Measurement identifier (as string)\n");
	printf("        Field 11: Raw measurement (phase measurements are prealigned) [m]\n");
	printf("        Field 12: Raw measurement plus total user-defined error (phase measurements are prealigned) [m]\n");
	printf("        Field 13: Total number of active user-defined error functions\n");
	printf("        Field 14: Total user-defined error [m]\n");
	printf("        Field 15: Number of active Step function error\n");
	printf("        Field 16: Step function error value [m]\n");
	printf("        Field 17: Number of active Ramp function error\n");
	printf("        Field 18: Ramp function error value [m]\n");
	printf("        Field 19: Number of active Sinusoidal function error\n");
	printf("        Field 20: Sinusoidal function error value [m]\n");
	printf("        Field 21: Number of active AWGN (Additive White Gaussian Noise) function error\n");
	printf("        Field 22: AWGN function error value [m]\n");
	printf("        Sample:\n");
	printf("            USERADDEDERROR   2015 161     0.00 00:00:00.00 1848 259200.00 GPS   4 C1C  23140309.8200  23140314.8200  1         5.0000  1         5.0000  0         0.0000  0         0.0000  0         0.0000\n\n");
	printf("    SFCSDATA\n");
	printf("        Internal values used in the computation of the single frequency carrier minus code cycle-slip detector\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'SFCSDATA' or 'SFCSDATA_USER' for Rover Station (user)\n");
	printf("                  'SFCSDATA_REF' for Reference Station\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Arc number\n");
	printf("        Field 9:  Arc length\n");
	printf("        Field 10: List of measurements used to build the carrier minus code combination, separated by dashes\n");
	printf("        Field 11: Code measurement [m]\n");
	printf("        Field 12: Carrier phase measurement [m]\n");
	printf("        Field 13: Difference between current code measurement and previous epoch code measurement [m]\n");
	printf("        Field 14: Difference between current carrier phase measurement and previous epoch carrier phase measurement [m]\n");
	printf("        Field 15: Absolute value of the difference between fields 13 and 14 [m]\n");
	printf("        Field 16: Mean value of the difference between code and carrier phase measurement inside the sliding window [m]\n");
	printf("        Field 17: Sigma value of the difference between code and carrier phase measurement inside the sliding window [m^2]\n");
	printf("        Field 18: Computed difference. It is the squared value of (field 12 minus field 11 minus field 16) squared [m^2]\n");
	printf("        Field 19: Computed threshold. It is the minimum value between the current sigma (field 17) and the initial sigma multiplied by the k factor [m^2]\n");
	printf("        Field 20: Maximum threshold for declaring a measurement unconsistent [m]\n");
	printf("        Field 21: Unconsistency flag. If an unconsistency is found, value is '1'. In all other cases, value is '0'\n");
	printf("        Field 22: Cycle-slip flag. If a cycle-slip is found, value is '1'. In all other cases, value is '0'\n\n");
	printf("        An unconsistency is triggered when field 15 is greater than field 20. In this case, all satellites samples are skipped (it is considered as a\n");
    printf("          data gap but without triggering N-consecutive check) Consistency check cannot be triggered two consecutive epochs.\n");
	printf("        A cycle-slip is triggered when field 18 is greater than field 19.\n");
	printf("        The cycle-slip flag in field 22 will only be enabled if the single frequency detector detects a cycle-slip, but not if another cycle-slip\n");
	printf("          running in parallel detects a cycle-slip trigger and the single frequency detector doesn't.\n");
	printf("        Sample:\n");
	printf("            SFCSDATA 2019 031 61530.00 17:05:30.00 GAL 24   1     2 C8Q-L8Q  24042582.3540  24042582.4685    -10183.8650    -10183.8300         0.0350      0.0795      9.0000      0.0012    225.0000  20.0000 0 0\n\n");
	printf("    MWCSDATA\n");
	printf("        Internal values used in the computation of the Melbourne-Wubbena cycle-slip detector\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'MWCSDATA' or 'MWCSDATA_USER' for Rover Station (user)\n");
	printf("                  'MWCSDATA_REF' for Reference Station\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Arc number\n");
	printf("        Field 9:  Arc length\n");
	printf("        Field 10: List of measurements used to build the Melbourne-Wubbena combination, separated by dashes\n");
	printf("        Field 11: Code measurement for building the narrow lane combination [m]\n");
	printf("        Field 12: Code measurement for building the narrow lane combination [m]\n");
	printf("        Field 13: Carrier phase measurement the wide lane combination [m]\n");
	printf("        Field 14: Carrier phase measurement the wide lane combination [m]\n");
	printf("        Field 15: Melbourne-Wubbena combination with current measurements [m]\n");
	printf("        Field 16: Mean value of Melbourne-Wubbena in the current arc [m]\n");
	printf("        Field 17: Mean value of Melbourne-Wubbena in the sliding window [m]\n");
	printf("        Field 18: Sigma value of Melbourne-Wubbena in the current arc [m^2]\n");
	printf("        Field 19: Absolute value of the difference between field 15 and field 16 [m]\n");
	printf("        Field 20: Absolute value of the difference between field 15 and field 17 [m]\n");
	printf("        Field 21: Computed threshold. It is the square root of field 18 by the k factor [m]\n");
	printf("        Field 22: Minimum standard deviation provided by parameter [m]\n");
	printf("        Field 23: Outlier flag. If an outlier is declared , value is '1'. In all other cases, value is '0'\n");
	printf("        Field 24: Cycle-slip flag. If a cycle-slip is found, value is '1'. In all other cases, value is '0'\n\n");
	printf("        A cycle-slip is triggered when fields 19 and 20 are greater than field 21 and the square root of field 18 is smaller than field 22 or\n");
	printf("          if field 18 is greater than ten times field 22.\n");
	printf("        The first time a cycle-slip is detected, the samples are considered as 'outlier' and samples are skipped (it is considered as data gap but\n");
	printf("          without triggering N-consecutive check). If the next sample a cycle-slip is triggered, then a new arc is declared. Otherwise, if no\n");
	printf("          cycle-slip is detected the next epoch, the arc continues with the previous epoch skipped\n");
	printf("        The cycle-slip flag in field 24 will only be enabled if the Melbourne-Wubbena detector detects a cycle-slip, but not if another cycle-slip\n");
	printf("          running in parallel detects a cycle-slip trigger and the Melbourne-Wubbena detector doesn't.\n");
	printf("        Sample:\n");
	printf("            MWCSDATA 2019 031 61660.00 17:07:40.00 GAL 24   2    12 C6C-C8Q-L6C-L8Q  24210219.9290  24210239.3620  24210219.9516  24210239.7865   281.2079   281.1575   281.1575     0.3692      0.0503      0.0503      3.0381   0.8000 0 0\n\n");
	printf("    LICSDATA\n");
	printf("        Internal values used in the computation of the geometry-free cycle-slip detector\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'LICSDATA' or 'LICSDATA_USER' for Rover Station (user)\n");
	printf("                  'LICSDATA_REF' for Reference Station\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Arc number\n");
	printf("        Field 9:  Arc length\n");
	printf("        Field 10: List of measurements used to build the geometry-free combination, separated by dashes\n");
	printf("        Field 11: Carrier phase measurement for building the geometry-free combination [m]\n");
	printf("        Field 12: Carrier phase measurement for building the geometry-free combination [m]\n");
	printf("        Field 13: First LI measurement saved in the LI buffer sliding window [m]\n");
	printf("        Field 14: LI combination with current measurements [m]\n");
	printf("        Field 15: Absolute value of the difference between field 13 and field 14 [m]\n");
	printf("        Field 16: Estimated LI value using a second degree least square adjustement [m]\n");
	printf("        Field 17: Absolute value of the difference between field 14 and field 16 [m]\n");
	printf("        Field 18: Absolute value of two times the residual of the LI estimation (threshold for maximum value of field 17) [m]\n");
	printf("        Field 19: Threshold for maximum value of field 15\n");
	printf("        Field 20: Threshold for maximum value of field 17\n");
	printf("        Field 21: Outlier flag. If an outlier is declared , value is '1'. In all other cases, value is '0'\n");
	printf("        Field 22: Cycle-slip flag. If a cycle-slip is found, value is '1'. In all other cases, value is '0'\n\n");
	printf("        A cycle-slip is triggered when field 15 is greater than field 19 or field 17 is greater than fields 18 and 20. If a cycle-slip\n");
	printf("          is declared with the first condition, no outlier is declared, as it is a check for large phase jumps. If a cycle-slip triggers\n");
	printf("          with the second condition, an outlier is declared. If in the next epoch a cycle-slip is triggered, then a new arc is declared.\n");
	printf("          Otherwise, if no cycle-slip is detected the next epoch, the arc continues with the previous epoch skipped.\n");
	printf("        The cycle-slip flag in field 22 will only be enabled if the geometry-free detector detects a cycle-slip, but not if another cycle-slip\n");
	printf("          running in parallel detects a cycle-slip trigger and the geometry-free detector doesn't.\n");
	printf("        Sample:\n");
	printf("            LICSDATA 2019 031 61610.00 17:06:50.00 GAL  4   1    10 L6C-L8Q  28902058.4672  28902058.4607   0.0040   0.0065   0.0025      0.0059      0.0006      0.0005   1.0000   0.0529 0 0\n\n");
	printf("    IGFCSDATA\n");
	printf("        Internal values used in the computation of the iono-geometry-free cycle-slip detector\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'IGFCSDATA' or 'IGFCSDATA_USER' for Rover Station (user)\n");
	printf("                  'IGFCSDATA_REF' for Reference Station\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Arc number\n");
	printf("        Field 9:  Arc length\n");
	printf("        Field 10: List of measurements used to build the iono-geometry-free combination, separated by dashes\n");
	printf("        Field 11: Carrier phase measurement for building the iono-geometry-free combination [m]\n");
	printf("        Field 12: Carrier phase measurement for building the iono-geometry-free combination [m]\n");
	printf("        Field 13: Carrier phase measurement for building the iono-geometry-free combination [m]\n");
	printf("        Field 14: Carrier phase measurement for building the iono-geometry-free combination [m]\n");
	printf("        Field 15: First IGF measurement saved in the IGF buffer sliding window [m]\n");
	printf("        Field 16: IGF combination with current measurements [m]\n");
	printf("        Field 17: Absolute value of the difference between field 15 and field 16 [m]\n");
	printf("        Field 18: Estimated IGF value using a second degree least square adjustement [m]\n");
	printf("        Field 19: Absolute value of the difference between field 16 and field 18 [m]\n");
	printf("        Field 20: Absolute value of two times the residual of the IGF estimation (threshold for maximum value of field 19) [m]\n");
	printf("        Field 21: Threshold for maximum value of field 17\n");
	printf("        Field 22: Threshold for maximum value of field 19\n");
	printf("        Field 23: Outlier flag. If an outlier is declared , value is '1'. In all other cases, value is '0'\n");
	printf("        Field 24: Cycle-slip flag. If a cycle-slip is found, value is '1'. In all other cases, value is '0'\n\n");
	printf("        If option '-pre:cs:igf:minnoise' is set, the IGF is computed with the following formula:\n");
	printf("               IGF = Alpha·L1 + Beta·L2 + Gamma·L3\n");
	printf("          With this option, field 14 will be 999999.0000, as only three measurements are used.\n");
	printf("          The next three fields are the computed values for Alpha, Beta and Gamma (adimensional factors)\n");
	printf("        Field 25: Alpha factor. To be multiplied with field 11\n");
	printf("        Field 26: Beta factor. To be multiplied with field 12\n");
	printf("        Field 27: Gamma factor. To be multiplied with field 13\n\n");
	printf("        A cycle-slip is triggered when field 17 is greater than field 21 or field 19 is greater than fields 20 and 22. If a cycle-slip\n");
	printf("          is declared with the first condition, no outlier is declared, as it is a check for large phase jumps. If a cycle-slip triggers\n");
	printf("          with the second condition, an outlier is declared. If in the next epoch a cycle-slip is triggered, then a new arc is declared.\n");
	printf("          Otherwise, if no cycle-slip is detected the next epoch, the arc continues with the previous epoch skipped.\n");
	printf("        The cycle-slip flag in field 24 will only be enabled if the iono-geometry-free detector detects a cycle-slip, but not if another cycle-slip\n");
	printf("          running in parallel detects a cycle-slip trigger and the iono-geometry-free detector doesn't.\n");
	printf("        Sample:\n");
	printf("            IGFCSDATA 2019 031 61640.00 17:07:20.00 GAL 26   1    13 L1C-L5Q-L6C-L8Q  23994292.6633  23994294.1164  23994293.2320  23994294.0525   3.0103   3.0243   0.0140      3.0077      0.0166      0.0020   1.0000   0.1057 0 0\n\n");
	printf("             or\n\n");
	printf("            IGFCSDATA 2019 031 61640.00 17:07:20.00 GAL 26   1    13 L1C-L8Q-L5Q      23994292.6633  23994294.0525  23994294.1164    999999.0000  -0.0149  -0.0147   0.0002     -0.0144      0.0003      0.0002   1.0000   0.0529 0 0  0.0421 -0.7272  0.6851\n\n");
	printf("    CS\n");
	printf("        Cycle-slip detection message information. It is shown when a cycle-slip is found by any detector.\n");
	printf("        A line will be printed for each CS detector that has found a CS.\n");
	printf("        The first 7 fields are common, afterwards, there are five possible different CS messages depending on\n");
	printf("        the cycle-slip detector activated.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'CS' or 'CS_USER' for Rover Station (user)\n");
	printf("                  'CS_REF' for Reference Station\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n\n");
	printf("        If cycle-slip detector is Data gap:\n");
	printf("            Field 8:   '-' (to align with SF, MW, LI and IGF detectors)\n");
	printf("            Field 9:   'DATA_GAP'\n");
	printf("            Field 10:  '='\n");
	printf("            Field 11:   Difference of time between current and last available epochs [s]\n");
	printf("            Field 12:  'THRESHOLD'\n");
	printf("            Field 13:  '='\n");
	printf("            Field 14:  Maximum time allowed data gap threshold [s]\n");
	printf("            Sample:\n");
	printf("                CS       2014 288 44997.00 12:29:57.00 GPS 32 - DATA_GAP = 45.00 THRESHOLD = 40.00\n\n");
	printf("        If cycle-slip detector is Loss of Lock Indicator:\n");
	printf("            Field 8:   '-' (to align with SF, MW, LI and IGF detectors)\n");
	printf("            Field 9:   'LLI'\n");
	printf("            Field 10-: List of measurements and its LLI flag value\n");
	printf("            Sample:\n");
	printf("                CS       2019 031 72340.00 20:05:40.00 GPS  9 - LLI L1C-1 L2L-1 L5Q-1\n\n");
	printf("        If cycle-slip detector is Carrier minus code difference (single frequency detector):\n");
	printf("            Field 8:   List of measurements used to build the carrier minus code combination, separated by dashes\n");
	printf("            Field 9:   'SF'\n");
	printf("            Field 10:  '='\n");
	printf("            Field 11:  Squared value of carrier phase minus code minus the current arc mean [m^2]\n");
	printf("            Field 12:  'THRESHOLD'\n");
	printf("            Field 13:  '='\n");
	printf("            Field 14:  SF threshold [m^2]\n");
	printf("            Sample:\n");
	printf("                CS       2019 032 19600.00 05:26:40.00 GAL  1 C5Q-L5Q SF = 39.8400 THRESHOLD = 25.4303\n\n");
	printf("        If cycle-slip detector is Melbourne-Wubbena:\n");
	printf("            Field 8:   List of measurements used to build the MW combination, separated by dashes\n");
	printf("            Field 9:   'MW'\n");
	printf("            Field 10:  '='\n");
	printf("            Field 11:  Absolute value of the difference between the current MW and the mean value of MW of current arc [m]\n");
	printf("            Field 12:  'THRESHOLD'\n");
	printf("            Field 13:  '='\n");
	printf("            Field 14:  MW threshold [m]\n");
	printf("            Sample:\n");
	printf("                CS       2019 032 10780.00 02:59:40.00 GPS 10 C1C-C5Q-L1C-L5Q MW = 1.1744 THRESHOLD = 1.1304\n\n");
	printf("        If cycle-slip detector is Geometry-free carrier phase:\n");
	printf("            Field 8:   List of measurements used to build the LI combination, separated by dashes\n");
	printf("            Field 9:   'LI'\n");
	printf("            Field 10:  '='\n");
	printf("            Field 11:  Absolute value of the difference between the computed LI and the measured LI. If LI could not be estimated, value will be '999999.0000' [m]\n");
	printf("            Field 12:  'THRESHOLD'\n");
	printf("            Field 13:  '='\n");
	printf("            Field 14:  LI threshold [m]\n");
	printf("            Sample:\n");
	printf("                CS       2019 032 17310.00 04:48:30.00 GPS 32 L1C-L2W LI = 0.1134 THRESHOLD = 0.0528\n\n");
	printf("        If cycle-slip detector is Iono-geometry-free carrier phase:\n");
	printf("            Field 8:   List of measurements used to build the IGF combination, separated by dashes\n");
	printf("            Field 9:   'IGF'\n");
	printf("            Field 10:  '='\n");
	printf("            Field 11:  Absolute value of the difference between the computed IGF and the measured IGF. If IGF could not be estimated, value will be '999999.0000' [m]\n");
	printf("            Field 12:  'THRESHOLD'\n");
	printf("            Field 13:  '='\n");
	printf("            Field 14:  IGF threshold [m]\n");
	printf("            Sample:\n");
	printf("                CS       2019 031 67660.00 18:47:40.00 GAL  3 L1C-L5Q-L6C-L8Q IGF = 0.0760 THRESHOLD = 0.0528\n\n");
	printf("    INPUT\n");
	printf("        Input data message. It is shown after an epoch is read, decimated and added user-defined error\n");
	printf("        It contains the measurements for each satellite for this epoch\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        NOTE: INPUT message is deprecated, use MEAS message instead\n");
	printf("        Field 1:  'INPUT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Arc number\n");
	printf("        Field 9:  Arc length\n");
	printf("        For GPS:\n");
	printf("            Field 10: C1 (C1C) [m]\n");
	printf("            Field 11: P1 (C1P) [m]\n");
	printf("            Field 12: P2 (C2P) [m]\n");
	printf("            Field 13: L1 (L1P) (prealigned) [m]\n");
	printf("            Field 14: L2 (L2P) (prealigned) [m]\n");
	printf("        For Galileo (GAL):\n");
	printf("            Field 10: C1A [m]\n");
	printf("            Field 11: C1B [m]\n");
	printf("            Field 12: C1C [m]\n");
	printf("            Field 13: C7Q [m]\n");
	printf("            Field 14: C8Q [m]\n");
	printf("            Field 15: L1A (prealigned) [m]\n");
	printf("            Field 16: L1B (prealigned) [m]\n");
	printf("            Field 17: L1C (prealigned) [m]\n");
	printf("            Field 18: L7Q (prealigned) [m]\n");
	printf("            Field 19: L8Q (prealigned) [m]\n");
	printf("        For GLONASS (GLO):\n");
	printf("            Field 10: C1 (C1C) [m]\n");
	printf("            Field 11: C2 (C2C) [m]\n");
	printf("            Field 12: L1 (L1P) (prealigned) [m]\n");
	printf("            Field 13: L2 (L2P) (prealigned) [m]\n");
	printf("        For GEO:\n");
	printf("            Field 10:  C1 (C1C) [m]\n");
	printf("        Sample:\n");
	printf("            INPUT     2006 200     0.00 00:00:00.00 GPS 19   1      1  23119003.9020  23119002.6110  23119004.0750  23119002.7507  23119004.0925\n\n");
	printf("    MEAS\n");
	printf("        Information of the input measurements in a variable format, and azimuth/elevation of the satellite.\n");
	printf("        It is written after modelling the message.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'MEAS'\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite block type\n");
	printf("        Field 9:   SVN (Space Vehicle Number)\n");
	printf("        Field 10:  Arc number\n");
	printf("        Field 11:  Arc length\n");
	printf("        Field 12:  Satellite elevation [degrees]\n");
	printf("        Field 13:  Satellite azimuth [degrees]\n");
	printf("        Field 14:  Number of measurements\n");
	printf("        Field 15:  List of measurements included\n");
	printf("        Field 16-: Each following column is the value of the measurement specified in field 15\n\n");
	printf("        If there is no data available on azimuth and elevation, the fields 12 and 13 will be fixed to zero.\n");
	printf("        User can define the measurements to be printed (in fields 14 and onwards) on a per satellite basis,\n"); 
	printf("          by using the parameter '-print:meas:select'.\n");
	printf("        The MEAS message can be used as a way to convert a RINEX file to a columnar text file\n");
	printf("        Sample:\n");
	printf("            MEAS      2019 182     0.00 00:00:00.00 GPS 26       BLOCK_IIF   71   1      1   29.689  -85.121 15 C1C:L1C:S1C:C1W:L1W:S1W:C2X:L2X:S2X:C2W:L2W:S2W:C5X:L5X:S5X  22797916.2960  22797916.3449 44.750  22797915.8300  22797915.9666 34.250 22797918.6020  22797918.7745 46.500  22797918.6990  22797918.7748 34.250  22797919.1480  22797919.3039 53.000\n\n");
	printf("    MODEL\n");
	printf("        Model break down message. It is shown when a model can be fully computed for each measurement.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        Satellite coordinates are in WGS84 system.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'MODEL' (if the satellite is used in the computation) or 'MODEL*' (if it is not)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite block type\n");
	printf("        Field 9:   SVN (Space Vehicle Number)\n");
	printf("        Field 10:  Arc number\n");
	printf("        Field 11:  Arc length\n");
	printf("        Field 12:  Satellite elevation [degrees]\n");
	printf("        Field 13:  Satellite azimuth [degrees]\n");
	printf("        Field 14:  Measurement identifier (as string)\n");
	printf("        Field 15:  Broadcast message type used for orbit computation\n");
	printf("        Field 16:  IOD of the broadcast message used for orbit computation\n");
	printf("        Field 17:  GLONASS frequency number (k)\n");
	printf("        Field 18:  Leap seconds (GLONASS) or BeiDou to GPS time offset [s]\n");
	printf("        Field 19:  Measured value [m]\n");
	printf("        Field 20:  Signal flight time [sec]\n");
	printf("        Field 21:  Satellite X position [m]\n");
	printf("        Field 22:  Satellite Y position [m]\n");
	printf("        Field 23:  Satellite Z position [m]\n");
	printf("        Field 24:  Satellite X velocity [m]\n");
	printf("        Field 25:  Satellite Y velocity [m]\n");
	printf("        Field 26:  Satellite Z velocity [m]\n");
	printf("        Field 27:  Satellite-receiver geometric distance [m]\n");
	printf("        Field 28:  Satellite clock correction [m]\n");
	printf("        Field 29:  Satellite phase centre projection [m]\n");
	printf("        Field 30:  Satellite phase centre variation projection [m]\n");
	printf("        Field 31:  Receiver phase centre projection [m]\n");
	printf("        Field 32:  Receiver phase centre variation projection [m]\n");
	printf("        Field 33:  Receiver Antenna Reference Point (ARP) projection [m]\n");
	printf("        Field 34:  Relativity correction [m]\n");
	printf("        Field 35:  Wind-up correction [m] (for carrier phase measurements)\n");
	printf("        Field 36:  Troposphere nominal correction [m]\n");
	printf("        Field 37:  Ionosphere correction [m]\n");
	printf("        Field 38:  Gravitational delay correction [m]\n");
	printf("        Field 39:  Solid tides correction [m]\n");
	printf("        Field 40:  (Reserved for future fields)\n");
	printf("        Field 41:  (Reserved for future fields)\n");
	printf("        Field 42:  (Reserved for future fields)\n");
	printf("        Field 43:  Inter system clock bias [m]\n");
	printf("        Field 44:  P1-C1 DCB (GPS only) [m]\n");
	printf("        Field 45:  Total Group Delay (TGD) correction [m]\n");
	printf("        Field 46:  Inter Signal Correction (if applied) [m]\n");
	printf("        Field 47:  Computed DCB for single frequency and precise orbits (BeiDou only) [m]\n");
	printf("        Field 48:  Sum of all DCB corrections applied (Field 44 + Field 45 + Field 46 + Field 47) [m]\n");
	printf("        Field 49:  Measurement SNR (Signal to Noise Ratio) [dbHz]\n");
	printf("        Field 50:  Full model value (except for dual-frequency DCB)[m]\n\n");
	printf("          If measurement needs to be applied a dual-frequency DCB, for each dual frequency combination where the measurement\n");
	printf("            is used, the following three fields will be provided:\n");
	printf("	      Field 51-: Measurements used for the dual frequency combination\n");
	printf("	      Field 52-: Dual-frequency DCB computed for current dual-frequency combination [m]\n");
	printf("	      Field 53-: Full model value with dual-frequency DCB applied [m]\n\n");
	printf("        If precise products are used, fields 15 and 16 will have the fixed values 'SP3' and '-1' respectively.\n");
	printf("        Field 18, for GLONASS satellites will have the number of leap seconds. For BeiDou satellites, the value will be the fixed offset to GPS.\n");
	printf("         	For other constellations value is 0\n");
	printf("        The satellite coordinates (fields 21-26) are given in the transmission epoch if the model of the\n");
 	printf("          signal transmission time is enabled (if it is disabled, they are given in the reception\n");
	printf("          time). The coordinates are relative to the antenna phase centre or satellite mass centre,\n");
	printf("          depending on the products input:\n");
	printf("            * Broadcast: Antenna Phase Centre\n");
	printf("            * Precise: Satellite Mass Centre\n");
	printf("        Field 19 is the direct measurement (as in the RINEX file), but scaled to metres for carrier phase\n");
	printf("          measurements. Field 48 is the model computed for this measurement, which is the direct sum of fields 27 to 47.\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("          or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        The SNR value in field 49 may be any of these values (in this order): the \"S\" measurement in the\n");
	printf("          observation file, or if it is not present, it will be the SNR flag in the current measurement (converted to numerical value).\n");
	printf("          If no SNR is available, 999 will be printed in this field.\n");
	printf("        Sample:\n");
	printf("            MODEL     2019 025 85862.00 23:51:02.00 GPS 15 BLOCK_IIR-M       55   1    363    9.133   56.540 C1C      LNAV    1  0  0 39110018.66000         0.0817  -5849446.9671  19529241.5438  16560946.2782     -1025.8786     -1939.4413      1934.8478  24502508.9762     99139.2638   0.00000   0.00000   0.00000   0.00000  -0.00000   1.12021   0.00000  13.46324   1.71706   0.00000   0.00000   0.00000   0.00000   0.00000   0.00000   0.00000  -3.21084   0.00000   0.00000  -3.21084   53.000  24601663.5797\n\n");
	printf("    SATSEL\n");
	printf("        Message with debug information of the reason why a satellite has been discarded (or selected) for processing.\n");
	printf("        If multiple discard conditions are met in a single satellite, then a SATSEL message for each condition will be printed.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'SATSEL' (if navigation solution will be computed), 'SATSEL*' (if model parameters will be recomputed before the navigation solution, only in SBAS mode)\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Error code\n");
	printf("        Field 9:  \"Selected\" if satellite used or \"Discard reason\" if satellite unused\n\n");
	printf("        The error code in field 8 is a number which identifies the discard reason with a range from 1 to 120. Useful for parsing purposes.\n");
	printf("        Field 9 will be always between quotes in order to ease parsing purposes.\n");
	printf("        Fields 8 and 9 may have the following values:\n");
	printf("             0   Selected\n");
	printf("             1   Deselection forced\n");
	printf("             2   Measurement selection for rover not finished\n");
	printf("             3   Measurements missing: <measurements>\n");
	printf("             4   SNR not met [<snr>]\n");
	printf("             5   Not enough consecutive samples (current <value>, minimum <value>)\n");
    printf("             6   Arc too short (<arclength>). Min arc length: <minarclength>\n");
	printf("             7   Unconsistency of measurements\n");
	printf("             8   Outlier in MW detector\n");
	printf("             9   Outlier in LI detector\n");
	printf("            10   Outlier in IGF detector\n");
	printf("            11   Cycle-slip\n");
	printf("            12   Steady-state operation not reached. <value> epochs passed, still <value> epochs to achieve <value>\n");
	printf("            19   Satellite missing in reference station\n");
	printf("            20   Measurement selection for reference station not finished\n");
	printf("            21   Measurements missing in reference station: <measurements>\n");
	printf("            22   SNR not met in reference station [<snr>]\n");
	printf("            23   Not enough consecutive samples in reference station (current <value>, minimum <value>)\n");
    printf("            24   Arc too short (<arclength>) in reference station. Min arc length: <minarclength>\n");
	printf("            25   Unconsistency of measurements in reference station\n");
	printf("            26   Outlier in MW detector in reference station\n");
	printf("            27   Outlier in LI detector in reference station\n");
	printf("            28   Outlier in IGF detector in reference station\n");
	printf("            29   Cycle-slip in reference station\n");
	printf("            40   No code measurement available for computing transmission time\n");
	printf("            41   No code and carrier phase measurement available for computing transmission time\n");
	printf("            42   Ephemerides unavailable\n");
	printf("            43   Satellite phase center corrections unavailable\n");
	printf("            44   GPS P1-C1 DCB unavailable\n");
	printf("            45   DCBs unavailable\n");
	printf("            46   Satellite under eclipse\n");
	printf("            47   Satellite was under eclipse <value> seconds ago\n");
	printf("            48   Elevation too low (<value> degrees)\n");
	printf("            49   Elevation too low (<value> degrees) for applying weight 1/(sin(elev)^2)\n");
	printf("            50   Elevation too low (<value> degrees) for applying weight 10^(-SNR/10)/(sin(elev)^2)\n");
	printf("            51   No SNR available for computing the weight for measurement <measurement>\n");
	printf("            52   Missing IONEX data\n");
	printf("            53   Missing ionosphere F-PPP data\n");
	printf("            54   SBAS iono unavailable\n");
	printf("            55   URA value (<value>) is equal or greater than the threshold (<threshold>)\n");
	printf("            56   Satellite is in marginal mode <healthtext>\n");
	printf("            57   Satellite is unhealthy <healthtext>\n");
	printf("            58   Missing frequency number (k) for FDMA signals\n");
	printf("            59   No measurements selected for the filter\n");
	printf("            80   STEP detected (jump of <value> greater than <threshold>)\n");
	printf("            81   Prefit too high for measurement <meas> in comparison with other satellites\n");
	printf("            82   Prefit too high for measurement <meas> in comparison with other satellites (threshold <threshold> metres)\n");
	printf("            83   Prefit too different (<value>) for measurement <meas> with respect to the prefit median (<median>), threshold <threshold> metres\n");
	printf("            84   NeQuick ionosphere could not be computed\n");
	printf("           100   SBAS corrections unavailable (GEO <PRN>)\n");
	printf("           101   C1C measurement unavailable\n");
	printf("           102   <value> constellation not monitored by SBAS (GEO <PRN>)\n");
	printf("           110   No DGNSS corrections\n");
	printf("           111   No DGNSS corrections: Time out\n");
	printf("           112   No DGNSS corrections: Excluded during the smoother conversion in the Reference Station\n");
	printf("           113   No DGNSS corrections: Excluded during the smoother conversion in the Rover Station\n");
	printf("           114   No DGNSS corrections: IODE from BRDC and RTCM do not match\n");
	printf("           115   No DGNSS corrections: Excluded due to differential correction is too large\n");
	printf("           116   No DGNSS corrections: Epoch in reference station (last read <ref_station_epoch>) cannot be aligned with rover\n\n");
	printf("            Error codes 1 to 18 are for rover preprocessing, 19 to 39 for reference station preprocessing,\n");
	printf("               40 to 79 for modelling, 80 to 99 for the filter, 100 to 109 for SBAS and 110 to 120 for DGNSS\n\n");
	printf("        Sample:\n");
	printf("            SATSEL    2019 025 85862.00 23:51:02.00 GPS 18  12 \"Steady-state operation not reached. 348 epochs passed, still 12 epochs to achieve 360\"\n\n");
	printf("    PREFIT\n");
	printf("        Prefilter values message. It provides the measurement-model values. It is shown in each filter execution.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'PREFIT' (if the satellite is used in the computation) or 'PREFIT*' (if it is not)\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Satellite block type\n");
	printf("        Field 9:  SVN (Space Vehicle Number)\n");
	printf("        Field 10: Arc number\n");
	printf("        Field 11: Arc length\n");
	printf("        Field 12: Satellite elevation [degrees]\n");
	printf("        Field 13: Satellite azimuth [degrees]\n");
	printf("        Field 14: Measurement identifier (as string)\n");
	printf("        Field 15: Measurement identifier for smoothing (as string)\n");
	printf("        Field 16: Measurement-model value (prefit) [m]\n");
	printf("        Field 17: Measurement value [m]\n");
	printf("        Field 18: Smoothed measurement value[m]\n");
	printf("        Field 19: Model value [m]\n");
	printf("        Field 20: X-partial derivative (-X component of the satellite line-of-sight vector)\n");
	printf("        Field 21: Y-partial derivative (-Y component of the satellite line-of-sight vector)\n");
	printf("        Field 22: Z-partial derivative (-Z component of the satellite line-of-sight vector)\n");
	printf("        Field 23: T-partial derivative \n");
	printf("        Field 24: Standard deviation of the measurement  (for the filter) [m]\n");
	printf("        Field 25: Troposphere wet mapping\n");
	printf("        Field 26: Wavelength of the measurement [m]\n");
	printf("        Field 27: GLONASS frequency number\n");
	printf("        Field 28: Conversion factor from TECUs to metres [m/TECU]\n\n");
	printf("        If no smoothing is enabled, field 15 will be a dash ('-'), field 18 will be 0 and Field 16 = Field 17 - Field 19\n");
	printf("        If smoothing is enabled, field 15 is the measurement used for smoothing, field 18 will be the smoothed value and Field 16 = Field 18 - Field 19\n");
	printf("        Field 26 is the frequency wavelength. When a iono-free combination is used, the wavelength is computed with the formula 'lambda=c/(f1+f2)'\n");
	printf("        Field 27 is the GLONASS frequency number 'k' read from navigation message. For other constellations, value is 0\n");
	printf("        Sample:\n");
	printf("            PREFIT    2019 025 85862.00 23:51:02.00 GPS 15 BLOCK_IIR-M       55   1    363    9.133   56.540          C1C          L1P  14508353.7082  39110017.2878  39110017.0467  24601663.5797         0.4131        -0.7708        -0.4850         1.0000    2.7740    6.0697    0.1903  0 0.1624\n\n");
	printf("    EPOCHSAT\n");
	printf("        Message with the satellites used to compute the solution. It is shown for each measurement in the filter plus an\n");
	printf("        additional one with the whole measurements (shown at the end).\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'EPOCHSAT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  Measurement identifier (as string)\n");
	printf("        Field 7:  Measurement identifier used for smoothing (as string)\n");
	printf("        Field 8:  Total number of satellites selected and unselected for the current measurement\n");
	printf("        Field 9:  Total number of satellites selected for the current measurement\n");
	printf("        Field 10: GPS constellation letter     ('G')\n");
	printf("        Field 11: Total number of GPS     satellites selected for the current measurement\n");
	printf("        Field 12: Galileo constellation letter ('E')\n");
	printf("        Field 13: Total number of Galileo satellites selected for the current measurement\n");
	printf("        Field 14: GLONASS constellation letter ('R')\n");
	printf("        Field 15: Total number of GLONASS satellites selected for the current measurement\n");
	printf("        Field 16: GEO constellation letter     ('S')\n");
	printf("        Field 17: Total number of GEO     satellites selected for the current measurement\n");
	printf("        Field 18: BeiDou constellation letter  ('C')\n");
	printf("        Field 19: Total number of BeiDou  satellites selected for the current measurement\n");
	printf("        Field 20: QZSS constellation letter    ('J')\n");
	printf("        Field 21: Total number of QZSS    satellites selected for the current measurement\n");
	printf("        Field 22: IRNSS constellation letter   ('I')\n");
	printf("        Field 23: Total number of IRNSS   satellites selected for the current measurement\n");
	printf("        Field 24: Total number of satellites unselected for the current measurement\n");
	printf("        Field 25: GPS constellation letter     ('G')\n");
	printf("        Field 26: Total number of GPS     satellites unselected for the current measurement\n");
	printf("        Field 27: Galileo constellation letter ('E')\n");
	printf("        Field 28: Total number of Galileo satellites unselected for the current measurement\n");
	printf("        Field 29: GLONASS constellation letter ('R')\n");
	printf("        Field 30: Total number of GLONASS satellites unselected for the current measurement\n");
	printf("        Field 31: GEO constellation letter     ('S')\n");
	printf("        Field 32: Total number of GEO     satellites unselected for the current measurement\n");
	printf("        Field 33: BeiDou constellation letter  ('C')\n");
	printf("        Field 34: Total number of BeiDou  satellites unselected for the current measurement\n");
	printf("        Field 35: QZSS constellation letter    ('J')\n");
	printf("        Field 36: Total number of QZSS    satellites unselected for the current measurement\n");
	printf("        Field 37: IRNSS constellation letter   ('I')\n");
	printf("        Field 38: Total number of IRNSS   satellites unselected for the current measurement\n");
	printf("        Field 39-: Satellite list. Each following column is a '+' or '-' sign, the satellite system and the PRN identifier.\n");
	printf("                   The '+' sign indicates that the satellite has been used in the solution computation.\n");
	printf("                   The '-' sign indicates that the satellite has not been used in the solution computation\n");
	printf("                   The satellite list will show first all the satellites with the '+' and after the ones with the '-' sign (ordered by constellation).\n\n");
	printf("        If the EPOCHSAT line refers to all measurements used in the filter, field 6 will have the value \"ALL\"\n");
	printf("        If no smoothing is enabled, field 7 will be a dash ('-').\n");
	printf("        If smoothing is enabled, field 7 is the measurement used for smoothing.\n");
	printf("        Sample:\n");
	printf("            EPOCHSAT  2018 130 86280.00 23:58:00.00          C5X            - 20  +8 G  4 E  4 R  0 S  0 C  0 J  0 I  0 -12 G 10 E  1 R  0 S  0 C  0 J  1 I  0 +G01 +G09 +G06 +G03 +E05 +E24 +E26 +E03 -G31 -G12 -G23 -G17 -G18 -G14 -G25 -G11 -G19 -G22 -E08 -J02\n\n");
	printf("    POSTFIT\n");
	printf("        Postfilter values message. It provides the corrected prefits with the filter estimation.\n");
	printf("        It is shown in each filter execution.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'POSTFIT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  GNSS System\n");
	printf("        Field 7:  PRN satellite identifier\n");
	printf("        Field 8:  Satellite block type\n");
	printf("        Field 9:  SVN (Space Vehicle Number)\n");
	printf("        Field 10: Arc number\n");
	printf("        Field 11: Arc length\n");
	printf("        Field 12: Satellite elevation [degrees]\n");
	printf("        Field 13: Satellite azimuth [degrees]\n");
	printf("        Field 14: Measurement identifier (as string)\n");
	printf("        Field 15: Measurement identifier for smoothing (as string)\n");
	printf("        Field 16: Measurement-corrected model value (postfit) [m]\n");
	printf("        Field 17: Measurement value [m]\n");
	printf("        Field 18: Smoothed measurement value[m]\n");
	printf("        Field 19: Corrected model value with the filter estimations [m]\n");
	printf("        Field 20: Estimated inter-system clock bias [m]\n");
	printf("        Field 21: Estimated carrier phase ambiguity (only for carrier phases) [m]\n");
	printf("        Field 22: Reserved\n");
	printf("        Field 23: Reserved\n");
	printf("        Field 24: Reserved\n\n");
	printf("        If no smoothing is enabled, field 15 will be a dash ('-') and field 18 will be 0.\n");
	printf("        If smoothing is enabled, field 15 is the measurement used for smoothing.\n");
	printf("        Field 21 will be zero if measurement is not a carrier phase or ambiguity estimation is disabled\n");
	printf("        Fields 22, 23 and 24 will be zero if the any of these parameters (ionosphere, satellite DCB and receiver DCB) are not estimated in the filter\n");
	printf("        Sample:\n");
	printf("            POSTFIT   2019 025 85862.00 23:51:02.00 GPS 21 BLOCK_IIR-A       45   1    363   38.373   61.866          C1C          L1P         0.0803  37372802.1720  37372802.0569  37372801.9021         0.0000         0.0000         0.0000         0.0000         0.0000\n\n");
	printf("    FILTER\n");
	printf("        Filter solution message. This message provides direct information on the filter estimates. It is shown\n");
	printf("        in each filter execution.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'FILTER'\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   Constellation used as reference clock\n");
	printf("        Field 7:   Number of inter-sytem clock bias estimated in the filter\n");
	printf("        Field 8:   Number of unknowns estimated in the filter\n");
	printf("        Field 9:   Receiver X position [m]\n");
	printf("        Field 10:  Receiver Y position [m]\n");
	printf("        Field 11:  Receiver Z position [m]\n");
	printf("        Field 12:  Receiver clock offset [m]\n"); 
	printf("        Field 13:  GPS inter-system clock bias [m]\n"); 
	printf("        Field 14:  Galileo inter-system clock bias [m]\n"); 
	printf("        Field 15:  GLONASS inter-system clock bias [m]\n"); 
	printf("        Field 16:  GEO inter-system clock bias [m]\n"); 
	printf("        Field 17:  BeiDou inter-system clock bias [m]\n"); 
	printf("        Field 18:  QZSS inter-system clock bias [m]\n"); 
	printf("        Field 19:  IRNSS inter-system clock bias [m]\n\n"); 
	printf("        If troposphere is estimated in the filter, the next field will appear:\n");
	printf("          Field 20:  Zenith Tropospheric Delay (vertical wet component) [m]\n\n");
//	printf("          Field 21:  Receiver wind-up [m]\n");
	printf("        If any of the inter-system clock biases in fields 13-19 is not estimated in the filter, its value will be 0.\n");
	printf("        Sample:\n");
	printf("           FILTER    2018 130     7.00 00:00:07.00 GPS 3 38   3924697.5020    301125.3025   5001905.0392       -10.2643         0.0000         1.8811         5.6634         0.0000         3.0240         0.0000         0.0000         2.4869\n");
	printf("    OUTPUT\n");
	printf("        Receiver solution message. This message provides the estimated receiver position in WGS84 system.\n");
	printf("        It is shown in each filter execution.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'OUTPUT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Time in HH:MM:SS.zz format\n");
	printf("        Field 6:  Processing mode indicator\n");
	printf("        Field 7:  Processing direction indicator\n");
	printf("        Field 8:  Number of satellites used in the navigation solution\n");
	printf("        Field 9:  Number of constellations used in the navigation solution\n");
	printf("        Field 10: List of constellations used in the filter (separated by dashes ('-')\n");
	printf("        Field 11: Square root of the sum of the X, Y and Z components of the covariance matrix. This is a measure of the convergence of the filter\n");
	printf("        Field 12: Receiver X position [m]\n");
	printf("        Field 13: Receiver Y position [m]\n");
	printf("        Field 14: Receiver Z position [m]\n");
	printf("        Field 15: Receiver X position - Nominal a priori X position [m]\n");
	printf("        Field 16: Receiver Y position - Nominal a priori Y position [m]\n");
	printf("        Field 17: Receiver Z position - Nominal a priori Z position [m]\n");
	printf("        Field 18: Receiver X formal error [m]\n");
	printf("        Field 19: Receiver Y formal error [m]\n");
	printf("        Field 20: Receiver Z formal error [m]\n");
	printf("        Field 21: Receiver latitude [degrees]\n");
	printf("        Field 22: Receiver longitude [degrees]\n");
	printf("        Field 23: Receiver height [m]\n");
	printf("        Field 24: Receiver North difference in relation to nominal a priori position [m]\n");
	printf("        Field 25: Receiver East difference in relation to nominal a priori position [m]\n");
	printf("        Field 26: Receiver Up difference in relation to nominal a priori position [m]\n");
	printf("        Field 27: Receiver formal error in North direction [m]\n");
	printf("        Field 28: Receiver formal error in East direction [m]\n");
	printf("        Field 29: Receiver formal error in Up direction [m]\n");
	printf("        Field 30: Receiver horizontal difference in relation to nominal a priori position [m]\n");
	printf("        Field 31: Receiver vertical difference in relation to nominal a priori position (absolute value of the error in Up direction) [m]\n");
	printf("        Field 32: Receiver 3D difference in relation to nominal a priori position [m]\n");
	printf("        Field 33: Constellation used as reference clock\n");
	printf("        Field 34: Receiver clock offset [m]\n");
	printf("        Field 35: Receiver clock formal error [m]\n");
	printf("        Field 36: Geometric Dilution of Precision (GDOP)\n");
	printf("        Field 37: Positioning Dilution of Precision (PDOP)\n");
	printf("        Field 38: Time Dilution of Precision (TDOP)\n");
	printf("        Field 39: Horizontal Dilution of Precision (HDOP)\n");
	printf("        Field 40: Vertical Dilution of Precision (VDOP)\n");
	printf("        Field 41: Zenith Tropospheric Delay (including nominal value) [m]\n");
	printf("        Field 42: Zenith Tropospheric Delay (excluding nominal value) [m]\n");
	printf("        Field 43: Zenith Tropospheric Delay formal error [m]\n\n");
	printf("        The fields 41, 42 and 43 will be zero if troposphere is not estimated (only estimated in PPP mode)\n");
	printf("        Processing mode indicator in field 6 may have the following values:\n");
	printf("           0 -> SPP\n");
	printf("           1 -> PPP\n");
	printf("           2 -> Reserved\n");
	printf("           3 -> Reserved\n");
	printf("           4 -> Reserved\n");
	printf("           5 -> SBAS 1 Frequency\n");
	printf("           6 -> SBAS DFMC\n");
	printf("           7 -> DGNSS\n");
	printf("        Processing direction indicator in field 7 may have the following values:\n");
	printf("           0 -> Forward processing\n");
	printf("           1 -> Backwards processing (not possible in SBAS and DGNSS modes)\n");
	printf("        The nominal a priori position is a prerequisite of the processing, and can be specified or read from the RINEX\n");
	printf("        input file. See the option '-pre:setrecpos' in the help ('-help') for more details.\n");
	printf("        Sample:\n");
	printf("            OUTPUT    2019 099 86100.00 23:55:00.00 1 0 30 5 GPS+GAL+GLO+BDS+QZS    0.0040  -6257572.1031    950333.4266    785215.5957     0.0265    -0.0182    -0.0044     0.0036     0.0016     0.0009    7.119151644  171.364514044        33.6692    -0.0008     0.0140    -0.0292     0.0013     0.0015     0.0035 GPS         1.4242         0.0573    0.0000    0.0000    0.0000    0.0000    0.0000     2.7166     0.3260     0.0035\n\n");
	printf("    SBASCORR [SBAS 1F processing mode]\n");
	printf("        SBAS corrections breakdown. It is shown when a model can be fully computed using SBAS corrections for GPS C1C measurement.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASCORR' (if it is used in computation) or 'SBASCORR*' (if it is not)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System (GPS, GLO or GEO)\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite block type\n");
	printf("        Field 9:   SVN (Space Vehicle Number)\n");
	printf("        Field 10:  Arc number\n");
	printf("        Field 11:  Arc length\n");
	printf("        Field 12:  Satellite elevation [degrees]\n");
	printf("        Field 13:  Satellite azimuth [degrees]\n");
	printf("        Field 14:  SBAS processing mode (PA or NPA)\n");
	printf("        Field 15:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 16:  Measurement-model value (prefit) [m]\n");
	printf("        Field 17:  Measurement value without smoothing [m]\n");
	printf("        Field 18:  Measurement value with smoothing [m]\n");
	printf("        Field 19:  Satellite-receiver geometric distance (with SBAS corrections) [m]\n");
	printf("        Field 20:  Relativity correction (with SBAS corrections) [m]\n");
	printf("        Field 21:  Satellite clock correction (with SBAS corrections) [m]\n");
	printf("        Field 22:  Total Group Delay (TGD) correction [m]\n");
	printf("        Field 23:  Ionosphere pierce point latitude [-90..90 degrees]\n");
	printf("        Field 24:  Ionosphere pierce point longitude [0..360 degrees]\n");
	printf("        Field 25:  Ionosphere correction [m]\n");
	printf("        Field 26:  Troposphere nominal correction [m]\n");
	printf("        Field 27:  PRC (fast correction) applied to the satellite [m]\n");
	printf("        Field 28:  RRC (range-rate correction) applied to the satellite [m]\n");
	printf("        Field 29:  Fast correction degradation factor [m/s^2]\n");
	printf("        Field 30:  PRC time out [s]\n");
	printf("        Field 31:  RRC time out (smallest PRC time out for all satellites) [s]\n");
	printf("        Field 32:  Time (seconds of day) used for computing PRC timeout [s]\n");
	printf("        Field 33:  Time (seconds of day) used for computing sigma UDRE (User Differential Range Error) timeout [s]\n");
	printf("        Field 34:  Time (seconds of day) used for computing fast correction degradation [s]\n");
	printf("        Field 35:  X component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 36:  Y component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 37:  Z component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 38:  Long term correction to be applied to the X component of the satellite [m]\n");
	printf("        Field 39:  Long term correction to be applied to the Y component of the satellite [m]\n");
	printf("        Field 40:  Long term correction to be applied to the Z component of the satellite [m]\n");
	printf("        Field 41:  Long term correction to be applied to the satellite clock [m]\n");
	printf("        Field 42:  IODP (Issue of Data PRN mask) used for fast corrections\n");
	printf("        Field 43:  IODF (Issue of Data Fast Correction) in messages type 2-5,24 for fast corrections\n");
	printf("        Field 44:  Satellite slot in the fast correction mask [1..51]\n");
	printf("        Field 45:  IODP used for long term corrections\n");
	printf("        Field 46:  Satellite slot in the long term correction mask [1..51]\n");
	printf("        Field 47:  IODE (Issue of Data Ephemeris) used for broadcast ephemeris\n");
	printf("        Field 48:  IODS (Service Issue of Data) used for service message\n");
	printf("        Field 49:  IODP used for covariance matrix\n");
	printf("        Field 50:  Satellite slot in the covariance mask [1..51]\n");
	printf("        Field 51:  Ionosphere model flag\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Field 47 is the IODE value from the broadcast message matched with the SBAS long term corrections. If the field value is negative,\n");
	printf("        it means that the IODE used does not match any SBAS long term correction message available (only in NPA mode). A value of 999 means\n");
	printf("        that no valid broadcast message was found for the current epoch.\n");
	printf("        Field 51 is a flag to indicate which ionosphere model is used. Its possible values are '-1' for no ionosphere model,\n");
	printf("         '0' for SBAS ionosphere model, '1' for Klobuchar ionosphere model and '2' for any other ionosphere model\n");
	printf("        Sample:\n");
	printf("            SBASCORR    2019 025 85862.00 23:51:02.00 GPS  10 BLOCK_IIF         73   1    363   46.442  148.754  PA 136  14508354.8230  36155216.6800  36155216.4923  21685564.5283         0.0277    -38710.0294         0.5584        45.0657        10.6000         1.1513         3.0581 -2.3750         0.0000 0.00580        12.0000        12.0000 85858.1 85858.1 85858.1  22933506.0221  11292690.1329   7615397.5010  -0.25000  -2.12500   0.25000   1.81482  1  0  9  1  9   49  0 -1 -1  0\n\n");
	printf("    SBASVAR [SBAS 1F processing mode]\n");
	printf("        SBAS variance contributions breakdown. It is shown when a model can be fully computed using SBAS corrections for GPS C1C measurement.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASVAR' (if it is used in computation) or 'SBASVAR*' (if it is not)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System (GPS, GLO or GEO)\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite block type\n");
	printf("        Field 9:   SVN (Space Vehicle Number)\n");
	printf("        Field 10:  Arc number\n");
	printf("        Field 11:  Arc length\n");
	printf("        Field 12:  Satellite elevation [degrees]\n");
	printf("        Field 13:  Satellite azimuth [degrees]\n");
	printf("        Field 14:  SBAS processing mode (PA or NPA)\n");
	printf("        Field 15:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 16:  Sigma of the total residual error associated to the satellite [m]\n");
	printf("        Field 17:  Sigma of the residual error associated to the fast and long-term corrections [m]\n");
	printf("        Field 18:  Sigma of the UDRE [m]\n");
	printf("        Field 19:  Delta UDRE (User Differential Range Error) factor\n");
	printf("        Field 20:  Data source (SBAS message type number) for Delta UDRE\n");
	printf("        Field 21:  Degradation parameter for fast correction data [m]\n");
	printf("        Field 22:  Degradation parameter for range rate correction data [m]\n");
	printf("        Field 23:  Degradation parameter for long term correction data or GEO navigation message data [m]\n");
	printf("        Field 24:  Degradation parameter for en route through NPA applications [m]\n");
	printf("        Field 25:  RSS (Root-Sum-Square) flag in message type 10\n");
	printf("        Field 26:  Sigma of the residual error associated to the ionosheric corrections [m]\n");
	printf("        Field 27:  Sigma of the residual error associated to the tropospheric corrections [m]\n");
	printf("        Field 28:  Sigma of the total receiver error [m]\n");
	printf("        Field 29:  Sigma of the receiver noise [m]\n");
	printf("        Field 30:  Sigma of the receiver multipath [m]\n");
	printf("        Field 31:  Sigma of the receiver divergence [m]\n");
	printf("        The data source indicator for Delta UDRE in field 20 may have the following values:\n"); 
	printf("          28 or 29 for their respective message type,\n");
	printf("          -28 or -29 if received any of these message types but there was missing data for current satellite or was timed out,\n");
	printf("          0 if no message type received or both received.\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Sample:\n");
	printf("            SBASVAR     2019 025 85862.00 23:51:02.00 GPS   8 BLOCK_IIF         72   1    363   29.725  -64.905  PA 136         1.8196         1.0975         0.9119    1.000  27         0.1856         0.0000         0.0000         0.0000 0         1.3762         0.2413         0.3928    0.360    0.157    0.000\n\n");
	printf("    SBASIONO [SBAS 1F processing mode]\n");
	printf("        SBAS ionosphere breakdown. It is shown when SBAS ionosphere can be computed.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASIONO' (if it is used in computation) or 'SBASIONO*' (if it is not)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite elevation [degrees]\n");
	printf("        Field 9:   Satellite azimuth [degrees]\n");
	printf("        Field 10:  SBAS processing mode (PA or NPA)\n");
	printf("        Field 11:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 12:  Ionosphere pierce point latitude [-90..90 degrees]\n");
	printf("        Field 13:  Ionosphere pierce point longitude [0..360 degrees]\n");
	printf("        Field 14:  Interpolation mode. 0 for square interpolation, [1-4] indicates the vertex not used in triangle interpolation\n");
	printf("        Field 15:  IODI (Issue of Data Ionospheric) for vertex 1\n");
	printf("        Field 16:  Band Number for vertex 1\n");
	printf("        Field 17:  IGP Number for vertex 1\n");
	printf("        Field 18:  Time of reception of last bit of vertex 1 IGP [seconds of day]\n");
	printf("        Field 19:  Latitude of the IGP for vertex 1 [-90..90 degrees]\n");
	printf("        Field 20:  Longitude of the IGP for vertex 1 [0..360 degrees]\n");
	printf("        Field 21:  Ionosphere delay (raw value from MT26) for vertex 1 [L1 m]\n");
	printf("        Field 22:  Ionosphere variance (raw value from MT26) for vertex 1 [L1 m^2]\n");
	printf("        Field 23:  Degradation term for vertex 1 [L1 m]\n");
	printf("        Field 24:  Ionosphere delay after interpolation (if required) for vertex 1 [L1 m]\n");
	printf("        Field 25:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 1 [L1 m^2]\n");
	printf("        Field 26:  Interpolation weight for vertex 1\n");
	printf("        Field 27:  IODI for vertex 2\n");
	printf("        Field 28:  Band Number for vertex 2\n");
	printf("        Field 29:  IGP Number for vertex 2\n");
	printf("        Field 30:  Time of reception of last bit of vertex 2 IGP [seconds of day]\n");
	printf("        Field 31:  Latitude of the IGP for vertex 2 [-90..90 degrees]\n");
	printf("        Field 32:  Longitude of the IGP for vertex 2 [0..360 degrees]\n");
	printf("        Field 33:  Ionosphere delay (raw value from MT26) for vertex 2 [L1 m]\n");
	printf("        Field 34:  Ionosphere variance (raw value from MT26) for vertex 2 [L1 m^2]\n");
	printf("        Field 35:  Degradation term for vertex 2 [L1 m]\n");
	printf("        Field 36:  Ionosphere delay after interpolation (if required) for vertex 2 [L1 m]\n");
	printf("        Field 37:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 2 [L1 m^2]\n");
	printf("        Field 38:  Interpolation weight for vertex 2\n");
	printf("        Field 39:  IODI for vertex 3\n");
	printf("        Field 40:  Band Number for vertex 3\n");
	printf("        Field 41:  IGP Number for vertex 3\n");
	printf("        Field 42:  Time of reception of last bit of vertex 3 IGP [seconds of day]\n");
	printf("        Field 43:  Latitude of the IGP for vertex 3 [-90..90 degrees]\n");
	printf("        Field 44:  Longitude of the IGP for vertex 3 [0..360 degrees]\n");
	printf("        Field 45:  Ionosphere delay (raw value from MT26) for vertex 3 [L1 m]\n");
	printf("        Field 46:  Ionosphere variance (raw value from MT26) for vertex 3 [L1 m^2]\n");
	printf("        Field 47:  Degradation term for vertex 3 [L1 m]\n");
	printf("        Field 48:  Ionosphere delay after interpolation (if required) for vertex 3 [L1 m]\n");
	printf("        Field 49:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 3 [L1 m^2]\n");
	printf("        Field 50:  Interpolation weight for vertex 3\n");
	printf("        Field 51:  IODI for vertex 4\n");
	printf("        Field 52:  Band Number for vertex 4\n");
	printf("        Field 53:  IGP Number for vertex 4\n");
	printf("        Field 54:  Time of reception of last bit of vertex 4 IGP [seconds of day]\n");
	printf("        Field 55:  Latitude of the IGP for vertex 4 [-90..90 degrees]\n");
	printf("        Field 56:  Longitude of the IGP for vertex 4 [0..360 degrees]\n");
	printf("        Field 57:  Ionosphere delay (raw value from MT26) for vertex 4 [L1 m]\n");
	printf("        Field 58:  Ionosphere variance (raw value from MT26) for vertex 4 [L1 m^2]\n");
	printf("        Field 59:  Degradation term for vertex 4 [L1 m]\n");
	printf("        Field 60:  Ionosphere delay after interpolation (if required) for vertex 4 [L1 m]\n");
	printf("        Field 61:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 4 [L1 m^2]\n");
	printf("        Field 62:  Interpolation weight for vertex 4\n");
	printf("        Field 63:  Mapping function\n");
	printf("        Field 64:  Slant delay [L1 m]\n");
	printf("        Field 65:  Slant Sigma [L1 m]\n");
	printf("        Vertex 1 is the IGP north east to IPP, vertex 2 is the IGP north west to IPP, vertex 3 is the IGP south west to IPP,\n");
	printf("        vertex 4 is the IGP south east to IPP. This order is shown in the following figure:\n");
	printf("                            NORTH\n");
	printf("                      v2..............v1\n");
	printf("                      .               .\n");
	printf("                      .               .\n");
	printf("                      .               .\n");
	printf("           WEST       .    IPP        .       EAST\n");
	printf("                      .     *         .\n");
	printf("                      .               .\n");
	printf("                      .               .\n");
	printf("                      v3..............v4\n");
	printf("                            SOUTH\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Sample:\n");
	printf("            SBASIONO     2019 025 85862.00 23:51:02.00 GPS  21   38.373   61.866  PA 136   49.061   13.442 0 0  4 200 85795.1  50  15  0.625   0.5322  0.000   0.6250   0.5322 0.5591 0  4 175 85795.1  50  10  0.625   0.5322  0.000   0.6250   0.5322 0.2531 0  4 174 85795.1  45  10  0.875 0.5322  0.000   0.8750   0.5322 0.0585 0  4 199 85795.1  45  15  0.875   0.5322  0.000   0.8750   0.5322 0.1293   1.4946   1.0043   1.0904\n\n");
	printf("    SBASUNSEL [SBAS 1F processing mode]\n");
	printf("        SBAS satellite unselection message. When a satellite is discarded due to MOPS criteria, this message details the reason.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASUNSEL' (if it is the definitive reason for discarding) or 'SBASUNSEL*' (if there has been a GEO or mode switch or not reached smoothed code steady-state operation)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System (GPS, GLO or GEO)\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 9:   GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 10:  Error code\n");
	printf("        Field 11:  \"Discard reason\"\n\n");
	printf("        The error code in field 10 is a number which identifies the discard reason with a range from 1 to 48. Useful for parsing purposes.\n");
	printf("        Field 11 will be always between quotes in order to ease parsing purposes.\n");
	printf("        Fields 10 and 11 may have the following values:\n");
	printf("          1    \"No GEO satellites available\"\n");
	printf("          2    \"No data for user selected GEO\"\n");
	printf("          3    \"Not enough almanac or GEO navigation message to determine the GEO with highest elevation\"\n");
	printf("          4    \"Received alarm message for current GEO at epoch <YYYY DoY SoD>. Time remaining to finish alarm: <seconds> seconds\"\n");
	printf("          5    \"Received <value> consecutive messages with errors (UDREI data has been forced to timeout) [PA only]\"\n");
	printf("          6    \"Missed <value> consecutive messages\"\n");
	printf("          7    \"No PRN mask\"\n");
	printf("          8    \"PRN mask timed out\"\n");
	printf("          9    \"Satellite is not monitored in any of the PRN mask available\"\n");
	printf("          10   \"No message type 10 available [PA only]\"\n");
	printf("          11   \"Message type 10 timed out [PA only]\"\n");
	printf("          12   \"No fast correction data received for current PRN [PA only]\"\n");
	printf("          13   \"Sigma UDRE timed out [PA only]\"\n");
	printf("          14   \"Satellite flagged as 'Not monitored' (UDREI=14)\"\n");
	printf("          15   \"Satellite flagged as 'Do not use' (UDREI=15)\"\n");
	printf("          16   \"Satellite has an UDREI value of <value> [PA only]\n");
	printf("          17   \"No fast correction degradation data [PA only]\"\n");
	printf("          18   \"Fast correction degradation data timed out [PA only]\"\n");
	printf("          19   \"Last PRC received timed out [PA only]\"\n");
	printf("          20   \"Only one PRC received. RRC calculation not possible [PA only]\"\n");
	printf("          21   \"RRC timed out (under alarm condition) due to time difference between PRC used [PA only]\"\n");
	printf("          22   \"RRC timed out (under alarm condition) due to excessive PRC propagation in time [PA only]\"\n");
	printf("          23   \"RRC timed out due to time difference between PRC used [PA only]\"\n");
	printf("          24   \"RRC timed out due to excessive PRC propagation in time [PA only]\"\n");
	printf("          25   \"Service message timed out [PA only]\"\n");
	printf("          26   \"Not received a full set of service messages with the same IODS [PA only]\"\n");
	printf("          27   \"No clock-ephemeris covariance matrix data for current satellite [PA only]\"\n");
	printf("          28   \"Clock-ephemeris covariance matrix data timed out [PA only]\"\n");
	printf("          29   \"No navigation data for ranging GEO\"\n");
	printf("          30   \"Ranging GEO navigation data timed out\"\n");
	printf("          31   \"URA index value of <value> for ranging GEO satellite\"\n");
	printf("          32   \"No long term correction data for current satellite [PA only]\"\n");
	printf("          33   \"Long term correction data timed out [PA only]\"\n");
	printf("          34   \"No broadcast block with IOD <value> [PA only]\"\n");
	printf("          35   \"No broadcast block available for current satellite (regardless of SBAS IOD) [NPA only]\"\n");
	printf("          36   \"Could not compute transmission time for current PRN measurement\"\n");
	printf("          37   \"No ionospheric grid mask [PA only]\"\n");
	printf("          38   \"Ionospheric grid mask timed out [PA only]\"\n");
	printf("          39   \"IGPs around ionospheric pierce point not found in MOPS grid [PA only]\"\n");
	printf("          40   \"Not enough IGPs available in ionospheric grid mask [PA only]\"\n");
	printf("          41   \"One IGP is set as don't use [PA only]\"\n");
	printf("          42   \"One or more IGPs is set as not monitored or has timed out [PA only]\"\n");
	printf("          43   \"Data not available for one or more IGPs [PA only]\"\n");
	printf("          44   \"Ionospheric pierce point is outside triangle [PA only]\"\n");
	printf("          45   \"External ionosphere model not available\"\n");
	printf("          46   \"Satellite has an UDREI value of <value> (user threshold is <value>)\"\n\n");
	printf("          47   \"Satellite is not in view (elevation <value> degrees)\"\n");
	printf("          48   \"Satellite elevation (<value> degrees) is too low\"\n");
	printf("        Error code number 45 will only appear if user has selected another ionosphere model for SBAS processing\n");
	printf("        Error codes number 46 and 47 will only appear in SBAS plots mode\n");
	printf("        Sample:\n");
	printf("            SBASUNSEL   2019 026  4102.00 01:08:22.00 GPS  26  PA 136 15 \"Satellite flagged as 'Do not use' (UDREI=15)\"\n\n");
	printf("    SBASDFMCCORR [SBAS DFMC processing mode]\n");
	printf("        SBAS corrections breakdown. It is shown when a model can be fully computed using SBAS DFMC corrections with iono-free measurements.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASDFMCCORR' (if it is used in computation) or 'SBASDFMCCORR*' (if it is not)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System (GPS, GAL, GLO, GEO or BDS)\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite block type\n");
	printf("        Field 9:   SVN (Space Vehicle Number)\n");
	printf("        Field 10:  Arc number\n");
	printf("        Field 11:  Arc length\n");
	printf("        Field 12:  Satellite elevation [degrees]\n");
	printf("        Field 13:  Satellite azimuth [degrees]\n");
	printf("        Field 14:  SBAS processing mode (PA or NPA)\n");
	printf("        Field 15:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 16:  Measurement identifier (as string)\n");
	printf("        Field 17:  Measurement identifier for smoothing (as string)\n");
	printf("        Field 18:  Measurement-model value (prefit) [m]\n");
	printf("        Field 19:  Measurement value without smoothing [m]\n");
	printf("        Field 20:  Measurement value with smoothing [m]\n");
	printf("        Field 21:  Satellite-receiver geometric distance (with SBAS corrections) [m]\n");
	printf("        Field 22:  Relativity correction (with SBAS corrections) [m]\n");
	printf("        Field 23:  Satellite clock correction (with SBAS corrections) [m]\n");
	printf("        Field 24:  GPS LNAV TGD (Total Group Delay) correction [L1 m]\n");
	printf("        Field 25:  Troposphere nominal correction [m]\n");
	printf("        Field 26:  X component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 27:  Y component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 28:  Z component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 29:  Correction to be applied to the X component of the satellite [m]\n");
	printf("        Field 30:  Correction to be applied to the Y component of the satellite [m]\n");
	printf("        Field 31:  Correction to be applied to the Z component of the satellite [m]\n");
	printf("        Field 32:  Correction to be applied to the satellite clock [m]\n");
	printf("        Field 33:  DFREI (Dual Frequency Residual Error Indicator) for the current satellite\n");
	printf("        Field 34:  Time (seconds of day) of last DFREI received [s]\n");
	printf("        Field 35:  Time (seconds of day) of last MT32 received [s]\n");
	printf("        Field 36:  Time (seconds of day) of last MT39/40 pair received [s]\n");
	printf("        Field 37:  Validity time of MT32 [s]\n");
	printf("        Field 38:  Validity time of MT39/40 message pair [s]\n");
	printf("        Field 39:  IODM (Issue of Data Mask) used for corrections\n");
	printf("        Field 40:  IODN (Issue of Data Navigation) for non GEO satellites or IODG (Issue of Data GEO) for GEO satellites\n");
	printf("        Field 41:  Slot Number in PRN mask\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        If no smoothing is enabled, field 17 will be a dash ('-')\n");
	printf("        Field 24 will be 0 for non GPS satellites, as TGD is only applied in GPS constellation.\n");
	printf("        Field 35 will be -1 when ranging satellite is the same as the GEO providing the corrections.\n");
	printf("        Field 36 will be -1 when ranging satellite is not a GEO satellite.\n");
	printf("        Field 37 will be 0 when ranging satellite is the same as the GEO providing the corrections.\n");
	printf("        Field 38 will be 0 when ranging satellite is not a GEO satellite.\n");
	printf("        Field 40 is the IODE value from the broadcast message matched with the SBAS corrections.\n");
	printf("        Sample:\n");
	printf("            SBASDFMCCORR    2019 183   366.00 00:06:06.00 GAL  12 GALILEO-1        102   1    367   56.240 -131.144  PA 122 PC15-C1C-C5Q LC15-L1C-L5Q    -77661.5914  22118290.4022  22118290.5451  24090622.3075    -0.2348  -1894344.7968     0.0000     2.8714   1063555.2596  20678074.5523 -21146925.6105   0.5000  -0.1250  -0.0625   1.5938  6   365.12   331.12    -1.00   240.00     0.00 0   30  86\n\n");
	printf("    SBASDFMCVAR [SBAS DFMC processing mode]\n");
	printf("        SBAS variance contributions breakdown. It is shown when a model can be fully computed using SBAS DFMC corrections with iono-free measurements.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASDFMCVAR' (if it is used in computation) or 'SBASDFMCVAR*' (if it is not)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System (GPS, GAL, GLO, GEO or BDS)\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   Satellite block type\n");
	printf("        Field 9:   SVN (Space Vehicle Number)\n");
	printf("        Field 10:  Arc number\n");
	printf("        Field 11:  Arc length\n");
	printf("        Field 12:  Satellite elevation [degrees]\n");
	printf("        Field 13:  Satellite azimuth [degrees]\n");
	printf("        Field 14:  SBAS processing mode (PA or NPA)\n");
	printf("        Field 15:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 16:  Sigma of the total residual error associated to the satellite [m]\n");
	printf("        Field 17:  DFC (Dual Frequency Corrections) sigma (residual error associated to SBAS corrections) [m]\n");
	printf("        Field 18:  DFREI (Dual Frequency Residual Error Indicator) for the current satellite\n");
	printf("        Field 19:  Flag to indicate if DFREI has been bumped by 1 (0->not bumped, 1->bumped) through MT34\n");
	printf("        Field 20:  DFRE (Dual Frequency Residual Error) sigma converted from DFREI [m]\n");
	printf("        Field 21:  Delta DFRE factor\n");
	printf("        Field 22:  Degradation parameter for corrections [m]\n");
	printf("        Field 23:  Degradation parameter for en route through NPA applications [m]\n");
	printf("        Field 24:  Sigma of the residual error associated to the ionosheric corrections [m]\n");
	printf("        Field 25:  Sigma of the residual error associated to the tropospheric corrections [m]\n");
	printf("        Field 26:  Sigma of the total receiver error [m]\n");
	printf("        Field 27:  Sigma of the receiver noise [m]\n");
	printf("        Field 28:  Sigma of the receiver multipath [m]\n");
	printf("        Field 29:  Sigma of the receiver divergence [m]\n");
	printf("        Field 30:  Ccorr used for computing degradation terms [m]\n");
	printf("        Field 31:  Icorr used for computing degradation terms [s]\n");
	printf("        Field 32:  Rcorr used for computing degradation terms [m/s]\n");
	printf("        Field 33:  DeltaRcorr factor used for computing degradation terms\n");
	printf("        Field 34:  Computed RcorrSV used for computing degradation terms [m/s]\n");
	printf("        Field 35:  Cer used for computing degradation terms [m]\n");
	printf("        Field 36:  Ccovariance used for computing degradation terms [m]\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Fields 30, 31, 32, 33, 35 and 36 may be provided by MT37 or by parameter.\n");
	printf("        Sample:\n");
	printf("            SBASDFMCVAR     2019 183   366.00 00:06:06.00 GAL  26 GALILEO-2        203   1    367   14.645   32.278  PA 122         1.3482         1.0003  5 0   1.0000   1.0000   0.0230   0.0000   0.1021   0.4678   0.7667   0.4000   0.6541   0.0000   0.1900  36.0000   0.0010   1.0000   0.0010   0.0000   0.0000\n\n");
	printf("    SBASDFMCUNSEL [SBAS DFMC processing mode]\n");
	printf("        SBAS satellite unselection message. When a satellite is discarded due to MOPS DFMC criteria, this message details the reason.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASDFMCUNSEL' (if it is the definitive reason for discarding) or 'SBASDFMCUNSEL*' (if there has been a GEO or mode switch or not reached smoothed code steady-state operation)\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System (GPS, GLO or GEO)\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 9:   GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 10:  Error code\n");
	printf("        Field 11:  \"Discard reason\"\n\n");
	printf("        The error code in field 10 is a number which identifies the discard reason with a range from 1 to 27. Useful for parsing purposes.\n");
	printf("        Field 11 will be always between quotes in order to ease parsing purposes.\n");
	printf("        Fields 10 and 11 may have the following values:\n");
	printf("          1    \"No GEO satellites available\"\n");
	printf("          2    \"No data for user selected GEO\"\n");
	printf("          3    \"Not enough almanac or GEO navigation message to determine the GEO with highest elevation\"\n");
	printf("          4    \"Received alarm message for current GEO at epoch <YYYY DoY SoD>. Time remaining to finish alarm: <seconds> seconds\"\n");
	printf("          5    \"Received <value> consecutive messages with errors (DFREI data has been forced to timeout)\"\n");
	printf("          6    \"Missed <value> consecutive messages\"\n");
	printf("          7    \"No PRN mask\"\n");
	printf("          8    \"PRN mask timed out\"\n");
	printf("          9    \"Satellite is not monitored in any of the PRN mask available\"\n");
	printf("          10   \"No message type 37 available\"\n");
	printf("          11   \"Message type 37 timed out\"\n");
	printf("          12   \"No DFREI data received for current PRN\"\n");
	printf("          13   \"DFREI timed out\"\n");
	printf("          14   \"Satellite flagged as 'Do not use' (DFREI=15)\"\n");
	printf("          15   \"Received DFRECI=1 in MT34 but no new DFREI value\"\n");
	printf("          16   \"Satellite has an DFREI value of <value> (user threshold is <value>)\"\n");
	printf("          17   \"No MT39/40 from GEO <value> received (same GEO as source corrections)\"\n");
	printf("          18   \"No data from GEO <value> received for MT39/40\"\n");
	printf("          19   \"No MT39/40 message pair from GEO <value> received\"\n");
	printf("          20   \"Message type 39/40 pair timed out\"\n");
	printf("          21   \"No message type 32 received for current PRN\"\n");
	printf("          22   \"Message type 32 timed out\"\n");
	printf("          23   \"IODN in Message type 32 does not match with IODG in message type 39/40\"\n");
	printf("          24   \"Could not compute transmission time for current PRN\"\n");
	printf("          25   \"No broadcast block with IOD <value>\"\n");
	printf("          26   \"Satellite is not in view (elevation <value> degrees)\"\n");
	printf("          27   \"Satellite elevation (<value> degrees) is too low\"\n\n");
	printf("        Error code number 15 should never occur, as SARPS requirements state that in MT34 a maximum of 7 DFRECI values can be equal to 1.\n");
	printf("        Error codes number 26 and 27 will only appear in SBAS plots mode\n");
	printf("        Sample:\n");
	printf("            SBASDFMCUNSEL   2019 183   366.00 00:06:06.00 GPS  22  PA 122 14 \"Satellite flagged as 'Do not use' (DFREI=15)\"\n\n");
	printf("    SBASOUT [SBAS 1F/DFMC processing mode]\n");
	printf("        Receiver solution message. This message provides the estimated receiver position, protection levels\n");
	printf("        and satellites used in solution computation.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASOUT'\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GPS week\n");
	printf("        Field 7:   Time of week\n");
	printf("        Field 8:   Receiver id\n");
	printf("        Field 9:   Processing mode indicator\n");
	printf("        Field 10:  SBAS processing mode (PA or NPA)\n");
	printf("        Field 11:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 12:  Receiver North difference in relation to nominal a priori position [m]\n");
	printf("        Field 13:  Receiver East difference in relation to nominal a priori position [m]\n");
	printf("        Field 14:  Receiver Up difference in relation to nominal a priori position [m]\n");
	printf("        Field 15:  Horizontal positioning error [m]\n");
	printf("        Field 16:  Horizontal protection level [m]\n");
	printf("        Field 17:  Horizontal alarm limit [m]\n");
	printf("        Field 18:  Vertical positioning error [m]\n");
	printf("        Field 19:  Vertical protection level [m]\n");
	printf("        Field 20:  Vertical alarm limit [m]\n");
	printf("        Field 21:  3D positioning error [m]\n");
	printf("        Field 22:  Receiver clock offset [m]\n");
	printf("        Field 23:  Number of satellites in view suitable for SBAS\n");
	printf("        Field 24:  Number of satellites used in SBAS solution computation\n");
	printf("        Field 25-: Satellite list. Each following column is a '+' or '-' sign, the satellite system and the PRN identifier.\n");
	printf("                   The '+' sign indicates that the satellite has been used in the solution computation for SBAS.\n");
	printf("                   The '-' sign indicates that the satellite has not been used in the solution computation for SBAS.\n");
	printf("                   The satellite list will show first all the satellite with the '+' and after the ones with the '-' sign.\n\n");
	printf("        Processing mode indicator in field 9 may have the following values:\n");
	printf("           0 -> SPP (this mode will never occur when using SBAS processing)\n");
	printf("           1 -> PPP (this mode will never occur when using SBAS processing)\n");
	printf("           2 -> Reserved\n");
	printf("           3 -> Reserved\n");
	printf("           4 -> Reserved\n");
	printf("           5 -> SBAS 1 Frequency\n");
	printf("           6 -> SBAS DFMC\n");
	printf("           7 -> DGNSS (this mode will never occur when using SBAS processing)\n");
	printf("        Sample:\n");
	printf("            SBASOUT     2015 165   386.00 00:06:26.00 1849    386.00 vigo 5  PA 120         0.7862         1.4262        -0.2907         1.6285        20.9835  40.00         0.2907        21.8638  50.00         1.6543    -94936.8129 11 10 +G23 +G17 +G01 +G04 +G10 +G11 +G03 +G06 +G31 +G32 -G09\n\n");
	printf("    DGNSS [DGNSS processing mode]\n");
	printf("        DGNSS corrections breakdown. It is shown when a model can be fully computed using DGNSS corrections for GPS C1C measurement.\n");
	printf("        Messages will be sorted by constellation, with this order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:      'DGNSS' (if it is used in computation) or 'DGNSS*' (if it is not, switched to SPP)\n");
	printf("        Field 2:      Year\n");
	printf("        Field 3:      Doy\n");
	printf("        Field 4:      Seconds of day\n");
	printf("        Field 5:      Time in HH:MM:SS.zz format\n");
	printf("        Field 6:      GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 7:      PRN Satellite identifier\n");
	printf("        Field 8:      Pseudorange correction to be applied to the satellite [m]\n");
	printf("        Field 9:      Range rate correction to be applied to the satellite [m]\n");
	printf("        Field 10:     Seconds elapsed since the reception of the RRC correction [s]\n");
	printf("        Field 11:     Delta of PRC to be applied in case of change in case of a change in ephemeris [m]\n");
	printf("        Field 12:     Delta of RRC to be applied in case of change in case of a change in ephemeris [m]\n");
	printf("        Field 13:     Seconds elapsed since the reception of the delta RRC correction [s]\n");
	printf("        Field 14:     Sigma of the total residual error associated to the satellite [m]\n");
	printf("                        Sigma of the total residual error = sigma of the UDRE + sigma degradation + sigma air\n");
	printf("        Field 15:     Sigma of the UDRE (User Differential Range Error) [m]\n");
	printf("        Field 16:     Sigma degradation consists of the URA (User Range Accuracy) degradation factor (we\n");
    printf("                        assume epsURA = 1 cm/s), and the satellite elevation. It only applies for RTCM v3.x [m]\n");
	printf("                            Sigma degradation = (epsURA * dt) / tan(satellite elevation)\n");
	printf("        Field 17:     Sigma air consists of the sigma multipath, the sigma to noise GPS (we assume 0.25 m) and\n");
   	printf("                        the sigma inflation (equal to 1 if deactivated) [m]\n");
	printf("                           Sigma air = ( sigma multipath + sigma to noise GPS ) * sigma inflation\n");
	printf("        Field 18:     Sigma multipath = 0.0625 / tan(elev) / tan(elev)\n");
	printf("        Field 19:     Sigma inflation during the convergence of the smoothing\n");
	printf("        Sample:\n");
	printf("            DGNSS     2016 294  5407.000 01:30:07.00 GPS  6  -4.1800   0.0000   1.5999   0.0000   0.0000   0.0000   0.6053   0.3000   0.0000   0.5257   0.0264   1.0000\n\n");
	printf("    SUMMARY\n");
	printf("          The processing summary is printed at the end of the output file if the summary option is enabled.\n");
	printf("          The contents of the summary are:\n\n"); 
	printf("             Number of epochs processed, along with the number epochs that had a solution.\n");
	printf("             Number of epochs skipped (epochs without solution) in total and per each possible reason for skipping the epoch.\n");
	printf("             Number of epochs missing during the summary period (if decimation is enabled, the epochs missing\n");
	printf("               will be separated into the epochs which would have been decimated or not decimated.\n");
	printf("             Number of epochs missing in the whole file.\n");
	printf("             Number of data gaps during the summary period.\n");
	printf("             Number of data gaps in the whole file.\n");
	printf("             Maximum data gap size during the summary period and the epoch where it occurred.\n");
	printf("             Maximum data gap size in the whole file and the epoch where it occurred.\n");
	printf("             The number of used constellation mean value, 50 and 95 percentile (or user defined percentile).\n");
	printf("             The number of not used constellation mean value, 50 and 95 percentile (or user defined percentile). User unselected constellations will not count as not used.\n");
	printf("             The number of epochs and the percentage in respect of total epochs with solution of each set of constellations used.\n");
	printf("             The number of epochs and the percentage in respect of total epochs with solution of each set of constellations not used. User unselected constellations will not count as not used.\n");
	printf("             The number of used satellites (in total and per constellation) mean value, 50 and 95 percentile (or user defined percentile).\n");
	printf("             The number of not used satellites (in total and per constellation) mean value, 50 and 95 percentile (or user defined percentile). User unselected satellites will not count as not used.\n");
	printf("             The maximum and minimum number of satellites used (in total and per constellation) and the epochs were it ocurred.\n");
	printf("             The maximum and minimum number of satellites not used (in total and per constellation) and the epochs were it ocurred. User unselected satellites will not count as not used.\n");
	printf("             Time to first fix (first epoch with solution).\n");
	printf("             The 95 Percentile (or user defined percentile) of the PDOP,GDOP,TDOP,HDOP and VDOP.\n");
	printf("             The minimum and maximum value of PDOP,GDOP,TDOP,HDOP and VDOP and the epochs were it ocurred.\n");
	printf("             The 95 Percentile (or user defined percentile) of the horizontal, vertical, east, north and 3D errors.\n");
	printf("             The maximum highest horizontal, vertical, east, north and 3D errors and the epochs were it ocurred.\n");
	printf("             The total processing time, providing also the percentages of processing time in user mode and in kernel mode.\n");
	printf("               In the non-mutithread version of gLAB, the processing times are provided by the system function that provided thread CPU time.\n");
	printf("               In multi-thread version of gLAB, the CPU time provided by the system function is the sum of all CPU time of all threads, which\n");
	printf("                can yield a total time greater than than the real time (user perceived time) passed. In this case, gLAB will show the real time\n");
	printf("                passed (but using the user and Kernel time percentages from the system functions).\n");
	printf("               The processing time is computed just at the end of the summary, where still the print with the processing time and the last line of\n"); 
	printf("                the summary are to be done, and also the last lines of gLAB code which are for freeing memory. These last instructions add less\n");
	printf("                than 1ms of processing time for user time and less than to 0.2 seconds of Kernel time.\n");
	printf("             A single line at the end with the previous info in columnar format. This is line is useful for doing plots.\n"); 
	printf("          Additionally, for PPP processing, the following information is provided:\n");
	printf("             Convergence time (counting from the first epoch with solution) using the horizontal, vertical and 3D formal error.\n"); 
	printf("             Convergence time (counting from the first epoch with solution) using the horizontal, vertical and 3D formal error and maintained during a given period.\n"); 
	printf("             Convergence time (counting from the first epoch with solution) using the horizontal, vertical and 3D positioning error.\n"); 
	printf("             Convergence time (counting from the first epoch with solution) using the horizontal, vertical and 3D positioning error and maintained during a given period.\n"); 
	printf("          Additionally, for SBAS processing, the following information is provided:\n");
	printf("             Number of epochs with solution under alarm limits.\n"); 
	printf("             Number of epochs with MIs.\n"); 
	printf("             The 95 Percentile (or user defined percentile) of the integrity ratio.\n");
	printf("             The Best Integrity Ratio (BIR) and Worst Integrity Ratio (WIR) and the epochs were it ocurred.\n"); 
	printf("             The epoch with minimum and maximum protection levels and the epochs were it ocurred.\n"); 
	printf("             The 95 Percentile (or user defined percentile) of the protection levels.\n"); 
	printf("          Additionally, for DGNSS processing, the following information is provided:\n");
	printf("             Number of epochs missing during the summary period in the reference station file (RINEX only).\n");
	printf("             Number of epochs missing in the whole file in the reference station file (RINEX only).\n");
	printf("             Number of data gaps during the summary period in the reference station file (RINEX only)..\n");
	printf("             Number of data gaps in the whole file in the reference station file (RINEX only)..\n");
	printf("             Maximum data gap size during the summary period and the epoch where it occurred in the reference station file (RINEX only).\n");
	printf("             Maximum data gap size in the whole file and the epoch where it occurred in the reference station file (RINEX only).\n");
	printf("\n    SPP SUMMARY [SPP processing modes]\n");
    printf("        SPP statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
    printf("        Sample:\n");
	printf("          INFO --------------------- SPP Summary ---------------------\n");
	printf("          INFO First epoch of summary: 02/07/2019 00:00:00.00 / 2019 183     0.00 / 2060 172800.00\n");
	printf("          INFO Last  epoch of summary: 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Total epochs processed: 86400\n");
	printf("          INFO Total epochs processed with solution: 86320 ( 99.907%% )\n");
	printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 2 ( 0.002%% )\n");
	printf("          INFO Total epochs skipped due to singular geometry matrix: 78 ( 0.090%% )\n");
	printf("          INFO Total epochs skipped due to reference constellation not available: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped (any reason): 80 ( 0.093%% )\n");
	printf("          INFO Total epochs missing in observation file (during summary period):   0\n");
	printf("          INFO Total epochs missing in observation file (all the file):            0\n");
	printf("          INFO Number of data gaps in observation file (during summary period):   0\n");
	printf("          INFO Number of data gaps in observation file (all the file):            0\n");
	printf("          INFO Maximum data gap size in observation file (during summary period):    0\n");
	printf("          INFO Maximum data gap size in observation file (all the file):             0\n");
	printf("          INFO Time To First Fix: 2 seconds (3 epochs) at epoch 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO Constellations     used 50 Percentile:  5 |  95 Percentile:  5 | Mean:  4.99\n");
	printf("          INFO Constellations not used 50 Percentile:  1 |  95 Percentile:  1 | Mean:  1.01\n");
	printf("          INFO Number of epochs with constellations used: GPS+QZS 13 ( 0.015%% ) GPS+BDS+QZS 25 ( 0.029%% ) GPS+GEO+BDS+QZS 625 ( 0.724%% ) GPS+GAL+GEO+BDS+QZS 85657 ( 99.232%% )\n");
	printf("          INFO Number of epochs with constellations not used: GAL+GLO+GEO+BDS 13 ( 0.015%% ) GAL+GLO+GEO 25 ( 0.029%% ) GAL+GLO 625 ( 0.724%% ) GLO 85657 ( 99.232%% )\n");
	printf("          INFO Constellations used as reference clock: GPS 86320 ( 100%% )\n");
	printf("          INFO Satellites used (all constellations) 50 Percentile: 31 |  95 Percentile: 27 | Mean: 30.56\n");
	printf("          INFO Satellites used (GPS)                50 Percentile:  8 |  95 Percentile:  7 | Mean:  8.75\n");
	printf("          INFO Satellites used (GAL)                50 Percentile:  7 |  95 Percentile:  5 | Mean:  6.61\n");
	printf("          INFO Satellites used (GEO)                50 Percentile:  3 |  95 Percentile:  2 | Mean:  2.77\n");
	printf("          INFO Satellites used (BDS)                50 Percentile: 10 |  95 Percentile:  8 | Mean:  9.77\n");
	printf("          INFO Satellites used (QZS)                50 Percentile:  3 |  95 Percentile:  2 | Mean:  2.66\n");
	printf("          INFO Satellites not used (all constellations) 50 Percentile: 14 |  95 Percentile: 17 | Mean: 14.11\n");
	printf("          INFO Satellites not used (GPS)                50 Percentile:  1 |  95 Percentile:  2 | Mean:  0.74\n");
	printf("          INFO Satellites not used (GAL)                50 Percentile:  1 |  95 Percentile:  2 | Mean:  0.90\n");
	printf("          INFO Satellites not used (GLO)                50 Percentile:  7 |  95 Percentile:  9 | Mean:  7.48\n");
	printf("          INFO Satellites not used (GEO)                50 Percentile:  3 |  95 Percentile:  4 | Mean:  3.23\n");
	printf("          INFO Satellites not used (BDS)                50 Percentile:  0 |  95 Percentile:  2 | Mean:  0.42\n");
	printf("          INFO Satellites not used (QZS)                50 Percentile:  1 |  95 Percentile:  2 | Mean:  1.34\n");
	printf("          INFO Minimum satellites used (all constellations) 24 (G 5 E 5 S 3 C 8 J 3) at epoch 02/07/2019 06:28:03.00 / 2019 183 23283.00 / 2060 196083.00\n");
	printf("          INFO Minimum satellites used (GPS)                 5                       at epoch 02/07/2019 06:29:57.00 / 2019 183 23397.00 / 2060 196197.00\n");
	printf("          INFO Minimum satellites used (GAL)                 4                       at epoch 02/07/2019 16:16:00.00 / 2019 183 58560.00 / 2060 231360.00\n");
	printf("          INFO Minimum satellites used (GEO)                 1                       at epoch 02/07/2019 22:37:27.00 / 2019 183 81447.00 / 2060 254247.00\n");
	printf("          INFO Minimum satellites used (BDS)                 7                       at epoch 02/07/2019 19:53:01.00 / 2019 183 71581.00 / 2060 244381.00\n");
	printf("          INFO Minimum satellites used (QZS)                 2                       at epoch 02/07/2019 23:31:21.00 / 2019 183 84681.00 / 2060 257481.00\n");
	printf("          INFO Maximum satellites used (all constellations) 36 (G 12 E 8 S 3 C 11 J 2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Maximum satellites used (GPS)                13                         at epoch 02/07/2019 02:45:09.00 / 2019 183  9909.00 / 2060 182709.00\n");
	printf("          INFO Maximum satellites used (GAL)                10                         at epoch 02/07/2019 10:35:40.00 / 2019 183 38140.00 / 2060 210940.00\n");
	printf("          INFO Maximum satellites used (GEO)                 3                         at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Maximum satellites used (BDS)                13                         at epoch 02/07/2019 16:54:06.00 / 2019 183 60846.00 / 2060 233646.00\n");
	printf("          INFO Maximum satellites used (QZS)                 3                         at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Minimum satellites not used (all constellations) 10 (R 5 S 3 J 2) at epoch 02/07/2019 12:39:53.00 / 2019 183 45593.00 / 2060 218393.00\n");
	printf("          INFO Minimum satellites not used (GPS)                 0               at epoch 02/07/2019 23:50:17.00 / 2019 183 85817.00 / 2060 258617.00\n");
	printf("          INFO Minimum satellites not used (GAL)                 0               at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Minimum satellites not used (GLO)                 5               at epoch 02/07/2019 14:38:40.00 / 2019 183 52720.00 / 2060 225520.00\n");
	printf("          INFO Minimum satellites not used (GEO)                 3               at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Minimum satellites not used (BDS)                 0               at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Minimum satellites not used (QZS)                 1               at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Maximum satellites not used (all constellations) 37 (G 4 E 7 R 8 S 6 C 10 J 2) at epoch 02/07/2019 00:00:06.00 / 2019 183     6.00 / 2060 172806.00\n");
	printf("          INFO Maximum satellites not used (GPS)                 4                            at epoch 02/07/2019 06:21:01.00 / 2019 183 22861.00 / 2060 195661.00\n");
	printf("          INFO Maximum satellites not used (GAL)                 7                            at epoch 02/07/2019 00:11:04.00 / 2019 183   664.00 / 2060 173464.00\n");
	printf("          INFO Maximum satellites not used (GLO)                10                            at epoch 02/07/2019 18:58:55.00 / 2019 183 68335.00 / 2060 241135.00\n");
	printf("          INFO Maximum satellites not used (GEO)                 6                            at epoch 02/07/2019 00:00:39.00 / 2019 183    39.00 / 2060 172839.00\n");
	printf("          INFO Maximum satellites not used (BDS)                10                            at epoch 02/07/2019 00:00:14.00 / 2019 183    14.00 / 2060 172814.00\n");
	printf("          INFO Maximum satellites not used (QZS)                 2                            at epoch 02/07/2019 23:31:21.00 / 2019 183 84681.00 / 2060 257481.00\n");
	printf("          INFO PDOP  95 Percentile:   1.31\n");
	printf("          INFO GDOP  95 Percentile:   1.53\n");
	printf("          INFO TDOP  95 Percentile:   0.80\n");
	printf("          INFO HDOP  95 Percentile:   0.67\n");
	printf("          INFO VDOP  95 Percentile:   1.14\n");
	printf("          INFO Minimum PDOP   0.79 with 36 satellites (G 12 E  8 S  3 C 11 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Minimum GDOP   0.91 with 36 satellites (G 12 E  8 S  3 C 11 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Minimum TDOP   0.44 with 36 satellites (G 12 E  8 S  3 C 11 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Minimum HDOP   0.46 with 36 satellites (G 12 E  8 S  3 C 11 J  2) at epoch 02/07/2019 21:21:25.00 / 2019 183 76885.00 / 2060 249685.00\n");
	printf("          INFO Minimum VDOP   0.65 with 36 satellites (G 12 E  8 S  3 C 11 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Maximum PDOP   4.57 with  9 satellites (G  7 J  2)                at epoch 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO Maximum GDOP   5.74 with  9 satellites (G  7 J  2)                at epoch 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO Maximum TDOP   3.48 with  9 satellites (G  7 J  2)                at epoch 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO Maximum HDOP   2.54 with  9 satellites (G  7 J  2)                at epoch 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO Maximum VDOP   3.80 with  9 satellites (G  7 J  2)                at epoch 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO First epoch of summary for computing positioning error percentiles: 02/07/2019 00:00:02.00 / 2019 183     2.00 / 2060 172802.00\n");
	printf("          INFO Last  epoch of summary for computing positioning error percentiles: 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Horizontal  95 Positioning Error Percentile:   1.46 metres\n");
	printf("          INFO Vertical    95 Positioning Error Percentile:   3.49 metres\n");
	printf("          INFO North       95 Positioning Error Percentile:   1.22 metres\n");
	printf("          INFO East        95 Positioning Error Percentile:   1.11 metres\n");
	printf("          INFO 3D          95 Positioning Error Percentile:   3.59 metres\n");
	printf("          INFO Maximum Horizontal Positioning Error:   5.89 metres with 27 satellites (G  8 E  5 S  2 C 10 J  2) at epoch 02/07/2019 14:31:07.00 / 2019 183 52267.00 / 2060 225067.00\n");
	printf("          INFO Maximum Vertical   Positioning Error:   5.56 metres with 30 satellites (G 10 E  6 S  3 C  9 J  2) at epoch 02/07/2019 21:47:00.00 / 2019 183 78420.00 / 2060 251220.00\n");
	printf("          INFO Maximum North      Positioning Error:   2.01 metres with 26 satellites (G 10 S  3 C 10 J  3)      at epoch 02/07/2019 00:10:13.00 / 2019 183   613.00 / 2060 173413.00\n");
	printf("          INFO Maximum East       Positioning Error:   5.68 metres with 27 satellites (G  8 E  5 S  2 C 10 J  2) at epoch 02/07/2019 14:31:07.00 / 2019 183 52267.00 / 2060 225067.00\n");
	printf("          INFO Maximum 3D         Positioning Error:   6.52 metres with 27 satellites (G  8 E  5 S  2 C 10 J  2) at epoch 02/07/2019 14:31:07.00 / 2019 183 52267.00 / 2060 225067.00\n");
	printf("          INFO Total Processing time: 59.078 seconds [User time: 54.891 seconds (92.912%%) Kernel time: 4.188 seconds (7.088%%)]\n");
	printf("          INFO (2)_Station: nnor (4)_Lon: 116.19272381 (6)_Lat:  -31.04872771 (8)_Height:  234.8044 (10)_Day:  2 (12)_Month:  7 (14)_Year: 2019 (16)_DoY: 183 (18)_GPSWeek: 2060 (20)_DoW: 2 (22)_Percentile:  95 (24)_HPE_Percentile:   1.46 (26)_VPE_Percentile:   3.49 (28)_NPE_Percentile:   1.22 (30)_EPE_Percentile:   1.11 (32)_3DPE_Percentile:   3.59 (34)_MaxHPE:   5.89 (36)_MaxVPE:   5.56 (38)_MaxNPE:   2.01 (40)_MaxEPE:   5.68 (42)_Max3DPE:   6.52 (44)_Avail%%:  99.907 (46)_PDOP_Percentile:   1.31 (48)_Min_PDOP:   0.79 (50)_Max_PDOP:   4.57 (52)_GDOP_Percentile:   1.53 (54)_Min_GDOP:   0.91 (56)_Max_GDOP:   5.74 (58)_TDOP_Percentile:   0.80 (60)_Min_TDOP:   0.44 (62)_Max_TDOP:   3.48 (64)_HDOP_Percentile:   0.67 (66)_Min_HDOP:   0.46 (68)_Max_HDOP:   2.54 (70)_VDOP_Percentile:   1.14 (72)_Min_VDOP:   0.65 (74)_Max_VDOP:   3.80 (76)_Sat_used_All_Const_Percentile: 31 (78)_Sat_not_used_All_Const_Percentile: 14 (80)_Min_sat_used_All_Const: 24 (82)_Min_sat_not_used_All_Const: 10 (84)_Max_sat_used_All_Const: 36 (86)_Max_sat_not_used_All_Const: 37 (88)_Epochs_processed: 86400 (90)_Epochs_with_solution: 86320 (92)_Epochs_with_solution_reference_file: 86320 (94)_Epochs_omitted_no_data_reference_file: 0 (96)_Epochs_skipped_no_data_reference_file: 0 (98)_Epochs_no_satellites: 2 (100)_Epochs_singular_matrix: 78 (102)_Epochs_No_Reference_GNSS: 0 (104)_Epochs_Over_HDOPorPDOP: 0 (106)_Epochs_Over_HDOP: 0 (108)_Epochs_Over_PDOP: 0 (110)_Epochs_Over_GDOP: 0 (112)_Total_Epochs_skipped: 80 (114)_Epochs_missing_Sum:   0 (116)_Epochs_missing_All_file:   0 (118)_Num_DataGaps_Sum:   0 (120)_Num_DataGaps_All_file:   0 (122)_MaxSize_DataGap_Sum:   0 (124)_MaxSize_DataGap_All_file:   0 (126)_Station_Network_Name: Other (128)_Time_To_First_Fix: 2 (130)_Epochs_First_Fix: 3 (132)_Processing_time: 59.078\n");
    printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight)\n");
    printf("            are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the summary and\n");
    printf("            the Stanford-ESA computation will be skipped. This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
	printf("          If backwards processing is active, epochs missing and data gaps will only be counted during the forward processing.\n");
	printf("          If receiver position is not fixed or provided by a reference file, the percentile lines will not appear.\n");
	printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
	printf("            the epoch will be skipped from the summary.\n");
    printf("          The last line of the summary contains all the values of the previous lines along with the station coordinates. The values between brackets\n");
	printf("            correspond to the column number.\n");
	printf("          The day printed in the last line of the summary corresponds to the day of the first epoch in the summary.\n");
	printf("          If receiver position is not fixed, the station coordinates will be the solution from the last computed epoch.\n");
    printf("          The last line is useful for plotting world maps with data from each station.\n");
    printf("          Stanford-ESA messages will not appear if Stanford-ESA computation has not been enabled.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
	printf("          The lines referring to a reference file will only appear if a user sets a reference file. If user sets the reference file just for comparing\n");
	printf("            the solution, the line \"Total epochs omitted in ...\" will appear. Otherwise, if the reference file was set to be used as the a priori\n");
	printf("            position for the modelling computation, the line \"Total epochs skipped due to no position from reference file ...\" will appear.\n");
	printf("\n    PPP SUMMARY [PPP processing modes]\n");
    printf("        PPP statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
    printf("        Sample:\n");
	printf("          INFO --------------------- PPP Summary ---------------------\n");
	printf("          INFO GDOP Threshold:  30.00\n");
	printf("          INFO First epoch of summary: 02/07/2019 00:00:00.00 / 2019 183     0.00 / 2060 172800.00\n");
	printf("          INFO Last  epoch of summary: 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Total epochs processed: 86400\n");
	printf("          INFO Total epochs processed with solution: 86393 ( 99.992%% )\n");
	printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 7 ( 0.008%% )\n");
	printf("          INFO Total epochs skipped due to singular geometry matrix: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped due to reference constellation not available: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped due to any DOP exceeding the threshold: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped due to GDOP exceeding the threshold:    0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped (any reason): 7 ( 0.008%% )\n");
	printf("          INFO Total epochs missing in observation file (during summary period):   0\n");
	printf("          INFO Total epochs missing in observation file (all the file):            0\n");
	printf("          INFO Number of data gaps in observation file (during summary period):   0\n");
	printf("          INFO Number of data gaps in observation file (all the file):            0\n");
	printf("          INFO Maximum data gap size in observation file (during summary period):    0\n");
	printf("          INFO Maximum data gap size in observation file (all the file):             0\n");
	printf("          INFO Time To First Fix: 7 seconds (8 epochs) at epoch 02/07/2019 00:00:07.00 / 2019 183     7.00 / 2060 172807.00\n");
	printf("          INFO Constellations     used 50 Percentile:  5 |  95 Percentile:  4 | Mean:  4.82\n");
	printf("          INFO Constellations not used 50 Percentile:  0 |  95 Percentile:  1 | Mean:  0.18\n");
	printf("          INFO Number of epochs with constellations used: GPS+GAL+GLO+BDS+QZS 70920 ( 82.090%% ) GPS+GAL+BDS+QZS 15473 ( 17.910%% )\n");
	printf("          INFO Number of epochs with constellations not used: GLO 15473 ( 17.910%% )\n");
	printf("          INFO Constellations used as reference clock: GPS 86393 ( 100%% )\n");
	printf("          INFO Satellites used (all constellations) 50 Percentile: 26 |  95 Percentile: 21 | Mean: 25.86\n");
	printf("          INFO Satellites used (GPS)                50 Percentile:  9 |  95 Percentile:  6 | Mean:  8.57\n");
	printf("          INFO Satellites used (GAL)                50 Percentile:  7 |  95 Percentile:  5 | Mean:  6.57\n");
	printf("          INFO Satellites used (GLO)                50 Percentile:  2 |  95 Percentile:  0 | Mean:  2.39\n");
	printf("          INFO Satellites used (BDS)                50 Percentile:  6 |  95 Percentile:  4 | Mean:  5.67\n");
	printf("          INFO Satellites used (QZS)                50 Percentile:  3 |  95 Percentile:  2 | Mean:  2.66\n");
	printf("          INFO Satellites not used (all constellations) 50 Percentile:  8 |  95 Percentile: 12 | Mean:  8.31\n");
	printf("          INFO Satellites not used (GPS)                50 Percentile:  1 |  95 Percentile:  2 | Mean:  0.92\n");
	printf("          INFO Satellites not used (GAL)                50 Percentile:  1 |  95 Percentile:  2 | Mean:  0.95\n");
	printf("          INFO Satellites not used (GLO)                50 Percentile:  0 |  95 Percentile:  2 | Mean:  0.58\n");
	printf("          INFO Satellites not used (BDS)                50 Percentile:  4 |  95 Percentile:  7 | Mean:  4.52\n");
	printf("          INFO Satellites not used (QZS)                50 Percentile:  1 |  95 Percentile:  2 | Mean:  1.34\n");
	printf("          INFO Minimum satellites used (all constellations) 18 (G 6 E 5 C 4 J 3) at epoch 02/07/2019 06:28:10.00 / 2019 183 23290.00 / 2060 196090.00\n");
	printf("          INFO Minimum satellites used (GPS)                 5                   at epoch 02/07/2019 18:59:08.00 / 2019 183 68348.00 / 2060 241148.00\n");
	printf("          INFO Minimum satellites used (GAL)                 4                   at epoch 02/07/2019 19:54:06.00 / 2019 183 71646.00 / 2060 244446.00\n");
	printf("          INFO Minimum satellites used (GLO)                 0                   at epoch 02/07/2019 12:45:19.00 / 2019 183 45919.00 / 2060 218719.00\n");
	printf("          INFO Minimum satellites used (BDS)                 4                   at epoch 02/07/2019 22:27:15.00 / 2019 183 80835.00 / 2060 253635.00\n");
	printf("          INFO Minimum satellites used (QZS)                 2                   at epoch 02/07/2019 23:31:33.00 / 2019 183 84693.00 / 2060 257493.00\n");
	printf("          INFO Maximum satellites used (all constellations) 33 (G 11 E 7 R 7 C 5 J 3) at epoch 02/07/2019 00:57:29.00 / 2019 183  3449.00 / 2060 176249.00\n");
	printf("          INFO Maximum satellites used (GPS)                14                        at epoch 02/07/2019 02:45:09.00 / 2019 183  9909.00 / 2060 182709.00\n");
	printf("          INFO Maximum satellites used (GAL)                10                        at epoch 02/07/2019 10:24:01.00 / 2019 183 37441.00 / 2060 210241.00\n");
	printf("          INFO Maximum satellites used (GLO)                 7                        at epoch 02/07/2019 01:14:50.00 / 2019 183  4490.00 / 2060 177290.00\n");
	printf("          INFO Maximum satellites used (BDS)                 9                        at epoch 02/07/2019 13:47:47.00 / 2019 183 49667.00 / 2060 222467.00\n");
	printf("          INFO Maximum satellites used (QZS)                 3                        at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Minimum satellites not used (all constellations)  4 (E 1 C 2 J 1) at epoch 02/07/2019 10:34:38.00 / 2019 183 38078.00 / 2060 210878.00\n");
	printf("          INFO Minimum satellites not used (GPS)                 0               at epoch 02/07/2019 23:50:17.00 / 2019 183 85817.00 / 2060 258617.00\n");
	printf("          INFO Minimum satellites not used (GAL)                 0               at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Minimum satellites not used (GLO)                 0               at epoch 02/07/2019 19:41:24.00 / 2019 183 70884.00 / 2060 243684.00\n");
	printf("          INFO Minimum satellites not used (BDS)                 2               at epoch 02/07/2019 13:18:02.00 / 2019 183 47882.00 / 2060 220682.00\n");
	printf("          INFO Minimum satellites not used (QZS)                 1               at epoch 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Maximum satellites not used (all constellations) 15 (G 4 E 1 R 2 C 7 J 1) at epoch 02/07/2019 17:01:00.00 / 2019 183 61260.00 / 2060 234060.00\n");
	printf("          INFO Maximum satellites not used (GPS)                 5                       at epoch 02/07/2019 18:30:06.00 / 2019 183 66606.00 / 2060 239406.00\n");
	printf("          INFO Maximum satellites not used (GAL)                 4                       at epoch 02/07/2019 18:43:49.00 / 2019 183 67429.00 / 2060 240229.00\n");
	printf("          INFO Maximum satellites not used (GLO)                 3                       at epoch 02/07/2019 23:56:34.00 / 2019 183 86194.00 / 2060 258994.00\n");
	printf("          INFO Maximum satellites not used (BDS)                 8                       at epoch 02/07/2019 16:54:06.00 / 2019 183 60846.00 / 2060 233646.00\n");
	printf("          INFO Maximum satellites not used (QZS)                 2                       at epoch 02/07/2019 23:31:33.00 / 2019 183 84693.00 / 2060 257493.00\n");
	printf("          INFO Convergence time with horizontal formal error from first fix to 0.2 metres:                                 150 seconds (151 epochs) at epoch 02/07/2019 00:02:37.00 / 2019 183   157.00 / 2060 172957.00\n");
	printf("          INFO Convergence time with horizontal formal error from first fix to 0.2 metres and maintained 300 seconds:      150 seconds (151 epochs) at epoch 02/07/2019 00:02:37.00 / 2019 183   157.00 / 2060 172957.00\n");
	printf("          INFO Convergence time with horizontal positioning error from first fix to 0.2 metres:                             62 seconds  (63 epochs) at epoch 02/07/2019 00:01:09.00 / 2019 183    69.00 / 2060 172869.00\n");
	printf("          INFO Convergence time with horizontal positioning error from first fix to 0.2 metres and maintained 300 seconds: 879 seconds (880 epochs) at epoch 02/07/2019 00:14:46.00 / 2019 183   886.00 / 2060 173686.00\n");
	printf("          INFO Convergence time with vertical formal error from first fix to 0.4 metres:                                    15 seconds  (16 epochs) at epoch 02/07/2019 00:00:22.00 / 2019 183    22.00 / 2060 172822.00\n");
	printf("          INFO Convergence time with vertical formal error from first fix to 0.4 metres and maintained 300 seconds:         15 seconds  (16 epochs) at epoch 02/07/2019 00:00:22.00 / 2019 183    22.00 / 2060 172822.00\n");
	printf("          INFO Convergence time with vertical positioning error from first fix to 0.4 metres:                                7 seconds   (8 epochs) at epoch 02/07/2019 00:00:14.00 / 2019 183    14.00 / 2060 172814.00\n");
	printf("          INFO Convergence time with vertical positioning error from first fix to 0.4 metres and maintained 300 seconds:   300 seconds (301 epochs) at epoch 02/07/2019 00:05:07.00 / 2019 183   307.00 / 2060 173107.00\n");
	printf("          INFO Convergence time with 3D formal error from first fix to 0.4 metres:                                          81 seconds  (82 epochs) at epoch 02/07/2019 00:01:28.00 / 2019 183    88.00 / 2060 172888.00\n");
	printf("          INFO Convergence time with 3D formal error from first fix to 0.4 metres and maintained 300 seconds:               81 seconds  (82 epochs) at epoch 02/07/2019 00:01:28.00 / 2019 183    88.00 / 2060 172888.00\n");
	printf("          INFO Convergence time with 3D positioning error from first fix to 0.4 metres:                                     59 seconds  (60 epochs) at epoch 02/07/2019 00:01:06.00 / 2019 183    66.00 / 2060 172866.00\n");
	printf("          INFO Convergence time with 3D positioning error from first fix to 0.4 metres and maintained 300 seconds:         308 seconds (309 epochs) at epoch 02/07/2019 00:05:15.00 / 2019 183   315.00 / 2060 173115.00\n");
	printf("          INFO PDOP  95 Percentile:   1.56\n");
	printf("          INFO GDOP  95 Percentile:   1.81\n");
	printf("          INFO TDOP  95 Percentile:   0.95\n");
	printf("          INFO HDOP  95 Percentile:   0.81\n");
	printf("          INFO VDOP  95 Percentile:   1.37\n");
	printf("          INFO Minimum PDOP   0.85 with 32 satellites (G 11 E  7 R  6 C  6 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Minimum GDOP   0.98 with 32 satellites (G 11 E  7 R  6 C  6 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Minimum TDOP   0.47 with 32 satellites (G 11 E  7 R  6 C  6 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Minimum HDOP   0.51 with 29 satellites (G  8 E  7 R  5 C  6 J  3) at epoch 02/07/2019 18:17:07.00 / 2019 183 65827.00 / 2060 238627.00\n");
	printf("          INFO Minimum VDOP   0.68 with 32 satellites (G 11 E  7 R  6 C  6 J  2) at epoch 02/07/2019 21:22:18.00 / 2019 183 76938.00 / 2060 249738.00\n");
	printf("          INFO Maximum PDOP   1.87 with 20 satellites (G  6 E  4 R  2 C  5 J  3) at epoch 02/07/2019 16:02:50.00 / 2019 183 57770.00 / 2060 230570.00\n");
	printf("          INFO Maximum GDOP   2.19 with 18 satellites (G  6 E  5 C  4 J  3)      at epoch 02/07/2019 06:28:10.00 / 2019 183 23290.00 / 2060 196090.00\n");
	printf("          INFO Maximum TDOP   1.24 with 18 satellites (G  6 E  5 C  4 J  3)      at epoch 02/07/2019 06:28:10.00 / 2019 183 57770.00 / 2060 196090.00\n");
	printf("          INFO Maximum HDOP   1.03 with 19 satellites (G  6 E  4 R  1 C  6 J  2) at epoch 02/07/2019 14:24:20.00 / 2019 183 51860.00 / 2060 224660.00\n");
	printf("          INFO Maximum VDOP   1.65 with 20 satellites (G  6 E  4 R  2 C  5 J  3) at epoch 02/07/2019 16:02:50.00 / 2019 183 57770.00 / 2060 230570.00\n");
	printf("          INFO First epoch of summary for computing positioning error percentiles: 02/07/2019 00:00:07.00 / 2019 183     7.00 / 2060 172807.00\n");
	printf("          INFO Last  epoch of summary for computing positioning error percentiles: 02/07/2019 23:59:59.00 / 2019 183 86399.00 / 2060 259199.00\n");
	printf("          INFO Horizontal  95 Positioning Error Percentile:   0.02 metres\n");
	printf("          INFO Vertical    95 Positioning Error Percentile:   0.03 metres\n");
	printf("          INFO North       95 Positioning Error Percentile:   0.01 metres\n");
	printf("          INFO East        95 Positioning Error Percentile:   0.02 metres\n");
	printf("          INFO 3D          95 Positioning Error Percentile:   0.04 metres\n");
	printf("          INFO Maximum Horizontal Positioning Error:   1.71 metres with 30 satellites (G 10 E  6 R  6 C  5 J  3) at epoch 02/07/2019 00:00:10.00 / 2019 183    10.00 / 2060 172810.00\n");
	printf("          INFO Maximum Vertical   Positioning Error:   1.89 metres with 30 satellites (G 10 E  6 R  6 C  5 J  3) at epoch 02/07/2019 00:00:07.00 / 2019 183     7.00 / 2060 172807.00\n");
	printf("          INFO Maximum North      Positioning Error:   0.24 metres with 30 satellites (G 10 E  6 R  6 C  5 J  3) at epoch 02/07/2019 00:00:07.00 / 2019 183     7.00 / 2060 172807.00\n");
	printf("          INFO Maximum East       Positioning Error:   1.71 metres with 30 satellites (G 10 E  6 R  6 C  5 J  3) at epoch 02/07/2019 00:00:10.00 / 2019 183    10.00 / 2060 172810.00\n");
	printf("          INFO Maximum 3D         Positioning Error:   2.39 metres with 30 satellites (G 10 E  6 R  6 C  5 J  3) at epoch 02/07/2019 00:00:07.00 / 2019 183     7.00 / 2060 172807.00\n");
	printf("          INFO Total Processing time: 1 minute and 2.563 seconds (62.563 seconds) [User time: 58.250 seconds (93.107%%) Kernel time: 4.313 seconds (6.893%%)]\n");
	printf("          INFO (2)_Station: nnor (4)_Lon: 116.19272381 (6)_Lat:  -31.04872771 (8)_Height:  234.8044 (10)_Day:  2 (12)_Month:  7 (14)_Year: 2019 (16)_DoY: 183 (18)_GPSWeek: 2060 (20)_DoW: 2 (22)_Percentile:  95 (24)_HPE_Percentile:   0.02 (26)_VPE_Percentile:   0.03 (28)_NPE_Percentile:   0.01 (30)_EPE_Percentile:   0.02 (32)_3DPE_Percentile:   0.04 (34)_MaxHPE:   1.71 (36)_MaxVPE:   1.89 (38)_MaxNPE:   0.24 (40)_MaxEPE:   1.71 (42)_Max3DPE:   2.39 (44)_Avail%%:  99.992 (46)_PDOP_Percentile:   1.56 (48)_Min_PDOP:   0.85 (50)_Max_PDOP:   1.87 (52)_GDOP_Percentile:   1.81 (54)_Min_GDOP:   0.98 (56)_Max_GDOP:   2.19 (58)_TDOP_Percentile:   0.95 (60)_Min_TDOP:   0.47 (62)_Max_TDOP:   1.24 (64)_HDOP_Percentile:   0.81 (66)_Min_HDOP:   0.51 (68)_Max_HDOP:   1.03 (70)_VDOP_Percentile:   1.37 (72)_Min_VDOP:   0.68 (74)_Max_VDOP:   1.65 (76)_Sat_used_All_Const_Percentile: 26 (78)_Sat_not_used_All_Const_Percentile: 8 (80)_Min_sat_used_All_Const: 18 (82)_Min_sat_not_used_All_Const: 4 (84)_Max_sat_used_All_Const: 33 (86)_Max_sat_not_used_All_Const: 15 (88)_Epochs_processed: 86400 (90)_Epochs_with_solution: 86393 (92)_Epochs_with_solution_reference_file: 86393 (94)_Epochs_omitted_no_data_reference_file: 0 (96)_Epochs_skipped_no_data_reference_file: 0 (98)_Epochs_no_satellites: 7 (100)_Epochs_singular_matrix: 0 (102)_Epochs_No_Reference_GNSS: 0 (104)_Epochs_Over_HDOPorPDOP: 0 (106)_Epochs_Over_HDOP: 0 (108)_Epochs_Over_PDOP: 0 (110)_Epochs_Over_GDOP: 0 (112)_Total_Epochs_skipped: 7 (114)_Epochs_missing_Sum:   0 (116)_Epochs_missing_All_file:   0 (118)_Num_DataGaps_Sum:   0 (120)_Num_DataGaps_All_file:   0 (122)_MaxSize_DataGap_Sum:   0 (124)_MaxSize_DataGap_All_file:   0 (126)_Station_Network_Name: Other (128)_Time_To_First_Fix: 7 (130)_Epochs_First_Fix: 8 (132)_Processing_time 62.563 (134)_Convergence_Time_&_Epochs_Formal_Error_Hor: 150 151 (137)_Convergence_Time_&_Epochs_Period_Formal_Error_Hor: 150 151 (140)_Convergence_Time_&_Epochs_Position_Error_Hor: 62 63 (143)_Convergence_Time_&_Epochs_Period_Position_Error_Hor: 879 880 (146)_Convergence_Time_&_Epochs_Formal_Error_Ver: 15 16 (149)_Convergence_Time_&_Epochs_Period_Formal_Error_Ver: 15 16 (152)_Convergence_Time_&_Epochs_Position_Error_Ver: 7 8 (155)_Convergence_Time_&_Epochs_Period_Position_Error_Ver: 300 301 (158)_Convergence_Time_&_Epochs_Formal_Error_3D: 81 82 (161)_Convergence_Time_&_Epochs_Period_Formal_Error_3D: 81 82 (164)_Convergence_Time_&_Epochs_Position_Error_3D: 59 60 (167)_Convergence_Time_&_Epochs_Period_Position_Error_3D: 308 309\n");
    printf("        NOTES:\n");
    printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight)\n");
    printf("            are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the summary.\n");
    printf("            This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
	printf("          If backwards processing is active, epochs missing and data gaps will only be counted during the forward processing.\n");
	printf("          If receiver position is not fixed or provided by a reference file, the percentile lines will not appear.\n");
	printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
	printf("            the epoch will be skipped from the summary.\n");
	printf("          The last line of the summary contains all the values of the previous lines along with the station coordinates. The values between brackets\n");
	printf("            correspond to the column number.\n");
	printf("          The day printed in the last line of the summary corresponds to the day of the first epoch in the summary.\n");
	printf("          If receiver position is not fixed, the station coordinates will be the solution from the last computed epoch.\n");
    printf("          The last line is useful for plotting world maps with data from each station.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
	printf("          The lines referring to a reference file will only appear if a user sets a reference file. If user sets the reference file just for comparing\n");
	printf("            the solution, the line \"Total epochs omitted in ...\" will appear. Otherwise, if the reference file was set to be used as the a priori\n");
	printf("            position for the modelling computation, the line \"Total epochs skipped due to no position from reference file ...\" will appear.\n");
	printf("\n    SBAS SUMMARY [SBAS processing mode]\n");
	printf("        SBAS statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Sample:\n");
    printf("          INFO --------------------- SBAS Summary ---------------------\n");
    printf("          INFO Horizontal Alarm limit:  40.00 metres\n");
    printf("          INFO Vertical   Alarm limit:  50.00 metres\n");
    printf("          INFO First epoch of summary: 21/04/2020 00:00:00.00 / 2020 112     0.00 / 2102 172800.00\n");
    printf("          INFO Last  epoch of summary: 21/04/2020 23:59:59.00 / 2020 112 86399.00 / 2102 259199.00\n");
    printf("          INFO Total epochs processed: 86372\n");
    printf("          INFO Total epochs processed with PA solution: 85650 ( 99.164%% )\n");
    printf("          INFO Total epochs processed with PA solution under alarm limits: 85648 ( 99.162%% )\n");
    printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 722 ( 0.836%% )\n");
    printf("          INFO Total epochs skipped due to singular geometry matrix: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to reference constellation not available: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped (any reason): 722 ( 0.836%% )\n");
    printf("          INFO Total epochs missing in observation file (during summary period):  28\n");
    printf("          INFO Total epochs missing in observation file (all the file):           28\n");
    printf("          INFO Number of data gaps in observation file (during summary period):   3\n");
    printf("          INFO Number of data gaps in observation file (all the file):            3\n");
    printf("          INFO Maximum data gap size in observation file (during summary period):   11 at epoch 21/04/2020 23:50:08.00 / 2020 112 85808.00 / 2102 258608.00\n");
    printf("          INFO Maximum data gap size in observation file (all the file):            11 at epoch 21/04/2020 23:50:08.00 / 2020 112 85808.00 / 2102 258608.00\n");
    printf("          INFO Time To First Fix: 361 seconds (362 epochs) at epoch 20/04/2020 23:51:01.00 / 2020 111 85861.00 / 2102 172261.00\n");
    printf("          INFO Number of epochs with constellations used: GPS 85650 ( 100%% )\n");
    printf("          INFO Number of epochs with constellations not used: 0 ( 0%% )\n");
    printf("          INFO Constellations used as reference clock: GPS 85650 ( 100%% )\n");
    printf("          INFO Satellites used (all constellations) 50 Percentile:  8 |  95 Percentile:  7 | Mean:  8.10\n");
    printf("          INFO Satellites used (GPS)                50 Percentile:  8 |  95 Percentile:  7 | Mean:  8.10\n");
    printf("          INFO Satellites not used (all constellations) 50 Percentile:  2 |  95 Percentile:  4 | Mean:  2.36\n");
    printf("          INFO Satellites not used (GPS)                50 Percentile:  2 |  95 Percentile:  4 | Mean:  2.36\n");
    printf("          INFO Minimum satellites used (all constellations)  6 (G 6) at epoch 21/04/2020 23:18:39.00 / 2020 112 83919.00 / 2102 256719.00\n");
    printf("          INFO Minimum satellites used (GPS)                 6      at epoch 21/04/2020 23:18:39.00 / 2020 112 83919.00 / 2102 256719.00\n");
    printf("          INFO Maximum satellites used (all constellations) 12 (G 12) at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Maximum satellites used (GPS)                12        at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Minimum satellites not used (all constellations)  0   at epoch 21/04/2020 20:47:19.00 / 2020 112 74839.00 / 2102 247639.00\n");
    printf("          INFO Minimum satellites not used (GPS)                 0   at epoch 21/04/2020 20:47:19.00 / 2020 112 74839.00 / 2102 247639.00\n");
    printf("          INFO Maximum satellites not used (all constellations)  7 (G 7) at epoch 21/04/2020 17:55:02.00 / 2020 112 64502.00 / 2102 237302.00\n");
    printf("          INFO Maximum satellites not used (GPS)                 7       at epoch 21/04/2020 17:55:02.00 / 2020 112 64502.00 / 2102 237302.00\n");
    printf("          INFO PDOP  95 Percentile:   2.98\n");
    printf("          INFO GDOP  95 Percentile:   3.44\n");
    printf("          INFO TDOP  95 Percentile:   1.79\n");
    printf("          INFO HDOP  95 Percentile:   1.53\n");
    printf("          INFO VDOP  95 Percentile:   2.57\n");
    printf("          INFO Minimum PDOP   1.24 with 12 satellites (G 12) at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Minimum GDOP   1.36 with 12 satellites (G 12) at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Minimum TDOP   0.56 with 12 satellites (G 12) at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Minimum HDOP   0.72 with 12 satellites (G 12) at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Minimum VDOP   1.01 with 12 satellites (G 12) at epoch 21/04/2020 18:17:45.00 / 2020 112 65865.00 / 2102 238665.00\n");
    printf("          INFO Maximum PDOP   5.27 with  7 satellites (G  7) at epoch 21/04/2020 23:28:58.00 / 2020 112 84538.00 / 2102 257338.00\n");
    printf("          INFO Maximum GDOP   5.97 with  7 satellites (G  7) at epoch 21/04/2020 23:28:49.00 / 2020 112 84529.00 / 2102 257329.00\n");
    printf("          INFO Maximum TDOP   3.02 with  6 satellites (G  6) at epoch 21/04/2020 02:20:49.00 / 2020 112 84532.00 / 2102 181249.00\n");
    printf("          INFO Maximum HDOP   2.68 with  6 satellites (G  6) at epoch 21/04/2020 01:30:12.00 / 2020 112  5412.00 / 2102 178212.00\n");
    printf("          INFO Maximum VDOP   4.83 with  7 satellites (G  7) at epoch 21/04/2020 23:28:52.00 / 2020 112 84532.00 / 2102 257332.00\n");
    printf("          INFO Continuity Risk Airborne (15 epochs sliding window): 7.0054E-04 (NumEpochsRisk:        60 TotalEpochsAvailable: 85648)\n");
    printf("          INFO Continuity Risk Maritime (15 epochs fixed window):   6.9444E-04 (NumDiscontinuities:    4 TotalEpochsSummary:   86400)\n");
    printf("          INFO First epoch of summary for computing MIs, PE, PL and percentiles: 21/04/2020 00:00:00.00 / 2020 112     0.00 / 2102 172800.00\n");
    printf("          INFO Last  epoch of summary for computing MIs, PE, PL and percentiles: 21/04/2020 23:59:59.00 / 2020 112 86399.00 / 2102 259199.00\n");
    printf("          INFO Total epochs with MIs: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs with Horizontal MIs: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs with Vertical   MIs: 0 ( 0.000%% )\n");
    printf("          INFO Horizontal  95 Positioning Error Percentile:   0.87 metres\n");
    printf("          INFO Vertical    95 Positioning Error Percentile:   1.26 metres\n");
    printf("          INFO North       95 Positioning Error Percentile:   0.69 metres\n");
    printf("          INFO East        95 Positioning Error Percentile:   0.66 metres\n");
    printf("          INFO 3D          95 Positioning Error Percentile:   1.42 metres\n");
    printf("          INFO Horizontal  95 Protection  Level Percentile:  12.68 metres\n");
    printf("          INFO Vertical    95 Protection  Level Percentile:  23.05 metres\n");
    printf("          INFO Maximum Horizontal Positioning Error:   1.52 metres with  7 satellites (G  7) at epoch 21/04/2020 05:00:22.00 / 2020 112 18022.00 / 2102 190822.00\n");
    printf("          INFO Maximum Vertical   Positioning Error:   2.51 metres with  8 satellites (G  8) at epoch 21/04/2020 16:30:19.00 / 2020 112 59419.00 / 2102 232219.00\n");
    printf("          INFO Maximum North      Positioning Error:   1.22 metres with  6 satellites (G  6) at epoch 21/04/2020 23:02:47.00 / 2020 112 82967.00 / 2102 255767.00\n");
    printf("          INFO Maximum East       Positioning Error:   0.99 metres with  7 satellites (G  7) at epoch 21/04/2020 05:00:50.00 / 2020 112 18050.00 / 2102 190850.00\n");
    printf("          INFO Maximum 3D         Positioning Error:   2.69 metres with  7 satellites (G  7) at epoch 21/04/2020 23:17:52.00 / 2020 112 83872.00 / 2102 256672.00\n");
    printf("          INFO Minimum Horizontal Protection  Level:   7.16 metres with 12 satellites (G 12) at epoch 21/04/2020 18:17:37.00 / 2020 112 65857.00 / 2102 238657.00\n");
    printf("          INFO Minimum Vertical   Protection  Level:  10.01 metres with 10 satellites (G 10) at epoch 21/04/2020 09:45:32.00 / 2020 112 35132.00 / 2102 207932.00\n");
    printf("          INFO Maximum Horizontal Protection  Level:  25.00 metres with  6 satellites (G  6) at epoch 21/04/2020 01:27:48.00 / 2020 112  5268.00 / 2102 178068.00\n");
    printf("          INFO Maximum Vertical   Protection  Level:  50.63 metres with  6 satellites (G  6) at epoch 21/04/2020 23:18:39.00 / 2020 112 83919.00 / 2102 256719.00\n");
    printf("          INFO Horizontal  95 Integrity Ratio Percentile: 0.0923\n");
    printf("          INFO Vertical    95 Integrity Ratio Percentile: 0.0848\n");
    printf("          INFO Best  Horizontal Integrity Ratio:  4.1355E-04 with  7 satellites (G  7) at epoch 21/04/2020 00:39:35.00 / 2020 112  2375.00 / 2102 175175.00\n");
    printf("          INFO Best  Vertical   Integrity Ratio:  1.3388E-06 with  9 satellites (G  9) at epoch 21/04/2020 21:11:36.00 / 2020 112 76296.00 / 2102 249096.00\n");
    printf("          INFO Worst Horizontal Integrity Ratio:      0.1519 with 10 satellites (G 10) at epoch 21/04/2020 19:30:12.00 / 2020 112 70212.00 / 2102 243012.00\n");
    printf("          INFO Worst Vertical   Integrity Ratio:      0.1731 with  8 satellites (G  8) at epoch 21/04/2020 16:30:19.00 / 2020 112 59419.00 / 2102 232219.00\n");
    printf("          INFO Total Processing time: 8.266 seconds [User time: 7.969 seconds (96.408%%) Kernel time: 0.297 seconds (3.592%%)]\n");
    printf("          INFO (2)_Station: cace (4)_Lon:  -6.34177927 (6)_Lat:   39.47886540 (8)_Height:  436.4878 (10)_Day: 21 (12)_Month:  4 (14)_Year: 2020 (16)_DoY: 112 (18)_GPSWeek: 2102 (20)_DoW: 2 (22)_Percentile:  95 (24)_HPE_Percentile:   0.87 (26)_VPE_Percentile:   1.26 (28)_NPE_Percentile:   0.69 (30)_EPE_Percentile:   0.66 (32)_3DPE_Percentile:   1.42 (34)_MaxHPE:   1.52 (36)_MaxVPE:   2.51 (38)_MaxNPE:   1.22 (40)_MaxEPE:   0.99 (42)_Max3DPE:   2.69 (44)_Avail%%:  99.162 (46)_PDOP_Percentile:   2.98 (48)_Min_PDOP:   1.24 (50)_Max_PDOP:   5.27 (52)_GDOP_Percentile:   3.44 (54)_Min_GDOP:   1.36 (56)_Max_GDOP:   5.97 (58)_TDOP_Percentile:   1.79 (60)_Min_TDOP:   0.56 (62)_Max_TDOP:   3.02 (64)_HDOP_Percentile:   1.53 (66)_Min_HDOP:   0.72 (68)_Max_HDOP:   2.68 (70)_VDOP_Percentile:   2.57 (72)_Min_VDOP:   1.01 (74)_Max_VDOP:   4.83 (76)_Sat_used_All_Const_Percentile: 8 (78)_Sat_not_used_All_Const_Percentile: 2 (80)_Min_sat_used_All_Const: 6 (82)_Min_sat_not_used_All_Const: 0 (84)_Max_sat_used_All_Const: 12 (86)_Max_sat_not_used_All_Const: 7 (88)_Epochs_processed: 86372 (90)_Epochs_with_solution: 0 (92)_Epochs_with_solution_reference_file: 85650 (94)_Epochs_omitted_no_data_reference_file: 0 (96)_Epochs_skipped_no_data_reference_file: 0 (98)_Epochs_no_satellites: 722 (100)_Epochs_singular_matrix: 0 (102)_Epochs_No_Reference_GNSS: 0 (104)_Epochs_Over_HDOPorPDOP: 0 (106)_Epochs_Over_HDOP: 0 (108)_Epochs_Over_PDOP: 0 (110)_Epochs_Over_GDOP: 0 (112)_Total_Epochs_skipped: 722 (114)_Epochs_missing_Sum:  28 (116)_Epochs_missing_All_file:  28 (118)_Num_DataGaps_Sum:   3 (120)_Num_DataGaps_All_file:   3 (122)_MaxSize_DataGap_Sum:  11 (124)_MaxSize_DataGap_All_file:  11 (126)_Station_Network_Name: Other (128)_Time_To_First_Fix: 361 (130)_Epochs_First_Fix: 362 (132)_Processing_time:  8.266 (134)_HIR_Percentile: 0.0923 (136)_VIR_Percentile: 0.0848 (138)_HWIR:  0.1519 (140)_VWIR:  0.1731 (142)_HBIR: 4.1355E-04 (144)_VBIR: 1.3388E-06 (146)_MIs:   0 (148)_Hor_MIs:   0 (150)_Ver_MIs:   0 (152)_HWIR_ESA:  0.0000 (154)_VWIR_ESA:  0.0000 (156)_MIs_ESA:    0 (158)_Hor_MIs_ESA:    0 (160)_Ver_MIs_ESA:    0 (162)_HPL_Percentile:  12.68 (164)_VPL_Percentile:  23.05 (166)_MinHPL:   7.16 (168)_MaxHPL:  25.00 (170)_MinVPL:  10.01 (172)_MaxVPL:  50.63 (174)_Cont_Risk: 7.0054E-04 (176)_Cont_Risk_Mar: 6.9444E-04\n");
	printf("        NOTES:\n");
	printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight)\n");
	printf("          	are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the SBAS summary and\n");
	printf("          	the Stanford-ESA computation will be skipped. This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
	printf("          If receiver position is not fixed or provided by a reference file, the percentile lines will not appear.\n");
	printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
	printf("            the epoch will be skipped from the summary.\n");
	printf("          The last line of the SBAS summary contains all the values of the previous lines along with the station coordinates. The values between brackets\n");
	printf("            correspond to the column number.\n");
	printf("          The last line is useful for plotting world maps with data from each station.\n");
	printf("          The day printed in the last line of the summary corresponds to the day of the first epoch in the summary.\n");
	printf("          If receiver position is not fixed, the station coordinates will be the solution from the last computed epoch.\n");
	printf("          The fields at the end of the last line 'HWIR_ESA', 'VWIR_ESA', 'MIs_ESA', 'Hor_MIs_ESA' and 'Ver_MIs_ESA' correspond to the values computed in Stanford-ESA.\n");
	printf("            These fields will appear even if Stanford-ESA has not been enabled, but with a value of 0 (so its column number is fixed).\n");
	printf("          Stanford-ESA messages will not appear if Stanford-ESA computation has not been enabled.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
	printf("          Number of epochs with NPA epoch message will not appear if mode switching has not been enabled.\n\n");
	printf("          If user forced NPA processing through parameters, then all values in SBAS summary will be referred to NPA mode.\n");
	printf("          The lines referring to a reference file will only appear if a user sets a reference file. If user sets the reference file just for comparing\n");
	printf("            the solution, the line \"Total epochs omitted in ...\" will appear. Otherwise, if the reference file was set to be used as the a priori\n");
	printf("            position for the modelling computation, the line \"Total epochs skipped due to no position from reference file ...\" will appear.\n");
    printf("\n    DGNSS SUMMARY [DGNSS processing mode]\n");
    printf("        DGNSS statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
    printf("        Sample:\n");
    printf("          INFO --------------------- DGNSS Summary ---------------------\n");
    printf("          INFO GDOP Threshold:  30.00\n");
    printf("          INFO First epoch of summary: 26/01/2020 00:00:00.00 / 2020 026     0.00 / 2090      0.00\n");
    printf("          INFO Last  epoch of summary: 26/01/2020 23:59:59.00 / 2020 026 86399.00 / 2090  86399.00\n");
    printf("          INFO Total epochs processed: 86389\n");
    printf("          INFO Total epochs processed with DGNSS solution: 86017 ( 99.569%% )\n");
    printf("          INFO Total epochs processed with SPP solution: 370 ( 0.428%% )\n");
    printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 2 ( 0.002%% )\n");
    printf("          INFO Total epochs skipped due to singular geometry matrix: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to reference constellation not available: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to any DOP exceeding the threshold: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to GDOP exceeding the threshold:    0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped (any reason): 2 ( 0.002%% )\n");
    printf("          INFO Total epochs missing  in rover observation file (during summary period):   11\n");
    printf("          INFO Total epochs missing  in rover observation file (all the file):            11\n");
    printf("          INFO Number of data gaps in rover observation file (during summary period):      1\n");
    printf("          INFO Number of data gaps in rover observation file (all the file):               1\n");
    printf("          INFO Maximum data gap size in rover observation file (during summary period):   11 at epoch 26/01/2020 11:37:59.00 / 2020 026 41879.00 / 2090  41879.00\n");
    printf("          INFO Maximum data gap size in rover observation file (all the file):            11 at epoch 26/01/2020 11:37:59.00 / 2020 026 41879.00 / 2090  41879.00\n");
    printf("          INFO Total epochs missing  in reference station RINEX observation file (during summary period):  11\n");
    printf("          INFO Total epochs missing  in reference station RINEX observation file (all the file):           11\n");
    printf("          INFO Number of data gaps   in reference station RINEX observation file (during summary period):   1\n");
    printf("          INFO Number of data gaps   in reference station RINEX observation file (all the file):            1\n");
    printf("          INFO Maximum data gap size in reference station RINEX observation file (during summary period):  11 at epoch 26/01/2020 18:20:43.00 / 2020 026 66043.00 / 2090  66043.00\n");
    printf("          INFO Maximum data gap size in reference station RINEX observation file (all the file):           11 at epoch 26/01/2020 18:20:43.00 / 2020 026 66043.00 / 2090  66043.00\n");
    printf("          INFO Time To First Fix: 359 seconds (360 epochs) at epoch 25/01/2020 23:50:59.00 / 2020 025 85859.00 / 2089 604259.00\n");
    printf("          INFO Number of epochs with constellations used: GPS 86017 ( 100%% )\n");
    printf("          INFO Number of epochs with constellations not used: 0 ( 0%% )\n");
    printf("          INFO Constellations used as reference clock: GPS 86017 ( 100%% )\n");
    printf("          INFO Satellites used (all constellations) 50 Percentile:  9 |  95 Percentile:  7 | Mean:  9.25\n");
    printf("          INFO Satellites used (GPS)                50 Percentile:  9 |  95 Percentile:  7 | Mean:  9.25\n");
    printf("          INFO Satellites not used (all constellations) 50 Percentile:  1 |  95 Percentile:  3 | Mean:  1.24\n");
    printf("          INFO Satellites not used (GPS)                50 Percentile:  1 |  95 Percentile:  3 | Mean:  1.24\n");
    printf("          INFO Minimum satellites used (all constellations)  6 (G 6) at epoch 26/01/2020 19:36:22.00 / 2020 026 70582.00 / 2090  70582.00\n");
    printf("          INFO Minimum satellites used (GPS)                 6       at epoch 26/01/2020 19:36:22.00 / 2020 026 70582.00 / 2090  70582.00\n");
    printf("          INFO Maximum satellites used (all constellations) 12 (G 12) at epoch 26/01/2020 15:45:12.00 / 2020 026 56712.00 / 2090  56712.00\n");
    printf("          INFO Maximum satellites used (GPS)                12        at epoch 26/01/2020 15:45:12.00 / 2020 026 56712.00 / 2090  56712.00\n");
    printf("          INFO Minimum satellites not used (all constellations)  0   at epoch 26/01/2020 23:09:06.00 / 2020 026 83346.00 / 2090  83346.00\n");
    printf("          INFO Minimum satellites not used (GPS)                 0   at epoch 26/01/2020 23:09:06.00 / 2020 026 83346.00 / 2090  83346.00\n");
    printf("          INFO Maximum satellites not used (all constellations)  6 (G 6) at epoch 26/01/2020 19:28:27.00 / 2020 026 70107.00 / 2090  70107.00\n");
    printf("          INFO Maximum satellites not used (GPS)                 6       at epoch 26/01/2020 19:28:27.00 / 2020 026 70107.00 / 2090  70107.00\n");
    printf("          INFO PDOP  95 Percentile:   2.44\n");
    printf("          INFO GDOP  95 Percentile:   2.83\n");
    printf("          INFO TDOP  95 Percentile:   1.43\n");
    printf("          INFO HDOP  95 Percentile:   1.32\n");
    printf("          INFO VDOP  95 Percentile:   2.06\n");
    printf("          INFO Minimum PDOP   1.19 with 12 satellites (G 12) at epoch 26/01/2020 15:45:08.00 / 2020 026 56708.00 / 2090  56708.00\n");
    printf("          INFO Minimum GDOP   1.29 with 12 satellites (G 12) at epoch 26/01/2020 15:45:08.00 / 2020 026 56708.00 / 2090  56708.00\n");
    printf("          INFO Minimum TDOP   0.49 with 12 satellites (G 12) at epoch 26/01/2020 15:45:08.00 / 2020 026 21221.00 / 2090  56708.00\n");
    printf("          INFO Minimum HDOP   0.68 with 12 satellites (G 12) at epoch 26/01/2020 15:45:08.00 / 2020 026 56708.00 / 2090  56708.00\n");
    printf("          INFO Minimum VDOP   0.94 with 12 satellites (G 12) at epoch 26/01/2020 05:53:41.00 / 2020 026 21221.00 / 2090  21221.00\n");
    printf("          INFO Maximum PDOP   3.05 with  6 satellites (G  6) at epoch 26/01/2020 11:06:20.00 / 2020 026 39980.00 / 2090  39980.00\n");
    printf("          INFO Maximum GDOP   3.66 with  6 satellites (G  6) at epoch 26/01/2020 11:06:27.00 / 2020 026 39987.00 / 2090  39987.00\n");
    printf("          INFO Maximum TDOP   2.02 with  6 satellites (G  6) at epoch 26/01/2020 11:06:42.00 / 2020 026 39982.00 / 2090  40002.00\n");
    printf("          INFO Maximum HDOP   1.49 with  7 satellites (G  7) at epoch 26/01/2020 22:12:36.00 / 2020 026 79956.00 / 2090  79956.00\n");
    printf("          INFO Maximum VDOP   2.66 with  6 satellites (G  6) at epoch 26/01/2020 11:06:22.00 / 2020 026 39982.00 / 2090  39982.00\n");
    printf("          INFO First epoch of summary for computing positioning error percentiles: 26/01/2020 00:00:00.00 / 2020 026     0.00 / 2090      0.00\n");
    printf("          INFO Last  epoch of summary for computing positioning error percentiles: 26/01/2020 23:59:59.00 / 2020 026 86399.00 / 2090  86399.00\n");
    printf("          INFO Horizontal  95 Positioning Error Percentile:   0.23 metres\n");
    printf("          INFO Vertical    95 Positioning Error Percentile:   0.46 metres\n");
    printf("          INFO North       95 Positioning Error Percentile:   0.19 metres\n");
    printf("          INFO East        95 Positioning Error Percentile:   0.17 metres\n");
    printf("          INFO 3D          95 Positioning Error Percentile:   0.48 metres\n");
    printf("          INFO Maximum Horizontal Positioning Error:   0.86 metres with 11 satellites (G 11) at epoch 26/01/2020 06:11:02.00 / 2020 026 22262.00 / 2090  22262.00\n");
    printf("          INFO Maximum Vertical   Positioning Error:   2.79 metres with  7 satellites (G  7) at epoch 26/01/2020 11:50:43.00 / 2020 026 42643.00 / 2090  42643.00\n");
    printf("          INFO Maximum North      Positioning Error:   0.85 metres with 11 satellites (G 11) at epoch 26/01/2020 06:11:02.00 / 2020 026 22262.00 / 2090  22262.00\n");
    printf("          INFO Maximum East       Positioning Error:   0.63 metres with  7 satellites (G  7) at epoch 26/01/2020 11:50:43.00 / 2020 026 42643.00 / 2090  42643.00\n");
    printf("          INFO Maximum 3D         Positioning Error:   2.86 metres with  7 satellites (G  7) at epoch 26/01/2020 11:50:43.00 / 2020 026 42643.00 / 2090  42643.00\n");
    printf("          INFO Total Processing time: 8.750 seconds [User time: 8.422 seconds (96.250%%) Kernel time: 0.328 seconds (3.750%%)]\n");
    printf("          INFO (2)_Station: gras (4)_Lon:   6.92057654 (6)_Lat:   43.75473918 (8)_Height: 1319.2344 (10)_Day: 26 (12)_Month:  1 (14)_Year: 2020 (16)_DoY:  26 (18)_GPSWeek: 2090 (20)_DoW: 0 (22)_Percentile:  95 (24)_HPE_Percentile:   0.23 (26)_VPE_Percentile:   0.46 (28)_NPE_Percentile:   0.19 (30)_EPE_Percentile:   0.17 (32)_3DPE_Percentile:   0.48 (34)_MaxHPE:   0.86 (36)_MaxVPE:   2.79 (38)_MaxNPE:   0.85 (40)_MaxEPE:   0.63 (42)_Max3DPE:   2.86 (44)_Avail%%:  99.569 (46)_PDOP_Percentile:   2.44 (48)_Min_PDOP:   1.19 (50)_Max_PDOP:   3.05 (52)_GDOP_Percentile:   2.83 (54)_Min_GDOP:   1.29 (56)_Max_GDOP:   3.66 (58)_TDOP_Percentile:   1.43 (60)_Min_TDOP:   0.49 (62)_Max_TDOP:   2.02 (64)_HDOP_Percentile:   1.32 (66)_Min_HDOP:   0.68 (68)_Max_HDOP:   1.49 (70)_VDOP_Percentile:   2.06 (72)_Min_VDOP:   0.94 (74)_Max_VDOP:   2.66 (76)_Sat_used_All_Const_Percentile: 9 (78)_Sat_not_used_All_Const_Percentile: 1 (80)_Min_sat_used_All_Const: 6 (82)_Min_sat_not_used_All_Const: 0 (84)_Max_sat_used_All_Const: 12 (86)_Max_sat_not_used_All_Const: 6 (88)_Epochs_processed: 86389 (90)_Epochs_with_solution: 0 (92)_Epochs_with_solution_reference_file: 86017 (94)_Epochs_omitted_no_data_reference_file: 0 (96)_Epochs_skipped_no_data_reference_file: 0 (98)_Epochs_no_satellites: 2 (100)_Epochs_singular_matrix: 0 (102)_Epochs_No_Reference_GNSS: 0 (104)_Epochs_Over_HDOPorPDOP: 0 (106)_Epochs_Over_HDOP: 0 (108)_Epochs_Over_PDOP: 0 (110)_Epochs_Over_GDOP: 0 (112)_Total_Epochs_skipped: 2 (114)_Epochs_missing_Sum:  11 (116)_Epochs_missing_All_file:  11 (118)_Num_DataGaps_Sum:   1 (120)_Num_DataGaps_All_file:   1 (122)_MaxSize_DataGap_Sum:  11 (124)_MaxSize_DataGap_All_file:  11 (126)_Station_Network_Name: Other (128)_Time_To_First_Fix: 359 (130)_Epochs_First_Fix: 360 (132)_Processing_time:  8.750 (134)_Epochs_missing_Ref_Sum:  11 (136)_Epochs_missing_Ref_All_file:  11 (138)_Num_DataGaps_Ref_Sum:   1 (140)_Num_DataGaps_Ref_All_file:   1 (142)_MaxSize_DataGap_Ref_Sum:  11 (144)_MaxSize_DataGap_Ref_All_file:  11\n");
    printf("        NOTES:\n");
    printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight)\n");
    printf("            are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the summary and\n");
    printf("            the Stanford-ESA computation will be skipped. This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
    printf("          If rover position is not provided, the percentile lines will not appear.\n");
    printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
    printf("            the epoch will be skipped from the summary.\n");
    printf("          If rover position is not provided, the station coordinates will be the solution from the last computed epoch.\n");
	printf("          The last line of the DGNSS summary contains all the values of the previous lines along with the station coordinates. The values between brackets\n");
	printf("            correspond to the column number.\n");
    printf("          The last line is useful for plotting world maps with data from each station.\n");
	printf("          The day printed in the last line of the summary corresponds to the day of the first epoch in the summary.\n");
    printf("          Stanford-ESA messages will not appear if Stanford-ESA computation has not been enabled.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
    printf("          The lines referring to a reference file will only appear if a user sets a reference file.\n");
	printf("\n    SATDIFF [orbit and clock comparison]\n");
	printf("        Satellite difference message for products comparison mode. This message shows the difference between\n");
	printf("        both orbit and clocks for two different OC products fonts for a specific time. It is shown each time step.\n");
	printf("        The SISRE fields are the Signal-in-Space Range Error, it is a measure of how the error impact a general\n");
	printf("        receiver found in the Earth's surface. It is computed as:\n");
	printf("            SISRE = sqrt((radDiff-clkDiff)^2 + 1/49*(ctDiff^2 + atDiff^2))\n");
	printf("        Being:\n");
	printf("            radDiff, the difference of satellite positions in the radial component\n");
	printf("            clkDiff, the difference of satellite clock offsets\n");
	printf("            ctDiff, the difference of satellite positions in the cross-track component\n");
	printf("            atDiff, the difference of satellite positions in the along-track component\n");
	printf("        Messages will be sorted by constellation and PRN, with this constellation order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SATDIFF'\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   DoY\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   Time in HH:MM:SS.zz format\n");
	printf("        Field 6:   GNSS System\n");
	printf("        Field 7:   PRN satellite identifier\n");
	printf("        Field 8:   SISRE difference [m]\n");
	printf("        Field 9:   SISRE orbit-only difference [m]\n");
	printf("        Field 10:  3D orbit difference [m]\n");
	printf("        Field 11:  Clock difference [m]\n");
	printf("        Field 12:  GPS P1-P2 DCB difference or QZSS C1C DCB difference. If not GPS or QZSS, this value is 0 [L1 m]\n");
	printf("        Field 13:  Radial position difference [m]\n");
	printf("        Field 14:  Along-track position difference [m]\n");
	printf("        Field 15:  Cross-track position difference [m]\n");
	printf("        Field 16:  X position difference [m]\n");
	printf("        Field 17:  Y position difference [m]\n");
	printf("        Field 18:  Z position difference [m]\n");
	printf("        Field 19:  Ephemerides block type name (LNAV, CNAV, etc.) or 'SP3' if precise products are used (separated by a dash '-')\n");
	printf("        Field 20:  IOD number or '-1' if no IOD in broadcast message or precise products are used for first source\n");
	printf("        Field 21:  IOD number or '-1' if no IOD in broadcast message or precise products are used for second source\n");
	printf("        Field 22:  Health letter (H=Healthy, M=Marginal, U=Unhealthy), health value. If unhealthy, health flags are shown by frequency for first source\n");
	printf("        Field 23:  Health letter (H=Healthy, M=Marginal, U=Unhealthy), health value. If unhealthy, health flags are shown by frequency for second source\n");
	printf("        Sample:\n");
	printf("            SATDIFF 2018 026   300.00 00:05:00.00 GPS  1     0.3205     0.7588     1.0104    -0.4470    -0.7526     0.2982    -0.6046     0.3084     0.9177     0.2892      LNAV-SP3        73  -1 H-0\n\n");
	printf("    SATSTAT [orbit and clock comparison]\n");
	printf("        Satellite difference summary message for products comparison mode. This message shows the differences\n");
	printf("        between orbit and clocks for two different OC products fonts for a specific satellite. It is shown after\n");
	printf("        all the comparisons are done, and presents a summary for each satellite.\n");
	printf("        Field 1:      'SATSTAT'\n");
	printf("        Field 2:      GNSS System\n");
	printf("        Field 3:      PRN satellite identifier\n");
	printf("        Field 4:      Number of samples\n");
	printf("        Field 5-7:    SISRE comparisons  (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 8-10:   SISRE orbit-only comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 11-13:  3D orbit comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 14-16:  Clock comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 17-19:  DCB comparisons (mean [L1 m], RMS [L1 m], stdDev [L1 m])\n");
	printf("        Field 20-22:  Radial position comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 23-25:  Along-track position comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 26-28:  Cross-track position comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Sample:\n");
	printf("            SATSTAT  1   95     1.5530     2.1112     1.4302     0.9279     1.0058     0.3881     1.4115     1.4714     0.4155    -0.3357     1.9280     1.8985     0.8988     0.9938     0.4239     0.6081     0.9604     0.7433     0.1717     0.5050     0.4750\n");
	printf("\n    SATSTATTOT [orbit and clock comparison]\n\n");
	printf("        Difference summary message for products comparison mode. This message shows the statistics of the\n");
	printf("        differences between orbit and clocks for two different OC products fonts. It is shown after all the\n");
	printf("        comparisons are done, and presents a summary for all of them.\n");
	printf("        Field 1:      'SATSTATTOT'\n");
	printf("        Field 2:      Number of samples\n");
	printf("        Field 3-5:    SISRE comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 6-8:    SISRE orbit-only comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 9-11:   3D orbit comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 12-14:  Clock comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 15-17:  DCB comparisons (mean [L1 m], RMS [L1 m], stdDev [L1 m])\n");
	printf("        Field 18-20:  Radial position comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 21-23:  Along-track position comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Field 24-26:  Cross-track position comparisons (mean [m], RMS [m], stdDev [m])\n");
	printf("        Sample:\n");
	printf("            SATSTATTOT 2660     1.2971     1.6206     0.9714     1.0207     1.1478     0.5250     1.6623     1.7701     0.6083    -0.1909     1.3835     1.3702     0.9488     1.1312     0.6160     0.0514     1.1930     1.1918    -0.0345     0.6560     0.6551\n\n");
	printf("    SATPVT [show product mode]\n");
	printf("        Satellite data messages for show product mode. This message show the PVT data for a specific time and satellite.\n");
	printf("        Messages will be sorted by constellation and PRN, with this constellation order: GPS, Galileo, GLONASS, GEO, BeiDou, QZSS, IRNSS.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Coordinates are in WGS84 system except for Galileo and BeiDou with broadcast orbits, which are in GTRF and CGCS2000 systems respectively.\n");
	printf("        GTRF and CGCS2000 systems are aligned to WGS84 to a few centimetres, therefore, it is assumed that GTRF=WGS84 and CGCS2000=WGS84.\n");
	printf("        Field 1:      'SATPVT'\n");
	printf("        Field 2:      Year\n");
	printf("        Field 3:      Doy\n");
	printf("        Field 4:      Seconds of day\n");
	printf("        Field 5:      Time in HH:MM:SS.zz format\n");
	printf("        Field 6:      GNSS System (GPS, GAL, GLO, GEO or BDS)\n");
	printf("        Field 7:      PRN satellite identifier\n");
	printf("        Field 8:      Satellite block type\n");
	printf("        Field 9:      SVN (Space Vehicle Number)\n");
	printf("        Field 10:     Satellite elevation [degrees]\n");
	printf("        Field 11:     Satellite azimuth [degrees]\n");
	printf("        Field 12:     Satellite X position [m]\n");
	printf("        Field 13:     Satellite Y position [m]\n");
	printf("        Field 14:     Satellite Z position [m]\n");
	printf("        Field 15:     Satellite X velocity [m/s]\n");
	printf("        Field 16:     Satellite Y velocity [m/s]\n");
	printf("        Field 17:     Satellite Z velocity [m/s]\n");
	printf("        Field 18:     Satellite Latitude  position [degrees]\n");
	printf("        Field 19:     Satellite Longitude position [degrees]\n");
	printf("        Field 20:     Satellite Height    position [m]\n");
	printf("        Field 21:     Satellite clock offset [m]\n");
	printf("        Field 22:     Ephemerides block type name (LNAV, CNAV, etc.) or 'SP3' if precise products are used\n");
	printf("        Field 23:     IOD number or '-1' if no IOD in broadcast message or precise products are used\n");
	printf("        Field 24:     Health letter (H=Healthy, M=Marginal, U=Unhealthy), health value. If unhealthy, health flags are shown by frequency.\n\n");
	printf("        Fields 10 and 11 will only be non zero if a user defined position is set with parameter '-pre:setrecpos'.\n");
	printf("        Sample:\n");
	printf("            SATPVT SATPVT 2019 182 64830.00 18:00:30.00 GPS  4 UNKNOWN_BLOCK     -1   24.452 -146.772  15726758.8543 -11721444.2647 -17893256.4825      2263.5069       284.8536      1801.6815  -42.418676449  -36.697844087  20181374.7732      50617.846188      LNAV    2 U-63_(L1-U_L2-U)\n");
}
/*****************************************************************************
 * Name        : showMessagesv5
 * Description : Shows the fields of each output message for v5 format
 * Parameters  : None
 *****************************************************************************/
void showMessagesv5 () {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread), built on %s %s\n",VERSION,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("GNSS LABORATORY. Tool to analyse GNSS data\n");
	printf("Write 'gLAB -help' for help on the options\n");
	printf("Usage:\n");
	printf("    gLAB [options]\n");
	printf("\n  MESSAGES FORMAT\n");
	printf("\n  Messages format shown below are only used in option '-print:v5format', which is the format of gLAB v5\n\n");
	printf("    INFO\n");
	printf("        INFO messages are shown at several points in the program and provide information on the\n");
	printf("          program configuration, events and problems it may encounter, which are:\n\n"); 
	printf("             At the start of the file, showing information about gLAB configuration.\n"); 
	printf("             An inconsistent clock update on the receiver.\n"); 
	printf("             A data gap in the RINEX observation file.\n"); 
	printf("             A change in the a priori receiver coordinates (only when receiver coordinates are computed by gLAB).\n");
	printf("             The new position to be used from the reference position file (only when a reference file is provided).\n");
	printf("             No solution was computed, along with the reason for not being able to compute the\n");
	printf("                solution (not enough satellites available, singular geometry matrix or DOP too high).\n"); 
	printf("             In SBAS processing, the elevation of each GEO and the one selected (if GEO selection with highest\n");
	printf("                elevation is enabled).\n");
	printf("             In SBAS processing, a GEO or mode switch.\n"); 
	printf("             In SBAS processing, if option '-mode:selectbestgeo' is enabled, in each epoch, for each GEO which a\n");
	printf("               solution can be computed, the GEO PRN, its protection levels and a message if the GEO was selected is\n"); 
	printf("               printed. The selected GEO will be always the last one.\n");  
	printf("             In DGNSS processing, a switch from DGNSS to SPP solution mode.\n"); 
	printf("             In DGNSS processing, a data gap in the reference station RINEX observation file.\n"); 
	printf("\n    USERADDEDERROR [when user-defined error file is given]\n");
	printf("        User-defined error added to measurements before cycle-slip detection and smoothing.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'USERADDEDERROR'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GPS week\n");
	printf("        Field 6:  Time of week\n");
	printf("        Field 7:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 8:  PRN satellite identifier\n");
	printf("        Field 9:  Measurement identifier (as string)\n");
	printf("        Field 10: Raw measurement (phase measurements are prealigned) [m]\n");
	printf("        Field 11: Raw measurement plus total user-defined error (phase measurements are prealigned) [m]\n");
	printf("        Field 12: Total number of active user-defined error functions\n");
	printf("        Field 13: Total user-defined error [m]\n");
	printf("        Field 14: Number of active Step function error\n");
	printf("        Field 15: Step function error value [m]\n");
	printf("        Field 16: Number of active Ramp function error\n");
	printf("        Field 17: Ramp function error value [m]\n");
	printf("        Field 18: Number of active Sinusoidal function error\n");
	printf("        Field 19: Sinusoidal function error value [m]\n");
	printf("        Field 20: Number of active AWGN (Additive White Gaussian Noise) function error\n");
	printf("        Field 21: AWGN function error value [m]\n");
	printf("        Sample:\n");
	printf("            USERADDEDERROR   2015 161     0.00 1848 259200.00 GPS   4 C1C  23140309.8200  23140314.8200  1         5.0000  1         5.0000  0         0.0000  0         0.0000  0         0.0000\n\n");
	printf("    CS\n");
	printf("        Cycle-slip message information. It is shown when a cycle-slip is found by any detector.\n");
	printf("        A line will be printed for each CS detector that has found a CS.\n");
	printf("        The first 6 fields are common, afterwards, there are five possible different CS messages depending on\n");
	printf("        the cycle-slip detector activated.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'CS' or 'CS_USER' for Rover Station (user)\n");
	printf("        Field 1:  'CS_REF' for Reference Station\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:  PRN satellite identifier\n");
	printf("        If cycle-slip detector is Data gap:\n");
	printf("            Field 7:  'DATA_GAP'\n");
	printf("            Field 8:  '='\n");
	printf("            Field 9:  Delta time between usable epochs\n");
	printf("            Field 10: 'THRESHOLD'\n");
	printf("            Field 11: '='\n");
	printf("            Field 12: Data gap threshold\n");
	printf("            Sample:\n");
	printf("                CS       2014 288 44997.00 GPS 32  DATA_GAP = 45.000000 THRESHOLD = 40.000000\n");
	printf("        If cycle-slip detector is Loss of Lock Indicator:\n");
	printf("            Field 7:  'LLI'\n");
	printf("            Sample:\n");
	printf("                CS       2014 288 44942.00 GPS 32  LLI\n");
	printf("        If cycle-slip detector is Geometry-free carrier phase:\n");
	printf("            Field 7:  'LI'\n");
	printf("            Field 8:  '='\n");
	printf("            Field 9:  LI value\n");
	printf("            Field 10: 'THRESHOLD'\n");
	printf("            Field 11: '='\n");
	printf("            Field 12: LI threshold\n");
	printf("            Sample:\n");
	printf("                CS       2014 288 42092.00 GPS  7  LI = 0.119386 THRESHOLD = 0.052861\n");
	printf("        If cycle-slip detector is Melbourne-Wubbena:\n");
	printf("            Field 7:  'LI'\n");
	printf("            Field 8:  '='\n");
	printf("            Field 9:  Bw value\n");
	printf("            Field 10: 'THRESHOLD'\n");
	printf("            Field 11: '='\n");
	printf("            Field 12: Bw threshold\n");
	printf("            Sample:\n");
	printf("                CS       2014 288 42092.00 GPS  7  Bw = 1.992188 THRESHOLD = 1.839927\n");
	printf("        If cycle-slip detector is L1-C1 difference:\n");
	printf("            Field 7:  'LI'\n");
	printf("            Field 8:  '='\n");
	printf("            Field 9:  L1C1 value\n");
	printf("            Field 10: 'THRESHOLD'\n");
	printf("            Field 11: '='\n");
	printf("            Field 12: L1C1 threshold\n");
	printf("            Sample:\n");
	printf("                CS       2014 365 55344.00 GPS  7  L1C1 = 747.078356 THRESHOLD = 0.876845\n\n");
	printf("    INPUT\n");
	printf("        Input data message. It is shown after an epoch is read, decimated and added user-defined error\n");
	printf("        It contains the measurements for each satellite for this epoch\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'INPUT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:  PRN satellite identifier\n");
	printf("        Field 7:  Arc length (number of undecimated epochs after the last cycle-slip)\n");
	printf("        For GPS:\n");
	printf("            Field 8:  C1 [C1C]\n");
	printf("            Field 9:  P1 [C1P]\n");
	printf("            Field 10: P2 [C2P]\n");
	printf("            Field 11: L1 [L1P] (prealigned, in metres)\n");
	printf("            Field 12: L2 [L2P] (prealigned, in metres)\n");
	printf("        For Galileo (GAL):\n");
	printf("            Field 8:  C1A\n");
	printf("            Field 9:  C1B\n");
	printf("            Field 10: C1C\n");
	printf("            Field 11: C7Q\n");
	printf("            Field 12: C8Q\n");
	printf("            Field 13: L1A (prealigned, in metres)\n");
	printf("            Field 14: L1B (prealigned, in metres)\n");
	printf("            Field 15: L1C (prealigned, in metres)\n");
	printf("            Field 16: L7Q (prealigned, in metres)\n");
	printf("            Field 17: L8Q (prealigned, in metres)\n");
	printf("        For GLONASS (GLO):\n");
	printf("            Field 8:  C1 [C1C]\n");
	printf("            Field 9:  C2 [C2C]\n");
	printf("            Field 10: L1 [L1P](prealigned, in metres)\n");
	printf("            Field 11: L2 [L2P](prealigned, in metres)\n");
	printf("        For GEO:\n");
	printf("            Field 8:  C1 [C1C]\n");
	printf("        Sample:\n");
	printf("            INPUT     2006 200     0.00 GPS 19      1  23119003.9020  23119002.6110  23119004.0750  23119002.7507  23119004.0925\n\n");
	printf("    MEAS\n");
	printf("        Information of the input measurements in a variable format, and azimuth/elevation of the satellite.\n");
	printf("        It is written after modelling the message.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'MEAS'\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   Doy\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:   PRN satellite identifier\n");
	printf("        Field 7:   Elevation of the satellite [degrees]\n");
	printf("        Field 8:   Azimuth of the satellite [degrees]\n");
	printf("        Field 9:   Number of measurements\n");
	printf("        Field 10:  List of measurements included\n");
	printf("        Field 11-: Each following column is the value of the measurement specified in Field 10\n\n");
	printf("        If there is no data available on azimuth and elevation, the fields 7 and 8 will be fixed to zero.\n");
	printf("        Sample:\n");
	printf("            MEAS      2006 200     0.00 GPS 19   26.66  -79.62  6  C1C:L1C:C1P:L1P:C2P:L2P  23119003.9020         0.0000  23119002.6110  23119002.7507  23119004.0750  23119004.0925\n\n");
	printf("    MODEL\n");
	printf("        Model break down message. It is shown when a model can be fully computed for each measurement.\n");
	printf("        Satellite coordinates are in WGS84 system. All time tags are in GPS time.\n");
	printf("        Field 1:  'MODEL' (if the satellite is used in the computation) or 'MODEL*' (if it is not)\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:  PRN satellite identifier\n");
	printf("        Field 7:  Measurement identifier (as string)\n");
	printf("        Field 8:  Signal flight time [sec]\n");
	printf("        Field 9:  Measured value [m]\n");
	printf("        Field 10: Full model value [m]\n");
	printf("        Field 11: Satellite X position [m]\n");
	printf("        Field 12: Satellite Y position [m]\n");
	printf("        Field 13: Satellite Z position [m]\n");
	printf("        Field 14: Satellite X velocity [m]\n");
	printf("        Field 15: Satellite Y velocity [m]\n");
	printf("        Field 16: Satellite Z velocity [m]\n");
	printf("        Field 17: Satellite-receiver geometric distance [m]\n");
	printf("        Field 18: Satellite clock correction [m]\n");
	printf("        Field 19: Satellite phase centre projection [m]\n");
	printf("        Field 20: Receiver phase centre projection [m]\n");
	printf("        Field 21: Receiver Antenna Reference Point (ARP) projection [m]\n");
	printf("        Field 22: Relativity correction [m]\n");
	printf("        Field 23: Wind-up correction [m] (for carrier phase measurements)\n");
	printf("        Field 24: Troposphere nominal correction [m]\n");
	printf("        Field 25: Ionosphere correction [m]\n");
	printf("        Field 26: Gravitational delay correction [m]\n");
	printf("        Field 27: Total Group Delay (TGD) correction [m]\n");
	printf("        Field 28: Solid tides correction [m]\n");
	printf("        Field 29: Elevation of the satellite [degrees]\n");
	printf("        Field 30: Azimuth of the satellite [degrees]\n");
	printf("        Field 31: Satellite SNR (Signal to Noise Ratio) [dbHz]\n\n");
	printf("        The satellite coordinates (fields 11-16) are given in the transmission epoch if the model of the\n");
 	printf("          signal transmission time is enabled (if it is disabled, they are given in the reception\n");
	printf("          time). The coordinates are relative to the antenna phase centre or satellite mass centre,\n");
	printf("          depending on the products input:\n");
	printf("            * Broadcast: Antenna Phase Centre\n");
	printf("            * Precise: Satellite Mass Centre\n");
	printf("        Field 9 is the direct measurement (as in the RINEX file), but scaled to metres for carrier phase\n");
	printf("          measurements. Field 10 is the model computed for this measurement. Field 10 is the direct sum\n");
	printf("          of fields 17 to 28.\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("          or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        The SNR value in field 31 may be any of these values (in this order): the \"S\" measurement in the\n");
	printf("          observation file, or if it is not present, it will be the SNR flag in the current measurement.\n");
	printf("          If no SNR is available, 999 will be printed in this field.\n");
	printf("        Sample:\n");
	printf("            MODEL     2006 200     0.00 GPS 19 L1P     0.07712  23119002.7507  23119008.7501   8811456.7780 -21033910.1687  13675922.8867      1828.7339      2353.7679      2467.3576  23119457.7652     -456.31787   0.00000  -0.04936  -0.01140   2.32333   0.10671   4.85412  -0.00000   0.01544   0.00000   0.06394   9.164  79.274\n\n");
	printf("    SATSEL\n");
	printf("        Message with debug information of the reason why a satellite has been discarded (or selected) for processing.\n");
	printf("        If multiple discard conditions are met in a single satellite, then a SATSEL message for each condition will be printed.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'SATSEL' (if navigation solution will be computed), 'SATSEL*' (if model parameters will be recomputed before the navigation solution, only in SBAS mode)\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:  PRN satellite identifier\n");
	printf("        Field 7:  'selected' if satellite is used or 'discarded:' if satellite is not used\n");
	printf("        Field 8:  Discard reason if satellite is not used\n");
	printf("        Sample:\n");
	printf("            SATSEL    2006 200     0.00 GPS 7 discarded: Elevation too low ( 3.04 )\n\n");
	printf("        The possible values for field 8 are:\n");
    printf("            - Arc too short (<arclength>)\n");
	printf("            - Pre-Check; measurements missing for CS detection\n");
	printf("            - Not enough consecutive samples (current <value>, minimum <value>)\n");
	printf("            - Unconsistency of measurements\n");
	printf("            - Outlier in LI detector\n");
	printf("            - Outlier in Bw detector\n");
	printf("            - Cycle-slip\n");
	printf("            - Measurement unavailable (<meas>)\n");
	printf("            - Deselection forced\n");
	printf("            - SNR too low (<value>)\n");
	printf("            - Steady-state operation not reached. <value> epochs passed, still <value> epochs to achieve <value>\n");
	printf("            - No code measurement available\n");
	printf("            - C1C measurement unavailable\n");
	printf("            - Ephemerides unavailable\n");
	printf("            - Satellite phase center corrections unavailable\n");
	printf("            - DCBs unavailable (strict TGD treatment)\n");
	printf("            - SBAS corrections unavailable (GEO <PRN>)\n");
	printf("            - Elevation too low (<value>)\n");
	printf("            - Satellite under eclipse\n");
	printf("            - Satellite was under eclipse <value> seconds ago\n");
	printf("            - URA value (<value>) is equal or greater than the threshold (<threshold>)\n");
	printf("            - Missing IONEX data\n");
	printf("            - Missing FPPP data\n");
	printf("            - SBAS iono unavailable (GEO <GEOPRN>)\n");
	printf("            - STEP detected (jump of <value> greater than <threshold>)\n");
	printf("            - Prefit too high in comparation with other satellites\n");
	printf("            - Prefit too high in comparation with other satellites (threshold <threshold> metres)\n");
	printf("            - Prefit too different (<value>) with respect to the prefit median (<median>), threshold <threshold> metres\n");
	printf("            - No DGNSS corrections\n");
	printf("            - No DGNSS corrections: Time out\n");
	printf("            - No DGNSS corrections: Excluded during the smoother conversion in the Reference Station\n");
	printf("            - No DGNSS corrections: IODE from BRDC and RTCM do not match\n");
	printf("            - No DGNSS corrections: Excluded due to differential correction is too large\n");
	printf("            - Invalid GNSS System: <system>\n\n");
	printf("    PREFIT\n");
	printf("        Prefilter values message. It provides the measurement-model values. It is shown in each filter execution.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'PREFIT' (if the satellite is used in the computation) or 'PREFIT*' (if it is not)\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:  PRN satellite identifier\n");
	printf("        Field 7:  Measurement identifier (as string)\n");
	printf("        Field 8:  Measurement-model value (prefit) [m]\n");
	printf("        Field 9:  Measurement value [m]\n");
	printf("        Field 10: Model value [m]\n");
	printf("        Field 11: X-partial derivative (-X component of the satellite line-of-sight vector)\n");
	printf("        Field 12: Y-partial derivative (-Y component of the satellite line-of-sight vector)\n");
	printf("        Field 13: Z-partial derivative (-Z component of the satellite line-of-sight vector)\n");
	printf("        Field 14: T-partial derivative \n");
	printf("        Field 15: Elevation of the satellite [degrees]\n");
	printf("        Field 16: Azimuth of the satellite [degrees]\n");
	printf("        Field 17: Standard deviation of the measurement  (for the filter) [m]\n");
	printf("        Field 18: Troposphere wet mapping\n");
	printf("        Field 19: Arc number\n\n");
	printf("        In general Field 8 = Field 9 - Field 10, but this is no longer true when using smoothing, as the\n");
	printf("          Field 9 is the raw measurement without smoothing, but the Field 8 computation takes smoothing into\n");
	printf("          account.\n");
	printf("        Sample:\n");
	printf("            PREFIT    2006 200   300.00 GPS 19  LC        -7.3029  22982271.7155  22982279.0184   28.28   0.3931  -0.4834   0.7822   1.0000   77.912   130.010    17.883     2\n\n");
	printf("    EPOCHSAT\n");
	printf("        Message with the satellites used to compute the solution. It is shown when the filter is run,\n");
	printf("        and is given for each measurement\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'EPOCHSAT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Measurement identifier (as string)\n");
	printf("        Field 6:  Number of satellites used in solution computation\n");
	printf("        Field 7-: Each following column is the identifier of a satellite\n");
	printf("        Sample:\n");
	printf("            EPOCHSAT  2006 200   300.00  PC  7 15  3 19 16 18 21 22\n\n");
	printf("    POSTFIT\n");
	printf("        Postfilter values message. It provides the corrected prefits with the filter estimation. It is\n");
	printf("        shown in each filter execution.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'POSTFIT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:  PRN satellite identifier\n");
	printf("        Field 7:  Measurement identifier (as string)\n");
	printf("        Field 8:  Measurement-corrected model value (postfit) [m]\n");
	printf("        Field 9:  Measurement value [m]\n");
	printf("        Field 10: Corrected model value with the filter estimations[m]\n");
	printf("        Field 11: Elevation of the satellite [degrees]\n");
	printf("        Field 12: Azimuth of the satellite [degrees]\n");
	printf("        Field 13: Only given for carrier phase measurements. It is the estimated carrier phase ambiguity. [m]\n\n");
	printf("        As with PREFIT messages, Field 8 is not necessary Field 9 - Field 10 when using smoothing.\n");
	printf("        Sample:\n");
	printf("            POSTFIT   2006 200   300.00 GPS 19  LC         0.0000  22982271.7155  22982271.7155   77.912   130.010   0.3029\n\n");
	printf("    FILTER\n");
	printf("        Filter solution message. This message provides direct information on the filter estimates. It is shown\n");
	printf("        in each filter execution.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'FILTER'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5-: Filter estimates. The order is: 3D estimated position, clock, troposphere and ambiguities\n"); 
	printf("        The number of fields is variable in this message. With a full filter (troposphere and ambiguities\n");
	printf("        estimation), the fields are as follows:\n");
	printf("            Field 5:  Receiver X position [m]\n");
	printf("            Field 6:  Receiver Y position [m]\n");
	printf("            Field 7:  Receiver Z position [m]\n");
	printf("            Field 8:  Receiver clock [m]\n");
	printf("            Field 9:  Zenith Tropospheric Delay [m]\n");
	printf("            Field 10: Carrierphase ambiguities [m]\n");
	printf("        Sample:\n");
	printf("            FILTER    2006 200   300.00   4849203.0770   -360328.5730   4114913.9184        -7.4867         2.1946        -0.0001         1.1079        -1.1073         0.3029         0.4555         0.0897         0.0001         0.3845         0.2136\n\n");
	printf("    OUTPUT\n");
	printf("        Receiver solution message. This message provides the estimated receiver position in WGS84 system.\n");
	printf("        It is shown in each filter execution.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:  'OUTPUT'\n");
	printf("        Field 2:  Year\n");
	printf("        Field 3:  Doy\n");
	printf("        Field 4:  Seconds of day\n");
	printf("        Field 5:  Square root of the sum of the covariance matrix. This is a measure of the convergence of the filter\n");
	printf("        Field 6:  Receiver X position [m]\n");
	printf("        Field 7:  Receiver Y position [m]\n");
	printf("        Field 8:  Receiver Z position [m]\n");
	printf("        Field 9:  Receiver X position - Nominal a priori X position [m]\n");
	printf("        Field 10: Receiver Y position - Nominal a priori Y position [m]\n");
	printf("        Field 11: Receiver Z position - Nominal a priori Z position [m]\n");
	printf("        Field 12: Receiver X formal error [m]\n");
	printf("        Field 13: Receiver Y formal error [m]\n");
	printf("        Field 14: Receiver Z formal error [m]\n");
	printf("        Field 15: Receiver latitude [degrees]\n");
	printf("        Field 16: Receiver longitude [degrees]\n");
	printf("        Field 17: Receiver height [m]\n");
	printf("        Field 18: Receiver North difference in relation to nominal a priori position [m]\n");
	printf("        Field 19: Receiver East difference in relation to nominal a priori position [m]\n");
	printf("        Field 20: Receiver Up difference in relation to nominal a priori position [m]\n");
	printf("        Field 21: Receiver formal error in North direction [m]\n");
	printf("        Field 22: Receiver formal error in East direction [m]\n");
	printf("        Field 23: Receiver formal error in Up direction [m]\n");
	printf("        Field 24: Geometric Dilution of Precision (GDOP)\n");
	printf("        Field 25: Positioning Dilution of Precision (PDOP)\n");
	printf("        Field 26: Time Dilution of Precision (TDOP)\n");
	printf("        Field 27: Horizontal Dilution of Precision (HDOP)\n");
	printf("        Field 28: Vertical Dilution of Precision (VDOP)\n");
	printf("        Field 29: Zenith Tropospheric Delay (including nominal value) [m]\n");
	printf("        Field 30: Zenith Tropospheric Delay (excluding nominal value) [m]\n");
	printf("        Field 31: Zenith Tropospheric Delay formal error [m]\n");
	printf("        Field 32: Number of satellites used in the navigation solution\n");
	printf("        Field 33: Processing mode indicator\n\n");
	printf("        The fields 29, 30 and 31 will be zero if troposphere is not estimated (only estimated in PPP mode)\n");
	printf("        Processing mode indicator in field 33 may have the following values:\n");
	printf("           0 -> SPP\n");
	printf("           1 -> PPP\n");
	printf("           2 -> SBAS\n");
	printf("           3 -> DGNSS\n");
	printf("        The nominal a priori position is a prerequisite of the processing, and can be specified or read from the RINEX\n");
	printf("        input file. See the option '-pre:setrecpos' in the help ('-help') for more details.\n");
	printf("        Sample:\n");
	printf("            OUTPUT    2006 200   300.00    2.6219   4849203.1236   -360328.5229   4114913.9535     0.7693     0.4145     0.7580     1.9353     0.6998     1.6246   40.429162956   -4.249653155  830.480629026     0.0993     0.4704     1.0522     1.1365     0.6772     2.2637     0.9572     12.2743     5.0975     7.2205     3.5866     3.0880     0.0097     0.4995 6 1\n\n");
	printf("    SBASCORR [SBAS processing mode]\n");
	printf("        SBAS corrections breakdown. It is shown when a model can be fully computed using SBAS corrections for GPS C1C measurement.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASCORR' (if it is used in computation) or 'SBASCORR*' (if it is not)\n");
	printf("        Field 2:   Receiver id\n");
	printf("        Field 3:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 4:   GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 5:   PRN satellite identifier\n");
	printf("        Field 6:   Year\n");
	printf("        Field 7:   Doy\n");
	printf("        Field 8:   Seconds of day\n");
	printf("        Field 9:   GPS week\n");
	printf("        Field 10:  Time of week\n");
	printf("        Field 11:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 12:  Measurement-model value (prefit) [m]\n");
	printf("        Field 13:  Measurement value without smoothing [m]\n");
	printf("        Field 14:  Measurement value with smoothing [m]\n");
	printf("        Field 15:  Satellite-receiver geometric distance (with SBAS corrections) [m]\n");
	printf("        Field 16:  Relativity correction (with SBAS corrections) [m]\n");
	printf("        Field 17:  Satellite clock correction (with SBAS corrections) [m]\n");
	printf("        Field 18:  Total Group Delay (TGD) correction [m]\n");
	printf("        Field 19:  Ionosphere pierce point latitude [-90..90 degrees]\n");
	printf("        Field 20:  Ionosphere pierce point longitude [0..360 degrees]\n");
	printf("        Field 21:  Ionosphere correction [m]\n");
	printf("        Field 22:  Troposphere nominal correction [m]\n");
	printf("        Field 23:  PRC (fast correction) applied to the satellite [m]\n");
	printf("        Field 24:  RRC (range-rate correction) applied to the satellite [m]\n");
	printf("        Field 25:  Fast correction degradation factor [m/s^2]\n");
	printf("        Field 26:  PRC time out [s]\n");
	printf("        Field 27:  RRC time out (smallest PRC time out for all satellites) [s]\n");
	printf("        Field 28:  Time (seconds of day) used for computing PRC timeout\n");
	printf("        Field 29:  Time (seconds of day) used for computing sigma UDRE (User Differential Range Error) timeout\n");
	printf("        Field 30:  Time (seconds of day) used for computing fast correction degradation\n");
	printf("        Field 31:  X component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 32:  Y component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 33:  Z component of the satellite position in WGS84 system at emission time with SBAS corrections [m]\n");
	printf("        Field 34:  Long term correction to be applied to the X component of the satellite [m]\n");
	printf("        Field 35:  Long term correction to be applied to the Y component of the satellite [m]\n");
	printf("        Field 36:  Long term correction to be applied to the Z component of the satellite [m]\n");
	printf("        Field 37:  Long term correction to be applied to the satellite clock [m]\n");
	printf("        Field 38:  IODP (Issue of Data PRN mask) used for fast corrections\n");
	printf("        Field 39:  IODF (Issue of Data Fast Correction) in messages type 2-5,24 for fast corrections\n");
	printf("        Field 40:  Satellite slot in the fast correction mask [1..51]\n");
	printf("        Field 41:  IODP used for long term corrections\n");
	printf("        Field 42:  Satellite slot in the long term correction mask [1..51]\n");
	printf("        Field 43:  IODE (Issue of Data Ephemeris) used for broadcast ephemeris\n");
	printf("        Field 44:  IODS (Service Issue of Data) used for service message\n");
	printf("        Field 45:  IODP used for covariance matrix\n");
	printf("        Field 46:  Satellite slot in the covariance mask [1..51]\n");
	printf("        Field 47:  Ionosphere model flag\n");
	printf("        Field 48:  Elevation of the satellite [degrees]\n");
	printf("        Field 49:  Azimuth of the satellite [degrees]\n\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Field 43 is the IODE value from the broadcast message matched with the SBAS long term corrections. If the field value is negative,\n");
	printf("        it means that the IODE used does not match any SBAS long term correction messagea available (only in NPA mode). A value of 999 means\n");
	printf("        that no valid broadcast message was found for the current epoch.\n");
	printf("        Field 47 is a flag to indicate which ionosphere model is used. Its possible values are '-1' for no ionosphere model,\n");
	printf("         '0' for SBAS ionosphere model, '1' for Klobuchar ionosphere model and '2' for any other ionosphere model\n");
	printf("        Sample:\n");
	printf("            SBASCORR    vigo  PA GPS  23 2015 165  5088.00 1849   5088.00 120     60577.5787  20948474.4600  20948474.4600  20853522.4567        -4.3086     34379.4657        -6.0029        42.7112        -7.1281         2.3087         2.7117        -0.2500         0.0000 0.00580        12.0000        12.0000  5084.1  5084.1  5084.1  17496575.5944 5306168.63534 19563205.09708  -1.00000   0.62500   0.12500   0.69801  0  1 22  0 22  99  0 -1 -1  0   65.512   66.455\n\n");
	printf("    SBASVAR [SBAS processing mode]\n");
	printf("        SBAS variance contributions breakdown. It is shown when a model can be fully computed using SBAS corrections for GPS C1C measurement.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASVAR' (if it is used in computation) or 'SBASVAR*' (if it is not)\n");
	printf("        Field 2:   Receiver id\n");
	printf("        Field 3:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 4:   GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 5:   PRN satellite identifier\n");
	printf("        Field 6:   Year\n");
	printf("        Field 7:   Doy\n");
	printf("        Field 8:   Seconds of day\n");
	printf("        Field 9:   GPS week\n");
	printf("        Field 10:  Time of week\n");
	printf("        Field 11:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 12:  Sigma of the total residual error associated to the satellite [m]\n");
	printf("        Field 13:  Sigma of the residual error associated to the fast and long-term corrections [m]\n");
	printf("        Field 14:  Sigma of the UDRE [m]\n");
	printf("        Field 15:  Delta UDRE (User Differential Range Error) factor\n");
	printf("        Field 16:  Data source (SBAS message type number) for Delta UDRE\n");
	printf("        Field 17:  Degradation parameter for fast correction data [m]\n");
	printf("        Field 18:  Degradation parameter for range rate correction data [m]\n");
	printf("        Field 19:  Degradation parameter for long term correction data or GEO navigation message data [m]\n");
	printf("        Field 20:  Degradation parameter for en route through NPA applications [m]\n");
	printf("        Field 21:  RSS (Root-Sum-Square) flag in message type 10\n");
	printf("        Field 22:  Sigma of the residual error associated to the ionosheric corrections [m]\n");
	printf("        Field 23:  Sigma of the residual error associated to the tropospheric corrections [m]\n");
	printf("        Field 24:  Sigma of the total receiver error [m]\n");
	printf("        Field 25:  Sigma of the receiver noise [m]\n");
	printf("        Field 26:  Sigma of the receiver multipath [m]\n");
	printf("        Field 27:  Sigma of the receiver divergence [m]\n");
	printf("        Field 28:  Elevation of the satellite [degrees]\n");
	printf("        Field 29:  Azimuth of the satellite [degrees]\n\n");
	printf("        The data source indicator for Delta UDRE in field 16 may have the following values:\n"); 
	printf("          27 or 28 for their respective message type,\n");
	printf("          -27 or -28 if received any of these message types but there was missing data for current satellite or was timed out,\n");
	printf("          0 if no message type received or both received.\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Sample:\n");
	printf("            SBASVAR     vigo  PA GPS  23 2015 165  5088.00 1849   5088.00 120         1.4270         1.0975         0.9119    1.000  27         0.1856         0.0000         0.0000         0.0000 0         0.8173         0.1318         0.3830    0.360    0.131    0.000   65.512   66.455\n\n");
	printf("    SBASIONO [SBAS processing mode]\n");
	printf("        SBAS ionosphere breakdown. It is shown when SBAS ionosphere can be computed.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASIONO' (if it is used in computation) or 'SBASIONO*' (if it is not)\n");
	printf("        Field 2:   Receiver id\n");
	printf("        Field 3:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 4:   GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 5:   PRN satellite identifier\n");
	printf("        Field 6:   Year\n");
	printf("        Field 7:   Doy\n");
	printf("        Field 8:   Seconds of day\n");
	printf("        Field 9:   GPS week\n");
	printf("        Field 10:  Time of week\n");
	printf("        Field 11:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 12:  Ionosphere pierce point latitude [-90..90 degrees]\n");
	printf("        Field 13:  Ionosphere pierce point longitude [0..360 degrees]\n");
	printf("        Field 14:  Interpolation mode. 0 for square interpolation, [1-4] indicates the vertex not used in triangle interpolation\n");
	printf("        Field 15:  IODI (Issue of Data Ionospheric) for vertex 1\n");
	printf("        Field 16:  Band Number for vertex 1\n");
	printf("        Field 17:  IGP Number for vertex 1\n");
	printf("        Field 18:  Time of reception of last bit of vertex 1 IGP [seconds of day]\n");
	printf("        Field 19:  Latitude of the IGP for vertex 1 [-90..90 degrees]\n");
	printf("        Field 20:  Longitude of the IGP for vertex 1 [0..360 degrees]\n");
	printf("        Field 21:  Ionosphere delay (raw value from MT26) for vertex 1 [L1 m]\n");
	printf("        Field 22:  Ionosphere variance (raw value from MT26) for vertex 1 [L1 m^2]\n");
	printf("        Field 23:  Degradation term for vertex 1 [L1 m]\n");
	printf("        Field 24:  Ionosphere delay after interpolation (if required) for vertex 1 [L1 m]\n");
	printf("        Field 25:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 1 [L1 m^2]\n");
	printf("        Field 26:  Interpolation weight for vertex 1\n");
	printf("        Field 27:  IODI for vertex 2\n");
	printf("        Field 28:  Band Number for vertex 2\n");
	printf("        Field 29:  IGP Number for vertex 2\n");
	printf("        Field 30:  Time of reception of last bit of vertex 2 IGP [seconds of day]\n");
	printf("        Field 31:  Latitude of the IGP for vertex 2 [-90..90 degrees]\n");
	printf("        Field 32:  Longitude of the IGP for vertex 2 [0..360 degrees]\n");
	printf("        Field 33:  Ionosphere delay (raw value from MT26) for vertex 2 [L1 m]\n");
	printf("        Field 34:  Ionosphere variance (raw value from MT26) for vertex 2 [L1 m^2]\n");
	printf("        Field 35:  Degradation term for vertex 2 [L1 m]\n");
	printf("        Field 36:  Ionosphere delay after interpolation (if required) for vertex 2 [L1 m]\n");
	printf("        Field 37:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 2 [L1 m^2]\n");
	printf("        Field 38:  Interpolation weight for vertex 2\n");
	printf("        Field 39:  IODI for vertex 3\n");
	printf("        Field 40:  Band Number for vertex 3\n");
	printf("        Field 41:  IGP Number for vertex 3\n");
	printf("        Field 42:  Time of reception of last bit of vertex 3 IGP [seconds of day]\n");
	printf("        Field 43:  Latitude of the IGP for vertex 3 [-90..90 degrees]\n");
	printf("        Field 44:  Longitude of the IGP for vertex 3 [0..360 degrees]\n");
	printf("        Field 45:  Ionosphere delay (raw value from MT26) for vertex 3 [L1 m]\n");
	printf("        Field 46:  Ionosphere variance (raw value from MT26) for vertex 3 [L1 m^2]\n");
	printf("        Field 47:  Degradation term for vertex 3 [L1 m]\n");
	printf("        Field 48:  Ionosphere delay after interpolation (if required) for vertex 3 [L1 m]\n");
	printf("        Field 49:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 3 [L1 m^2]\n");
	printf("        Field 50:  Interpolation weight for vertex 3\n");
	printf("        Field 51:  IODI for vertex 4\n");
	printf("        Field 52:  Band Number for vertex 4\n");
	printf("        Field 53:  IGP Number for vertex 4\n");
	printf("        Field 54:  Time of reception of last bit of vertex 4 IGP [seconds of day]\n");
	printf("        Field 55:  Latitude of the IGP for vertex 4 [-90..90 degrees]\n");
	printf("        Field 56:  Longitude of the IGP for vertex 4 [0..360 degrees]\n");
	printf("        Field 57:  Ionosphere delay (raw value from MT26) for vertex 4 [L1 m]\n");
	printf("        Field 58:  Ionosphere variance (raw value from MT26) for vertex 4 [L1 m^2]\n");
	printf("        Field 59:  Degradation term for vertex 4 [L1 m]\n");
	printf("        Field 60:  Ionosphere delay after interpolation (if required) for vertex 4 [L1 m]\n");
	printf("        Field 61:  Ionosphere variance after applying degradation and interpolation (if required) for vertex 4 [L1 m^2]\n");
	printf("        Field 62:  Interpolation weight for vertex 4\n");
	printf("        Field 63:  Mapping function\n");
	printf("        Field 64:  Slant delay [L1 m]\n");
	printf("        Field 65:  Slant Sigma [L1 m]\n");
	printf("        Field 66:  Elevation of the satellite [degrees]\n");
	printf("        Field 67:  Azimuth of the satellite [degrees]\n\n");
	printf("        Vertex 1 is the IGP north east to IPP, vertex 2 is the IGP north west to IPP, vertex 3 is the IGP south west to IPP,\n");
	printf("        vertex 4 is the IGP south east to IPP. This order is shown in the following figure:\n");
	printf("                            NORTH\n");
	printf("                      v2..............v1\n");
	printf("                      .               .\n");
	printf("                      .               .\n");
	printf("                      .               .\n");
	printf("           WEST       .    IPP        .       EAST\n");
	printf("                      .     *         .\n");
	printf("                      .               .\n");
	printf("                      .               .\n");
	printf("                      v3..............v4\n");
	printf("                            SOUTH\n");
	printf("        When the '*' appears in field 1, it is due to smoothed code of the satellite has not reached steady-state, a SBAS processing mode switch\n");
	printf("         or SBAS GEO switch. When a mode or GEO switch occurs, the SBAS corrections have to be computed again.\n");
	printf("        Sample:\n");
	printf("            SBASIONO    vigo  PA GPS  23 2015 165  5088.00 1849   5088.00 120   42.711  352.872 0 0  4  98  4899.1  45 355  2.000   0.5322  0.000   2.0000   0.5322 0.3114 0  4  73  4963.1  45 350  2.000   0.6735  0.000   2.0000   0.6735 0.2308 0  4  72  4963.1  40 350  2.125   0.5322  0.000   2.1250   0.5322 0.1948 0  4  97  4899.1  40 355  2.375   0.5322  0.000   2.3750   0.5322 0.2629   1.0875   2.3087   0.8173 65.51 66.46\n\n");
	printf("    SBASUNSEL [SBAS processing mode]\n");
	printf("        SBAS satellite unselection message. When a satellite is discarded due to MOPS criteria, this message details the reason.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASUNSEL' (if it is the definitive reason for discarding) or 'SBASUNSEL*' (if there has been a GEO or mode switch or not reached smoothed code steady-state operation)\n");
	printf("        Field 2:   Receiver id\n");
	printf("        Field 3:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 4:   GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 5:   PRN satellite identifier\n");
	printf("        Field 6:   Year\n");
	printf("        Field 7:   Doy\n");
	printf("        Field 8:   Seconds of day\n");
	printf("        Field 9:   GPS week\n");
	printf("        Field 10:  Time of week\n");
	printf("        Field 11:  GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 12:  Error code\n");
	printf("        Field 13:  \"Discard reason\"\n");
	printf("        The error code in field 12 is a number which identifies the discard reason with a range from 1 to 48. Useful for parsing purposes.\n");
	printf("        Field 13 will be always between quotes in order to ease parsing purposes.\n");
	printf("        Fields 12 and 13 may have the following values:\n");
	printf("          1    \"No GEO satellites available\"\n");
	printf("          2    \"No data for user selected GEO\"\n");
	printf("          3    \"Not enough almanac or GEO navigation message to determine the GEO with highest elevation\"\n");
	printf("          4    \"Received alarm message for current GEO at epoch <YYYY DoY SoD>. Time remaining to finish alarm: <seconds> seconds\"\n");
	printf("          5    \"Received <value> consecutive messages with errors (UDREI data has been forced to timeout) [PA only]\"\n");
	printf("          6    \"Missed <value> consecutive messages\"\n");
	printf("          7    \"No PRN mask\"\n");
	printf("          8    \"PRN mask timed out\"\n");
	printf("          9    \"Satellite is not monitored in any of the PRN mask available\"\n");
	printf("          10   \"No message type 10 available [PA only]\"\n");
	printf("          11   \"Message type 10 timed out [PA only]\"\n");
	printf("          12   \"No fast correction data received for current PRN [PA only]\"\n");
	printf("          13   \"Sigma UDRE timed out [PA only]\"\n");
	printf("          14   \"Satellite flagged as 'Not monitored' (UDREI=14)\"\n");
	printf("          15   \"Satellite flagged as 'Do not use' (UDREI=15)\"\n");
	printf("          16   \"Satellite has an UDREI value of <value> [PA only]\n");
	printf("          17   \"No fast correction degradation data [PA only]\"\n");
	printf("          18   \"Fast correction degradation data timed out [PA only]\"\n");
	printf("          19   \"Last PRC received timed out [PA only]\"\n");
	printf("          20   \"Only one PRC received. RRC calculation not possible [PA only]\"\n");
	printf("          21   \"RRC timed out (under alarm condition) due to time difference between PRC used [PA only]\"\n");
	printf("          22   \"RRC timed out (under alarm condition) due to excessive PRC propagation in time [PA only]\"\n");
	printf("          23   \"RRC timed out due to time difference between PRC used [PA only]\"\n");
	printf("          24   \"RRC timed out due to excessive PRC propagation in time [PA only]\"\n");
	printf("          25   \"Service message timed out [PA only]\"\n");
	printf("          26   \"Not received a full set of service messages with the same IODS [PA only]\"\n");
	printf("          27   \"No clock-ephemeris covariance matrix data for current satellite [PA only]\"\n");
	printf("          28   \"Clock-ephemeris covariance matrix data timed out [PA only]\"\n");
	printf("          29   \"No navigation data for ranging GEO\"\n");
	printf("          30   \"Ranging GEO navigation data timed out\"\n");
	printf("          31   \"URA index value of <value> for ranging GEO satellite\"\n");
	printf("          32   \"No long term correction data for current satellite [PA only]\"\n");
	printf("          33   \"Long term correction data timed out [PA only]\"\n");
	printf("          34   \"No broadcast block with IOD <value> [PA only]\"\n");
	printf("          35   \"No broadcast block available for current satellite (regardless of SBAS IOD) [NPA only]\"\n");
	printf("          36   \"Could not compute transmission time for current PRN measurement\"\n");
	printf("          37   \"No ionospheric grid mask [PA only]\"\n");
	printf("          38   \"Ionospheric grid mask timed out [PA only]\"\n");
	printf("          39   \"IGPs around ionospheric pierce point not found in MOPS grid [PA only]\"\n");
	printf("          40   \"Not enough IGPs available in ionospheric grid mask [PA only]\"\n");
	printf("          41   \"One IGP is set as don't use [PA only]\"\n");
	printf("          42   \"One or more IGPs is set as not monitored or has timed out [PA only]\"\n");
	printf("          43   \"Data not available for one or more IGPs [PA only]\"\n");
	printf("          44   \"Ionospheric pierce point is outside triangle [PA only]\"\n");
	printf("          45   \"External ionosphere model not available\"\n");
	printf("          46   \"Satellite is not in view (elevation <value> degrees)\"\n");
	printf("          47   \"Satellite elevation (<value> degrees) is too low\"\n");
	printf("          48   \"Satellite has an UDREI value of <value> (user threshold is <value>)\"\n\n");
	printf("        Error code number 45 will only appear if user has selected another ionosphere model for SBAS processing\n");
	printf("        Error codes number 46 and 47 will only appear in SBAS plots mode\n");
	printf("        Sample:\n");
	printf("            SBASUNSEL   vigo  PA  31 2015 165   397.00 1849    397.00 120 16 \"Satellite has an UDREI value of 12 [PA only]\"\n\n");
	printf("    SBASOUT [SBAS processing mode]\n");
	printf("        Receiver solution message. This message provides the estimated receiver position, protection levels\n");
	printf("        and satellites used in solution computation.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SBASOUT'\n");
	printf("        Field 2:   Receiver id\n");
	printf("        Field 3:   SBAS processing mode (PA or NPA)\n");
	printf("        Field 4:   Year\n");
	printf("        Field 5:   Doy\n");
	printf("        Field 6:   Seconds of day\n");
	printf("        Field 7:   GPS week\n");
	printf("        Field 8:   Time of week\n");
	printf("        Field 9:   GEO PRN from which SBAS corrections are used ('0' means all GEOs)\n");
	printf("        Field 10:  Receiver North difference in relation to nominal a priori position [m]\n");
	printf("        Field 11:  Receiver East difference in relation to nominal a priori position [m]\n");
	printf("        Field 12:  Receiver Up difference in relation to nominal a priori position [m]\n");
	printf("        Field 13:  Horizontal positioning error [m]\n");
	printf("        Field 14:  Horizontal protection level [m]\n");
	printf("        Field 15:  Vertical positioning error [m]\n");
	printf("        Field 16:  Vertical protection level [m]\n");
	printf("        Field 17:  Receiver clock offset [m]\n");
	printf("        Field 18:  Number of satellites in view suitable for SBAS\n");
	printf("        Field 19:  Number of satellites used in SBAS solution computation\n");
	printf("        Field 20-: Satellite list. Each following column is a '+' or '-' sign, the satellite system and the PRN identifier.\n");
	printf("                   The '+' sign indicates that the satellite has been used in the solution computation for SBAS.\n");
	printf("                   The '-' sign indicates that the satellite has not been used in the solution computation for SBAS.\n");
	printf("                   The satellite list will show first all the satellite with the '+' and after the ones with the '-' sign.\n");
	printf("        Sample:\n");
	printf("            SBASOUT     vigo  PA 2015 165   386.00 1849    386.00 120         0.3565         1.0723        -0.3439         1.1300        20.9835        21.8638    -94936.8124 11 10 +G23 +G17 +G01 +G04 +G10 +G11 +G03 +G06 +G31 +G32 -G09\n");
	printf("    DGNSS [DGNSS processing mode]\n");
	printf("        DGNSS corrections breakdown. It is shown when a model can be fully computed using DGNSS corrections for GPS C1C measurement.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:      'DGNSS' (if it is used in computation) or 'DGNSS*' (if it is not, switched to SPP)\n");
	printf("        Field 2:      Year\n");
	printf("        Field 3:      Doy\n");
	printf("        Field 4:      Seconds of day\n");
	printf("        Field 5:      GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:      PRN Satellite identifier\n");
	printf("        Field 7:      Pseudorange correction to be applied to the satellite [m]\n");
	printf("        Field 8:      Range rate correction to be applied to the satellite [m]\n");
	printf("        Field 9:      Seconds elapsed since the reception of the RRC correction [s]\n");
	printf("        Field 10:     Delta of PRC to be applied in case of change in case of a change in ephemeris [m]\n");
	printf("        Field 11:     Delta of RRC to be applied in case of change in case of a change in ephemeris [m]\n");
	printf("        Field 12:     Seconds elapsed since the reception of the delta RRC correction [s]\n");
	printf("        Field 13:     Sigma of the total residual error associated to the satellite [m]\n");
	printf("                        Sigma of the total residual error = sigma of the UDRE + sigma degradation + sigma air\n");
	printf("        Field 14:     Sigma of the UDRE (User Differential Range Error) [m]\n");
	printf("        Field 15:     Sigma degradation consists of the URA (User Range Accuracy) degradation factor (we assume epsURA = 1 cm/s), and the satellite elevation. It only applies for RTCM v3.x [m]\n");
	printf("                        Sigma degradation = (epsURA * dt) / tan(satellite elevation)\n");
	printf("        Field 16:     Sigma air consists of the sigma multipath, the sigma to noise GPS (we assume 0.25 m) and the sigma inflation (equal to 1 if deactivated) [m]\n");
	printf("                        Sigma air = ( sigma multipath + sigma to noise GPS ) * sigma inflation\n");
	printf("        Field 17:     Sigma multipath = 0.0625 / tan(elev) / tan(elev)\n");
	printf("        Field 18:     Sigma inflation during the convergence of the smoothing\n");
	printf("        Sample:\n");
	printf("            DGNSS     2016 294  5407.000 GPS  6  -4.1800   0.0000   1.5999   0.0000   0.0000   0.0000   0.6053   0.3000   0.0000   0.5257   0.0264   1.0000\n");
	printf("\n    SUMMARY\n");
	printf("          The processing summary is printed at the end of the output file if the summary option is enabled.\n");
	printf("          The contents of the summary are:\n\n"); 
	printf("             Number of epochs processed, along with the number epochs that had a solution.\n");
	printf("             Number of epochs skipped (epochs without solution).\n");
	printf("             Number of epochs missing during the summary period (if decimation is enabled, the epochs missing\n");
	printf("               will be separated into the epochs which would have been decimated or not decimated.\n");
	printf("             Number of epochs missing in the whole file.\n");
	printf("             Number of data gaps during the summary period.\n");
	printf("             Number of data gaps in the whole file.\n");
	printf("             Maximum data gap size during the summary period and the epoch where it occurred.\n");
	printf("             Maximum data gap size in the whole file and the epoch where it occurred.\n");
	printf("             The 95 Percentile (or user defined percentile) of the PDOP,GDOP,TDOP,HDOP and VDOP.\n");
	printf("             The maximum value of PDOP,GDOP,TDOP,HDOP and VDOP and the epochs were it ocurred.\n");
	printf("             The 95 Percentile (or user defined percentile) of the errors.\n");
	printf("             The epoch with highest errors and the epoch were it ocurred.\n");
	printf("             A single line at the end with the previous info in columnar format. This is line is useful for doing plots.\n"); 
	printf("          Additionally, for SBAS processing, the following information is provided:\n");
	printf("             Number of epochs with solution under alarm limits.\n"); 
	printf("             Number of epochs with MIs.\n"); 
	printf("             The Worst Integrity Ratio (WIR) and the epoch were it ocurred.\n"); 
	printf("             The epoch with highest protection levels and the epoch were it ocurred.\n"); 
	printf("             The 95 Percentile (or user defined percentile) of the protection levels.\n"); 
	printf("          Additionally, for DGNSS processing, the following information is provided:\n");
	printf("             Number of epochs missing during the summary period in the reference station file (RINEX only).\n");
	printf("             Number of epochs missing in the whole file in the reference station file (RINEX only).\n");
	printf("             Number of data gaps during the summary period in the reference station file (RINEX only)..\n");
	printf("             Number of data gaps in the whole file in the reference station file (RINEX only)..\n");
	printf("             Maximum data gap size during the summary period and the epoch where it occurred in the reference station file (RINEX only).\n");
	printf("             Maximum data gap size in the whole file and the epoch where it occurred in the reference station file (RINEX only).\n");
	printf("\n    SPP/PPP SUMMARY [SPP or PPP processing modes]\n");
    printf("        SPP or PPP statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
    printf("        Sample:\n");
    printf("          INFO --------------------- SPP/PPP Summary ---------------------\n");
    printf("          INFO HDOP Threshold:   4.00\n");
    printf("          INFO PDOP Threshold:   6.00\n");
    printf("          INFO GDOP Threshold:  30.00\n");
	printf("          INFO First epoch of summary: 27/10/2016 00:00:00.00 / 2016 301     0.00 / 1920 345600.00\n");
	printf("          INFO Last  epoch of summary: 27/10/2016 23:59:59.00 / 2016 301 86399.00 / 1920 431999.00\n");
    printf("          INFO Total epochs processed: 86293\n");
    printf("          INFO Total epochs processed with solution: 85932 ( 99.582%% )\n");
	printf("          INFO Total epochs processed with solution and position from reference file: 85932 ( 99.582%% )\n");
	printf("          INFO Total epochs omitted in summary due to no position from reference file: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped due to no position from reference file for modelling: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 361 ( 0.418%% )\n");
    printf("          INFO Total epochs skipped due to singular geometry matrix: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to any DOP exceeding the threshold:       0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to HDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to PDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to HDOP and PDOP exceeding the threshold: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to GDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped (any reason): 361 ( 0.418%% )\n");
	printf("          INFO Total epochs missing in observation file (during summary period and not decimated):   1\n");
	printf("          INFO Total epochs missing in observation file (during summary period and decimated):       4\n");
	printf("          INFO Total epochs missing in observation file (during summary period):                     5\n");
	printf("          INFO Total epochs missing in observation file (all the file):                             13\n");
    printf("          INFO Number of data gaps in observation file (during summary period):   4\n");
    printf("          INFO Number of data gaps in observation file (all the file):            7\n");
    printf("          INFO Maximum data gap size in observation file (during summary period):    2 at epoch 26/01/2018 23:50:04.00 / 2018 026 85804.00 / 1985 517804.00\n");
    printf("          INFO Maximum data gap size in observation file (all the file):             6 at epoch 25/01/2018 23:46:36.00 / 2018 025 85596.00 / 1985 431196.00\n");
	printf("          INFO PDOP  95 Percentile:   2.33\n");
	printf("          INFO GDOP  95 Percentile:   2.69\n");
	printf("          INFO TDOP  95 Percentile:   1.34\n");
	printf("          INFO HDOP  95 Percentile:   1.30\n");
	printf("          INFO VDOP  95 Percentile:   1.98\n");
	printf("          INFO Maximum PDOP   3.04 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum GDOP   3.57 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum TDOP   1.87 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum HDOP   1.60 at epoch 26/01/2018 02:20:30.00 / 2018 026  8430.00 / 1985 440430.00\n");
	printf("          INFO Maximum VDOP   2.66 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO First epoch of summary for computing positioning error percentiles: 27/10/2016 00:00:00.00 / 2016 301     0.00 / 1920 345600.00\n");
	printf("          INFO Last  epoch of summary for computing positioning error percentiles: 27/10/2016 23:59:59.00 / 2016 301 86399.00 / 1920 431999.00\n");
    printf("          INFO Total samples in Stanford-ESA processed: 111056799\n");
    printf("          INFO Total samples in Stanford-ESA processed with solution: 111056798 ( 99.999%% )\n");
    printf("          INFO Total samples in Stanford-ESA skipped due to singular geometry matrix: 1 ( 9.004E-07%% )\n");
    printf("          INFO Horizontal  95 Positioning Error Percentile:   0.80 metres\n");
    printf("          INFO Vertical    95 Positioning Error Percentile:   1.73 metres\n");
    printf("          INFO Maximum Horizontal Positioning Error: 4.26 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Maximum Vertical   Positioning Error: 7.53 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Station: helg Lon:   7.89309376 Lat:   54.17448223 Height:   48.4689 HPE_Percentile:  95   0.80 VPE_Percentile:  95   1.73 MaxHPE:   0.00 MaxVPE:   0.00 Avail%%:   0.000 PDOP_Percentile:   95   2.33 Max_PDOP:   3.04 GDOP_Percentile:   95   2.69 Max_GDOP:   3.57 TDOP_Percentile:   95   1.34 Max_TDOP:   1.87 HDOP_Percentile:   95   1.30 Max_HDOP:   1.60 VDOP_Percentile:   95   1.98 Max_VDOP:   2.66 Epochs_missing_Sum:   5 Epochs_missing_All_file:  13 Num_DataGaps_Sum:   4 Num_DataGaps_All_file:   7 MaxSize_DataGap_Sum:   2 MaxSize_DataGap_All_file:   6 Station_Network_Name: Other\n");
    printf("        NOTES:\n");
    printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight)\n");
    printf("            are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the summary and\n");
    printf("            the Stanford-ESA computation will be skipped. This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
	printf("          If backwards processing is active, epochs missing and data gaps will only be counted during the forward processing.\n");
	printf("          If receiver position is not fixed or provided by a reference file, the percentile lines will not appear.\n");
	printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
	printf("            the epoch will be skipped from the summary.\n");
    printf("          The last line of the summary contains all the values of the previous lines along with the station coordinates.\n");
	printf("          If receiver position is not fixed, the station coordinates will be the solution from the last computed epoch.\n");
    printf("          The last line is useful for plotting world maps with data from each station.\n");
    printf("          Stanford-ESA messages will not appear if Stanford-ESA computation has not been enabled.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
	printf("          The lines referring to a reference file will only appear if a user sets a reference file. If user sets the reference file just for comparing\n");
	printf("            the solution, the line \"Total epochs omitted in ...\" will appear. Otherwise, if the reference file was set to be used as the a priori\n");
	printf("            position for the modelling computation, the line \"Total epochs skipped due to no position from reference file ...\" will appear.\n");
	printf("\n    SBAS SUMMARY [SBAS processing mode]\n");
	printf("        SBAS statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Sample:\n");
	printf("          INFO --------------------- SBAS Summary ---------------------\n");
	printf("          INFO Horizontal Alarm limit:  40.00 metres\n");
	printf("          INFO Vertical   Alarm limit:  50.00 metres\n");
    printf("          INFO HDOP Threshold:   4.00\n");
    printf("          INFO PDOP Threshold:   6.00\n");
	printf("          INFO GDOP Threshold: 100.00\n");
	printf("          INFO First epoch of summary: 27/10/2016 00:00:00.00 / 2016 301     0.00 / 1920 345600.00\n");
	printf("          INFO Last  epoch of summary: 27/10/2016 23:59:59.00 / 2016 301 86399.00 / 1920 431999.00\n");
	printf("          INFO Total epochs processed: 86293\n");
	printf("          INFO Total epochs processed with PA solution: 85932 ( 99.582%% )\n");
	printf("          INFO Total epochs processed with PA solution under alarm limits: 85932 ( 99.582%% )\n");
	printf("          INFO Total epochs processed with PA solution and position from reference file: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs processed with NPA solution: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs omitted in summary due to no position from reference file: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped due to no position from reference file for modelling: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 361 ( 0.418%% )\n");
	printf("          INFO Total epochs skipped due to singular geometry matrix: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to any DOP exceeding the threshold:       0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to HDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to PDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to HDOP and PDOP exceeding the threshold: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to GDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped (any reason): 361 ( 0.418%% )\n");
	printf("          INFO Total epochs missing in observation file (during summary period):   5\n");
	printf("          INFO Total epochs missing in observation file (all the file):           13\n");
    printf("          INFO Number of data gaps  in observation file (during summary period):   4\n");
    printf("          INFO Number of data gaps  in observation file (all the file):            7\n");
    printf("          INFO Maximum data gap size in observation file (during summary period):    2 at epoch 26/01/2018 23:50:04.00 / 2018 026 85804.00 / 1985 517804.00\n");
    printf("          INFO Maximum data gap size in observation file (all the file):             6 at epoch 25/01/2018 23:46:36.00 / 2018 025 85596.00 / 1985 431196.00\n");
	printf("          INFO PDOP  95 Percentile:   2.33\n");
	printf("          INFO GDOP  95 Percentile:   2.69\n");
	printf("          INFO TDOP  95 Percentile:   1.34\n");
	printf("          INFO HDOP  95 Percentile:   1.30\n");
	printf("          INFO VDOP  95 Percentile:   1.98\n");
	printf("          INFO Maximum PDOP   3.04 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum GDOP   3.57 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum TDOP   1.87 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum HDOP   1.60 at epoch 26/01/2018 02:20:30.00 / 2018 026  8430.00 / 1985 440430.00\n");
	printf("          INFO Maximum VDOP   2.66 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Continuity Risk Airborne (15 epochs sliding window): 1.7456E-04\n");
	printf("          INFO Continuity Risk Maritime (15 epochs fixed window):   1.8156E-03\n");
	printf("          INFO First epoch of summary for computing MIs, PE, PL and percentiles: 27/10/2016 00:00:00.00 / 2016 301     0.00 / 1920 345600.00\n");
	printf("          INFO Last  epoch of summary for computing MIs, PE, PL and percentiles: 27/10/2016 23:59:59.00 / 2016 301 86399.00 / 1920 431999.00\n");
	printf("          INFO Total epochs with MIs: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs with Horizontal MIs: 0 ( 0.000%% )\n");
	printf("          INFO Total epochs with Vertical   MIs: 0 ( 0.000%% )\n");
	printf("          INFO Total samples in Stanford-ESA processed: 111056799\n");
	printf("          INFO Total samples in Stanford-ESA processed with solution: 111056798 ( 99.999%% )\n");
	printf("          INFO Total samples in Stanford-ESA skipped due to singular geometry matrix: 1 ( 9.004E-07%% )\n");
	printf("          INFO Total samples in Stanford-ESA with MIs: 219 ( 1.972E-04%% )\n");
	printf("          INFO Total samples in Stanford-ESA with Horizontal MIs: 157 ( 1.414E-04%% )\n");
	printf("          INFO Total samples in Stanford-ESA with Vertical   MIs: 139 ( 1.252E-04%% )\n");
	printf("          INFO Stanford-ESA Worst Horizontal Integrity Ratio: 1.6777\n");
	printf("          INFO Stanford-ESA Worst Vertical   Integrity Ratio: 1.9140\n");
	printf("          INFO Horizontal  95 Positioning Error Percentile:   0.80 metres\n");
	printf("          INFO Vertical    95 Positioning Error Percentile:   1.73 metres\n");
	printf("          INFO Horizontal  95 Protection  Level Percentile:  10.27 metres\n");
	printf("          INFO Vertical    95 Protection  Level Percentile:  16.50 metres\n");
    printf("          INFO Maximum Horizontal Positioning Error:   4.26 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Maximum Vertical   Positioning Error:   7.53 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Maximum Horizontal Protection  Level:  16.21 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Maximum Vertical   Protection  Level:  23.92 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
	printf("          INFO Worst Horizontal Integrity Ratio: 0.5317 at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
	printf("          INFO Worst Vertical   Integrity Ratio: 0.4763 at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
	printf("          INFO Station: helg Lon:   7.89309376 Lat:   54.17448223 Height:   48.4689 HWIR:  0.5317 VWIR:  0.4763 MIs:   0 Hor_MIs:   0 Ver_MIs:   0 HPE_Percentile:  95   0.80 VPE_Percentile:  95   1.73 MaxHPE:   4.26 MaxVPE:   7.53 HPL_Percentile:  95  10.27 VPL_Percentile:  95  16.50 MaxHPL:  16.21 MaxVPL:  23.92 Avail%%:  99.582 Cont_Risk: 1.7456E-04 HWIR_ESA:  1.6777 VWIR_ESA:  1.9140 MIs_ESA:  219 Hor_MIs_ESA:  157 Ver_MIs_ESA:  139 Cont_Risk_Mark: 0.0000E+00 PDOP_Percentile:   95   2.33 Max_PDOP:   3.04 GDOP_Percentile:   95   2.69 Max_GDOP:   3.57 TDOP_Percentile:   95   1.34 Max_TDOP:   1.87 HDOP_Percentile:   95   1.30 Max_HDOP:   1.60 VDOP_Percentile:   95   1.98 Max_VDOP:   2.66 Epochs_missing_Sum:   5 Epochs_missing_All_file:  13 Num_DataGaps_Sum:   4 Num_DataGaps_All_file:   7 MaxSize_DataGap_Sum:   2 MaxSize_DataGap_All_file:   6 Station_Network_Name: Other\n\n");
	printf("        NOTES:\n");
	printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight\n");
	printf("          	are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the SBAS summary and\n");
	printf("          	the Stanford-ESA computation will be skipped. This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
	printf("          If receiver position is not fixed or provided by a reference file, the percentile lines will not appear.\n");
	printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
	printf("            the epoch will be skipped from the summary.\n");
	printf("          The last line of the SBAS summary contains all the values of the previous lines along with the station coordinates.\n");
	printf("          If receiver position is not fixed, the station coordinates will be the solution from the last computed epoch.\n");
	printf("          The last line is useful for plotting world maps with data from each station.\n");
	printf("          The fields at the end of the last line 'HWIR_ESA', 'VWIR_ESA', 'MIs_ESA', 'Hor_MIs_ESA' and 'Ver_MIs_ESA' correspond to the values computed in Stanford-ESA.\n");
	printf("            These fields will appear even if Stanford-ESA has not been enabled, but with a value of 0 (so its column number is fixed).\n");
	printf("          Stanford-ESA messages will not appear if Stanford-ESA computation has not been enabled.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
	printf("          Number of epochs with NPA epoch message will not appear if mode switching has not been enabled.\n\n");
	printf("          If user forced NPA processing through parameters, then all values in SBAS summary will be referred to NPA mode.\n");
	printf("          The lines referring to a reference file will only appear if a user sets a reference file. If user sets the reference file just for comparing\n");
	printf("            the solution, the line \"Total epochs omitted in ...\" will appear. Otherwise, if the reference file was set to be used as the a priori\n");
	printf("            position for the modelling computation, the line \"Total epochs skipped due to no position from reference file ...\" will appear.\n");
    printf("\n    DGNSS SUMMARY [DGNSS processing mode]\n");
    printf("        DGNSS statiscal summary. It is printed at the end of the output file if summary is enabled.\n");
	printf("        All time tags are in GPS time.\n");
    printf("        Sample:\n");
    printf("          INFO --------------------- DGNSS Summary ---------------------\n");
    printf("          INFO HDOP Threshold:   4.00\n");
    printf("          INFO PDOP Threshold:   6.00\n");
    printf("          INFO GDOP Threshold:  30.00\n");
	printf("          INFO First epoch of summary: 27/10/2016 00:00:00.00 / 2016 301     0.00 / 1920 345600.00\n");
	printf("          INFO Last  epoch of summary: 27/10/2016 23:59:59.00 / 2016 301 86399.00 / 1920 431999.00\n");
    printf("          INFO Total epochs processed: 86293\n");
    printf("          INFO Total epochs processed with DGNSS solution: 85932 ( 99.582%% )\n");
    printf("          INFO Total epochs processed with SPP solution: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs processed with DGNSS solution and position from reference file: 85932 ( 99.582%% )\n");
    printf("          INFO Total epochs omitted in summary due to no position from reference file: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to less than 4 valid satellites available: 361 ( 0.418%% )\n");
    printf("          INFO Total epochs skipped due to singular geometry matrix: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to any DOP exceeding the threshold:       0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to HDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to PDOP exceeding the threshold:          0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to HDOP and PDOP exceeding the threshold: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped due to GDOP exceeding the threshold: 0 ( 0.000%% )\n");
    printf("          INFO Total epochs skipped (any reason): 361 ( 0.418%% )\n");
    printf("          INFO Total epochs missing  in rover observation file (during summary period):    0\n");
    printf("          INFO Total epochs missing  in rover observation file (all the file):             0\n");
    printf("          INFO Number of data gaps in rover observation file (during summary period):      0\n");
    printf("          INFO Number of data gaps in rover observation file (all the file):               0\n");
    printf("          INFO Maximum data gap size in rover observation file (during summary period):    0\n");
    printf("          INFO Maximum data gap size in rover observation file (all the file):             0\n");
    printf("          INFO Total epochs missing  in reference station RINEX observation file (during summary period):   5\n");
    printf("          INFO Total epochs missing  in reference station RINEX observation file (all the file):           13\n");
    printf("          INFO Number of data gaps   in reference station RINEX observation file (during summary period):   4\n");
    printf("          INFO Number of data gaps   in reference station RINEX observation file (all the file):            7\n");
    printf("          INFO Maximum data gap size in reference station RINEX observation file (during summary period):   2 at epoch 26/01/2018 23:50:04.00 / 2018 026 85804.00 / 1985 517804.00\n");
    printf("          INFO Maximum data gap size in reference station RINEX observation file (all the file):            6 at epoch 25/01/2018 23:46:36.00 / 2018 025 85596.00 / 1985 431196.00\n");
	printf("          INFO PDOP  95 Percentile:   2.33\n");
	printf("          INFO GDOP  95 Percentile:   2.69\n");
	printf("          INFO TDOP  95 Percentile:   1.34\n");
	printf("          INFO HDOP  95 Percentile:   1.30\n");
	printf("          INFO VDOP  95 Percentile:   1.98\n");
	printf("          INFO Maximum PDOP   3.04 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum GDOP   3.57 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum TDOP   1.87 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO Maximum HDOP   1.60 at epoch 26/01/2018 02:20:30.00 / 2018 026  8430.00 / 1985 440430.00\n");
	printf("          INFO Maximum VDOP   2.66 at epoch 26/01/2018 23:52:30.00 / 2018 026 85950.00 / 1985 517950.00\n");
	printf("          INFO First epoch of summary for computing positioning error percentiles: 27/10/2016 00:00:00.00 / 2016 301     0.00 / 1920 345600.00\n");
	printf("          INFO Last  epoch of summary for computing positioning error percentiles: 27/10/2016 23:59:59.00 / 2016 301 86399.00 / 1920 431999.00\n");
    printf("          INFO Total samples in Stanford-ESA processed: 111056799\n");
    printf("          INFO Total samples in Stanford-ESA processed with solution: 111056798 ( 99.999%% )\n");
    printf("          INFO Total samples in Stanford-ESA skipped due to singular geometry matrix: 1 ( 9.004E-07%% )\n");
    printf("          INFO Horizontal  95 Positioning Error Percentile:   0.80 metres\n");
    printf("          INFO Vertical    95 Positioning Error Percentile:   1.73 metres\n");
    printf("          INFO Maximum Horizontal Positioning Error: 4.26 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Maximum Vertical   Positioning Error: 7.53 metres at epoch 27/10/2016 17:40:32.00 / 2016 301 63632.00 / 1920 409232.00\n");
    printf("          INFO Rover: helg Lon:   7.89309376 Lat:   54.17448223 Height:   48.4689 HPE_Percentile:  95   0.80 VPE_Percentile:  95   1.73 MaxHPE:   0.00 MaxVPE:   0.00 Avail%%:   0.000 PDOP_Percentile:   95   2.33 Max_PDOP:   3.04 GDOP_Percentile:   95   2.69 Max_GDOP:   3.57 TDOP_Percentile:   95   1.34 Max_TDOP:   1.87 HDOP_Percentile:   95   1.30 Max_HDOP:   1.60 VDOP_Percentile:   95   1.98 Max_VDOP:   2.66 Epochs_missing_Rover_Sum:   0 Epochs_missing_Rover_All_file:   0 Num_DataGaps_Rover_Sum:   0 Num_DataGaps_Rover_All_file:   0 MaxSize_DataGap_Rover_Sum:   0 MaxSize_DataGap_Rover_All_file:   0 Epochs_missing_Ref_Sum:   5 Epochs_missing_Ref_All_file:  13 Num_DataGaps_Ref_Sum:   4 Num_DataGaps_Ref_All_file:   7 MaxSize_DataGap_Ref_Sum:   2 MaxSize_DataGap_Ref_All_file:   6 Station_Network_Name: Other\n");
    printf("        NOTES:\n");
    printf("          If observation file starts at 22 hours or later, gLAB will automatically assume that all the epochs until the start of the next day (midnight)\n");
    printf("            are for convergence time. During this convergence time, all the epochs computed will not be taken into account for the summary and\n");
    printf("            the Stanford-ESA computation will be skipped. This behaviour can be disabled with the parameter '--summary:waitfordaystart'.\n");
    printf("          If rover position is not provided, the percentile lines will not appear.\n");
    printf("          If user provides a reference file for comparing the solution and if at a certain epoch the reference file position is not available,\n");
    printf("            the epoch will be skipped from the summary.\n");
    printf("          If rover position is not provided, the station coordinates will be the solution from the last computed epoch.\n");
    printf("          The last line of the summary contains all the values of the previous lines along with the station coordinates.\n");
    printf("          The last line is useful for plotting world maps with data from each station.\n");
    printf("          Stanford-ESA messages will not appear if Stanford-ESA computation has not been enabled.\n");
    printf("          HDOP, PDOP and GDOP threshold messages will not appear if HDOP, PDOP or GDOP thresholds have not been enabled respectively.\n");
    printf("          The lines referring to a reference file will only appear if a user sets a reference file.\n");
	printf("\n    SATDIFF [orbit and clock comparison]\n");
	printf("        Satellite difference message for products comparison mode. This message shows the difference between\n");
	printf("        both orbit and clocks for two different OC products fonts for a specific time. It is shown each time step.\n");
	printf("        The SISRE fields are the Signal-in-Space Range Error, it is a measure of how the error impact a general\n");
	printf("        receiver found in the Earth's surface. It is computed as:\n");
	printf("            SISRE = sqrt((radDiff-clkDiff)^2 + 1/49*(ctDiff^2 + atDiff^2))\n");
	printf("        Being:\n");
	printf("            radDiff, the difference of satellite positions in the radial component\n");
	printf("            clkDiff, the difference of satellite clock offsets\n");
	printf("            ctDiff, the difference of satellite positions in the cross-track component\n");
	printf("            atDiff, the difference of satellite positions in the along-track component\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:   'SATDIFF'\n");
	printf("        Field 2:   Year\n");
	printf("        Field 3:   Doy\n");
	printf("        Field 4:   Seconds of day\n");
	printf("        Field 5:   GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 6:   PRN satellite identifier\n");
	printf("        Field 7:   SISRE difference\n");
	printf("        Field 8:   SISRE orbit-only difference\n");
	printf("        Field 9:   3D orbit difference\n");
	printf("        Field 10:  Clock difference\n");
	printf("        Field 11:  Radial position difference\n");
	printf("        Field 12:  Along-track position difference\n");
	printf("        Field 13:  Cross-track position difference\n");
	printf("        Field 14:  X position difference\n");
	printf("        Field 15:  Y position difference\n");
	printf("        Field 16:  Z position difference\n");
	printf("        Sample:\n");
	printf("            SATDIFF 2006 200     0.00 GPS  1     4.1082     0.5359     1.1019    -3.5883     0.5176     0.5497     0.8025      1.527     0.4156     3.7061\n\n");
	printf("    SATSTAT [orbit and clock comparison]\n");
	printf("        Satellite difference summary message for products comparison mode. This message shows the differences\n");
	printf("        between orbit and clocks for two different OC products fonts for a specific satellite. It is shown after\n");
	printf("        all the comparisons are done, and presents a summary for each satellite.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:      'SATSTAT'\n");
	printf("        Field 2:      GNSS System (GPS, GAL, GLO or GEO)\n");
	printf("        Field 3:      PRN satellite identifier\n");
	printf("        Field 4:      Number of samples\n");
	printf("        Field 5-7:    SISRE comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 8-10:   SISRE orbit-only comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 11-13:  3D orbit comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 14-16:  Clock comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 17-19:  Radial position comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 20-22:  Along-track position comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 23-25:  Cross-track position comparisons  [mean,RMS,stdDev]\n");
	printf("        Sample:\n");
	printf("            SATSTAT  1   95     1.5530     2.1112     1.4302     0.9279     1.0058     0.3881     1.4115     1.4714     0.4155    -0.3357     1.9280     1.8985     0.8988     0.9938     0.4239     0.6081     0.9604     0.7433     0.1717     0.5050     0.4750\n");
	printf("\n    SATSTATTOT [orbit and clock comparison]\n\n");
	printf("        Difference summary message for products comparison mode. This message shows the statistics of the\n");
	printf("        differences between orbit and clocks for two different OC products fonts. It is shown after all the\n");
	printf("        comparisons are done, and presents a summary for all of them.\n");
	printf("        All time tags are in GPS time.\n");
	printf("        Field 1:      'SATSTATTOT'\n");
	printf("        Field 2:      Number of samples\n");
	printf("        Field 3-5:    SISRE comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 6-8:    SISRE orbit-only comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 9-11:   3D orbit comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 12-14:  Clock comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 15-17:  Radial position comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 18-20:  Along-track position comparisons  [mean,RMS,stdDev]\n");
	printf("        Field 21-23:  Cross-track position comparisons  [mean,RMS,stdDev]\n");
	printf("        Sample:\n");
	printf("            SATSTATTOT 2660     1.2971     1.6206     0.9714     1.0207     1.1478     0.5250     1.6623     1.7701     0.6083    -0.1909     1.3835     1.3702     0.9488     1.1312     0.6160     0.0514     1.1930     1.1918    -0.0345     0.6560     0.6551\n\n");
	printf("    SATPVT [show product mode]\n");
	printf("        Satellite data messages for show product mode. This message show the PVT data for a specific time\n");
	printf("        and satellite. All time tags are in GPS time.\n");
	printf("        Coordinates are in WGS84 system except for BeiDou with broadcast orbits, which are in CGCS2000 system.\n");
	printf("        CGCS2000 system is aligned to WGS84 to a few centimetres, therefore, it is assumed that CGCS2000=WGS84.\n");
	printf("        Field 1:      'SATPVT'\n");
	printf("        Field 2:      Year\n");
	printf("        Field 3:      Doy\n");
	printf("        Field 4:      Seconds of day\n");
	printf("        Field 5:      GNSS System (GPS, GAL, GLO, GEO or BDS)\n");
	printf("        Field 6:      PRN satellite identifier\n");
	printf("        Field 7:      Satellite X position [m]\n");
	printf("        Field 8:      Satellite Y position [m]\n");
	printf("        Field 9:      Satellite Z position [m]\n");
	printf("        Field 10:     Satellite X velocity [m/s]\n");
	printf("        Field 11:     Satellite Y velocity [m/s]\n");
	printf("        Field 12:     Satellite Z velocity [m/s]\n");
	printf("        Field 13:     Satellite clock offset [m]\n");
	printf("        Sample:\n");
	printf("            SATPVT 2006 199 79500.00 GPS  1  15340446.1662 -20066066.3778  -7929249.6479      1191.6479      2132.5615     -3023.0448     19826.4736\n\n");
}
/*****************************************************************************
 * Name        : showsigmamultipathfile
 * Description : Shows an example of a sigma multipath configuration file
 * Parameters  : None
 *****************************************************************************/
void showsigmamultipathfile () {

	#if defined _OPENMP
		printf("#gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("#gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("#Lines with comments start with a # at the beginning of line\n");
	printf("#If the symbol # is found in the middle of the line, the rest of the line will be omitted, as it will be considered a comment\n");
	printf("#Empty lines will be skipped\n");
	printf("#This is an example of user multipath model configuration file.\n");
	printf("#This file is for introducing a user defined model for sigma multipath model for a SBAS receiver, which can be elevation or SNR dependent.\n");
	printf("#By executing 'gLAB -sigmamultipathfile > usermultipathfile.txt' a valid user multipath model configuration file is created (this file).\n");
	printf("#\n");
	printf("#The following lines explain the rules for creating this configuration file:\n");
	printf("#First line (non empty or without '#') indicates if the following values are for an elevation or S/N ratio model\n");
	printf("#Values for first line are: 'Elevation' or 'SNR' (values are case insensitive)\n");
	printf("#For example:\n");
	printf("#Elevation\n");
	printf("#SNR\n");
	printf("#\n");
	printf("#Values will be given in the same manner for both cases:\n");
	printf("#For each line, the first column will be either the elevation or the SNR sample, the second column will be the relevant sigma value for the sample.\n");
	printf("#There will be as many lines as the number of available samples.\n");
	printf("#Lines must be sorted from lower to higher range values. If lines are not sorted, gLAB will show an error and exit.\n");
	printf("#The unit for the samples are:\n");
	printf("#  degrees for an elevation dependent model\n");
	printf("#  dBHz for a S/N ratio dependent model\n");
	printf("#The unit for the sigma values are metres\n");
	printf("#Sigma values between intervals will be linearly interpolated\n");
	printf("#If a value to be interpolated is below the minimum sample, the minimum sample value will be used. The same criteria will be used for values over the maximum sample.\n");
	printf("#Range step does not need to be constant.\n");
	printf("#\n");
	printf("#If SNR model is selected and no SNR from RINEX is available, the highest SNR sample will be used.\n");
	printf("#\n");
	printf("#Example for an elevation dependent model:\n");
	printf("#Elevation\n");
	printf("#20   0.7\n");
	printf("#30   0.6\n");
	printf("#40   0.5\n");
	printf("#60   0.3\n");
	printf("#78   0.2\n");
	printf("#80   0.1\n");
	printf("# \n");
	printf("#Example for a SNR dependent model:\n");
	printf("#SNR\n");
	printf("#30     0.6\n");
	printf("#40 0.5\n");
	printf("#56 0.4\n");
	printf("#60 0.3\n");
	printf("#\n");
	printf("#Data columns do not need to have a specific number of spaces between them, as well as leading and trailing spaces at the beginning or end of line respectively are ignored. Furthermore, leading zero for values lower than 1 is optional.\n");
	printf("#Data columns may have as column separator white spaces (' '), commas (',') or semicolon (';'). gLAB, internally, will replace all commas and semicolons by spaces, therefore, these column separators can be set combined in different or in the same line.\n");
	printf("#Numbers MUST have decimals with a dot ('.'), as commas are treated as a column separator\n");
	printf("#For example, this line:\n");
	printf("#20   0.5\n");
	printf("#Can also be written like this:\n");
	printf("#   20        .5\n");
	printf("#\n");
	printf("Elevation\n");
	printf("10  0.8\n");
	printf("20      0.7\n");
	printf("30  0.6\n");
	printf("40  0.5\n");
	printf("50  0.4\n");
	printf("60  0.3\n");
	printf("70  0.2\n");
	printf("80  0.1\n");
	printf("90  0.1\n");
}


/*****************************************************************************
 * Name        : showusererrorfile
 * Description : Shows an example of a user-defined error configuration file
 * Parameters  : None
 *****************************************************************************/
void showusererrorfile () {
	#if defined _OPENMP
		printf("#gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("#gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("#This is an example of user-defined error configuration file\n");
	printf("#Lines with comments start with a # at the beginning of line\n");
	printf("#If the symbol # is found in the middle of the line, the rest of the line will be omitted, as it will be considered a comment\n");
	printf("#Empty lines will be skipped\n");
	printf("#By executing 'gLAB -usererrorfile > usererrorfile.txt' a valid user-defined error configuration file is created (this file). Only dates need to be adjusted by user\n");
	printf("#\n");
	printf("#The following lines explain the rules for creating a user defined error configuration file:\n");
	printf("#First line (non empty or without '#') will have two words:\n");
	printf("##The first word indicates if time is given in [GPS week and ToW (Time of Week)] or in [GPS Year, DoY (Day of Year) and SoD (Seconds of Day)]:\n");
	printf("## ToW        -> Time of week (case insensitive)\n");
	printf("## SoD        -> Seconds of Day (case insensitive)\n");
	printf("##The second word indicates if the user wants to indicate the duration of the user-defined error either by specifying the length (in seconds) with the word \"Length\" or by giving the date where the error ends (in the same time format as the initial time) with the word \"Time\".\n");
	printf("## Length     -> Length of user-defined error (case insensitive)\n");
	printf("## Time       -> End time (case insensitive)\n");
	printf("#\n");
	printf("#The second line indicates the seed (random function initial value) for the AWGN (Additive White Gaussian Noise) noise (applied just after being read). It can be the system time, specified with the word \"Time\" or by a number given by user. This line will start with the word \"Seed\" (or \"seed\") and then the word to specify the seed type:\n");
	printf("## CurrentTime -> Use current execution time (from system) as seed (case insensitive)\n");
	printf("## <number>    -> Use this number as seed. It must be a positive integer. Floating values will be truncated, but negative values will make gLAB show an error and exit. \n");
	printf("#\n");
	printf("#Each line will contain a type of user-defined error to be generated for a given time period.\n");
	printf("#The entries MUST be sorted by time (from earliest to latest). If entries are not sorted, user-defined errors from previous epochs will be ignored.\n");
	printf("#\n");
	printf("#The first word of each line will indicate the type of user-defined error to be generated\n");
	printf("#The type of user-defined error possible are:\n");
	printf("#  Step       -> for a step function\n");
	printf("#  Ramp       -> for a ramp function\n");
	printf("#  Sinu       -> for a sinusoidal function\n");
	printf("#  AWGN       -> for AWGN noise\n");
	printf("#The second word will be to indicate the constellation and PRN in which the error is added.\n");
	printf("##The constellation will be given with one the following letters:\n");
	printf("#  G -> GPS\n");
	printf("#  R -> GLONASS\n");
	printf("#  E -> Galileo\n");
	printf("#  S -> SBAS\n");
	printf("#  C -> BeiDou\n");
	printf("#  J -> QZSS\n");
	printf("##The PRN number is from 0 to 32. A PRN of 0 means that all satellites in the constellation will have this added noise.\n");
	printf("#The third word is to indicate the signal where to add the error. \n");
	printf("#The signal code must be one of the observation codes from RINEX version 3.03, (e.g. C1C, L1P, etc.).  For a full list of observation codes, refer to [RINEX, The Receiver Independent Exchange Format, Version 3.02, 14 July 2015].\n");
	printf("#\n");
	printf("#Step function definition:\n");
	printf("#       Step(t)=A*(u(t-t0)-u(t-t1))\n");
	printf("# Where:\n");
	printf("#    A is the amplitude of step, which is a constant value. It is defined by the user (in metres).\n");
	printf("#    t is the current epoch (in seconds of day).\n");
	printf("#    t0 is the epoch where the step function begins (in seconds of day). It is defined by the user.\n");
	printf("#    t1 is the epoch where the step function ends (in seconds of day). It is defined by the user.\n");
	printf("#    u(t) is the unit step or Heavyside function, defined as:\n");
	printf("#          t>=0 u(t)=1\n");
	printf("#          t<0  u(t)=0\n");
	printf("#    Step(t) is the added error to the measurement (in metres).\n");
	printf("#\n");
	printf("#Ramp function definition:\n");
	printf("#       Ramp(t)=B*(t-t0)*(u(t-t0)-u(t-t1))\n");
	printf("# Where:\n");
	printf("#    B is the amplitude of ramp, which is a constant value. It is defined by the user (in metres).\n");
	printf("#    t is the current epoch (in seconds of day).\n");
	printf("#    t0 is the epoch where the ramp function begins (in seconds of day). It is defined by the user.\n");
	printf("#    t1 is the epoch where the ramp function ends (in seconds of day). It is defined by the user.\n");
	printf("#    u(t) is the unit step or Heavyside function, defined as:\n");
	printf("#          t>=0 u(t)=1\n");
	printf("#          t<0  u(t)=0\n");
	printf("#    Ramp(t) is the added error to the measurement (in metres).\n");
	printf("#\n");
	printf("#Sinusoidal function definition:\n");
	printf("#       Sinusoidal(t)=C*sin(2*Pi*t/T + alpha)*(u(t-t0)-u(t-t1))\n");
	printf("# Where:\n");
	printf("#    C is the amplitude of sinusoidal, which is a constant value. It is defined by the user (in metres).\n");
	printf("#    T is the period of the sinusoidal, which is a constant value. It is defined by the user (in seconds).\n");
	printf("#    alpha is the offset of the sinusoidal, which is a constant value. It is defined by the user (in degrees).\n");
	printf("#    t is the current epoch (in seconds of day).\n");
	printf("#    t0 is the epoch where the sinusoidal function begins (in seconds of day). It is defined by the user.\n");
	printf("#    t1 is the epoch where the sinusoidal function ends (in seconds of day). It is defined by the user.\n");
	printf("#    u(t) is the unit step or Heavyside function, defined as:\n");
	printf("#          t>=0 u(t)=1\n");
	printf("#          t<0  u(t)=0\n");
	printf("#    sin(t) is the nominal sinusoidal function.\n");
	printf("#    Sinusoidal(t) is the added error to the measurement (in metres).\n");
	printf("#\n");
	printf("#AWGN function definition:\n");
	printf("#       AWGN(t)=w(t)*(u(t-t0)-u(t-t1))\n");
	printf("# Where:\n");
	printf("#    w(t) is an Additive White Gaussian Noise (AWGN) random process. In particular:\n");
	printf("#      w(t) samples has an associated sigma which can be defined by the user (in metres).\n");
	printf("#      The mean value of w(t) samples is zero.\n");
	printf("#    t is the current epoch (in seconds of day).\n");
	printf("#    t0 is the epoch where the ramp function begins (in seconds of day). It is defined by the user.\n");
	printf("#    t1 is the epoch where the ramp function ends (in seconds of day). It is defined by the user.\n");
	printf("#    u(t) is the unit step or Heavyside function, defined as:\n");
	printf("#          t>=0 u(t)=1\n");
	printf("#          t<0  u(t)=0\n");
	printf("#    AWGN(t) is the added error to the measurement (in metres).\n");
	printf("#\n");
	printf("#Example for Step function (using SoD and Length):\n");
	printf("#Step G3 C1C 5 2016 1 300 500\n");
	printf("# Where \"G3\" indicates satellite with PRN 3 from GPS constellation\n");
	printf("#       \"C1C\" is the observation code for GPS L1 frequency civil psudorange measurement\n");
	printf("#       \"5\" is the amplitude (in metres) of the step function\n");
	printf("#       \"2016\" is the year when the step starts\n");
	printf("#       \"1\" is the day of year when the step starts\n");
	printf("#       \"300\" is the seconds of day when the step starts\n");
	printf("#       \"500\" is the duration (in seconds) of the step\n");
	printf("#\n");
	printf("#Example for Ramp function (using SoD and Time):\n");
	printf("#Ramp G0 L1P 5 2016 1 300 2016 1 500\n");
	printf("# Where \"G0\" indicates all satellites from GPS constellation\n");
	printf("#       \"L1P\" is the observation code for GPS L1 frequency carrier phase measurement\n");
	printf("#       \"5\" is the amplitude (in metres/second) of the ramp function\n");
	printf("#       \"2016\" is the year when the ramp starts\n");
	printf("#       \"1\" is the day of year when the ramp starts\n");
	printf("#       \"300\" is seconds of day when the ramp starts\n");
	printf("#       \"2016\" is the year when the ramp ends\n");
	printf("#       \"1\" is the day of year when the ramp ends\n");
	printf("#       \"500\" is the seconds of day when the ramp ends\n");
	printf("#Example for Sinusoidal function (using ToW and Length):\n");
	printf("#Sinu G12 C1C 5 20E-6 90 1848 259200 500\n");
	printf("# Where \"G12\" indicates satellite with PRN 12 from GPS constellation\n");
	printf("#       \"C1C\" is the observation code for GPS L1 frequency civil psudorange measurement\n");
	printf("#       \"5\" is the amplitude (in metres) of the sinusoidal function\n");
	printf("#       \"20E-6\" is the period of the signal (in seconds). \n");
	printf("#       \"90\" is the offset (in degrees) to be added in the sinusoidal function\n");
	printf("#       \"1848\" is the GPS week when the sinusoidal starts\n");
	printf("#       \"259200\" is the seconds of week when the sinusoidal starts\n");
	printf("#       \"500\" is the duration (in seconds) of the sinusoidal\n");
	printf("#\n");
	printf("#Example for AWGN function (using ToW and Time):\n");
	printf("#AWGN G31 C1C 5 1848 259200 1848 259700\n");
	printf("# Where \"G31\" indicates satellite with PRN 31 from GPS constellation\n");
	printf("#       \"C1C\" is the observation code for GPS L1 frequency civil psudorange measurement\n");
	printf("#       \"5\" is the standard deviation (in metres) of the AWGN random process\n");
	printf("#       \"\"1848\" is the GPS week when the AWGN starts\n");
	printf("#       \"259200\" is the seconds of week when the AWGN starts\n");
	printf("#       \"1848\" is the GPS week when the AWGN ends\n");
	printf("#       \"259700\" is the seconds of week when the AWGN ends\n");
	printf("#\n");
	printf("#Data lines with wrong number of columns will be ignored (except for the initial two lines with time format and seed)\n");
	printf("#Data lines with a user-defined error model different from the ones listed above will be ignored\n");
	printf("#\n");
	printf("#Data columns do not need to have a specific number of spaces between them, as well as leading and trailing spaces at the beginning or end of line respectively are ignored. Furthermore, leading zero for values lower than 1 is optional.\n");
	printf("#Data columns may have as column separator white spaces (' '), commas (',') or semicolon (';'). gLAB, internally, will replace all commas and semicolons by spaces, therefore, these column separators can be combined in different or in the same line.\n");
	printf("#Numbers MUST have decimals with a dot ('.'), as commas are treated as a column separator\n");
	printf("#For example, this line:\n");
	printf("#Step G10 C1C 5 2016 1 300 50\n");
	printf("#Can also be written like this:\n");
	printf("# Step   G10  C1C     5    2016    1 300        50   \n");
	printf("#\n");
	printf("#gLAB will print the user-defined error in the lines starting with 'USERADDEDERROR' (which are enabled by default). The description of each field in the message is shown by executing 'gLAB -messages'.\n");
	printf("#\n");
	printf("#For RINEX 2 files, the user must use the equivalent measurements for RINEX 3. The measurement conversion table is:\n");
	printf("#C1 -> C1C (except for BeiDou, where it is transformed to C1X)\n");
	printf("#P1 -> C1P\n");
	printf("#L1 -> L1P (except for Galileo, QZSS and GEO, where it is transformed to L1C, and in BeiDou to L1X)\n");
	printf("#D1 -> D1P (except for Galileo, QZSS and GEO, where it is transformed to D1C, and in BeiDou to D1X)\n");
	printf("#S1 -> S1P (except for Galileo, QZSS and GEO, where it is transformed to S1C, and in BeiDou to S1X)\n");
	printf("#\n");
	printf("#C2 -> C2C (except for BeiDou and QZSS, where it is transformed to C2X)\n");
	printf("#P2 -> C2P (except for BeiDou and QZSS, where it is transformed to C2X)\n");
	printf("#L2 -> L2P (except for BeiDou and QZSS, where it is transformed to L2X)\n");
	printf("#D2 -> D2P (except for BeiDou and QZSS, where it is transformed to D2X)\n");
	printf("#S2 -> S2P (except for BeiDou and QZSS, where it is transformed to S2X)\n");
	printf("#\n");
	printf("#C3 -> C3X\n");
	printf("#L3 -> L3X\n");
	printf("#D3 -> D3X\n");
	printf("#S3 -> S3X\n");
	printf("#\n");
	printf("#C4 -> C4X\n");
	printf("#L4 -> L4X\n");
	printf("#D4 -> D4X\n");
	printf("#S4 -> S4X\n");
	printf("#\n");
	printf("#C5 -> C5X\n");
	printf("#L5 -> L5X\n");
	printf("#D5 -> D5X\n");
	printf("#S5 -> S5X\n");
	printf("#\n");
	printf("#C6 -> C6X\n");
	printf("#L6 -> L6X\n");
	printf("#D6 -> D6X\n");
	printf("#S6 -> S6X\n");
	printf("#\n");
	printf("#C7 -> C7X (except for GPS and QZSS, where it is transformed to C1X, and in GLONASS to C3X)\n");
	printf("#L7 -> L7X (except for GPS and QZSS, where it is transformed to L1X, and in GLONASS to L3X)\n");
	printf("#D7 -> D7X (except for GPS and QZSS, where it is transformed to D1X, and in GLONASS to D3X)\n");
	printf("#S7 -> S7X (except for GPS and QZSS, where it is transformed to S1X, and in GLONASS to S3X)\n");
	printf("#\n");
	printf("#C8 -> C8X (except for QZSS, where it is transformed to C1Z)\n");
	printf("#L8 -> L8X (except for QZSS, where it is transformed to L1Z)\n");
	printf("#D8 -> D8X (except for QZSS, where it is transformed to D1Z)\n");
	printf("#S8 -> S8X (except for QZSS, where it is transformed to S1Z)\n");
	printf("#\n");
	printf("#C9 -> C9X\n");
	printf("#L9 -> L9X\n");
	printf("#D9 -> D9X\n");
	printf("#S9 -> S9X\n");
	printf("#\n");
	printf("#Usage Example:\n");
	printf("SoD Length\n");
	printf("Seed 10\n");
	printf("#Add all user-defined errors at the same time\n");
	printf("Step G10 C1C 5 2016 1 300 50\n");
	printf("Ramp G20 C1C 5 2016 1 300 500\n");
	printf("Sinu G15 L1P 5 20E-6 90 2016 1 300 500\n");
	printf("AWGN G10 C1C 5 2016 1 300 500\n");
	printf("#Add some more user-defined error later\n");
	printf("Ramp G0 C1C 5 2016 1 500 400\n");
	printf("Sinu G32 L1P 5 20E-6 90 2016 1 5000 300\n");
}

/*****************************************************************************
 * Name        : showRTCMv2ConversionInfo
 * Description : Shows an explanation of what fields are written in the
 *                 output files from a conversion fron RTCMv2
 * Parameters  : None
 *****************************************************************************/
void showRTCMv2ConversionInfo () {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("Here are detailed the contents of the two files generated when converting an RTCM v2.x\n");
	printf("  to text format. As there is no standard for converting to text files the RTCM v2.x files,\n");
	printf("  gLAB will create two files: the \"corrections\" file and the \"antenna\" file, which will\n");
	printf("  the following fields:\n\n");
	printf("Corrections File:\n");
	printf("The fields written in the corrections file are:\n\n");
	printf("    GPS_week: GPS week of the RTCM message.\n");
	printf("    SoW: Second of week of the RTCM message (the epoch is not given in the message except for the seconds of hour in Z-count value).\n");
	printf("    MSG_number: Message type number (appears in the header of all messages).\n");
	printf("    Station_ID: Station ID of the RTCM v2.x message (appears in the header of all messages).\n");
	printf("    Z-count: Seconds of hour (appears in the header of all messages). As this is only the time reference in RTCM v2.x messages,\n");
	printf("              the user must provide the inital date and hour to convert it to a normal date format.\n");
	printf("    SV_health: Station health status (appears in the header of all messages).\n");
	printf("        The values for the health status are a scale factor for the measurement UDRE,\n");
	printf("        with the following values:\n\n");
	printf("            0: UDRE scale factor = 1.\n");
	printf("            1: UDRE scale factor = 0.75.\n");
	printf("            2: UDRE scale factor = 0.5.\n");
	printf("            3: UDRE scale factor = 0.3.\n");
	printf("            4: UDRE scale factor = 0.2.\n");
	printf("            5: UDRE scale factor = 0.1.\n");
	printf("            6: Reference station transmission not monitored (a UDRE scale factor = 1 is applied if corrections are used).\n");
	printf("            7: Reference station not working (a UDRE scale factor = 1 is applied if corrections are used).\n\n");
	printf("    PRN: Satellite PRN to apply the corrections.\n");
	printf("    PRC: Pseudorange correction to be applied to the satellite (metres).\n");
	printf("    RRC: Range-rate corrections to be applied to the satellite (metres).\n");
	printf("    IOD: IOD (Issue of Data) of the navigation message used to compute the corrections.\n");
	printf("           The user must also use the same IOD when applying the corrections.\n");
	printf("    UDRE: UDRE (User Differential Range Error). Provides a rough estimation of the error in the measurements.\n");
	printf("           This estimation must be multiplied by the UDRE scale factor read in the message header.\n");
	printf("           The possible values for the UDRE are:\n\n");
	printf("             0: 1 metre.\n");
	printf("             1: 4 metres.\n");
	printf("             2: 8 metres.\n");
	printf("             3: 10 metres.\n");
	printf("\nAntenna File:\n");
	printf("The fields written in the antenna file are:\n");
	printf("    Station_ID: Station ID of the RTCM v2.x message (appears in the header of all messages).\n");
	printf("    X_coordinate: X coordinate component of the reference antenna (metres).\n");
	printf("    Y_coordinate: Y coordinate component of the reference antenna (metres).\n");
	printf("    Z_coordinate: Z coordinate component of the reference antenna (metres).\n");
	printf("    MSG_number: Message type number (appears in the header of all messages).\n");
	printf("      The possible values of message type number in this file are:\n");
	printf("        MT03: In message type 3, reference station antenna coordinates are in GPS computed coordinates (in ECEF -Earth Centered Earth Fixed-)\n");
	printf("        MT24: In message type 24, reference station antenna coordinates are referred to the Antenna Reference Point (ARP) (in ECEF)\n");
}


/*****************************************************************************
 * Name        : showReferencePositionFileInfo
 * Description : Shows an example of a reference position file
 * Parameters  : None
 *****************************************************************************/
void showReferencePositionFileInfo () {
	#if defined _OPENMP
		printf("#gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("#gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("#This is an example of a reference position file\n");
	printf("#Lines with comments start with a '#' or '%%' at the beginning of line\n");
	printf("#If the symbol # is found in the middle of the line, the rest of the line will be omitted, as it will be considered a comment\n");
	printf("#Empty lines will be skipped\n");
	printf("#By executing 'gLAB -referenceposfile > referencepositionfile.txt' a valid reference position file is created (this file). Dates and positions have to be adjusted by user\n");
	printf("#\n");
	printf("#The following lines explain the rules for creating a reference position file:\n");
	printf("#Data columns do not need to have a specific number of spaces between them, as well as leading and trailing spaces at the beginning or end of line respectively are ignored. Furthermore, leading zero for values lower than 1 is optional.\n");
	printf("#Data columns may have as column separator white spaces (' '), commas (',') or semicolon (';'). gLAB, internally, will replace all commas and semicolons by spaces, therefore, these column separators can be set combined in different or in the same line.\n");
	printf("#Numbers MUST have decimals with a dot ('.'), as commas are treated as a column separator.\n");
	printf("#The first line of data (first line non empty or without a '#') must have the names of the elements of each column.\n");
	printf("#Names of columns are case insensitive, and must be given in the same order as the data (so gLAB what type of data has each column).\n");
	printf("#The order of the data is not important as long as the data type matches the position of the name of the data in the first line.\n");
	printf("#The accepted names of columns are (all time tags must be in GPS time):\n");
	printf("#Year      -> Year\n");
	printf("#DoY       -> Day of Year\n");
	printf("#SoD       -> Seconds of Day\n");
	printf("#GPSWeek   -> GPSWeek\n");
	printf("#SoW       -> Seconds of Day\n");
    printf("#Date      -> Date in calendar format (YYYY/MM/DD)\n");
	printf("#Time      -> Time in calendar format (HH:MM:SS.zzz). 'zzz' are milliseconds\n");
	printf("#X         -> X coordinate (metres)\n");
	printf("#Y         -> Y coordinate (metres)\n");
	printf("#Z         -> Z coordinate (metres)\n");
	printf("#Lon       -> Longitude (degrees). Range is [-180..180]. Values outside of this range will be rejected\n");
	printf("#Longitude -> Longitude (degrees). Range is [-180..180]. Values outside of this range will be rejected\n");
	printf("#Lat       -> Latitude (degrees). Range is [-90..90]. Values outside of this range will be rejected\n");
	printf("#Latitude  -> Latitude (degrees). Range is [-90..90]. Values outside of this range will be rejected\n");
	printf("#Height    -> Height (metres)\n");
	printf("#\n");
	printf("#X, Y and Z are in cartesian ECEF WGS84 reference frame.\n");
	printf("#Latitude, Longitude and Height are in geodetic ECEF WGS84 reference frame.\n");
	printf("#\n");
	printf("#The file must contain a full set of valid date and coordinates. That is, it must have at least the fields 'Year, DoY, SoD' or 'GPSWeek, SoW' or 'Date Time' for the date, and fields 'X, Y ,Z' or 'Lon, Lat, Height' for the coordinates\n");
	printf("#If file contains more than one date formats or both coordinate systems, gLAB will prefer 'Year, DoY, SoD' format for date and 'X, Y, Z' for coordinates (it has less computational cost)\n");
	printf("#All other columns that do not match any of the accepted names will be ignored.\n");
	printf("#\n");
	printf("#Furthermore, RTKlib output file is also supported (output must be in 'Lat/Lon/Height' -in ellipsodial or geodetic height- or 'X/Y/Z-ECEF' formats).\n");
	printf("#\n");
	printf("#For example, the first line could be like the following samples (note that order and number of column separators is not important):\n");
	printf("#Year DoY SoD  X Y Z\n");
	printf("#Year, DoY, SoD,  X, Y, Z\n");
	printf("#GPSWeek  SoW    Y  X      Z\n");
	printf("#DoY   SoD   Year  Lon   Lat    Height\n");
	printf("#SoW    GPSWeek  Lat Lon Height\n");
	printf("#DoY  Year  Lon  Height  SoD  Lat\n");
	printf("#\n");
	printf("#The lines below are a valid set of data lines:\n");
	printf("Year DoY       SoD              X              Y              Z\n");
	printf("2014 067 21200.000   3219920.5954   4672079.7551   3465886.3080\n");
	printf("2014 067 21500.000   3219919.9508   4672079.7847   3465887.1434\n");
	printf("2014 067 21800.000   3219920.2422   4672080.7439   3465887.0480\n");
}

/*****************************************************************************
 * Name        : showSBASPlotsInfo
 * Description : Shows info on how to generate SBAS plots
 * Parameters  : None
 *****************************************************************************/
void showSBASPlotsInfo () {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("\nPlease open this document in Notepad or a terminal or a text editor with a monospace font (all characters with equal width), otherwise\n");
	printf("the ASCII figures below will not be aligned.\n");
	printf("\nSBAS plots mode is a processing mode (available only in command line) where, instead of computing the navigation solution, gLAB\n");
	printf("loops through a grid of points (in longitude and latitude) in the map (by default the EGNOS coverage area), during a 24 hour period.\n");
	printf("In each point, gLAB checks how many satellites are available for SBAS solution (by computing its SBAS corrections). If there are\n");
	printf("4 or more satellites with SBAS corrections (and the geometry matrix can be inverted), the protection levels are computed. If the\n");
	printf("protection levels are below the alarm limits, then there is PA (Precision Approach) solution available for the current point and epoch.\n");
	printf("When the selected GEO is below the elevation mask or has no PA solution, if GEO switching is enabled, gLAB will loop through all GEO\n");
	printf("until a GEO is over the elevation mask and provides a PA solution or no unprocessed GEO remain.\n\n");
	printf("In order to compute the geometry matrix, receiver a priori coordinates are needed. The a priori coordinates are the\n");
	printf("longitude and latitude of the current point in the grid, and the height is a fixed for all points (by default 0 metres\n");
	printf("-over the WGS84 geoid-). The geometry matrix also contains the measurements weights provided by the SBAS corrections.\n\n");
	printf("In SBAS plots mode, no RINEX observation file is used (as it is not necessary to compute the navigation solution). In order\n");
	printf("to select which satellites are available at each point in each epoch, gLAB has to loop through all available PRN\n");
	printf("(for GPS, PRNs 1 to 32) and try to compute its SBAS corrections.\n\n");
	printf("The number of epochs to be processed for the SBAS maps depends on the data files and the software used. gLAB\n");
	printf("computes daily (24 hours) SBAS map, with the possibility to generate hourly maps (use option '-sbasplots:hourlymaps').\n\n");
	printf("Two data files are necessary for computing a daily SBAS map (24 hours): a SBAS corrections file and a navigation file.\n");
	printf("In order to account for the convergence time (in this case, wait for the SBAS data buffers get filled), the SBAS data\n");
	printf("file must contain additional corrections from the previous day. The minimum amount of data is 15 minutes, but gLAB accepts up to\n");
	printf("two hours of data of convergence time. That is, if the SBAS data file starts at 22h or later, gLAB will automatically assume\n");
	printf("that all the data from 22h (or later) until 23:59h is data for convergence time and will read all this corrections at once for filling\n");
	printf("its internal SBAS data memory buffers. Once it reaches 0:00h of the following day it will start the data processing until 23:59h.\n");
	printf("Since version 5.4.0, gLAB shows an INFO message with the amount of convergence time detected in the SBAS file. If it less\n");
	printf("than 15 minutes, gLAB warns the user by stating that there is not enough convergence time.\n\n");
	printf("Regarding the navigation file, it is necessary for the user to create a consolidated navigation data file using data from many\n");
	printf("different stations (for instance, all IGS stations). This is due to each station does not have all of the navigation\n");
	printf("messages (selected by the IODE) used by SBAS (this can even occur with the 'brdc' consolidated file). One way to check that\n");
	printf("the navigation file has missing messages is to do a standard SBAS processing (using a RINEX observation file from any station)\n");
	printf("and enable the \"SBASUNSEL\" output message. In this message it should appear messages with the text \"No broadcast block with IOD...\".\n");
	printf("Since version 5.4.0, gLAB prints an INFO message about the need to create a consolidated file (except if the navigation filename's\n");
	printf("first 4 characters are \"mixn\" or \"gage\", as these are the navigation files created by the gAGE research group).\n");
	printf("Aside, for the navigation file, it is necessary to include 2 hours of navigation messages from the previous day and 2 hours from\n");
	printf("the following day. This is due as some of the navigation messages used by SBAS at the start or end of the day are saved in the\n");
	printf("previous or following day. Since version 5.4.0, gLAB checks the start and end time of the navigation file for these 2 hours\n");
	printf("of data from the previous and following day. If not included, a warning message is printed.\n");
	printf("Furthermore, it is recommended to apply a data cleansing algorithm to the navigation messages when creating the consolidated\n");
	printf("navigation message file, in order to remove data logging errors. An algorithm for data cleansing is described in chapter 3.3\n");
	printf("of the thesis \"Safe satellite navigation with multiple constellations: global monitoring of GPS and GLONASS signal-in-space anomalies\",\n");
	printf("available at \"https://web.stanford.edu/group/scpnt/gpslab/pubs/theses/LHengThesisFinalSignedSecured.pdf\"\n\n");
	printf("As stated above, gLAB can only process a single day in each run. When the user wants to process a range of days,\n");
	printf("it will need to process each day independently and join the results following the instructions below.\n");
	printf("Processing only a single day per run has the following advantages and disadvantages:\n");
	printf("  Advantages:\n");
	printf("    - More efficient code as it does not need to deal with day changes.\n");
	printf("    - Multiple instances of gLAB can be run independently in parallel (one for each CPU available).\n");
	printf("        It is much more efficient than running a single instance with multi-threading for multiple days.\n");
	printf("    - If the results are not as expected, it is easier to identify the day(s) with problems (e.g. an ionospheric storm),\n");
	printf("       as each day is an independent run.\n");
	printf("    - If one processed day fails (e.g. missing data), only that day has to be reprocessed.\n");
	printf("    - Data files remain the same size independently of the data range size processed.\n");
	printf("  Disadvantages:\n");
	printf("    - Data files with the convergence time have to be created for each day.\n");
	printf("    - An external script to run gLAB for each day must be generated by the user.\n");
	printf("    - Percentiles for DOP can only be computed for a single day, as DOP samples are not printed. Nevertheless, the DOP percentile\n");
	printf("        cannot be computed for a long range of days, as for each day, each DOP component (HDOP, PDOP or GDOP) needs around 1GB of\n");
	printf("        memory. For instance, computing HDOP, PDOP and GDOP percentiles for 10 days would need around 30GB of memory.\n");
	printf("    - Data for each day has to be added up in order to get the statistics for the whole period (explained below).\n\n");
	printf("In order to join the results from multiple days, it is necessary to build a script that reads the gLAB output files and adds everything up.\n");
	printf("The user can generate this script in many ways (e.g. a Python script). Below is provided some Bash scripts (which can be executed in Linux,\n");
	printf("Mac or in Windows -using the Cygwin terminal-). In these scripts, the following assumptions are made:\n");
	printf("  - The output files have the day of year (padded with zeros) and the year in its filenames. This is very important, as this allows to\n");
	printf("      select all the files at once in chronological order (as the bash interpreter automatically orders the selected files). In the examples\n");
	printf("      the filenames used are (user can set the output filenames using the appropriate parameters):\n");
	printf("        Daily files:\n");
	printf("          AvailMap_001_2017.txt, RiskMap_002_2017.txt, RiskMarMap_003_2017.txt, IonoMap_004_2017.txt, ...\n");
	printf("          HDOPMap_001_2017.txt, PDOPMap_002_2017.txt, GDOPMap_003_2017.txt, Discontinuities_List_004_2017.txt, ...\n");
	printf("        Hourly files:\n");
	printf("          AvailMap_001_2017_00h.txt, RiskMap_002_2017_01h.txt, RiskMarMap_003_2017_10h.txt, IonoMap_004_2017_11h.txt, ...\n");
	printf("          HDOPMap_001_2017_12h.txt, PDOPMap_002_2017_13h.txt, GDOPMap_003_2017_14h.txt, Discontinuities_List_004_2017_23h.txt, ...\n\n");
	printf("  - Data files are saved in a different folder for each day. The folder structure is \"YYYY/DoY/\", being \"YYYY\" the year with four digits\n");
    printf("      and \"DoY\" the day of year padded with zeros.\n");
	printf("  - This example will join data from two years (2017 and 2018).\n");
	printf("\n\nADDING UP SBAS AVAILABILITY MAPS\n\n");
	printf("SBAS Availability map data is easy to add up, as the output file contains the number of epochs with PA solution under both alarm limits (horizontal and vertical)\n");
	printf("and the number of epochs processed. These values are independent from day to day, therefore it is only needed to add to total number of epochs\n");
	printf("with solution and the total number of epochs processed for each day and location, and divide these values in order to get the availability\n");
	printf("percentage for the whole period. The following bash script does this computation:\n\n");
	printf("cat ./201\?/\?\?\?/AvailMap_\?\?\?_201\?.txt|awk -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {avail[$1\" \"$2]+=$4;numepochs[$1\" \"$2]+=$5} END {for (i in avail) {print i,avail[i],numepochs[i],numepochs[i]==0\?0:100*avail[i]/numepochs[i]}}'|awk '{printf \"%%6.2f %%7.2f %%9.5f %%8d %%8d\\n\",$1,$2,$5,$3,$4}'|sort -g -k1 -k2 > Avail_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/AvailMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/AvailMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/AvailMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the\n");
	printf("output files for availability maps can be used. The following command reads the header from the file \"AvailMap_001_2017.txt\" and copy it\n");
	printf("to the previous file:\n\n");
	printf("head -3 ./2017/001/AvailMap_001_2017.txt|cat - Avail_added_no_header.txt > Avail_added_with_header.txt\n\n");
	printf("The file created, 'Avail_added_with_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS availability plot file.\n");
	printf("The user will have to change the plot title to state that the file has data for the two years (using the '-t' parameter).\n");
	printf("\n\nADDING UP SBAS IONOSPHERE AVAILABILITY MAPS\n\n");
	printf("The process is identical as the SBAS availability maps. The same scripts are used, but changing the filenames:\n\n");
	printf("cat ./201\?/\?\?\?/IonoMap_\?\?\?_201\?.txt|awk -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {avail[$1\" \"$2]+=$4;numepochs[$1\" \"$2]+=$5} END {for (i in avail) {print i,avail[i],numepochs[i],numepochs[i]==0\?0:100*avail[i]/numepochs[i]}}'|awk '{printf \"%%6.2f %%7.2f %%9.5f %%8d %%8d\\n\",$1,$2,$5,$3,$4}'|sort -g -k1 -k2 > IonoAvail_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/IonoMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/IonoMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/IonoMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the output files\n");
	printf("for availability maps can be used. The following command reads the header from the file \"IonoAvailMap_001_2017.txt\" and copy it to the previous file:\n\n");
	printf("head -3 ./2017/001/IonoAvailMap_001_2017.txt|cat - IonoAvail_added_no_header.txt > IonoAvail_added_with_header.txt\n\n");
	printf("The file created, 'IonoAvail_added_with_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS ionosphere availability\n");
	printf("plot file. The user will have to change the plot title to state that the file has data for the two years (using the '-t' parameter).\n");
	printf("\n\nADDING UP SBAS HDOP MAPS\n\n");
	printf("SBAS HDOP output files contain the mean value, the total HDOP and the number of epochs with PA solution. Note that all epochs with protection\n");
	printf("levels over the alarm limits are not counted for the DOP percentile or mean value, as most of them will be outliers (this is the behaviour\n");
	printf("since version 5.4.0, whereas in version 5.3.0 all epochs with PA solution were included in the mean computation)\n");
	printf("The mean value for each day is independent from each day, therefore we just need to add the total HDOP value for each day and position and the\n");
	printf("total number of epochs with PA solution, and compute the global mean for the two years. In some positions (in the edges), the number of epochs\n");
	printf("with PA solution may be 0, so it is necessary to check for this value in order to avoid dividing by zero:\n\n");
	printf("cat ./201\?/\?\?\?/HDOPMap_\?\?\?_201\?.txt|awk -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {mean[$1\" \"$2]+=$3;numepochs[$1\" \"$2]+=$5;total[$1\" \"$2]+=$4;percent[$1\" \"$2]+=$6} END {for (i in total) {print i,total[i],numepochs[i],numepochs[i]==0\?0:total[i]/numepochs[i],percent[i]}}'|awk '{printf \"%%6.2f %%7.2f %%15.2f %%17.2f %%8d %%10.2f\\n\",$1,$2,$5,$3,$4,$6}'|sort -g -k1 -k2 > HDOP_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/HDOPMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/HDOPMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/HDOPMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the output\n");
	printf("files for HDOP maps can be used. The following command reads the header from the file \"HDOPMap_001_2017.txt\" and copy it to the previous file:\n\n");
	printf("head -3 ./2017/001/HDOPMap_001_2017.txt|cat - HDOP_added_no_header.txt > HDOP_added_with_header.txt\n\n");
	printf("The file created, 'HDOP_added_with_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS HDOP plot file. The user\n");
	printf("will have to change the plot title to state that the file has data for the two years (using the '-t' parameter).\n");
	printf("\n\nADDING UP SBAS PDOP MAPS\n\n");
	printf("Identical to HDOP maps, but changing the filenames to PDOP files:\n");
	printf("cat ./201\?/\?\?\?/PDOPMap_\?\?\?_201\?.txt|awk -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {mean[$1\" \"$2]+=$3;numepochs[$1\" \"$2]+=$5;total[$1\" \"$2]+=$4;percent[$1\" \"$2]+=$6} END {for (i in total) {print i,total[i],numepochs[i],numepochs[i]==0\?0:total[i]/numepochs[i],percent[i]}}'|awk '{printf \"%%6.2f %%7.2f %%15.2f %%17.2f %%8d %%10.2f\\n\",$1,$2,$5,$3,$4,$6}'|sort -g -k1 -k2 > PDOP_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/PDOPMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/PDOPMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/PDOPMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the output\n");
	printf("files for PDOP maps can be used. The following command reads the header from the file \"PDOPMap_001_2017.txt\" and copy it to the previous file:\n\n");
	printf("head -3 ./2017/001/PDOPMap_001_2017.txt|cat - PDOP_added_no_header.txt > PDOP_added_with_header.txt\n\n");
	printf("The file created, 'PDOP_added_with_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS PDOP plot file. The user\n");
	printf("will have to change the plot title to state that the file has data for the two years (using the '-t' parameter).\n");
	printf("\n\nADDING UP SBAS GDOP MAPS\n\n");
	printf("Identical to HDOP maps, but changing the filenames to GDOP files:\n");
	printf("cat ./201\?/\?\?\?/GDOPMap_\?\?\?_201\?.txt|awk -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {mean[$1\" \"$2]+=$3;numepochs[$1\" \"$2]+=$5;total[$1\" \"$2]+=$4;percent[$1\" \"$2]+=$6} END {for (i in total) {print i,total[i],numepochs[i],numepochs[i]==0\?0:total[i]/numepochs[i],percent[i]}}'|awk '{printf \"%%6.2f %%7.2f %%15.2f %%17.2f %%8d %%10.2f\\n\",$1,$2,$5,$3,$4,$6}'|sort -g -k1 -k2 > GDOP_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/GDOPMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/GDOPMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/GDOPMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the output\n");
	printf("files for GDOP maps can be used. The following command reads the header from the file \"GDOPMap_001_2017.txt\" and copy it to the previous file:\n\n");
	printf("head -3 ./2017/001/GDOPMap_001_2017.txt|cat - GDOP_added_no_header.txt > GDOP_added_with_header.txt\n\n");
	printf("The file created, 'GDOP_added_with_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS GDOP plot file. The user\n");
	printf("will have to change the plot title to state that the file has data for the two years (using the '-t' parameter).\n");
	printf("\n\nADDING UP SBAS AVIATION CONTINUITY RISK MAPS (SLIDING WINDOW)\n\n");
	printf("When computing the total continuity risk for multiple continuous days from several single day files (or hourly files), data files are not\n");
	printf("independent from each other, as each discontinuity (defined as the transition from an epoch with PA solution -under both alarm limits- to an epoch\n");
	printf("without PA solution or with PA solution over any alarm limits) found affects previous samples. In the case of the sliding window, every time a discontinuity is found,\n");
	printf("the epochs with PA solution (under alarm limits) previous to the current discontinuity are counted as \"in risk\" or affected by the current discontinuity.\n"); 
	printf("The number of samples \"in risk\" is the size of the window if the number of continuous epochs with PA solution under alarm limits (prior to the previous discontinuity)\n");
	printf("is equal or greater than the window size, otherwise, only the number of continuous epochs with PA solution under alarm limits (prior to the previous discontinuity) are \"in risk\".\n");
	printf("The total discontinuity risk is finally computed by dividing the total number of epochs \"in risk\" by the total number of epochs with PA solution under alarm limits.\n");
	printf("Discontinuities can occur, for instance, at the beginning of the day, which would affect samples from the previous day. To account for these\n");
	printf("cases, a script (attached at the end of this manual) has to read the discontinuities (from the discontinuity list file generated by gLAB) and\n");
	printf("count the number of samples which were \"in risk\" by discontinuities but not counted as \"in risk\" due to the day or hour change.\n");
	printf("In order to understand how to count these samples, two facts about how gLAB computes the number of discontinuities for the sliding window:\n");
	printf("    - For daily and hourly files, if the processing ended with discontinuity, the epochs \"in risk\" for this discontinuity are accounted in the statistics.\n");
	printf("    - For hourly files, at the beginning of each hour, internal counters are all reset, therefore, discontinuities from each\n");
	printf("        hour do not affect the previous hour or the following one.\n\n");
	printf("An example is shown below on how to compute the continuity risk, using a sliding window of 5 epochs (this is a very small\n");
	printf("window size, used for explanatory purposes. Default aviation sliding window size is 15 seconds):\n\n");
	printf("  NOTE: the following symbols are used:\n"); 
	printf("    - '||' is a separator for a day or hour transition\n");
	printf("    - 'X' is an epoch with PA solution under alarm limits (or in short, \"epoch with PA solution\")\n");
	printf("    - 'O' is an epoch without PA solution or with PA limits over any alarm limit (or in short, \"epoch without PA solution\")\n\n");
	printf("        O O O X X X X X X X X O O O O X X X X X O O O O O O X X X O O O X X\n");
	printf("                    |       |         |       |             |   |\n");
	printf("                    - - - - -         - - - - -             - - - \n");
	printf("                        |                 |                   |\n");
	printf("                        v                 v                   v\n");
	printf("             5 epochs \"in risk\"   5 epochs \"in risk\"  3 epochs \"in risk\"\n\n");
	printf("                      Total epochs \"in risk\":        13 epochs\n");
	printf("                      Total epochs with PA solution: 18 epochs\n");
	printf("                      Continuity Risk = 13/18 = 0.72\n\n");
	printf("The following cases can occur during a day or hour transition:\n\n");
	printf("Case 1: Day/hour ends without PA solution\n\n");
	printf("               X O O||O O O\n");
	printf("          or   X X O||X X O   (all epochs \"in risk\" are correctly accounted)\n");
	printf("          or   X X O||X X X\n\n");
	printf("  As stated above, when the day or hour ends with discontinuity, the previous epochs with\n");
	printf("    PA solution are counted for the number of epochs \"in risk\". No additional epochs \"in risk\"\n");
	printf("    have to be accounted to the global counter.\n\n");
	printf("Case 2: Day/hour ends with PA solution and the next day/hour file starts without PA solution\n\n");
	printf("               X X X||O O O   or   X X X||O O X\n");
	printf("               |   |               |   |\n");
	printf("               - - -               - - -\n");
	printf("                 |                   |\n");
	printf("                 v                   v\n");
	printf("        These epochs are not accounted as \"in risk\" due to the day/hour change\n\n");
	printf("  The discontinuity at the beginning of the next day/hour affects the epochs with PA solution\n");
	printf("    from the previous day. The number of epochs \"in risk\" from the previous day will be the\n");
	printf("    size of the window (if the number of continuous epoch with PA solution is equal or larger\n");
	printf("    than the window size) or the number of continuous epoch with PA solution if it is smaller\n");
	printf("    than the window size.\n\n");
	printf("Case 3: Day/hour ends with PA solution, the next day/hour starts with PA solution and a discontinuity\n");
	printf("        occurs in an epoch which is smaller than the window size:\n\n");
	printf("               X X X||X X X O   or   O X X||X X X O\n");
	printf("               |   |                   | |\n");
	printf("               - - -                   - -\n");
	printf("                 |                      |\n");
	printf("                 v                      v\n");
	printf("        These epochs are not accounted as \"in risk\" due to the day/hour change\n\n");
	printf("  When a day/hour ends with PA solution, the following day starts with PA solution, and a discontinuity\n");
	printf("    occurs, if the epoch of the discontinuity is equal or larger than the window size, all epochs \"in risk\"\n");
	printf("    will be accounted (as they will all be from the next day), but if the epoch of the discontinuity\n");
	printf("    is smaller than the window size, some of the epochs \"in risk\" will be in the previous day. Precisely,\n");
	printf("    the number of epochs in \"in risk\" from the previous day that need to be added to the global counter will be\n");
	printf("    the difference between the window size and the number of epochs with PA solution in the current day. If this\n");
	printf("    difference is greater than the number of continuous epochs until the end of the day in the previous day, then\n");
	printf("    the number of epochs \"in risk\" to be added to the global counter will be the number of continuous epochs\n");
	printf("    until the end of the previous day.\n\n");
	printf("To count the total continuity risk (sliding window) for the whole period, it has to be done in four steps. First, add the\n");
	printf("total number of epochs \"in risk\" and the total number of epochs with PA solution. This can be done with the following\n");
	printf("command line instruction:\n\n");
	printf("cat ./201\?/\?\?\?/RiskMap_\?\?\?_201\?.txt| awk -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {numdiscont[$1\" \"$2]+=$4;numepochs[$1\" \"$2]+=$5} END {for (i in numdiscont) {print i,numdiscont[i],numepochs[i],numepochs[i]==0\?1:numdiscont[i]/numepochs[i]}}'|awk '{printf \"%%6.2f %%7.2f %%9.5f %%8d %%8d\\n\",$1,$2,$5,$3,$4}'|sort -g -k1 -k2 > Risk_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/RiskMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/RiskMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/RiskMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header.\n");
	printf("The second step is to count the number of epochs \"in risk\" missing in the global counter due to the day/hour transitions. The AWK\n");
	printf("script 'count_samples_sliding_window.awk' at the end of this help) does the counting. To run it, execute the following command line:\n\n");
	printf("cat ./201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?.txt|awk -f count_samples_sliding_window.awk > epochs_to_add_in_risk.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?.txt' to './201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n");
	printf("     - The script 'count_samples_sliding_window.awk' will automatically recognize if files are daily or hourly and count epochs accordingly\n\n");
	printf("The script 'count_samples_sliding_window.awk' creates an output file with the same format as the file 'Risk_added_no_header.txt'.\n");
	printf("The third step is to add the epochs \"in risk\" from the 'epochs_to_add_in_risk.txt' file (generated by the AWK) script to the total epoch\n");
	printf("counter in 'Risk_added_no_header.txt' file. It can be done with the following command:\n\n");
	printf("awk -v OFMT=\"%%9.5f\" 'NR==FNR {numdiscont[$1\" \"$2]+=$4;numepochs[$1\" \"$2]+=$5;next} {numdiscont[$1\" \"$2]+=$3} END{for (i in numdiscont) {print i,numdiscont[i],numepochs[i],numepochs[i]==0\?1:numdiscont[i]/numepochs[i]}}' Risk_added_no_header.txt epochs_to_add_in_risk.txt|awk '{printf \"%%6.2f %%7.2f %%9.5f %%8d %%8d\\n\",$1,$2,$5,$3,$4}'|sort -g -k1 -k2 > Risk_added_allriskepochs_no_header.txt\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the\n");
	printf("output files for continuity risk maps can be used. The following command reads the header from the file \"RiskMap_001_2017.txt\" and copy\n");
	printf("it to the previous file:\n\n");
	printf("head -3 ./2017/001/RiskMap_001_2017.txt|cat - Risk_added_allriskepochs_no_header.txt > Risk_added_allriskepochs_header.txt\n\n");
	printf("The file created, 'Risk_added_allriskepochs_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS Continuity Risk\n");
	printf("plot file. The user will have to change the plot title to state that the file has data for the two years (using the '-t' parameter).\n\n");
	printf("NOTE: To ensure the steps were done correctly, it is recommended to execute the previous commands twice. Once using only the daily files,\n");
	printf("and the next time using only the hourly files. The resulting files created by both executions should be equal, as the total number of epochs\n");
	printf("\"in risk\" has to be equal independently if the total number of epochs \"in risk\" are counted using daily or hourly files.\n");
	printf("\n\nADDING UP SBAS MARITIME CONTINUITY RISK MAPS (FIXED WINDOW)\n\n");
	printf("The continuity risk for the fixed window is computed as the number of discontinuities multiplied by the window size and divided by the total\n");
	printf("number of epochs in the processed range (independently if any epoch had PA solution under alarm limits or not). For instance, if the processed range\n");
	printf("is two non-gap years, the total number of epochs is 2*365*86400=63072000 (or 63158400 if there is a leap year). When adding up the total number\n");
	printf("of discontinuities for several days/hours, it can occur that some discontinuities are not accounted or other are counted twice. Prior to\n");
	printf("explain what these cases are, it is necessary first to detail three facts about how gLAB computes the discontinuities for the fixed window:\n");
	printf("    - For daily and hourly files, if the processing ended with discontinuity, this last discontinuity is accounted in the statistics.\n");
	printf("    - For hourly files, at the beginning of each hour, internal counters are all reset, therefore, discontinuities from each\n");
	printf("        hour do not affect the previous hour or the following one.\n");
	printf("    - If one day or hour has no epochs with PA solution under alarm limits, the number of discontinuities and number of epochs will be 0.\n");
	printf("An example is shown below on how to compute the continuity risk, using a fixed window of 5 epochs (this is a very small\n");
	printf("window size, used for explanatory purposes. Default maritime fixed window size is 900 seconds or 15 minutes):\n\n");
	printf("  NOTE: the following symbols are used:\n"); 
	printf("    - '||' is a separator for a day or hour transition\n");
	printf("    - 'X' is an epoch with PA solution under alarm limits (or in short, \"epoch with PA solution\")\n");
	printf("    - 'O' is an epoch without PA solution or with PA limits over any alarm limit (or in short, \"epoch without PA solution\")\n\n");
	printf("        O O O X X X X X X X X O O O O X X X X X O O O O O O X X X O O O X X\n");
	printf("        |   |                 |     |           |         |       |   |\n");
	printf("        - - -                 - - - -           - - - - - -       - - -\n");
	printf("          |                      |                   |              |\n");
	printf("          v                      v                   v              v\n");
	printf("   1 discontinuity       1 discontinuity      1 discontinuity   1 discontinuity\n\n");
	printf("                      Total number of discontinuities:     4 discontinuities\n");
	printf("                      Total number of epochs processed:   34 epochs\n");
	printf("                      Window Size:                         5 epochs\n");
	printf("                      Continuity Risk = 4*5/34 = 0.59\n\n");
	printf("The following cases can occur during a day or hour transition:\n");
	printf("Case 1: Day/hour ends without PA solution and the next epoch with PA solution is at the beginning of day/hour:\n\n");
	printf("               O X O||X X O\n");
	printf("          or   X X O||X X X          (All discontinuities are correctly accounted)\n");
	printf("          or   X X O||O O O||X X X\n\n");
	printf("  When the day or hour ends with discontinuity, the discontinuity is accounted in the global counter\n");
	printf("    of total discontinuities. As the following day starts with PA solution (or if the discontinuity spans\n");
	printf("     for multiple days but the first epoch with PA solution is at the beginning of the day/hour), only\n");
	printf("     one discontinuity is accounted (as days without any epoch with PA solution have zero discontinuities).\n");
	printf("     Therefore, no discontinuities have to be subtracted from the global counter.\n\n");
	printf("Case 2: Day/hour ends without PA solution and the following day starts without PA solution:\n\n");
	printf("            O X O||O X O   or   X X O||O X X   or   X X O||O O O||O X X   or   X O O||O O O||O O X\n");
	printf("                |  |                |  |                |         |              |             |\n");
	printf("                -  -                -  -                - - - - - -              - - - - - - - -\n");
	printf("                 |                   |                       |                           |\n");
	printf("                 v                   v                       v                           v\n");
	printf("        The discontinuity is counted twice due to the day/hour change (at the end and at the beginning of next day)\n\n");
	printf("  In this case, there is one discontinuity that start spans in multiple days/hours. This discontinuity is\n");
	printf("    accounted at the end of the day/hour and at the beginning of the next day/hour with PA solution (if the\n");
	printf("    discontinuity spans for multiple days/hours, days without any epochs with PA solution have zero discontinuities).\n");
	printf("    That is, it is counted twice. Therefore it is necessary to subtract one discontinuity to the global counter of discontinuities.\n\n");
	printf("Case 3: At the beginning of the data range, a discontinuity lasts a full day/hour and the next day starts with PA solution:\n\n");
	printf("           ||O O O||X X O   or   ||O O O||X X X   or   ||O O O||O O O||X X X   or   ||O O O||O O O||X X O\n");
	printf("             |   |                 |   |                 |          |                 |          |\n");
	printf("             - - -                 - - -                 - - -  - - -                 - - -  - - -\n");
	printf("               |                     |                        |                            |\n");
	printf("               v                     v                        v                            v\n");
	printf("       The discontinuity is not counted due to it starts with the first epoch processed and ends at the end of a day\n\n");
	printf("  If in the first day/hour of the data range processed (or every time there is a reset due to the data considered is not\n");
	printf("    a range of continuous days or hours), the discontinuity lasts for the full day (and it may span to multiple days)\n");
	printf("    and the first epoch with PA solution is at the beginning of the day, then this initial discontinuity is not accounted\n");
	printf("    in the global counter. It is necessary to add one to the global counter.\n\n");
	printf("Case 4: A discontinuity lasts a full day/hour (or several days/hours) and the next day starts with PA solution:\n\n");
	printf("               X X X||O O O||X X X   or   X X X||O O O||O O O||X X X\n");
	printf("                      |   |                      |          |\n");
	printf("                      - - -                      - - -  - - -\n");
	printf("                        |                              |\n");
	printf("                        v                              v\n");
	printf("       The discontinuity is not counted due to it starts at the beginning of a day and ends at the end of a day\n\n");
	printf("  If a discontinuity lasts for multiple days/hours, and it starts at the beginning of a day/hour and ends at the end of\n");
	printf("    a day/hour, this discontinuity will not be accounted in the global counter of discontinuities, as days without PA solution\n");
	printf("    have zero discontinuities. It is necessary to add one to the global counter.\n\n");
	printf("Case 5: At the end of the data range, a discontinuity starts at the beginning of day/hour and last until the end of the data range:\n\n");
	printf("               X X X||O O O||   or   O X X||O O O||O O O||\n");
	printf("                      |   |                 |          |\n");
	printf("                      - - -                 - - -  - - -\n");
	printf("                        |                        |\n");
	printf("                        v                        v\n");
	printf("     The discontinuity is not counted due to it starts at the beginning of a day and ends in the last epoch processed\n\n");
	printf("  At the end of the data range, if a discontinuity starts at the beginning of day and lasts for a full day or hour\n");
	printf("    (or multiple full days or hours) until the end of data, then this discontinuity is not accounted in the global\n");
	printf("    counter of discontinuities, as days without PA solution have zero discontinuities. Therefore it is necessary\n");
	printf("    to add one discontinuity to the global counter of discontinuities.\n\n");
	printf("To count the total continuity risk (fixed window) for the whole period, it has to be done in four steps. First, add the total\n");
	printf("total number of discontinuities. This can be done with the following command line instruction:\n\n");
	printf("cat ./201\?/\?\?\?/RiskMarMap_\?\?\?_201\?.txt| awk -v totalepochs=63072000 -v windowsize=900 -v OFMT=\"%%9.5f\" '$1==\"#MINLAT\" {getline;getline;getline} {numdiscont[$1\" \"$2]+=$4;numepochs[$1\" \"$2]+=$5} END {for (i in numdiscont) {print i,numdiscont[i],numepochs[i],numepochs[i]==0\?1:windowsize*numdiscont[i]/totalepochs}}'|awk '{printf \"%%6.2f %%7.2f %%9.5f %%8d %%8d\\n\",$1,$2,$5,$3,$4}'|sort -g -k1 -k2 > RiskMar_added_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - The size of the window must be set (in seconds). By default is 900. To change it, change the text 'windowsize=900' to another value.\n");
	printf("         For instance, to set the window size to 15, the text should be 'windowsize=15'\n");
	printf("     - The total number of epochs of the processed must be set (in this example it is two years, which are 63072000 epochs). To change it,\n"); 
	printf("          change the text 'totalepochs=63072000' to another value.\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/RiskMarMap_\?\?\?_201\?.txt' to './201\?/\?\?\?/RiskMarMap_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/RiskMarMap_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n\n");
	printf("The second step is to count the number of discontinuities counted twice and the number of discontinuities not counted\n");
	printf("due to the day/hour transitions. As the cases of discontinuities not being counted only occur if there were any epochs\n");
	printf("with PA solution and are less frequent than the number of discontinuities counted twice, the AWK script\n");
	printf("'count_samples_fixed_window.awk' will count both cases and provide the number of discontinuities to be subtracted\n");
	printf("from the global counter of discontinuities, as there will be more case of discontinuities counted twice. To run the\n");
	printf("script, execute the following command line:\n\n");
	printf("cat ./201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?.txt|awk -f count_samples_fixed_window.awk > epochs_to_subtract_riskmar.txt\n\n");
	printf("  NOTES:\n");
	printf("     - For selecting all the hourly maps, change the filename in the previous command from './201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?.txt' to './201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?_\?\?h.txt'\n");
	printf("     - For selecting some hourly maps (not necessarily continuous hours), a comma separated list of hours (padded with zeros) inside curly braces must be given in the filenames.\n");
	printf("         For instance, for selecting hours \"1,3,16,17,18,23\", the filename should be: './201\?/\?\?\?/Discontinuities_List_\?\?\?_201\?_{01,03,16,17,18,23}h.txt'\n");
	printf("     - The script 'count_samples_fixed_window.awk' will automatically recognize if files are daily or hourly and count discontinuities accordingly\n\n");
	printf("The script 'count_samples_fixed_window.awk' creates an output file with the same format as the file 'RiskMar_added_no_header.txt'.\n");
	printf("The third step is to subtract the discontinuities from the 'epochs_to_subtract_riskmar.txt' file (generated by the AWK) script to the\n");
	printf("total epoch counter in 'RiskMar_added_no_header.txt' file. It can be done with the following command:\n\n");
	printf("awk -v totalepochs=63072000 -v windowsize=900 -v OFMT=\"%%9.5f\" 'NR==FNR {numdiscont[$1\" \"$2]+=$4;numepochs[$1\" \"$2]+=$5;next} {numdiscont[$1\" \"$2]-=$3} END{for (i in numdiscont) {print i,numdiscont[i],numepochs[i]==0\?0:totalepochs,numepochs[i]==0\?1:windowsize*numdiscont[i]/63072000}}' RiskMar_added_no_header.txt epochs_to_subtract_riskmar.txt|awk '{printf \"%%6.2f %%7.2f %%9.5f %%8d %%8d\\n\",$1,$2,$5,$3,$4}'|sort -g -k1 -k2 > RiskMar_subtracted_alldiscontinuities_no_header.txt\n\n");
	printf("  NOTES:\n");
	printf("     - The size of the window must be set (in seconds). By default is 900. To change it, change the text 'windowsize=900' to another value.\n");
	printf("         For instance, to set the window size to 15, the text should be 'windowsize=15' (the default for aviation is 15 seconds,\n");
	printf("           for maritime is 900 seconds or 15 minutes).\n");
	printf("     - The total number of epochs of the processed must be set (in this example it is two years, which are 63072000 epochs). To change it,\n"); 
	printf("          change the text 'totalepochs=63072000' to another value.\n\n");
	printf("The previous command line creates a new file in the gLAB format with all the values added, but with no header. Any header from any of the output\n");
	printf("files for maritime continuity risk maps can be used. The following command reads the header from the file \"RiskMarMap_001_2017.txt\" and copy\n");
	printf("it to the previous file:\n\n");
	printf("head -3 ./2017/001/RiskMarMap_001_2017.txt|cat - RiskMar_subtracted_alldiscontinuities_no_header.txt > RiskMar_subtracted_alldiscontinuities_header.txt\n\n");
	printf("The file created, 'RiskMar_subtracted_alldiscontinuities_header.txt' can now be processed by the gLAB plotting tool as a normal SBAS\n");
	printf("Maritime Continuity Risk plot file. The user will have to change the plot title to state that the file has data for the two years\n");
	printf("(using the '-t' parameter).\n\n");
	printf("NOTE: To ensure the steps were done correctly, it is recommended to execute the previous commands twice. One time using only the daily files,\n");
	printf("and the second time using only the hourly files. The resulting files created by both executions should be equal, as the total number of\n");
	printf("discontinuities has to be equal independently if the total number of discontinuities are counted using daily or hourly files.\n\n");
	printf("---------------------------------------------------------------------------------------------\n");
	printf("AWK script 'count_samples_sliding_window.awk' for counting the number of samples that have\n");
	printf("to be added to the total number of epochs with continuity risk when computing the total\n");
	printf("number of of epochs with continuity risk for a multiple day period with a sliding window.\n");
	printf("NOTES:\n");
	printf(" - Before running the script, the window size has to be set in the second line of the script.\n");
	printf(" - This script works in gLAB version 5.4.0 and onwards.\n");
	printf("---------------------------------------------------------------------------------------------\n");
	printf("BEGIN {\n");
	printf("	WinSize=15 #Set the size of the window size (in seconds)\n");
	printf("    #Default window size of SBAS Aviation: 15\n");
	printf("    #Default window size of SBAS Maritime: 900\n");
	printf("	FirstFile=0\n");
	printf("	Firstday=1\n");
	printf("	HourlyMap=0\n");
	printf("} \n");
	printf("\n");
	printf("$1==\"#MINLAT\" {\n");
	printf("	#Check if we are joining hourly files\n");
	printf("	if ($NF==\"HOUR\") {\n");
	printf("		HourlyMap=1\n");
	printf("	}\n");
	printf("	getline\n");
	printf("	Hour23to0=0\n");
	printf("	if (HourlyMap==1 && ($9!=DoY || $10!=Year)) {\n");
	printf("		if (Hour==23 && $NF==0 && ($9==(DoY+1) || (DoY==1 && $10==(Year+1)))) {\n");
	printf("			Offset=3600*23\n");
	printf("			Hour23to0=1\n");
	printf("			#Reset lastValidEpoch values that are previous to 23 hour\n");
	printf("			for (i in lastValidEpochHour) {\n");
	printf("				if (lastValidEpochHour[i]<23) {\n");
	printf("					lastValidEpoch[i]=0\n");
	printf("					lastValidEpochHour[i]=0\n");
	printf("				}\n");
	printf("			}\n");
	printf("		} else {\n");
	printf("			#New day found. Don't take into account discontinuities\n");
	printf("			#from previous day as when joining hourly maps we do not\n");
	printf("			#join the whole day (except when hour 23 and hour 0 is used)\n");
	printf("			FirstFile=0\n");
	printf("			Firstday=1\n");
	printf("			Offset=3600\n");
	printf("			#Reset lastValidEpoch values\n");
	printf("			for (i in lastValidEpoch) {\n");
	printf("				lastValidEpoch[i]=0\n");
	printf("				lastValidEpochHour[i]=0\n");
	printf("			}\n");
	printf("		}\n");
	printf("	} else if (HourlyMap==1 && $9==DoY && $10==Year) {\n");
	printf("   		if ((Hour+1)!=$NF) {\n");
	printf("			#For the case we are joining hourly files but hourly files\n");
	printf("			#are not consecutive hours\n");
	printf("			FirstFile=0\n");
	printf("			Firstday=1\n");
	printf("			#Reset lastValidEpoch values\n");
	printf("			for (i in lastValidEpoch) {\n");
	printf("				lastValidEpoch[i]=0\n");
	printf("				lastValidEpochHour[i]=0\n");
	printf("			}\n");
	printf("		}\n");
	printf("		Offset=3600\n");
	printf("	} else if (HourlyMap==0) {\n");
	printf("   		if ($9==(DoY+1) || (DoY==1 && $10==(Year+1))) {\n");
	printf("			#New day, which is the following one\n");
	printf("		} else {\n");
	printf("			#New day, but it is not a continuous day. Don't take into account\n");
	printf("		    #discontinuities from the previous days\n");
	printf("			FirstFile=0\n");
	printf("			Firstday=1\n");
	printf("			#Reset lastValidEpoch values\n");
	printf("			for (i in lastValidEpoch) {\n");
	printf("				lastValidEpoch[i]=0\n");
	printf("				lastValidEpochHour[i]=0\n");
	printf("			}\n");
	printf("		}\n");
	printf("	}\n");
	printf("	DoY=$9\n");
	printf("	Year=$10\n");
	printf("	if (HourlyMap==1) {\n");
	printf("		Hour=$NF\n");
	printf("		TotalEpochs=3600*Hour\n");
	printf("	} else {\n");
	printf("		TotalEpochs=86400\n");
	printf("		Hour=0\n");
	printf("		Offset=0\n");
	printf("	}\n");
	printf("	getline\n");
	printf("	for (i in TodayAlreadyComputed) {\n");
	printf("		TodayAlreadyComputed[i]=0\n");
	printf("	}\n");
	printf("	FirstFile++\n");
	printf("	if (FirstFile>1) {\n");
	printf("		Firstday=0\n");
	printf("	}\n");
	printf("	next\n");
	printf("}\n");
	printf("\n");
	printf("($3-3600*Hour)<WinSize && Firstday==0 {\n");
	printf("	NumAffectedToday=$3-3600*Hour\n");
	printf("	StablePeriod=$6\n");
	printf("	NumToAffectYesterday=WinSize-NumAffectedToday\n");
	printf("	if (Hour23to0==1) {\n");
	printf("		LastEpochsAvailYesterday=86400-lastValidEpoch[$1\" \"$2]\n");
	printf("	} else if (HourlyMap==1 && lastValidEpoch[$1\" \"$2]>TotalEpochs) {\n");
	printf("		LastEpochsAvailYesterday=WinSize\n");
	printf("	} else {\n");
	printf("		LastEpochsAvailYesterday=TotalEpochs-lastValidEpoch[$1\" \"$2]\n");
	printf("	}\n");
	printf("	#Check that last epoch of previous day was not in a discontinuity\n");
	printf("	if (TodayAlreadyComputed[$1\" \"$2]==0 && lastValidEpoch[$1\" \"$2]!=(TotalEpochs+Offset)) {\n");
	printf("		#Check if the continuity duration was from the start of the file\n");
	printf("		if (NumAffectedToday<WinSize) {\n");
	printf("			if (LastEpochsAvailYesterday>0) {\n");
	printf("				#Check that discontinuity started at epoch 0 or that is is the first\n");
	printf("				#discontinuity found in the file\n");
	printf("				if ((NumAffectedToday-StablePeriod)==0) { \n");
	printf("					if (LastEpochsAvailYesterday>=NumToAffectYesterday) {\n");
	printf("						TotalExtraAffected[$1\" \"$2]+=NumToAffectYesterday\n");
	printf("					} else {\n");
	printf("						TotalExtraAffected[$1\" \"$2]+=LastEpochsAvailYesterday\n");
	printf("					}\n");
	printf("				}\n");
	printf("			}\n");
	printf("		}\n");
	printf("	}\n");
	printf("	TodayAlreadyComputed[$1\" \"$2]=1\n");
	printf("}\n");
	printf("\n");
	printf("{\n");
	printf("	lastValidEpoch[$1\" \"$2]=$4+1 #Add 1 as the available epoch starts the next epoch\n");
	printf("	lastValidEpochHour[$1\" \"$2]=Hour\n");
	printf("}\n");
	printf("\n");
	printf("END {\n");
	printf("	for (i in TotalExtraAffected) {\n");
	printf("		split(i,coord)\n");
	printf("		printf \"%%6.2f %%7.2f %%6d\\n\",coord[1],coord[2],TotalExtraAffected[i]\n");
	printf("	}\n");
	printf("}\n\n");
	printf("---------------------------------------------------------------------------------------------\n");
	printf("AWK script 'count_samples_fixed_window.awk' for counting the number of samples that have\n");
	printf("to be subtracted to the total number of discontinuities when computing the total number\n");
	printf("of discontinuities for a multiple day period with a fixed window.\n");
	printf("NOTES:\n");
	printf(" - Before running the script, the window size has to be set in the second line of the script.\n");
	printf(" - This script works in gLAB version 5.4.0 and onwards.\n");
	printf("---------------------------------------------------------------------------------------------\n");
	printf("BEGIN {\n");
	printf("	WinSize=900 #Set the size of the window size (in seconds)\n");
	printf("    #Default window size of SBAS Aviation: 15\n");
	printf("    #Default window size of SBAS Maritime: 900\n");
	printf("	FirstFile=0\n");
	printf("	Firstday=1\n");
	printf("	HourlyMap=0\n");
	printf("} \n");
	printf("\n");
	printf("$1==\"#MINLAT\" {\n");
	printf("	#For the case that the files has no discontinuity data\n");
	printf("	if (NumLinesReadFile<=3) {\n");
	printf("		for (i in SubtractDiscon) {\n");
	printf("			if (SubtractDiscon[$1\" \"$2]==1) {\n");
	printf("				EpochAvailStartFile[$1\" \"$2]=1\n");
	printf("			}\n");
	printf("		}\n");
	printf("	}\n");
	printf("	NumLinesReadFile=1\n");
	printf("	#Check if we are joining hourly files\n");
	printf("	if ($NF==\"HOUR\") {\n");
	printf("		HourlyMap=1\n");
	printf("	}\n");
	printf("	getline\n");
	printf("	if (HourlyMap==1 && ($9!=DoY || $10!=Year)) {\n");
	printf("		if (Hour==23 && $NF==0 && ($9==(DoY+1) || (DoY==1 && $10==(Year+1)))) {\n");
	printf("			Offset=86400\n");
	printf("		} else {\n");
	printf("			#New day found. Don't take into account discontinuities\n");
	printf("			#from previous day as when joining hourly maps we do not\n");
	printf("			#join the whole day (except when hour 23 and hour 0 is used)\n");
	printf("			FirstFile=0\n");
	printf("			Firstday=1\n");
	printf("			Offset=0\n");
	printf("			#Reset lastValidEpoch values\n");
	printf("			for (i in lastValidEpoch) {\n");
	printf("				lastValidEpoch[i]=0\n");
	printf("				DataAvailAndEndedWithDiscontinuity[i]=0\n");
	printf("				SubtractDiscon[i]=0\n");
	printf("				EpochAvailStartFile[i]=0\n");
	printf("			}\n");
	printf("		}\n");
	printf("	} else if (HourlyMap==1 && $9==DoY && $10==Year) {\n");
	printf("   		if ((Hour+1)!=$NF) {\n");
	printf("			#For the case we are joining hourly files but hourly files\n");
	printf("			#are not consecutive hours\n");
	printf("			FirstFile=0\n");
	printf("			Firstday=1\n");
	printf("			#Reset lastValidEpoch values\n");
	printf("			for (i in lastValidEpoch) {\n");
	printf("				lastValidEpoch[i]=0\n");
	printf("				DataAvailAndEndedWithDiscontinuity[i]=0\n");
	printf("				SubtractDiscon[i]=0\n");
	printf("				EpochAvailStartFile[i]=0\n");
	printf("			}\n");
	printf("		}\n");
	printf("		Offset=0\n");
	printf("	} else if (HourlyMap==0) {\n");
	printf("   		if ($9==(DoY+1) || (DoY==1 && $10==(Year+1))) {\n");
	printf("			#New day, which is the following one\n");
	printf("		} else {\n");
	printf("			#New day, but it is not a continuous day. Don't take into account\n");
	printf("		    #discontinuities from the previous days\n");
	printf("			FirstFile=0\n");
	printf("			Firstday=1\n");
	printf("			#Reset lastValidEpoch values\n");
	printf("			for (i in lastValidEpoch) {\n");
	printf("				lastValidEpoch[i]=0\n");
	printf("				DataAvailAndEndedWithDiscontinuity[i]=0\n");
	printf("				SubtractDiscon[i]=0\n");
	printf("				EpochAvailStartFile[i]=0\n");
	printf("			}		\n");
	printf("		}\n");
	printf("	}\n");
	printf("	DoY=$9\n");
	printf("	Year=$10\n");
	printf("	if (HourlyMap==1) {\n");
	printf("		Hour=$NF\n");
	printf("		TotalEpochs=3600*Hour\n");
	printf("		MaxDisconDuration=3600\n");
	printf("	} else {\n");
	printf("		TotalEpochs=86400\n");
	printf("		MaxDisconDuration=86400\n");
	printf("		Hour=0\n");
	printf("		Offset=0\n");
	printf("	}\n");
	printf("	getline\n");
	printf("	for (i in TodayAlreadyComputed) {\n");
	printf("		TodayAlreadyComputed[i]=0\n");
	printf("	}\n");
	printf("	FirstFile++\n");
	printf("	if (FirstFile>1) {\n");
	printf("		Firstday=0\n");
	printf("	}\n");
	printf("	next\n");
	printf("} \n");
	printf("\n");
	printf("{\n");
	printf("	NumLinesReadFile++\n");
	printf("}\n");
	printf("\n");
	printf("#If the first day has no available epochs, we need to check if the first\n");
	printf("#day with valid data, the valid data starts at the first hour or day\n");
	printf("((($3-3600*Hour-$6)==0 || ($3-$6)==0)) && $6>0 {\n");
	printf("	if (SubtractDiscon[$1\" \"$2]==1) {\n");
	printf("		EpochAvailStartFile[$1\" \"$2]=1\n");
	printf("	}\n");
	printf("}\n");
	printf("\n");
	printf("SubtractDiscon[$1\" \"$2]==1 && $5!=MaxDisconDuration {\n");
	printf("	SubtractDiscon[$1\" \"$2]=0\n");
	printf("}\n");
	printf("\n");
	printf("($3-3600*Hour)==0 && Firstday==0 {\n");
	printf("	#Discontinuities that are counted double are only in the case that previous day ends\n");
	printf("	#with a discontinuity and the next day starts with a discontinuity. Also, the \n");
	printf("	#discontinuity from the previous day must be one that did not last the hole day,\n");
	printf("	#as in this case, the number of discontinuities (NUMDISCONT) is set to 0, as no PA\n");
	printf("	#epochs were available, no discontinuity events occurred\n");
	printf("	if (lastValidEpoch[$1\" \"$2]==(TotalEpochs+Offset) && TodayAlreadyComputed[$1\" \"$2]==0 && $5!=MaxDisconDuration) {\n");
	printf("		#if (HourlyMap==0 || (HourlyMap==1 && DataAvailAndEndedWithDiscontinuity[$1\" \"$2]==1) ) {\n");
	printf("		if (DataAvailAndEndedWithDiscontinuity[$1\" \"$2]==1) {\n");
	printf("			if (EpochAvailStartFile[$1\" \"$2]==0) {\n");
	printf("				TotalExtraAffected[$1\" \"$2]++\n");
	printf("			}\n");
	printf("			SubtractDiscon[$1\" \"$2]=0\n");
	printf("			EpochAvailStartFile[$1\" \"$2]=0\n");
	printf("		}\n");
	printf("		DataAvailAndEndedWithDiscontinuity[$1\" \"$2]=0\n");
	printf("	}\n");
	printf("	TodayAlreadyComputed[$1\" \"$2]=1\n");
	printf("}\n");
	printf("\n");
	printf("{\n");
	printf("	if ($5==MaxDisconDuration) {\n");
	printf("		#if (Firstday==1) {\n");
	printf("		if (lastValidEpoch[$1\" \"$2]!=86400) {\n");
	printf("			#If the discontinuity lasts the whole day and the previous day ended without discontinuity,\n");
	printf("			#and the next day starts with valid data, this discontinuity will not be counted\n");
	printf("			#Therefore we need to subtract one from the total count when necessary\n");
	printf("			#The check for if the following day starts with data is done later\n");
	printf("			if ((lastValidEpoch[$1\" \"$2]!=(3600*Hour) && Hour>0) || (lastValidEpoch[$1\" \"$2]==0 && Hour==0 ) ) {\n");
	printf("				SubtractDiscon[$1\" \"$2]=1\n");
	printf("			}\n");
	printf("		}\n");
	printf("		#Discontinuity lasts the hole day or hour\n");
	printf("		if (HourlyMap==0) {\n");
	printf("			lastValidEpoch[$1\" \"$2]=86400\n");
	printf("		} else {\n");
	printf("			lastValidEpoch[$1\" \"$2]=3600*(Hour+1) \n");
	printf("		}\n");
	printf("	} else if ((HourlyMap==1 && ($4+1)==(3600*(Hour+1))) || (HourlyMap==0 && ($4+1)==86400) ) {\n");
	printf("		lastValidEpoch[$1\" \"$2]=$4+1 #Add 1 as the avail epoch starts the next epoch\n");
	printf("		DataAvailAndEndedWithDiscontinuity[$1\" \"$2]=1\n");
	printf("		HasHadDataAvail[$1\" \"$2]=1\n");
	printf("	} else {\n");
	printf("		lastValidEpoch[$1\" \"$2]=$4+1 #Add 1 as the avail epoch starts the next epoch\n");
	printf("		DataAvailAndEndedWithDiscontinuity[$1\" \"$2]=0\n");
	printf("		HasHadDataAvail[$1\" \"$2]=1\n");
	printf("	}\n");
	printf("}\n");
	printf("\n");
	printf("END {\n");
	printf("	for (i in SubtractDiscon) {\n");
	printf("		#If the last day(s) or hour(s) ends had discontinuity for the hole day/hour and the\n");
	printf("		#last available epoch was at the end of a day/hour, then the discontinuity that lasted\n");
	printf("		#all the hour(s) or day(s) is not accounted for, so it is necessary to subtract one\n");
	printf("		#to the total count so it is taken into account\n");
	printf("		if (SubtractDiscon[i]==1 && TotalExtraAffected[i]>0 && HasHadDataAvail[i]==1) {\n");
	printf("			TotalExtraAffected[i]--\n");
	printf("		}\n");
	printf("	}\n");
	printf("	for (i in TotalExtraAffected) {\n");
	printf("		split(i,coord)\n");
	printf("		printf \"%%6.2f %%7.2f %%6d\\n\",coord[1],coord[2],TotalExtraAffected[i]\n");
	printf("	}\n");
	printf("}\n");

}

/*****************************************************************************
 * Name        : showFAQ
 * Description : Shows answers to frequently asked questions (FAQ)
 * Parameters  : None
 *****************************************************************************/
void showFAQ() {
	#if defined _OPENMP
		printf("gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("\n-------------------------KNOWN ISSUES---------------------------------\n");
	printf("\n  IN WINDOWS 11, WHY IS THE PROCESSING TIME MUCH SMALLER THAN THE REAL PROCESSING TIME?\n\n");
	printf("       This is a Windows 11 bug since Windows 11 version 22H2, which makes processing time reported by function 'GetProcessTimes' (the only Windows function\n");
	printf("        that provides processing time separated by user and kernel times) be much smaller than the real wall time. The only workaround for this issue is to\n");
	printf("        launch gLAB (without multi-threading) from command line with CPU affinity set to CPU 0 only, which can be done in the following way:\n\n");
	printf("          - Windows command line:\n\n");
	printf("               start /affinity 1 gLAB.exe <gLAB_parameters>\n\n");
	printf("          - Linux/Cygwin command line:\n\n");
	printf("               taskset -c 0 ./gLAB_linux <gLAB_parameters>\n\n");
	printf("        When using the Windows command line method, the standard output redirection (with the '>' symbol) will not work, so it is mandatory to use '-output:file'\n");
	printf("         parameter to redirect the gLAB output.\n\n");
	printf("        Moreover, it possible to compute the total processing time (without separating user and kernel modes) in Windows Powershell, with the following command:\n\n");
	printf("               Measure-Command {gLAB.exe <gLAB_parameters>}\n\n");
	printf("        With this method, the gLAB output must be redirected to a file, otherwise it is not shown in the terminal. It can be done by either using the redirection\n");
	printf("         sign ('>') inside the curly brackets ('}') or using parameter '-output:file'.\n");
	printf("\n  WHY THE GUI IN SOME NEWER VERSIONS OF LINUX STARTS WITH A VERTICAL SCROLLBAR?\n\n");
	printf("       It is not known why this graphical bug occurs, as there is enough space to fit the elements without a vertical scrollbar, but for some reason vertical\n");
	printf("         space is added, which does not occur in older versions of Linux (where no vertical scrollbar appears at launch). It does not seem a Qt issue, as it is\n");
	printf("         embedded in the executable (statically compiled), but an issue with system libraries. Note that Linux is forward compatible but not backward compatible,\n");
	printf("         that is, a software compiled in a given Linux version will work in newer Linux versions but not in older ones, therefore it is necessary to compile the\n");
	printf("         GUI in older versions of Linux (the GUI is compiled in Ubuntu 14.04).\n");
	printf("       If this bug occurs, just increase the vertical size of the application until the scrollbar disappears, as it is only a graphical bug which does not affect\n"); 
	printf("        any functionality.\n");
	printf("\n  WHY THE GUI IN MAC IS NOT AESTHETICALLY AS GOOD AS IN WINDOWS AND LINUX?\n\n");
	printf("       This is mainly due to Qt libraries in Mac, which create a very different result with respect to Windows and Linux.\n");
	printf("       To set the GUI in Mac similar level as in Windows and Linux, a lot of manual tweaking would be necessary, which we have no time and interest to fix.\n");
	printf("       We only provide Mac for convenience for our users, and only commit to fix functional or visual (e.g. text not visible) breaking bugs in the Mac GUI.\n");
	printf("\n-------------------------gLAB GENERAL QUESTIONS-----------------------\n");
	printf("\n  HOW TO CONTACT gAGE GROUP FOR SUPPORT WITH gLAB?\n\n");
	printf("       In case you need support for gLAB, you can contact us at glab.%s %c upc.%s.\n","gage",'@',"edu");
	printf("        Before writing the request, please check that your doubt is not answered in the FAQ below.\n");
	printf("        Please provide as much information as possible. The easiest it is for us to understand your problem, the faster we can help you.\n");
	printf("        If the issue is related to the output of gLAB, please attach all the files used and the configuration file (you can create one with\n");
	printf("        the GUI in the menu 'Configuration->Save Configuration file') or the command line used. If files are large, you can use online services\n");
	printf("        such as WeTransfer (https://wetransfer.com) to send the files. With this info, we will be able to reproduce the problem and provide a quicker answer.\n");
	printf("\n  HOW TO REFERENCE gLAB?\n\n");
	printf("       For referencing the gLAB tool, please cite the following PhD thesis:\n\n");
	printf("           Ibanez D. (2023) Contributions to multi-purpose GNSS positioning to support multi-frequency and multi-constellation with high accuracy\n");
	printf("           and integrity. PhD thesis, URL https://server.gage.upc.edu/PhD/Ibanez_Deimos/PhD_Ibanez_Deimos.pdf\n");
	printf("\n  WHICH ARE THE INPUT FILES SUPPORTED?\n\n");
	printf("       RINEX OBSERVATION FILE: 2.10, 2.11, 3.00, 3.01, 3.02, 3.03, 3.04, 3.05\n");
	printf("       RINEX NAVIGATION  FILE: 2.10, 2.11, 3.00, 3.01, 3.02, 3.03, 3.04, 3.05\n");
	printf("       SP3               FILE: a, b, c, d\n");
	printf("       RINEX CLOCK       FILE: 2.00, 3.00, 3.01, 3.02, 3.04\n");
	printf("       ANTEX             FILE: 1.0, 1.1, 1.2, 1.3, 1.4\n");
	printf("       IONEX             FILE: 1.00, 1.1 (including support for multi-layer maps and irregular time spacing between samples)\n");
	printf("       CODE DCB          FILE: P1-C1 and P1-P2 DCB files (no version number on these files)\n");
	printf("       RINEX-B           FILE: 2.00, 2.10, 2.11\n");
	printf("       EMS               FILE: version for SBAS 1F messages and version for SBAS 1F and DFMC messages is supported (no version number in these files)\n");
	printf("       RTCM              FILE: 2.0, 2.1, 2.2, 2.3, 3.0, 3.1, 3.2, 3.3 (it only decodes GPS data for any of the RTCM versions)\n\n");
	printf("     Although RINEX 4 is not supported, RINEX 4 observation file does not change the file format, so it should work fine.\n");
	printf("     The unofficial MGEX RINEX navigation version '4.00' with GPS CNAV data is supported, but has different format as the official RINEX 4.\n");
	printf("\n  WHICH ARE THE OPERATIVE SYSTEMS AND ARCHITECTURES SUPPORTED?\n\n");
	printf("       WINDOWS (x86):                  The GUI, core and graphical tool can run on x86, but must be compiled by the user.\n");
	printf("       WINDOWS (x86_64):               7, 8, 8.1, 10, 11\n");
	printf("       LINUX   (x86):                  The GUI, core and graphical tool can run on x86, but must be compiled by the user.\n");
	printf("       LINUX   (x86_64, ARMv7, ARM64): Ubuntu 16.04 and above. Compatible with other Linux distributions.\n");
	printf("       MAC     (x86_64):               OS X 10.11 (El Capitan) and above.\n\n");
	printf("        Note that this list corresponds to the whole gLAB software (core, GUI and graph tool).\n");
	printf("        The core uses standard C99 libraries, therefore any platform and operative system with a C99 compiler should be able to run the core.\n");
	printf("\n  HOW TO RUN GLAB WITH A CONFIGURATION FILE (GENERATED WITH THE GUI OR MANUALLY)?\n\n");
	printf("       To run gLAB with a configuration file, use the following command:\n\n");
	printf("          %s -input:cfg configuration_file \n\n",GLABPROGRAMEXECUTABLE);
	printf("       Note that using a configuration file does not prevent to provide additional parameters in command line. For instance, the configuration file\n");
	printf("        can be used to set the processing parameters and then in command line provide the input files. For instance:\n\n");
	printf("          %s -input:cfg configuration_file -input:obs rinex_file -input:nav nav_file\n",GLABPROGRAMEXECUTABLE);
	printf("\n  WHAT CONSTELLATIONS CAN AND CANNOT PROCESS gLAB IN VERSION 6 (FIRST MULTICONSTELLATION VERSION)?\n\n");
	printf("       SPP mode: Process all constellations.\n\n");
	printf("       PPP mode: Process all constellations.\n\n");
	printf("       SBAS 1F mode: Only GPS SBAS processing (same as previous versions).\n\n");
	printf("       SBAS DFMC mode: GPS and Galileo as in current SBAS DFMC version (although it should work with other constellations if the message structure is the same).\n\n");
	printf("       DGNSS mode: Only GPS DGNSS processing (same as previous versions, including RTCM decoding), although internal\n");
	printf("             architecture for DGNSS processing has been prepared for multi-constellation.\n\n");
	printf("       Add User Error to RINEX mode: All constellations supported.\n");
	printf("\n  WHAT ARE THE MEASUREMENT SELECTION MODES IN gLAB?\n\n");
	printf("       In SPP and PPP modes (SBAS and DGNSS have fixed measurements), gLAB internally works in three modes for measurement selection:\n");
 	printf("         - Automatic mode: gLAB automatically selects which measurements (or combinations) and frequencies to use based on the processing mode (SPP, PPP).\n");
	printf("            The frequencies and measurements selected are based on the frequency and measurement priority lists, which can be modified by the user\n");
	printf("              a per satellite basis. In SPP mode, automatic mode will select single frequency measurements, while in PPP mode it will select dual\n");
	printf("              frequency measurements. The user can force gLAB to autoselect single frequency, dual frequency or graphical combination measurements\n");
	printf("              independently of the processing mode using parameter '-filter:combtype'.\n");
	printf("              Moreover, If an ANTEX file is provided, gLAB will autoremove all measurements not available on each satellite (e.g. L5 for GPS).\n");
	printf("            Automatic mode is triggered when the user does not set any measurement to be used in the navigation filter or it sets some measurements for some\n");
	printf("              satellites and for the rest it is explicitly stated to 'auto' (e.g. -filter:select G0-code-1 E0-auto). In the latter case, satellites without\n");
	printf("              any information in the parameter will not be used.\n\n");
	printf("         - Semi-automatic mode: This mode is triggered when the user sets a measurement type (or combination) to use (and its frequency) to be\n");
	printf("            used in the filter, but not the measurement names (eg. G0-PC12). In this case, gLAB selects the measurement to use according to\n");
	printf("            the measurement priority list (which can be modified by the user in a per satellite basis) and the available measurements\n");
	printf("            in the RINEX observation file. Furthermore, the user can set satellite measurements 'auto' (as in previous case) for automatic selection.\n\n");
	printf("         - Manual mode: This mode is triggered when the user sets the measurement types and measurement names (e.g. G0-PC12-C1C-C2P) to be used\n");
	printf("            in the navigation filter. Furthermore, the user can set satellite measurements 'auto' (as in previous case) for automatic selection.\n\n");
	printf("         Note that semi-automatic and manual mode can both co-exist at the same time if user sets for the navigation filter measurement types (without\n");
	printf("          the measurement names) and also measurement types with measurement names.\n");
	printf("         In semi-automatic and manual modes, the measurement selection will be done after reading the first epoch of data, as satellites may not have all\n");
	printf("          measurements listed in the header. The first epoch of data is read after the INFO messages with gLAB configuration printed at the start of the\n");
	printf("          output file. Therefore, to check the measurements selected by gLAB, the user must check any of the MODEL, PREFIT, POSTFIT or EPOCHSAT messages.\n\n");
	printf("         The frequency and measurement priority lists are available in the menu 'Set GNSS Frequencies and Measurements Order' in the 'Filter' tab in the GUI\n");
    printf("          or in the description of parameters '-pre:freqorder' and '-pre:measorder' in the command line help.\n");
	printf("\n  CAN gLAB AUTOMATICALLY SELECT SMOOTHED MEASUREMENTS?\n\n");
	printf("       Yes, but the user needs to explicitly provide parameter '-pre:smoothauto' in order to use smoothed measurements (except in SBAS and DGNSS modes,\n");
	printf("        which is the default). The default smoothing time is 100 epochs if none set (it can be changed in the GUI or with parameter '-pre:smooth').\n");
	printf("        If user provides both parameters '-pre:smoothauto' and '-pre:smoothmeas', the former will be ignored to avoid interfering\n");
	printf("        with user selection of smoothed measurements.\n");
	printf("\n  IS IT NECESSARY TO SELECT MEASUREMENTS FOR CYCLE-SLIP DETECTORS WHEN MEASUREMENTS FOR THE FILTER ARE MANUALLY SET?\n\n");
	printf("       No, gLAB will check that all carrier phases used in the filter are processed by all enabled cycle-slip detectors. If any carrier phase measurement\n");
	printf("        is missing in any cycle-slip detector, gLAB will automatically add it to each cycle-slip detector without it. Note that each cycle-slip detector\n");
	printf("        can run multiple iterations with different measurements, so it will not remove any other iteration already set.\n");
	printf("       It is possible to disable the auto measurement filling in the cycle-slip detectors by providing parameter '-pre:cs:noautofill'.\n");
	printf("\n  CAN gLAB AUTO DETECT THE MEASUREMENTS AVAILABLE IN EACH SATELLITE?\n\n");
	printf("       Yes, but only if an ANTEX is provided. From the ANTEX, it detects the satellite block, which determines the available frequencies and measurements\n");
	printf("        for a given satellite. In PPP mode it will use the provided ANTEX file. If no ANTEX is provided or it is not PPP mode, the option '-input:antsatblock'\n");
	printf("        can be used to provide an ANTEX for this purpose.\n");
	printf("       An example of use case of this feature: the user wants process with a iono-free combination with L1/L5 for all GPS with L5, otherwise use L1/L2 instead.\n");
	printf("        To accomplish this, the only additional command line parameter required is to change the frequency priority list to 1-5-2 (or any order where\n");
	printf("        frequency 5 is in first or second position) with parameter '-pre:freqorder G0-152'.\n");
	printf("\n  CAN gLAB PROCESS MULTIPLES DAYS IN A SINGLE RUN IN FORWARD AND BACKWARDS MODES?\n\n");
	printf("       Yes, it can process multiple days in a row (without reset between days) as long as the input files (observation, navigation or precise files) are concatenated in a single file.\n\n");
	printf("          - For forward processing mode only, all the files (observation, navigation, precise files, SBAS files) can all be concatenated with or without headers.\n");
	printf("              o For the special case of IONEX file, or either it is concatenated with the header, or with only the first header but modifying it to include the total\n");
	printf("                 number of maps after concatenating.\n");
	printf("              0 CODE DCB GPS P1-C1 and GPS P1-P2 files do not support concatenation, but this should be not much of a problem, as P1-C1 DCB files are monthly files,\n");
	printf("                 while P1-P2 DCB can be read from navigation files instead.\n\n");
	printf("          - For backward processing mode, it is compulsory to concatenate all files without headers, as input cannot be read backwards. There are a few exceptions:\n");
	printf("              o The RINEX observation file is the only file that supports backwards reading (with or without headers). The only limitation is that when reading backwards,\n");
	printf("                 it will skip all headers found, as when reading backwards the headers found refer to the data already read. Therefore, it is compulsory that the\n");
	printf("                 observation file always keeps the same order and number of measurements (only for backwards mode).\n");
	printf("              o If using SP3 or CLK files and the number of concatenated files is equal or below 3, it is not necessary to remove headers as gLAB reads up to three\n");
	printf("                  days of SP3 and CLK data at a time.\n");
	printf("              o If using navigation files and the number of concatenated files is equal or below 2, it is not necessary to remove headers as gLAB reads up to two\n");
	printf("                  days of navigation data at a time.\n\n");
	printf("          - SBAS and DGNSS modes do not support backwards processing mode.\n\n");
	printf("          For concatenating files, see question 'HOW TO CONCATENATE FILES?' below.\n");
	printf("\n  CAN MEAS MESSAGE BE USED AS A CONVERTER FROM RINEX OBSERVATION TO A COLUMNAR TEXT FILE?\n\n");
	printf("       Yes, since version v6, MEAS message can print all measurements in RINEX observation file (pseudorange, carrier phase, SNR, Doppler and LLI flag). Moreover, for the case\n");
	printf("        of the SNR, if the SNR as a measurement is provided, it will print the measurement. Otherwise, it will print the SNR read as a flag (converted to a number).\n");
	printf("       Also, since version 6 the user can select which measurements to print (and in which order) in a per satellite basis, independently of the RINEX observation contents.\n");
	printf("       Moreover, the user can select which satellites to print. This is done by selecting the satellites with option '-pre:sat'.\n");
	printf("       Last but not least, since version 6 the MEAS message also includes the arc number and length, the block type and the SVN, therefore the MEAS message contains\n");
	printf("        information from the RINEX observation file, ANTEX file (if provided) and the cycle-slips.\n");
	printf("\n  IS IT POSSIBLE TO PRINT CLOCK ESTIMATES IN NANOSECONDS?\n\n");
	printf("       Yes, by providing the parameter '-print:clkns'. When this parameter is provided, the receiver clock offset in FILTER and OUTPUT messages will be printed in\n");
	printf("        nanoseconds instead of metres, and the inter-sytem clock bias in FILTER and MODEL messages will also be printed in nanoseconds.\n");
	printf("       Furthermore, in the INFO messages at the beginning, the Q and P0 values for the receiver clock and inter-system clock bias in the filter will also be printed\n");
	printf("        in nanoseconds. Note that there are also specific parameters for providing these values in nanoseconds, instead of metres.\n");
	printf("\n  HOW TO CONCATENATE FILES?\n\n");
	printf("       As gLAB accepts multiple headers in data files, we just need to concatenate the files directly. The only requirement is to do it chronological order.\n\n");
	printf("          - Windows command line (the user can concatenate as many files as wanted at once):\n\n");
	printf("               copy /b file1+file2+file3 concatenated_file\n\n");
	printf("          - Linux/Cygwin command line (the user can concatenate as many files as wanted at once):\n\n");
	printf("               cat file1 file2 file3 > concatenated_file\n\n");
	printf("       Moreover, for the case of RINEX navigation files, it is convenient to concatenate files without the header (except for the first file) in SBAS modes, as in this case\n");
	printf("        gLAB will read all the three day as a single day, which is useful to avoid missing packages at the beginning or end of day (specially for SBAS modes). It can\n");
	printf("        be done with the following command in Linux or Cygwin terminal (valid for RINEX navigation v2 and v3):\n\n");
	printf("               cat file2 file3 | sed -n '/[A-Z#][ ]\\{0,\\}$/!p' | sed '/WAVELENGTH FACT/d' | sed '/GLONASS SLOT/d' | cat file1 - > concatenated_brc_file_with_first_file_header\n\n");
	printf("       With the previous command, the remaining header will be from the first file. To keep the header of the second file, just swap file1 with file2. Otherwise,\n");
	printf("        if only the 'IONOSPHERIC CORR' header lines are need for the Klobuchar, Nequick or BeiDou Klobuchar models, gLAB can read them from a different file than the\n");
	printf("        source file of navigation messages (parameter '-input:nav') by providing parameter '-input:klb', '-input:neq' or '-input:bds' for each model respectively.\n");
	printf("\n  HOW TO MERGE MULTIPLE SBAS DATA FILES (RINEX-B OR EMS) FROM DIFFERENT GEOS TO CREATE A SINGLE MULTI-GEO FILE?\n\n");
	printf("       In order for gLAB to process SBAS and be able to switch GEOs, it needs to have data from all the GEOs to be used in the same file, with data ordered in\n");
	printf("        chronological order, but usually SBAS messages file are given in a file per each GEO. To join the files, follow the next steps:\n\n");
	printf("         - Convert file from RINEX-B to EMS format (if file is in EMS format, the user can skip this step). Use gLAB to convert from RINEX-B to EMS, as both files\n");
	printf("            do not have the same timestamp reference.\n\n");
	printf("                 %s -input:sbas rinexbfile -output:ems -onlyconvert -output:dir conversionfolder\n\n",GLABPROGRAMEXECUTABLE);
	printf("              Parameter '-output:dir' is optional and specifies and output directory (which will be created by gLAB if it doesn't exist). If not specified\n");
	printf("               or directory is '.', output file will be written in current directory.\n");
	printf("              Repeat the process for each file to be converted.\n\n");
	printf("         - Concatenate files and sort them by timestamp. This command must be executed in a Linux or Cygwin terminal. In Windows, it is necessary to downloaded\n");
	printf("            precompiled version of UNIX 'cat' and 'sort' programs to execute the same command as in Linux/Cygwin.\n");
	printf("            The command is (the user can execute the command with as many files at a time as necessary):\n\n");
	printf("                 cat emsfile1 emsfile2 emsfile |sort -n -k2 -k3 -k4 -k5 -k6 -k7 -k1 > multigeo_ems_file\n\n");
	printf("         - (Optional) Convert the merged EMS file back to RINEX-B:\n\n");
	printf("                 %s -input:sbas multigeo_ems_file -output:rinexb -onlyconvert\n\n",GLABPROGRAMEXECUTABLE);
	printf("        The user can later concatenate merged files from different days to create a multi-GEO and multi-day SBAS file.\n");
	printf("\n  HOW TO PROCESS A FULL DAY OF DATA WITHOUT CONVERGENCE TIME?\n\n");
	printf("       Convergence time occurs in both PPP (for cycle-slip detection and the carrier phase ambiguities convergence) and SBAS modes (smoothing and SBAS message buffering).\n");
	printf("        To process a full day without convergence time, it is necessary to concatenate two days (see question 'HOW TO CONCATENATE FILES?'), the first day for the convergence\n");
	printf("         and the second day with the results of interest. In the case of SBAS (or PPP for only the cycle-slip convergence), a 15 minute convergence suffices, so the user can either\n");
	printf("         concatenate 15 minutes of data (not explained in this FAQ) or set the start time in gLAB (with parameter '-pre:starttime') to 23:45 of the first day and the summary\n");
	printf("         start time (with parameter '-summary:starttime') to 00:00 of the second day.\n");
	printf("\n  WHY GLAB NEEDS TO CONCATENATE FILES INSTEAD OF READING MULTIPLE FILES TO PROCESS MULTIPLE DAYS?\n\n");
	printf("       This is a usual question from professional users, where tools are designed with very specific purposes and requirements. Indeed, reading multiple files for multiple days\n");
	printf("        is convenient as the user only needs to provide the input files, but comes with the disadvantage that the user must also provide to the tool a folder when to find the files\n");
	printf("        and a strict file convention so the tool reads only the files of interest and in the correct order. This rigidity is a problem for both educational and research users. For the\n");
	printf("        former usage, only having to provide an input file makes new gLAB users first contact much easier (specially with the GUI). For the latter usage, researcher perform many tests by\n");
	printf("        modifying existing files, and being able to use any filename (as gLAB does not care about filenames and extensions) is a crucial feature. As gLAB was first designed with these\n");
	printf("        two usages in mind, this was the approach chosen and it will not change.\n");
	printf("\n  WHAT ARE THE 'DUAL FREQUENCY DCB'?\n\n");
	printf("       To explain what are 'dual frequency DCBs', first it is need to explain what is a DCB (Differential Code Bias).\n");
	printf("       Broadcast navigation messages or precise products provide orbits and clock products. These are computed using a reference measurement or a combination (usually\n");
	printf("        a ionospheric-free). For instance, broadcast BeiDou products that are referred to the B3 signal). whereas GPS products are referred to the iono-free\n");
	printf("        combination built with measurements C1P and C2P.\n\n");
	printf("       Therefore, the satellite clock correction is referred to this combination. In the case of using any single frequency measurement or any iono-free combination\n");
	printf("        with different measurements (even if they are different attributes, like C5I or C5Q), it is necessary an additional term to convert the measurement used (in\n");
	printf("        terms of clock correction only) to the reference measurement used by the orbit and clock products used. This term is called the DCB.\n\n");
	printf("       When GPS and GLONASS where available with only two frequencies and few measurements, the DCB provided in the navigation message were to convert from a single\n");
	printf("        frequency measurement (C1P or C2P) to the reference iono-free combination with C1P and C2P. For this reason, gLAB applied this DCB in the modelling of the\n");
	printf("        measurement prior to performing any measurement combination (if necessary). Therefore, if a iono-free combination was computed later in the gLAB processing,\n");
	printf("        the DCBs would cancel if they had been applied.\n\n");
	printf("       With the current paradigm of multiple frequencies and measurements, there are several different measurements and iono-free combinations available. However, the\n");
	printf("        measurements used as a reference in the orbit and clock products have not changed. Therefore, it is needed additional DCBs or provide additional correction terms to\n");
	printf("        the existing DCBs (which will also be DCBs). The latter approach has been used, and these terms are named ISC (Inter Signal Correction), and can be used to convert\n");
	printf("        single frequency measurements or iono-free combinations to the reference clock. In the case of iono-free combinations, according to the ICDs, they have to be applied\n");
	printf("        after computing the iono-free combination, not before, with a specific formula which may use multiple DCBs. For instance, the ICD for GPS uses iono-free combination\n");
	printf("        built with frequencies F1 and F5 uses two DCBs: the TGD and an ISC DCB). The specific formula to be applied in such iono-free combinations is what gLAB\n");
	printf("        defines as 'dual frequency DCBs'.\n");
	printf("\n  WHAT IS THE 'BEIDOU SINGLE FREQUENCY PRECISE ORBITS DCB MODEL' DCB TERM SHOWN IN THE INFO MESSAGES?\n\n");
	printf("       As commented in the previous question \"WHAT ARE THE 'DUAL FREQUENCY DCB'?\", DCBs for BeiDou (for BDS-2 signals) are a special case, because the satellite clock\n");
	printf("        broadcast in the navigation message is referred to the B3 measurement, instead to an iono-free combination. Then, when using single frequency measurement with\n");
	printf("        precise orbits and clocks (e.g. IGS), it is necessary to apply a DCB, because the precise products are referred to the iono-free combination of signals B1-B2b,\n");
	printf("        whilst the DCB provided in the navigation message is referred to the B3 measurement.\n");
	printf("       Therefore, when using precise products, it is necessary to add a correction factor instead of applying directly the DCB from the navigation message. The\n");
	printf("        correction factor is computed as follows:\n\n");
	printf("                       Correction_factor = (TGD26*f2^2 - TGD76*f7^2) / (f2^2 - f7^2)\n\n");
	printf("       Where:\n\n");
	printf("           TGD26 -> DCB term (in seconds) provided in D1 or D2 broadcast navigation messages which corrects signal B1 (frequency 2) to B3 (frequency 6)\n");
	printf("           TGD76 -> DCB term (in seconds) provided in D1 or D2 broadcast navigation messages which corrects signal B2b (frequency 7) to B3 (frequency 6)\n");
	printf("           f2 -> frequency (in hertz) of signal B1\n");
	printf("           f7 -> frequency (in hertz) of signal B2b\n\n");
	printf("        Once correction factor has been computed, the DCB to be applied to a single frequency measurement with precise orbits is computed as follows:\n\n");
	printf("                       DCB_to_apply = TGDX6 - Correction_factor\n\n");
	printf("       Where:\n\n");
	printf("           TGDX6 -> DCB term (in seconds) in any navigation message which corrects a signal (from frequency X) to B3 (frequency 6)\n\n");
	printf("        Note that both terms 'Correction_factor' and 'DCB_to_apply' are in seconds, as the TGD applied were in seconds.\n");
	printf("\n  WHY DOES GLAB SOMETIMES REPORT THAT GPS C1P MEASUREMENT IS AVAILABLE (AND MAY ALSO BE USED IN THE FILTER) WHEN THE MEASUREMENT IS NOT IN THE RINEX OBSERVATION FILE?\n\n");
	printf("       Receivers tracking the legacy GPS signals (L1 and L2), can be classified in three different types:\n\n");
	printf("          Type 1: Cross-correlated receiver. This receiver type provides C1C and C2P measurement (but not C1P). To obtain C1P and a consistent C2P measurement,\n");
	printf("                   the P1-C1 DCB (or ISC L1C/A) must be applied to C1C (to obtain C1P) and to C2P (to obtain a consisten C2P measurement).\n\n");
	printf("          Type 2: No P1 (C1P). This receiver provides C1C and C2P, but does not provide C1P. To obtain C1P, the P1-C1 DCB (or ISC L1C/A) must be applied to obtain C1P.\n\n");
	printf("          Type 3: Consistent measurements. This receiver provides C1C, C1P and C2P and no correction is needed.\n\n");
	printf("        When receiver type is unknown, type 3 is assumed (no correction applied). When receiver is set to type 1 or 2 (either with parameter '-pre:setrectype' or\n");
	printf("         by providing a GPS Receiver file with option '-input:rec'), gLAB knows that C1P will never be provided, so internally creates the GPS C1P measurement by\n");
	printf("         copying the values read from C1C (as if C1P had been provided in the RINEX observation file).\n");
	printf("        Later, in the modelling step, the P1-C1 DCB or the ISC L1C/A (in this order of preference) will be applied if they are available. The logic for this\n");
	printf("         behaviour is to allow the user to be able to select between C1C (the provided measurement) and C1P (the resulting measurement of adding C1C plus the DCB).\n");
	printf("\n  WHEN COMPUTING THE NAVIGATION SOLUTION WITH A MOVING RECEIVER, WHY DOES THE POSITIONING ERROR IS VERY HIGH OR KEEPS INCREASING OVER TIME?\n\n");
	printf("       gLAB by default has the a priori receiver set to 'RINEX', which means that it will always use the same a priori position read from the RINEX observation header\n");
	printf("        for both modelling and computing the positioning error. This implicitly means that the receiver is always in the same position (static).\n");
	printf("       To compute the navigation solution with moving receiver, the user will need to set the a priori position to 'calculate'. If the user has a text or SP3 file\n");
	printf("        with the receiver trajectory to compare the solution, it can be provided with parameter '-input:refpos' (this option will automatically set the a priori\n");
	printf("        receiver position to 'calculateRef'.\n");
	printf("       Also, in PPP mode, make sure to select 'kinematic' mode in the filter (in command line, with parameter '-filter:nav kinematic').\n");
	printf("       Last, if after the previous configuration changes the solution is not good enough, the user can disable the prefit outlier detector with\n");
	printf("        option '--filter:prefitouliers:median'.\n");
	printf("\n  WHY THE POSITIONING ERROR COMPONENTS IN THE OUTPUT MESSAGE ARE ZERO WHEN SETTING THE A PRIORI RECEIVER POSITION TO 'CALCULATE'?\n\n");
	printf("       In order to compute the position error, gLAB needs a reference position. By default, gLAB uses the a priori position, but when the\n");
	printf("        user sets the a priori receiver position to 'calculate', the user make gLAB calculate it (that is it can not trust the position of the\n");
	printf("        RINEX observation because it is not good enough or because the receiver is moving). If the receiver is moving and the user has a text or SP3\n");
	printf("        file with the trajectory, the user can provide it to gLAB (with option '-input:refpos') to use a reference position only for computing the positioning error.\n");
	printf("\n  THE NAVIGATION SOLUTION HAS A VERY HIGH ERROR, EITHER FROM THE BEGINNING OR FROM A PARTICULAR EPOCH. HOW CAN I IMPROVE IT?\n\n");
	printf("       If the navigation solution is computed with a moving receiver, check first question 'WHEN COMPUTING THE NAVIGATION SOLUTION WITH A MOVING RECEIVER,\n");
	printf("         WHY DOES THE POSITIONING ERROR IS VERY HIGH OR KEEPS INCREASING OVER TIME?'. Otherwise, try the following steps:\n\n");
	printf("       - Enable minimum SNR filtering (only enabled by default in SBAS and DGNSS modes). By default the threshold is 33 dBHz, but this value can be changed\n");
	printf("          in a per satellite a per measurement basis. For instance, for GPS L2P measurement, which transmits 3dB less power, the threshold could be set to 30dBHz.\n\n");
	printf("       - Enable DOP filters. By default, only GDOP is enabled in PPP and DGNSS modes. For instance, the user can enable GDOP to the default threshold of 30 or reduce it.\n\n");
	printf("       - If only code measurements are used, enable cycle-slip detectors and manually set the corresponding carrier phase measurements to the codes used in the filter (if\n");
	printf("          they are not manually set, gLAB will not automatically select any carrier phase as no carrier phase is used in the filter).\n\n");
	printf("       - Enable the prefit outlier detector with option '-filter:prefitouliers:median 30' (by default is enabled). This should remove most of the incorrect measuremerents\n");
	printf("          (outliers) that degrade the solution. The value '30' is the usual threshold of 30 metres.\n\n");
	printf("\n  CAN THE NAVIGATION SOLUTION BE IMPROVED USING RANDOM WALK?\n\n");
	printf("       Random walk will not necessarily improve the navigation solution, as it will only make a difference if the uncertainty between epochs (Q) is very small\n");
	printf("        (i.e. a receiver moving slowly) and the value Q is well adjusted. In gLAB, it is fixed for the whole processing, but in order to exploit random walk\n");
	printf("        it would be necessary to adjust the Q each epoch according to the previous epoch receiver speed and acceleration plus a margin of error (which gLAB does not perform).\n");
	printf("        Even if this adjusted is performed, it would still not make a difference if the receiver does not move slowly or the Q value is below or at the same level as the error\n"); 
	printf("        in your data. For instance, if your receiver moves one meter between epochs but you are processing in SPP, where meter error measurements are used (i.e. pseudoranges),\n");
	printf("        then there will be no differences as only noise is being correlated between epochs.\n");
	printf("       Note also that random walk will be exactly as a static positioning if Q is set to zero, and equivalent to a kinematic positioning if the Q has a high value. Therefore,\n");
	printf("        it makes no sense to use random walk and use high values of Q. In that case, just use default kinematic processing.\n");
	printf("\n  WHY SOMETIMES THE ELEVATION AND AZIMUTH VALUES SUDDENLY CHANGE TO ZERO?\n\n");
	printf("       This occurs when gLAB discards a satellite for the navigation solution for a reason prior to be able to compute the azimuth and elevation values, which are\n");
	printf("        the following: missing measurements, missing navigation message or missing precise orbits. When any of these cases occur, the elevation and azimuth will\n");
	printf("        be set to zero, as they could not be computed.\n");
	printf("\n  IN SPP or PPP, WHY I AM GETTING OR ERROR OR BIAS AROUND METRE LEVEL WITH CERTAIN SIGNALS OR FREQUENCY COMBINATIONS?\n\n");
	printf("       Broadcast orbits or precise orbits are referred to a reference signal or combination (depends on the constellation). If the measurements used in the filter\n");
	printf("        do not match the reference signal or combination, an error or bias can occur. These errors can be compensated with DCBs, but on the one hand, there not DCBs\n");
	printf("        for all possible combinations, and on the other hand, gLAB (in version 6) cannot read all navigation messages or the SINEX BIAS file.\n");
	printf("       For this case, the user can either use another measurement matching the reference signal or has a DCB available in gLAB, or manually provide the DCB correction\n");
	printf("        through the 'User Added Error' option.\n"); 
	printf("\n  IN STATIC PPP, WHY DOES IT APPEAR A BIAS (SPECIALLY IN THE UP COMPONENT) IN THE SOLUTION WHEN USING GPS L5 OR ANY CONSTELLATION DIFFERENT THAN GPS OR GLONASS?\n\n");
	printf("       Prior to ANTEX file \"igs14_2112.atx\", it did not contain receiver antenna phase centre data for frequency L5 of GPS and for any frequency for Galileo, GEO, BeiDou,\n");
	printf("        QZSS or IRNSS. Users can set these values manually with option '-model:recphasecenter' independently if the ANTEX provides them or not. If the user wants to add\n");
	printf("        the receiver antenna phase centre correction for a iono-free combination, it will have to set the same correction values for the two frequencies used.\n");
	printf("\n  IS THERE ANY DIFFERENCE BETWEEN COMPUTING THE SOLUTION FORWARDS AND BACKWARDS?\n\n");
	printf("       There are a few sections that can make the solution from a same epoch slightly differ if calculated in forward direction or in backwards direction.\n");
	printf("       They are the following:\n\n");
	printf("        - The 'N-consecutive' sample filter: This option is enabled with '-pre:cs:ncon', and is enabled by default. It unselects the first two samples after a data gap.\n");
	printf("            This blind filter is to avoid selecting the first two samples after a data gap, which usually are not good. It also removes satellites which may appear one\n"); 
	printf("            or two epochs with bad measurements and then disappear and then appear again. This errors are common for high rate files (<15 sec), therefore this option\n");
	printf("            will auto-disable if the input observation file has a sampling rate smaller than 15 seconds. The problem is that in backwards mode, it will discard the\n");
	printf("            samples prior to the data gap, not after (as the processing in the opposite direction), therefore the bad samples are processed and the good ones\n");
	printf("            prior to the data gap are discarded.\n\n");
	printf("        - Cycle-slips: For cycle-slip detection, a buffer of samples are filled (and during the time the buffer is filling, the satellite is discarded).\n");
	printf("            In backwards mode, the epochs discarded due to the buffer when a cycle-slip is detected are the ones prior to the cycle-slip, instead of the ones\n");
	printf("            after the cycle-slip. Therefore, the samples that enter in the filter in one direction or the other will not be the same.\n\n");
	printf("        - Satellite eclipse: gLAB discards satellites under eclipse and 30 minutes after the eclipse finished. This is because during an eclipse the satellite\n");
	printf("            may have more problems to orientate itself due to the lack of sun. The error is very slow, so this option can be disabled quite safely. In backwards mode,\n");
    printf("            it does not apply any safe guard time after or before the eclipse. To be consistent, it should also apply the safe guard time after the eclipse, but\n");
	printf("            the fix is very complicated to implement and it would barely make any difference.\n\n");
	printf("        - Satellite wind-up: The wind-up is an accumulative effect which resets in each cycle-slip. To model this value, it is used the previous computed value.\n");
	printf("            When going backwards, it keeps accumulating (including from forward direction, until a cycle-slip occurs), but in the opposite direction.\n");
	printf("\n  IN PPP, WHY NO GLONASS SATELLITES ARE SELECTED BY DEFAULT ON MANY CASES?\n\n");
	printf("       GLONASS signals G1 and G2 use FDMA (Frequency Division Multiple Access), which means that instead of using a different PRN (Pseudo-Random Noise) code for\n");
	printf("        each satellite, it uses a different frequency for each satellite. Each frequency is computed as a central frequency plus a frequency offset. The frequency\n");
	printf("        offset with a frequency factors ('k') that are provided in the navigation message or in the header of RINEX observation files (since version 3.01). As these\n");
	printf("        frequency factors are needed, if they are not in the header of the RINEX observation file, the user must provide them with a GLONASS navigation file, using\n");
	printf("        parameter '-input:navglo'.\n");
	printf("\n  IN PPP, WHY DURING THE LAST 15 MINUTES THERE IS NO SOLUTION?\n\n");
	printf("       Precise products files (SP3 and CLK files), provide data for a single day. For instance, the data rate is 15 minutes, the last sample provided will be at\n");
	printf("        at epoch 23h 45 minutes (this occurs for both SP3 and CLK), therefore the last 15 minutes there is no data for orbit or clock interpolation, as gLAB will not\n");
	printf("        extrapolate orbits and clocks. To fix this, the user must concatenate data for the next day in both orbit and clock files (see question 'HOW TO CONCATENATE FILES?'\n");
	printf("        above for more info on concatenating files).\n");
	printf("\n  IN PPP, IS IT USEFUL TO CONCATENATE PRECISE ORBIT AND CLOCKS FILES WITH PREVIOUS AND NEXT DAY DATA EVEN IF USER PROCESSES A SINGLE DAY?\n\n");
	printf("       Yes, it is highly recommended to concatenate orbit and clock files with the previous and next day, as in order to get the best interpolation results\n");
	printf("        it is needed to have equally distanced samples around the centre, which does not occur at the beginning and at the end of the day when the precise\n");
	printf("        orbit and clocks files only contain data for a single day.\n");
	printf("\n  IN PPP, WHY DOES IT TAKE 7 SAMPLES TO START COMPUTING THE NAVIGATION SOLUTION?\n\n");
	printf("       In PPP, the Melbourne-Wubbena and Geometry Free cycle slip detector need to fill their data buffers before they can check if a cycle-slip occurred.\n");
	printf("        By default, the buffer size is 7 samples, but it can be increased or decreased with parameter '-pre:cs:mw:samples' for Melbourne-Wubbena detector and\n");
	printf("        '-pre:cs:li:samples' for Geometry Free detector.\n");
	printf("\n  IN SPP OR AFTER A DATA GAP (IN ANY MODE) WITH HIGH RATE FILES (<15s), WHY DOES IT TAKE 3 SAMPLES UNTIL THE SATELLITE IS USED AGAIN?\n\n");
	printf("       The N-consecutive (or N-con) data filter will force to discard the next N-1 samples after a data gap (by default N=3), so the satellite is not used again\n");
	printf("        until N consecutive samples are read. This is done because at high rate files, usually the first one or two samples after a data gap are very low quality,\n");
	printf("        adding a considerable error to the navigation solution. There are also cases where a satellite appears one or two samples, then disappears, then reappears again\n");
	printf("        during a short time. When this occurs, the samples are really bad. In these cases, the N-consecutive filter removes all this low quality samples even if there\n");
	printf("        is no cycle-slip detector (as it is by default in SPP). As these cases only occur in high rate files, the N-consecutive will auto disable if the RINEX\n");
	printf("        observation file rate is larger than 15 seconds.\n");
	printf("\n  IN SPP OR PPP, IS IT POSSIBLE TO USE ANY MEASUREMENT OR COMBINATION?\n\n");
	printf("       In SPP or PPP, the user can use multiple measurement types (e.g C2W, C2L, C2S, C5I, C5Q, etc.) or frequency combinations (e.g 12, 15, 25, etc.). gLAB is able to\n");
	printf("        handle any of these combinations and in general they are all valid to compute the navigation solution, but there is a catch: if the measurements used to compute\n");
	printf("        the navigation solution are not the same as the ones used to compute the orbit and clock data used, a bias will appear (e.g. for GPS, for both broadcast and\n");
	printf("        IGS precise products the measurements used are the iono-free combination with frequencies 1,2 and measurements C1W,C2W,L1W,L2W. This DCBs may be provided in the\n");
	printf("        navigation message (for instance the GPS L5I5 ISC) or not. In PPP this DCB can be corrected or else it may be partially or totally integrated into the carrier phase\n");
	printf("        ambiguity (only if the DCB is constant during an arc), as gLAB estimates carrier phase ambiguities as real values.\n");
	printf("\n  IN SBAS MODE, WHY THERE IS NO SOLUTION AT THE BEGINNING AND AT THE END OF FILE?\n\n");
	printf("       SBAS processing requires to use navigation messages with the IODE indicated in the SBAS messages. Usually, the messages used by SBAS at the beginning of the\n");
	printf("        day are stored at the end of the navigation file from previous day, and the messages at the end are stored at the beginning of the navigation file of the\n");
	printf("        next day. Therefore, it is necessary to add to the current day navigation file messages from the last two hours of the previous day and of the first two\n");
	printf("        hours of the previous day.\n");
	printf("        Another option instead of manually adding the two hours of data from previous and the next day is to concatenate the navigation files. In order to work\n");
	printf("        correctly, the concatenation must be done without headers in between. This is because the current version only stores up to two days of data in memory,\n");
	printf("        so when it detects a third header, it will not read any more data until the epoch of the observation day changes. This behaviour may be changed in the\n");
	printf("        future (so as it matches the behaviour with precise orbits and clocks, which store in memory three days at a time).\n");
	printf("       To make sure that reason for not having navigation solution in SBAS is due to the missing navigation messages, execute gLAB with the SBASUNSEL message\n");
	printf("        (enabled in SBAS 1F, with option '-print:sbasunsel') or with SBASDFMCUNSEL message enabled (in SBAS DFMC, with option '-print:sbasdfmcunsel') and the\n");
	printf("        text 'No broadcast block with IOD <iode>' should appear.\n");
	printf("\n  IN SBAS AND DGNSS MODES, WHY IT TAKES 360 SECONDS TO COMPUTE THE FIRST NAVIGATION SOLUTION?\n\n");
	printf("       In SBAS (1F and DFMC), it is compulsory to wait 360 seconds in order for the smoothing to converge.\n");
	printf("       In DGNSS, it is used to wait for the smoothing to converge in the reference station, although there is not any formal requirement for this.\n");
	printf("       It is possible change or disable this waiting time with parameter '-pre:smoothmin'.\n");
	printf("\n  IN SBAS AND DGNSS MODES, WHY THERE IS NO NAVIGATION SOLUTION WHEN PROCESSING WITH 30 SECONDS FILES?\n\n");
	printf("       The default options for SBAS and DGNSS is to use a data gap of 10 seconds. With a 30 seconds file, a data gap will be detected in each epoch, as more\n");
	printf("        than 10 seconds have passed between epoch. To avoid this problem, set the data gap size to 40 seconds in the GUI or with parameter '-pre:cs:datagap 40'.\n");
	printf("       Moreover, the default smoothing is set to 100 epochs with a minimum continuous smoothing time of 360 epochs. With a 1 second file, it is a 100 second smoothing\n");
	printf("        with 360 seconds excluding time, but at slower data rates (like 30 seconds), the time span gets very high and nearly impossible due to the cycle-slips.\n");
	printf("        Therefore, it is necessary to reduce the smoothing and exclusion by the data rate or to completely disable it. The latter recommended, as with very small\n");
	printf("        smoothing times and distance between epochs the smoothing can be even worst that no smoothing at all. To disable smoothing and smoothing exclusion during\n");
	printf("        convergence time, use parameters '-pre:smooth 0' and '-pre:smoothmin 0'. In DGNSS, also provide '-pre:dgnss:smoothmin 0' to disable smoothing exclusion\n");
	printf("        during convergence time in the reference station.\n");
	printf("       Since gLAB v6, when the RINEX observation file has a data rate of 1Hz, the smoothing and smoothing convergence time will be automatically reduced by the data\n");
    printf("        rate of the observation file (e.g. a factor 30 for 30s RINEX observation file) only if user did not set any smoothing option. Furthermore, the data gap will\n");
	printf("        also automatically adapt to the RINEX observation file data rate. Therefore, by default gLAB will autoconfigure to provide a solution. Nevertheless, the current\n");
	printf("        question is written as if gLAB did not autoconfigure as many users had this problem in previous versions.\n");
	printf("       See also question 'IN SBAS OR DGNSS, IS IT EQUIVALENT TO PROCESS WITH A 30 SECOND FILE THAN TO PROCESS AT A 30 SECOND RATE WITH A 1 HZ FILE?'\n");
	printf("\n  IN SBAS OR DGNSS, IS IT EQUIVALENT TO PROCESS WITH A 30 SECOND FILE THAN TO PROCESS AT A 30 SECOND RATE WITH A 1 HZ FILE?\n\n");
	printf("       No, it isn't equivalent. This is a very common error, rather for avoiding to download a 1Hz file or to try to reduce processing time with smaller files.\n");
	printf("       The difference is due to smoothing:\n");
	printf("        - With a 30 second file, you have to either reduce the smoothing epochs to a factor 30 (the file data rate) in order to keep\n");
	printf("           the smoothing time window (if the number of epochs were maintained, there would be noticeable ionospheric divergence in the smoother). Reducing so much the\n");
	printf("           number of samples for the smoothing makes the smoothing be useless or even worst, so it is recommended to completely disable in these cases (see question\n");
	printf("           above 'IN SBAS AND DGNSS MODES, WHY THERE IS NO NAVIGATION SOLUTION WHEN PROCESSING WITH 30 SECONDS FILES?').\n");
	printf("        - With a 1 Hz file, gLAB will compute cycle-slip and smoothing at 1 Hz (or the data file rate) independently of the decimation set by the user. The navigation\n");
	printf("           solution will be computed at 30 second rate (at the user defined decimation), but it will have the same cycle-slips and smoothing as in a 1 Hz decimation.\n");
	printf("\n  WHY IS SOME INFORMATION (SUCH AS ARC NUMBER OR SVN) REPEATED IN SEVERAL MESSAGES?\n\n");
	printf("       In gLAB version <=5.5.1, the criteria was to split info in different messages and repeat as minimum as possible. The problem with this approach is that many cases\n");
	printf("        the user wants to do a quick analysis and needs info splitted in different messages, which is quite annoying to join, even for experienced programmers.\n");
	printf("        Having the info repeated in several messages will make very probably that all the info the user needs is in the message, so parsing is straightforward.\n");
	printf("       This criteria has the side effect that output files get bigger, but if necessary, the user can extract only the fields needed from the gLAB output\n");
	printf("        before saving it to a file, by piping to the 'awk' command. For instance, if a user only wants the seconds of day (field 4), north (field 24)\n");
	printf("        east (field 25) and up (field 26) errors from the OUTPUT message, the following command line would apply (for Linux and Cygwin, in Windows command line\n");
	printf("        the user will have to install the 'awk' command first):\n\n");
	printf("                %s <parameters> | awk '$1==\"OUTPUT\" {print $4,$24,$25,$26}' > outputfile.txt\n",GLABPROGRAMEXECUTABLE);
	printf("\n  WHY DOES THE ARC LENGTH VALUE SOMETIMES DOES NOT INCREASE EVEN IF THERE IS DATA AVAILABLE?\n\n");
	printf("       Arc length can remain unchanged in the following cases:\n\n");
	printf("        - If option 'N-consecutive' ('-pre:cs:ncon') is enabled, the first N-1 samples after a small data gap will be ignored.\n\n");
	printf("        - The Melbourne-Wubbena, Geometry-Free and Iono-Geometry Free cycle-slip detectors have a built-in 'outlier' flag. When any of these detectors detect a cycle-slip,\n");
	printf("           the sample is discarded for the current and future epochs (as if it were a data gap) and thus the arc length does not increase. If in the next sample a\n");
	printf("           cycle-slip is detected again, then a cycle-slip is declared. Otherwise, the arc is maintained (but the outlier sample is discarded).\n");
	printf("           It is possible to disable the outlier detection in each detector independently (with options '-pre:cs:mw:nooutliers', '-pre:cs:li:nooutliers' and\n");
	printf("           '-pre:cs:igf:nooutliers') or to all detectors at once (with option '-pre:cs:nooutliers').\n");
	printf("\n  WHY THE PROGRESS BAR IS DISABLED WHEN THE STANDARD OUTPUT IS PIPED TO ANOTHER COMMAND?\n\n");
	printf("       gLAB can detect if the standard output is redirected to a file or to a pipe. When it is redirected to a pipe, gLAB does not know to which program it is piped.\n");
	printf("        Writing the progress bar could mess with the output of the next program, for instance, 'less' or 'more' programs. Therefore gLAB takes the safe approach\n");
	printf("        to disable the progress bar.\n");
	printf("       Nevertheless, there are many cases where printing the progress bar is perfectly compatible with piped output (as the progress bar is printed in a different\n");
	printf("        channel than the pipe), such as an 'awk' or 'grep' command that later end up writing to a file. For instance, the following command will have no problem\n");
	printf("        or interference with printing the progress bar:\n\n");
	printf("                  %s <parameters> | awk '$1==\"OUTPUT\" {print $4,$24,$25,$26}' > outputfile.txt\n\n",GLABPROGRAMEXECUTABLE);
	printf("        For these cases, there is the option '-print:progressalways' (or in a shorter form, '-print:pa'), which will make gLAB to print the progress bar\n");
	printf("         regardless the standard output redirection. The command will now be:\n\n");
	printf("                  %s <parameters> -print:pa | awk '$1==\"OUTPUT\" {print $4,$24,$25,$26}' > outputfile.txt\n",GLABPROGRAMEXECUTABLE);
	printf("\n  WHY PROCESSING TIME IN MULTI-THREADED gLAB VERSION IS SOMETIMES SLOWER THAN SINGLE THREADED gLAB VERSION?\n\n");
	printf("       There are two reasons:\n");
	printf("          1 - Multi-threading is only used during cycle-slip computation and modelling, as these are the tasks that can be done per satellite in parallel.\n");
	printf("          2 - When using multi-threading, the program has to create multiple threads and synchronize them, which is expensive in processing power. This can\n");
	printf("               be seen when checking the processing time in the summary, where the kernel time is greatly increased with respect to single thread.\n\n");
	printf("         Therefore, it is recommended to use the multi-threaded version only where there a lot of satellites in view or in SBAS maps mode.\n");
	printf("\n  IS IT POSSIBLE TO USE A DIFFERENT ANTEX FOR THE SATELLITES AND THE RECEIVER ANTENNA PHASE CENTER?\n\n");
	printf("       Yes. By default, gLAB will the APC for satellites and receiver from the ANTEX provided with parameter '-input:ant'.\n");
	printf("        In order to use a different ANTEX for the receiver, just provide the parameter '-input:antrec' with the receiver ANTEX file.\n");
	printf("\n  DOES gLAB CARE ABOUT FILENAME FORMAT OR EXTENSIONS?\n\n");
	printf("       No. You can set the input and output names with any filename or extension (or no extension at all). As the user has to set in the parameters\n");
	printf("        what type of data contains each filename (e.g. '-input:nav brdc2000.16n'), gLAB will check that the content of the file matches with the type set in\n");
	printf("        the parameter. As an example, the following command line:\n\n");
	printf("            %s -input:obs vigo1650.19o -input:nav vigo1650.18n\n\n",GLABPROGRAMEXECUTABLE);
	printf("        Will work exactly the same if the filenames are changed to something such as 'foo' and 'foo2', as it can be seen below:\n\n");
	printf("            %s -input:obs foo -input:nav foo2\n",GLABPROGRAMEXECUTABLE);
	printf("\n  WHAT IS GPS RECEIVER TYPES FILES FOR?\n\n");
	printf("       For GPS only, some receivers used cross-correlation techniques to track legacy P1 (C1P) and P2 (C2P) measurements, or they don't print P1 (C1P) measurement\n");
	printf("        in the observation file. For these cases, it is necessary to correct P2 (C2P) measurement or to generate P1 (C1) measurement from C1 (C1C) measurement\n");
	printf("        using the P1-C1 DCB. As from the RINEX observation file it is not possible to know what receiver type is, gLAB will set it to 'unknown' and will assume\n");
	printf("        it is a receiver that does not need any correction. When a GPS Receiver Type file is provided (with parameter '-input:rec'), it will be able to determine\n");
	printf("        what type of receiver is and apply the P1-C1 correction (if P1-C1 DCB file is provided with parameter '-input:dcb').\n");
	printf("\n  IS IT POSSIBLE TO PROCESS ONLY IN BACKWARDS MODE?\n\n");
	printf("       Yes. Just set the start time (with option '-pre:starttime' in command line) to the last epoch in the RINEX observation file.\n");
	printf("\n  IS gLAB VERSION 6+ BACKWARDS COMPATIBLE?\n\n");
	printf("       Yes. gLAB v6+ is fully backwards compatible, both in the input and in the output messages.\n");
	printf("       For the input options, even though option names may have changed (e.g '-input:sbas' to '-input:sbas1f') or arguments formats have changed (e.g. option\n");
	printf("         '-filter:select') and the old format does not appear in the gLAB help, if the user uses the version v5 parameters, gLAB will detect it automatically\n");
	printf("         and correctly parse them. When gLAB detects an v5 parameter or argument, it will apply it only to GPS satellites.\n");
	printf("       For the output messages (which have been noticeably expanded), use option '-print:v5format' for printing output messages with the version 5 format.\n");
	printf("\n  WHAT ARE THE MAIN DIFFERENCES BETWEEN gLAB VERSION 5 ans 6+?\n\n");
	printf("       Some of the default behaviour in gLAB has changed in versíon 6+. They are explained in the table below:\n\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("       |  Behaviour definition  |        gLAB version <=5.5.1       |                gLAB version >=6+               |                Reason                |\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("       | Measurements used      | GPS only, hardcoded to P1,P2,L1,  | Measurement selection is done according to     | Satellites now have multiple         |\n");
	printf("       | for navigation         | L2 (or C1P,C2P,L1P,L2P). C1 (C1C) |  user parameters and available measurements    |  frequencies and multiples signals   |\n");
	printf("       |                        | was used if P1 was not available  |  in the RINEX observation file in a per        |  per frequency, and satellites from  |\n");
	printf("       |                        | in the header of receiver was     |  satellite basis (each satellite may have      |  same constellations may have        |\n");
	printf("       |                        | type 1 or type 2                  |  different measurements)                       |  different signals tracked           |\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("       | Cycle-slip measurement | GPS only, measurements to use in  | Measurements selection for all constellations  | Multi-constellation and              |\n");
	printf("       | selection              | detectors were hardcoded to       |  follow the configuration of the filter.       |  multi-frequency provide a large     |\n");
	printf("       |                        | C1P (or C1C if C1P was missing or |  That is, all carrier phase measurements will  |  amount of different signals and     |\n");
	printf("       |                        | SBAS mode selected) and C2P,      |  be added in each enabled CS (adding multiple  |  possible combinations, therefore    |\n");
	printf("       |                        | independently of the filter       |  iterations if needed). If the filter does     |  CS has to adapt to whatever the     |\n");
	printf("       |                        |                                   |  not have carrier phase measurement selected,  |  filter is using                     |\n");
	printf("       |                        |                                   |  no CS will be run (unless manually set or     |                                      |\n");
	printf("       |                        |                                   |  in showINPUT mode, were configuration will    |                                      |\n");
	printf("       |                        |                                   |  be set as default PPP mode)                   |                                      |\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("       | Measurements modelled  | All measurements were modelled    | Only the measurements used in the filter are   | Save computation time, as multi-     |\n");
	printf("       |                        |                                   |  modelled (with parameter '-model:allfilemeas' |  constellation files can have dozens |\n");
	printf("       |                        |                                   |  the user can force to model all measurements) |  of different measurements           |\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("       | Enabled output prints  | INFO, CS, INPUT, MODEL, EPOCHSAT, | Only INFO, CS, OUTPUT and summary enabled      | Save computation time and disk as    |\n");
	printf("       | in default             | PREFIT, POSTFIT, FILTER, OUTPUT   |                                                |  with multi-constellation the number |\n");
	printf("       | configuration          | messages and summary enabled      |                                                |  of lines to print have multiplied   |\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("       | Satellites printed in  | All satellites (selected or       | Only selected satellites are printed.          | Save computation time and disk as    |\n");
	printf("       | PREFIT output message  | unselected) are printed           | With option '-print:prefit:unsel' it is        |  multi-constellation files have a    |\n");
	printf("       |                        |                                   | possible to print also unselected satellites   |  lot more available satellites       |\n");
	printf("       +------------------------+-----------------------------------+------------------------------------------------+--------------------------------------+\n");
	printf("\n  WHY gLAB DISCARDS A SATELLITE WHEN ANY OF THE MEASUREMENTS IS MISSING?\n\n");
	printf("         For a satellite to be used in the navigation solution, all the measurements selected for the filter and the cycle-slip detector must be available in each epoch.\n");
	printf("         Otherwise, the satellite is unselected. As a user, the first thought normally is \"if a measurement is missing, try to use the remaining ones so the satellite can be still used\".\n");
	printf("         This approach, although theoretically is good, has not been followed due to the following reasons:\n\n");
	printf("           Short version: It will be too complicated to implemented, it would greatly increase processing time and the solution improvement will be, in general, very low (specially in\n");
	printf("               multiconstellation). It would only make sense to implement it in the case there is a complete knowledge of how the receiver works.\n\n");
	printf("           Long version: Discarding a satellite when a measurement is missing allows the following steps:\n");
	printf("                    - Skip cycle-slip detection, modelling and prefit computation for the satellite\n");
	printf("                    - Build measurements lists only once (there are multiple list according to several function needs), instead of every epoch.\n");
	printf("                    - Remove measurement availability checks in each step as it is guaranteed that all measurements are available.\n");
	printf("                    - Add code flow optimizations based on that it is guaranteed that all measurements to be used are available.\n\n");
	printf("             For the reasons listed above, discarding a satellite when a measurement is missing allows the reduction of the processing time.\n\n");
	printf("             In the current implementation it is necessary to check the behaviour in each processing mode:\n\n");
	printf("              SPP: In SPP mode, precision is few metres level or greater, therefore removing one satellite will not make much difference, except if the user has\n");
	printf("                very few satellites available (which will be infrequent when using multi-constellation). Furthermore, in SPP, using more than one\n");
	printf("                measurement per satellite does not improve the navigation solution, as precision is limited due to code multipath and orbit error.\n\n");
	printf("              PPP: In PPP it is necessary to use the ionosphere-free combination, therefore, if one the code or phase measurements is missing,\n");
	printf("                the combination cannot be built. Furthermore, for the carrier phases, it is necessary to detect cycle-slips. If a missing measurement\n");
	printf("                is used only in cycle-slip detection, then cycle-slip detection cannot be done, and it would be a high risk to use carrier phase\n");
	printf("                measurements in the filter without the guarantee of no cycle-slips. Furthermore, there is the estimation of the carrier phase\n");
	printf("                ambiguity, as using satellites whose measurements are not continuously available would make much more difficult to estimate them.\n");
	printf("             SBAS: The SBAS template forces which measurements are to be used. Then, if any of them is not available, the SBAS MOPS forces to unselect to the satellite.\n");
	printf("             DGNSS: As data is used from both the rover and the reference station, if missing any measurement or model component, then\n");
	printf("                the differential correction cannot be computed. Therefore, the satellite needs to be unselected.\n");
	printf("\n  IS IT POSSIBLE TO CHANGE MEASUREMENTS TO PROCESS DURING A RUN?\n\n");
	printf("       It is not possible to change the selected measurements in the filter during a run, but gLAB can be forced to add or discard measurements by adding or removing them\n");
	printf("         in the RINEX observation file using headers with different measurements. Every time an observation RINEX header is found, measurement selection is triggered for all\n");
	printf("         satellites. If a measurement to be used (set by default or by parameter) is available after reading the new header, it is added to the measurements to use (in\n");
	printf("         the case of a carrier phase measurement, a forced cycle-slip will be triggered to ensure that all cycle-slip buffers are filled before using the new measurement).\n");
	printf("         Otherwise, if a measurement that was being used is no longer present in the RINEX observation file, it will be removed from the measurements to use (and not\n");
	printf("         accounted as missing measurement).\n\n");
	printf("       For instance, if a receiver is tracking GPS L1 and L2 only, and at some point it switches to L1 and L5 only, the procedure (for a PPP) is the following:\n");
	printf("          - In the input parameters for the filter, set it to use both GPS iono-free with L1/L2 and L1/L5. For instance (assuming all GPS satellites have L5):\n");
	printf("                        -filter:select G0-PC12 G0-LC12 G0-PC15 G0-LC15\n");
	printf("          - In the first observation header, in the list of measurements, remove all L5 measurements (and also from subsequent epoch data)\n");
	printf("              As L5 measurements are not available, they will be discarded and gLAB will only try to use PC12 and LC12.\n");
	printf("          - Prior to the epoch where the receiver switches to L5, add a header in the observation file. In this header, L5 measurements shall be added and L2\n");
	printf("              measurements have to be removed (and also from subsequent epoch data). In this way, gLAB will discard L2 measurements and only use PC15 and LC15.\n");
	printf("          - Repeat this procedure as many times as necessary (every time available measurements change).\n\n");
	printf("        Some notes;\n");
	printf("          - Order of measurements can change in every header, therefore it only matters if measurements have changed or not.\n");
	printf("          - In the previous example, if the user adds L5 measurements but does not remove L2 measurements, gLAB will then use both combinations (PC12, PC15, LC12, LC15)\n");
	printf("             and if any is missing, the satellite will not be used.\n");
	printf("\n  CAN gLAB PROCESS CARRIER PHASE MEASUREMENTS AS ABSOLUTE (UNAMBIGUOUS) MEASUREMENTS?\n\n");
	printf("       Yes, there is the option '-filter:noambiguities' for this issue. When this option is provided, gLAB assumes that carrier phase measurements are absolute measurements,\n");
	printf("        that is, the ambiguity has been already been added to the carrier phase measurement, either by modifying the RINEX observation file or by adding it as a user defined\n");
	printf("        error with option '-input:usererror'. Setting this option will also disable code jumps detection and carrier phase alignment.\n");
	printf("       When using carrier phase measurements, there is a caveat: the wind-up correction, as this correction is cumulative and needs to be reset every time\n");
	printf("        there is a cycle-slip. If carrier phases are provided as absolute measurements, cycle-slips will not be detected properly. To work around this issue,\n");
	printf("        three possibilities are possible:\n\n");
	printf("          - Use the RINEX observation file without modification and provide the carrier phase ambiguities values as an 'error' to the measurements, using parameter\n");
	printf("             '-input:usererror'. Also, provide the parameter '-pre:usererrorafter', which will make to add the error to the measurements after the preprocessing. In this\n");
	printf("             way, during the cycle-slip detection, it will use the RINEX observation carrier phase measurements (which will allow to correctly detect cycle-slip), but in\n");
	printf("             the modelling and filter the absolute measurements will be used.\n\n");
	printf("          - Use the RINEX observation file without modification and provide the carrier phase ambiguities values and wind-up correction as an 'error' to the measurements,\n");
	printf("             using parameter '-input:usererror'. Both corrections can be added a single error or as multiple errors, as gLAB supports multiple error sources for the same\n");
	printf("             satellite and epoch. When this mode is used, it is necessary to disable wind-up correction with parameter '--model:windup' and to disable all cycle-slip detectors\n");
	printf("             by using the option '-pre:allcsoff'.\n\n");
	printf("          - Provide a RINEX observation file with carrier phase measurements already corrected with the carrier phase ambiguity and the wind-up correction. When this mode is\n");
	printf("             used, it is necessary to disable wind-up correction with parameter '--model:windup' and to disable all cycle-slip detectors by using the option '-pre:allcsoff'.\n\n");
	printf("        As a last comment, the user can retrieve the wind-up correction from the MODEL message (in field 35), when processing in PPP mode with non absolute carrier phase measurements.\n");
	printf("\n  HOW ARE RINEX 2 OBSERVABLE MEASUREMENTS TREATED IN gLAB?\n\n");
	printf("       When reading a RINEX observation file version 2, gLAB converts internally the measurements to the RINEX 3 nomenclature, with the following hardcoded table:\n\n");
    printf("                         GPS | C1 -> C1C | C2 -> C2C | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C1X | C8 -> C8X | C9 -> C9X\n");
    printf("                         GPS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
    printf("                         GPS | L1 -> L1C | L2 -> L2P | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L1X | L8 -> L8X | L9 -> L9X\n");
    printf("                         GPS | D1 -> D1C | D2 -> D2P | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D1X | D8 -> D8X | D9 -> D9X\n");
    printf("                         GPS | S1 -> S1C | S2 -> S2P | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S1X | S8 -> S8X | S9 -> S9X\n\n");
    printf("                     Galileo | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
    printf("                     Galileo | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
    printf("                     Galileo | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
    printf("                     Galileo | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
    printf("                     Galileo | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
    printf("                     GLONASS | C1 -> C1C | C2 -> C2C | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C3X | C8 -> C8X | C9 -> C9X\n");
    printf("                     GLONASS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C3P | P8 -> C8P | P9 -> C9P\n");
    printf("                     GLONASS | L1 -> L1C | L2 -> L2P | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L3X | L8 -> L8X | L9 -> L9X\n");
    printf("                     GLONASS | D1 -> D1C | D2 -> D2P | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D3X | D8 -> D8X | D9 -> D9X\n");
    printf("                     GLONASS | S1 -> S1C | S2 -> S2P | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S3X | S8 -> S8X | S9 -> S9X\n\n");
    printf("                         GEO | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
    printf("                         GEO | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
    printf("                         GEO | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
    printf("                         GEO | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
    printf("                         GEO | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
    printf("                      BeiDou | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
    printf("                      BeiDou | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
    printf("                      BeiDou | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
    printf("                      BeiDou | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
    printf("                      BeiDou | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
    printf("                        QZSS | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5X | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9X\n");
    printf("                        QZSS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
    printf("                        QZSS | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5X | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9X\n");
    printf("                        QZSS | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5X | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9X\n");
    printf("                        QZSS | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5X | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9X\n\n");
    printf("                       IRNSS | C1 -> C1C | C2 -> C2X | C3 -> C3X | C4 -> C4X | C5 -> C5A | C6 -> C6X | C7 -> C7X | C8 -> C8X | C9 -> C9A\n");
    printf("                       IRNSS | P1 -> C1P | P2 -> C2P | P3 -> C3P | P4 -> C4P | P5 -> C5P | P6 -> C6P | P7 -> C7P | P8 -> C8P | P9 -> C9P\n");
    printf("                       IRNSS | L1 -> L1C | L2 -> L2X | L3 -> L3X | L4 -> L4X | L5 -> L5A | L6 -> L6X | L7 -> L7X | L8 -> L8X | L9 -> L9A\n");
    printf("                       IRNSS | D1 -> D1C | D2 -> D2X | D3 -> D3X | D4 -> D4X | D5 -> D5A | D6 -> D6X | D7 -> D7X | D8 -> D8X | D9 -> D9A\n");
    printf("                       IRNSS | S1 -> S1C | S2 -> S2X | S3 -> S3X | S4 -> S4X | S5 -> S5A | S6 -> S6X | S7 -> S7X | S8 -> S8X | S9 -> S9A\n\n");
    printf("                      Note that the equivalent measurement in RINEX 3 does not need to exist for a given constellation, it just has to be\n");
    printf("                        the same measurement type (code, carrier phase, Doppler or SNR) and any attribute supported in RINEX 3.04. Moreover,\n");
    printf("                        the frequency in the RINEX 2 measurement does not have to match the RINEX 3 frequency. This is allowed in order to\n");
    printf("                        support 'teqc' program extended measurements, which for instance, converts frequency 7 to the equivalent L1C signal.\n\n");
    printf("                      Most of the measurements are converted to RINEX 3 with the 'X' attribute. This is due to in RINEX 2 it is not possible\n");
    printf("                        to know with what component of the signal the measurement was tracked.\n");
	printf("\n  WHEN COMPUTING SBAS (1F OR DFMC) MAPS, WHY 99.9%% OR HIGHER AVAILABILITY IS NOT ACHIEVED ANYWHERE, EVEN IN A NOMINAL DAY?\n\n");
	printf("       This is due to there is not enough data in the SBAS message file or in the RINEX navigation file. They should contain the following:\n\n");
	printf("         - SBAS message file: SBAS messages for the full day to be processed plus 15 minutes of messages of the previous day. These messages\n");
	printf("            are necessary to fill the SBAS message data buffer, so when processing starts at epoch 0, all SBAS corrections are available.\n\n");
	printf("         - RINEX Navigation file: It must contain data for the current day plus two hours of data from the previous and following day. This is\n");
	printf("            due to navigation messages used by SBAS at the beginning and the end of day are stored in the navigation files from the previous\n"); 
	printf("            and following day respectively.\n\n");
	printf("       If your file does have the data pointed above, it will be due to in the RINEX navigation file there are still messages missing. You can\n");
	printf("         check it with two methods:\n\n");
	printf("         - Enable the SBASUNSEL message when computing the SBAS map. Messages with the content 'No broadcast block with IOD <IOD> [PA only]'\n");
	printf("            will be printed. The downside is that for each epoch and position in the scanned area several will be printed.\n\n");
	printf("         - Process one station inside the SBAS area with the SBASUNSEL message enabled. when computing the SBAS map.\n\n");
	printf("       For more info on SBAS maps, check SBAS maps help, section 'SBAS Maps Description' in the manual or with parameter '-sbasplotsinfo' in command line.\n");
	printf("\n  WHY ARE GEO SATELLITES (IN ALL MODES) UNSELECTED BY DEFAULT?\n\n");
	printf("       GEO satellites ranging quality are usually not as good as other satellites, Furthermore, the improvement in the DOP is barely noticeable,\n");
	printf("        as most of its improvement is cancelled by the need to compute an inter-system clock bias.\n");
	printf("       The user can enable GEO satellites for navigation by providing parameter '-pre:sat +S0'.\n"); 
	printf("\n  HOW TO OBTAIN MORE INFO ABOUT GNSS POSITIONING?\n\n");
	printf("       For obtaining more information about the algorithms or about GNSS positioning, there are the following sources:\n\n");
	printf("         - GNSS BOOK Vol I and II, freely available at https://gage.upc.edu/en/learning-materials/library/gnss-books/gnss-data-processing-book\n\n");
	printf("         - A complete GNSS course, with theory and practical exercises, freely available at\n");
	printf("              https://gage.upc.edu/en/learning-materials/software-tools/glab-tool-suite-links/glab-tutorials/gnss-tutorials\n\n");
	printf("         - An HTML interactive description to RINEX, ANTEX and SP3 files, with tooltips for each field. Available at\n");
	printf("              https://gage.upc.edu/en/learning-materials/library/gnss-format-descriptions\n\n");
	printf("         - The 'Help' menu in the gLAB GUI, which contains links to download GNSS files, links to file standards, file extension description,\n");
	printf("            date and coordinate converters.\n\n");
	printf("         - The GUI tooltips, which provide complete explanation for each option and its effect on positioning.\n");
	printf("\n  DOES THE GUI HAVE ALL GLAB MODES?\n\n");
	printf("       No, the GUI does not have SBAS PLOTS and SHOW INPUT modes. The former mode is for computing SBAS plots and the latter for converting a RINEX observation\n");
	printf("        file to columnar text format using MEAS message (see question 'CAN MEAS MESSAGE BE USED AS A CONVERTER FROM RINEX OBSERVATION TO A COLUMNAR TEXT FILE?').\n");	
	printf("\n  DOES THE GUI HAVE ALL GLAB COMMAND LINE OPTIONS?\n\n");
	printf("       No, the GUI has most of the command line options, but a few of them are only command line (the most rare). Moreover, options that can be\n");
	printf("       set in a per satellite basis, the GUI only allows to use them in a per constellation basis (to avoid cluttering the GUI).\n");
	printf("       The parameters that are only on command line for positioning mode are the following:\n\n");
	printf("          -autofillscript, -pre:cs:sf:noautofill, -pre:cs:mw:noautofill, -pre:cs:li:noautofill, -pre:cs:igf:noautofill, -pre:cs:noautofill, -pre:allcson,\n");
	printf("           -pre:allcsoff, -pre:meassel:pairedmeas, -pre:meassel:noblocktypeunsel, -pre:intseconds, -model:skipunhealthymarg, -model:skipunhealthy,\n");
	printf("           -model:maxurabrdc, -model:globrdcintstep, -model:allfilemeas, -filter:prefitoutliers:abs, -filter:gloifb, -filter:recwindup,\n");
	printf("           -filter:noambiguities, -filter:snrweight:comb, -filter:sbasdgnssweightmode, -print:meas:snr, -print:meas:doppler, -print:meas:lli,\n");
	printf("           -print:meas:doppler, -print:meas:lli, -print:progressalways, -print:prefit:unsel, -print:pa and -summary:stationnetworkname.\n\n");
	printf("       Additionally, there are these DGNSS options which are not usually necessary as they are set according to the rover automatically:\n\n");
	printf("         -pre:smoothmeasdgnss, -pre:setrectypedgnss, -pre:cs:li:freqdgnss, -pre:cs:li:freqlistdgnss, -pre:cs:li:measdgnss, -pre:cs:li:measlistdgnss,\n");
	printf("          -pre:cs:mw:freqdgnss, -pre:cs:mw:freqlistdgnss, -pre:cs:mw:measdgnss, -pre:cs:mw:measlistdgnss, -pre:cs:sf:freqdgnss, -pre:cs:sf:measdgnss,\n");
	printf("          -pre:cs:igf:freqdgnss, -pre:cs:igf:freqlistdgnss, -pre:cs:igf:measdgnss, -pre:cs:igf:measlistdgnss, -pre:measorderdgnss, -pre:measorderlistdgnss and\n");
	printf("          -pre:meassel:pairedmeasdgnss\n");
	printf("\n  ARE THE SNR OPTIONS ACTUALLY REFERRED TO THE C/N0?\n\n");
	printf("       Yes, as the RINEX observation provides the C/N0 (Carrier-to-Noise density) instead of the SNR (Signal to Noise Ratio), as the C/N0 is the only term\n");
	printf("        that can be directly compared between receivers. This is because the C/N0 is the SNR value divided by the bandwidth used by the receiver. As the\n");
	printf("        bandwidth in each receiver varies, the SNR will vary according to the bandwidth, while the C/N0 will be consistent across all receivers.\n\n");
	printf("       At processing level, there is no difference as the values are used directly without any conversion and the units are correctly set.\n");
	printf("       Due to all the options and tooltips are currently named with the SNR, there is no plan to rename them as there is no practical difference for gLAB use cases.\n");
	printf("\n  IS IT POSSIBLE TO REDUCE RAM USAGE WITHOUT LOSING FUNCTIONALITY?\n\n");
	printf("       Yes, but the user will need to rebuild gLAB core. The selected strategy is to reduce constant sizes in dataHandling.h for different purposes.\n");
	printf("        The following constant changes are SAFE to change, as gLAB checks if read values are over the its internal limits (defined by these constants),\n");
	printf("         and in that case, an error message is shown and gLAB execution terminates.\n");
	printf("          - If user is not using BeiDou, or it knows the maximum PRN value to be read, the following constants can be changed:\n");
	printf("             - Set MAX_SATELLITES_PER_GNSS to the maximum PRN value read plus one (e.g. if maximum PRN value is 36, set constant to 37).\n");
	printf("             - Set MAX_SAT_GAL, MAX_SAT_GEO and MAX_SAT_BDS to the maximum PRN value read (e.g. if maximum PRN value is 36, set constants to 36)\n");
	printf("            Setting the previous constants to 37 and 36 saves about 30MB of RAM.\n\n");
	printf("          - If user knows the total number of different satellites (from all constellations) that the receiver will have in view during the entire processing,\n");
	printf("              then the following constant can be changed:\n");
	printf("             - Set MAX_SATELLITES_VIEWED to the maximum number of satellites viewed plus one (e.g. if maximum number of satellites viewed is 60, set constant to 61).\n");
	printf("            Setting the previous constant to 61 saves about 20MB of RAM.\n\n");
	printf("          - Reducing the maximum number of runs for each of the cycle-slip detectors. Each cycle-slip detector, will run as many times as necessary for checking\n");
	printf("              all carrier phase measurements used in the filter. Typically, only or two runs are needed.\n");
	printf("             - Set MAX_CS_LIST to the number of runs needed (e.g. if only one run is needed, set constant to 1).\n");
	printf("            Setting the previous constant to 1 saves about 40MB of RAM.\n\n");
	printf("          - Reducing the maximum number of measurements to process in the filter per each satellite. Typically, in SPP/SBAS/DGNSS only one measurement is necessary,\n");
	printf("              and in PPP two measurements are necessary.\n");
	printf("             - Set MAX_FILTER_MEASUREMENTS_SAT to the number of measurements needed in the gLAB execution (e.g. if only one measurement is needed, set constant to 1).\n");
	printf("            Setting the previous constant to 1 saves about 20MB of RAM.\n\n");
	printf("       Additionally, if the user will only print any of these messages INFO, INPUT, MEAS, OUTPUT, SBASOUT, SATDIFF, SATSTAT, SATSTATTOT and SATPVT,\n");
	printf("         it is possible to reduce to 1 byte the size of the internal buffers used for storing the not used messages types. This method is not safe, as if the\n");
	printf("         user enables any of the CS, SFCSDATA, MWCSDATA, LICSDATA, IGFCSDATA, MODEL, PREFIT, EPOCHSAT, POSTFIT, FILTER, SBASCORR, SBASVAR, SBASIONO, SBASUNSEL\n");
	printf("         or DGNSS messages, the program will crash or have undefined behaviour.\n");
	printf("         For reducing the internal buffers, set the constants MAX_PRINT_LINE, MAX_PRINT_LINE_MODEL and MAX_PRINT_LINE_FILTER to 1 (do not modify MAX_PRINT_LINE_TEPOCH constant).\n");
	printf("         This saves around 70MB of RAM.\n");

}

/*****************************************************************************
 * Name        : showBashAutoCompleteScript
 * Description : Shows the Bash script for  autocompleting gLAB's option in
 *                Bash terminal
 * Parameters  : None
 *****************************************************************************/
void showBashAutoCompleteScript() {
	printf("#!/bin/bash\n");
	printf("#Author: Deimos Ibanez\n");
	printf("#\n");
	#if defined _OPENMP
		printf("#gLAB version v%s (with OpenMP multithread v%d), built on %s %s\n",VERSION,_OPENMP,__DATE__,__TIME__);
	#else
		printf("#gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
	#endif
	printf("#This bash script is for enabling autofilling of gLAB options when pressing <TAB> key in Bash terminal.\n");
	printf("#In order to make it work, it is necessary to make Bash aware of this autofill script.\n");
	printf("#There are three methods to achieve it:\n");
	printf("#\n");
	printf("#Method 1:\n");
	printf("#\n");
	printf("#Generate this file with gLAB parameter '-autofillscript' and then source the file with bash \"source\" command:\n");
	printf("#\n");
	printf("#          %s -autofillscript > gLAB_autofillscript.sh\n",GLABPROGRAMEXECUTABLE);
	printf("#\n");
	printf("#          source gLAB_autofillscript.sh\n");
	printf("#\n");
	printf("#The disadvantage of this method is that you will need to execute the \"source\" command each time a bash shell is started.\n");
	printf("#Other terminals already running when executing this command will also need to execute the \"source\" command.\n");
	printf("#\n");
	printf("#\n");
	printf("#Method 2:\n");
	printf("#\n");
	printf("#Same as method 1, but adding the \"source\" command to the \"~/.bashrc\" file, so the autofill works automatically\n");
	printf("#when a bash shell is started (only for current user):\n");
	printf("#\n");
	printf("#          %s -autofillscript > gLAB_autofillscript.sh\n",GLABPROGRAMEXECUTABLE);
	printf("#\n");
	printf("#          source gLAB_autofillscript.sh\n");
	printf("#\n");
	printf("#          echo \"source ${PWD}/gLAB_autofillscript.sh\" >> ~/.bashrc\n");
	printf("#\n");
	printf("#Other terminals already running when executing this command will also need to execute the \"source\" command.\n");
	printf("#\n");
	printf("#Method 3:\n");
	printf("#\n");
	printf("#Same as method 1, but moving the script to \"/etc/bash_completion.d\" folder (requires root permission).\n");
	printf("#With this method all users will have gLAB autofill enabled when a bash terminal is started:\n");
	printf("#\n");
	printf("#          %s -autofillscript > gLAB_autofillscript.sh\n",GLABPROGRAMEXECUTABLE);
	printf("#\n");
	printf("#          source gLAB_autofillscript.sh\n");
	printf("#\n");
	printf("#          chmod +x gLAB_autofillscript.sh\n");
	printf("#\n");
	printf("#          sudo mv gLAB_autofillscript.sh /etc/bash_completion.d/\n");
	printf("#\n");
	printf("#Other terminals already running when executing this command will also need to execute the \"source\" command.\n");
	printf("#\n");
	printf("#Note: If the script was generated using the windows version of gLAB, it is necessary to convert the file from\n");
	printf("#Windows end of line format (CRLF) to Linux end of line format (LF). It can be done with the following command:\n");
	printf("#\n");
	printf("#          sed -i 's/\\r//' gLAB_autofillscript.sh\n");
	printf("#\n");
	printf("#Completion script for gLAB:\n\n");
	printf("_glab_completion()\n");
	printf("{\n");
	printf("    local cur prev cmd args\n\n");
	printf("    COMPREPLY=()\n");
	printf("    cur=${COMP_WORDS[COMP_CWORD]}\n");
	printf("    prev=${COMP_WORDS[COMP_CWORD-1]}\n");
	printf("    cmd=${COMP_WORDS[0]}\n\n");
    printf("    if [[ \"${prev}\" == \"-pre\\:setrecpos\" ]]\n");
    printf("    then\n");
    printf("      args='RINEX SINEX SetGeod SetRef \\\n");
    printf("        calculate calculateRef calculateRINEX \\\n");
    printf("        calculateRINEXRef calculateUSER calculateUSERGeod \\\n");
    printf("        calculateUSERRef calculateUSERGeodRef DGNSSbaseline \\\n");
    printf("        DGNSSRinexRover DGNSSRoverUSER DGNSSRoverUSERGeod \\\n");
    printf("        DGNSSRoverUSERRef DGNSSUserRoverRef DGNSSUserGeodRoverRef \\\n");
    printf("        DGNSSUserbaseline DGNSSUserGeodbaseline DGNSSUserRinexRover \\\n");
    printf("        DGNSSUserGeodRinexRover DGNSSRefRoverUSER DGNSSRefGeodRoverUSERGeod \\\n");
    printf("        DGNSSRefCarRoverUSERGeod DGNSSRefGeodRoverUSERCar'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-pre\\:setrectype\" ]]\n");
    printf("    then\n");
    printf("      args='gpsrt 0 1 2 3'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:iono\" ]]\n");
    printf("    then\n");
    printf("      args='no Klobuchar BeiDou IONEX NeQuick SBAS'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:trop\\:nominal\" ]]\n");
    printf("    then\n");
    printf("      args='Simple UNB3'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:trop\\:mapping\" ]]\n");
    printf("    then\n");
    printf("      args='Simple Niell'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:recphasecenter\" ]]\n");
    printf("    then\n");
    printf("      args='no ANTEX'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:arp\" ]]\n");
    printf("    then\n");
    printf("      args='no RINEX'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:gps\\:p1c1\" ]]\n");
    printf("    then\n");
    printf("      args='no strict'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:gps\\:p1p2\" ]] || [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:glo\\:p1p2\" ]]\n");
    printf("    then\n");
    printf("      args='no RINEX DCBFILE IONEX'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" =~ \"-model\\:dcb\\:sf\\:gps\\:isc\"* ]] || [[ \"${prev}\" =~ \"-model\\:dcb\\:sf\\:gps\\:all\"* ]] ||\n");
    printf("      [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:gal\\:\"* ]] || [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:bsa\\:\"* ]] ||\n");
    printf("      [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:qzs\\:\"* ]] || [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:irn\\:\"* ]] ||\n");
    printf("      [[ \"${prev}\" == \"-model\\:dcb\\:df\\:\"* ]]\n");
    printf("    then\n");
    printf("      args='no RINEX'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:gps\\:isc\"* ]] || [[ \"${prev}\" == \"-model\\:dcb\\:sf\\:gps\\:all\"* ]]\n");
    printf("    then\n");
    printf("      args='no RINEX'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:brdc\\:gps\" ]]\n");
    printf("    then\n");
    printf("      args='PreferLNAV PreferCNAV PreferCNAV2 LNAV CNAV CNAV2 AnyCNAV \\\n");
    printf("        LNAVvsCNAV CNAVvsLNAV LNAVvsCNAV2 CNAV2vsLNAV CNAVvsCNAV2 CNAV2vsCNAV'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:brdc\\:gal\" ]]\n");
    printf("    then\n");
    printf("      args='PreferINAV PreferFNAV INAV INAVE1 INAVE5b INAVE1E5b FNAV INAVvsFNAV FNAVvsINAV'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:brdc\\:bds\" ]]\n");
    printf("    then\n");
    printf("      args='PreferD1 PreferD2 PreferCNAV1 PreferCNAV2 D1 D2 CNAV1 CNAV2 \\\n");
    printf("        D1vsD2 D2vsD1 D1vsCNAV1 CNAV1vsD1 D1vsCNAV2 CNAV2vsD1 D2vsCNAV1 CNAV1vsD2 \\\n");
    printf("        D2vsCNAV2 CNAV1vsD2 D2vsCNAV2 CNAV2vsD2 CNAV1vsCNAV2 CNAV2vsCNAV1'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:brdc\\:qzs\" ]]\n");
    printf("    then\n");
    printf("      args='PreferLNAV PreferCNAV PreferCNAV2 LNAV CNAV CNAV2 AnyCNAV \\\n");
    printf("      LNAVvsCNAV CNAVvsLNAV LNAVvsCNAV2 CNAV2vsLNAV CNAVvsCNAV2 CNAV2vsCNAV'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-model\\:sbasmode\" ]]\n");
    printf("    then\n");
    printf("      args='PA NPA'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-filter\\:nav\" ]]\n");
    printf("    then\n");
    printf("      args='static kinematic randomwalk'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-filter\\:meastype\" ]]\n");
    printf("    then\n");
    printf("      args='pseudorange carrierphase'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-filter\\:combtype\" ]]\n");
    printf("    then\n");
    printf("      args='auto singlefreq dualfreq'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-output\\:rinexversion\" ]]\n");
    printf("    then\n");
    printf("      args='2 3'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-output\\:satvel\" ]]\n");
    printf("    then\n");
    printf("      args='inertial ITRF'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${cur}\" == -* ]]\n");
 	printf("    then\n");
	printf("      args='-autofillscript --autofillscript -config \\\n");
	printf("--config -coordconv:cartesian -coordconv:geodetic \\\n");
	printf("-coordconv:spherical -dateconv:calendar -dateconv:doy \\\n");
	printf("-dateconv:gpsweek -dateconv:mjdn -examples \\\n");
	printf("--examples -faq --faq \\\n");
	printf("-filter:backward --filter:backward -filter:clk:randomwalk \\\n");
	printf("--filter:clk:randomwalk -filter:dopplermeas -filter:dopplermeaslist \\\n");
	printf("-filter:dr:randomwalk --filter:dr:randomwalk -filter:elevweight \\\n");
	printf("-filter:elevweightsat -filter:fixedweight -filter:fixedweightsat \\\n");
	printf("-filter:gloifb --filter:gloifb -filter:hdoporpdop \\\n");
	printf("--filter:hdoporpdop -filter:iono --filter:iono \\\n");
	printf("-filter:iscb -filter:iscb:randomwalk --filter:iscb:randomwalk \\\n");
	printf("-filter:maxgdop --filter:maxgdop -filter:maxhdop \\\n");
	printf("--filter:maxhdop -filter:maxpdop --filter:maxpdop \\\n");
	printf("-filter:meas -filter:meastype -filter:combtype -filter:nav \\\n");
	printf("-filter:noambiguities --filter:noambiguities -filter:nochangerefclk \\\n");
	printf("--filter:nochangerefclk -filter:p0:amb -filter:p0:clk \\\n");
	printf("-filter:p0:clk:ns -filter:p0:dr -filter:p0:gloifb \\\n");
	printf("-filter:p0:iscb -filter:p0:iscb:ns -filter:p0:recwindup \\\n");
	printf("-filter:p0:trop -filter:phi:amb -filter:phi:clk \\\n");
	printf("-filter:phi:dr -filter:phi:gloifb -filter:phi:iscb \\\n");
	printf("-filter:phi:recwindup -filter:phi:trop -filter:prefitoutliers:abs \\\n");
	printf("--filter:prefitoutliers:abs -filter:prefitoutliers:median --filter:prefitoutliers:median \\\n");
	printf("-filter:q:amb -filter:q:clk -filter:q:clk:ns \\\n");
	printf("-filter:q:dr -filter:q:gloifb -filter:q:iscb \\\n");
	printf("-filter:q:iscb:ns -filter:q:recwindup -filter:q:trop \\\n");
	printf("-filter:recdcb --filter:recdcb -filter:recwindup \\\n");
	printf("--filter:recwindup -filter:refclkonlyorder -filter:refclkorder \\\n");
	printf("-filter:satdcb --filter:satdcb -filter:sbasdgnssweightmode \\\n");
	printf("-filter:select -filter:selectlist -filter:sigmaiono \\\n");
	printf("--filter:sigmaiono -filter:sinelevweight -filter:sinelevweightsat \\\n");
	printf("-filter:snrelevweight -filter:snrelevweightsat -filter:snrweight \\\n");
	printf("-filter:snrweight:comb -filter:snrweight:combsat -filter:snrweightsat \\\n");
	printf("-filter:stepdetector --filter:stepdetector -filter:stfdesa \\\n");
	printf("--filter:stfdesa -filter:stfdesa:hwir -filter:stfdesa:maxsat \\\n");
	printf("--filter:stfdesa:maxsat -filter:stfdesa:vwir -filter:stfdesa:xmax \\\n");
	printf("-filter:stfdesa:xres -filter:stfdesa:ymax -filter:stfdesa:yres \\\n");
	printf("-filter:stfdesaloi --filter:stfdesaloi -filter:trop \\\n");
	printf("--filter:trop -filter:tropo --filter:tropo \\\n");
	printf("-filter:velocity --filter:velocity -help \\\n");
	printf("--help -input:ant -input:antrec \\\n");
	printf("-input:antsatblock -input:bds -input:bei \\\n");
	printf("-input:cfg -input:clk -input:con \\\n");
	printf("-input:dcb -input:dgnss -input:fpp \\\n");
	printf("-input:inx -input:klb -input:nav \\\n");
	printf("-input:navglo -input:navhealth -input:neq \\\n");
	printf("-input:obs -input:orb -input:rec \\\n");
	printf("-input:refpos -input:rtcm -input:rtcm:initdate \\\n");
	printf("-input:rtcm:inithour -input:rtcm2 -input:rtcm3 \\\n");
	printf("-input:sbas -input:sbas1f -input:sbasdfmc \\\n");
	printf("-input:sbasiono -input:sigmpath -input:snx \\\n");
	printf("-input:sp3 -input:usererror -messages \\\n");
	printf("--messages -messagesv5 --messagesv5 \\\n");
	printf("-model:alarmmsgtype2 --model:alarmmsgtype2 -model:allfilemeas \\\n");
	printf("--model:allfilemeas -model:allowmarginal --model:allowmarginal \\\n");
	printf("-model:arp --model:arp -model:brdc:bds \\\n");
	printf("-model:brdc:gal -model:brdc:glo -model:brdc:gps \\\n");
	printf("-model:brdc:qzss -model:brdctranstime --model:brdctranstime \\\n");
	printf("-model:clk:deg -model:clkmaxgaps --model:clkmaxgaps \\\n");
	printf("-model:clkprevsample --model:clkprevsample -model:clktotmaxgaps \\\n");
	printf("--model:clktotmaxgaps -model:clock:deg --model:dcb:df:all \\\n");
	printf("-model:dcb:df:bds --model:dcb:df:bds -model:dcb:df:gps \\\n");
	printf("--model:dcb:df:gps -model:dcb:df:qzs -model:dcb:df:qzss --model:dcb:df:qzs --model:dcb:df:qzss \\\n");
	printf("-model:dcb:p1c1 --model:dcb:p1c1 -model:dcb:p1p2 \\\n");
	printf("--model:dcb:p1p2 --model:dcb:sf:all -model:dcb:sf:bds:all \\\n");
	printf("--model:dcb:sf:bds:all -model:dcb:sf:bds:b1b6 --model:dcb:sf:bds:b1b6 \\\n");
	printf("-model:dcb:sf:bds:b2b6 --model:dcb:sf:bds:b2b6 -model:dcb:sf:bds:b5b6 \\\n");
	printf("--model:dcb:sf:bds:b5b6 -model:dcb:sf:bds:b7b6 --model:dcb:sf:bds:b7b6 \\\n");
	printf("-model:dcb:sf:bds:isc:all --model:dcb:sf:bds:isc:all -model:dcb:sf:bds:isc:b1cd \\\n");
	printf("--model:dcb:sf:bds:isc:b1cd -model:dcb:sf:bds:isc:b2ad --model:dcb:sf:bds:isc:b2ad \\\n");
	printf("-model:dcb:sf:bds:sp3 --model:dcb:sf:bds:sp3 -model:dcb:sf:gal:all \\\n");
	printf("--model:dcb:sf:gal:all -model:dcb:sf:gal:e1e5a --model:dcb:sf:gal:e1e5a \\\n");
	printf("-model:dcb:sf:gal:e1e5b --model:dcb:sf:gal:e1e5b -model:dcb:sf:glo:all \\\n");
	printf("--model:dcb:sf:glo:all -model:dcb:sf:glo:p1p2 --model:dcb:sf:glo:p1p2 \\\n");
	printf("-model:dcb:sf:gps:all --model:dcb:sf:gps:all -model:dcb:sf:gps:isc:all \\\n");
	printf("--model:dcb:sf:gps:isc:all -model:dcb:sf:gps:isc:l1ca --model:dcb:sf:gps:isc:l1ca \\\n");
	printf("-model:dcb:sf:gps:isc:l1cd --model:dcb:sf:gps:isc:l1cd -model:dcb:sf:gps:isc:l1cp \\\n");
	printf("--model:dcb:sf:gps:isc:l1cp -model:dcb:sf:gps:isc:l2c --model:dcb:sf:gps:isc:l2c \\\n");
	printf("-model:dcb:sf:gps:isc:l5i5 --model:dcb:sf:gps:isc:l5i5 -model:dcb:sf:gps:isc:l5q5 \\\n");
	printf("--model:dcb:sf:gps:isc:l5q5 -model:dcb:sf:gps:p1c1 --model:dcb:sf:gps:p1c1 \\\n");
	printf("-model:dcb:sf:gps:p1p2 --model:dcb:sf:gps:p1p2 -model:dcb:sf:irn:all \\\n");
	printf("--model:dcb:sf:irn:all -model:dcb:sf:irn:c9c5 --model:dcb:sf:irn:c9c5 \\\n");
	printf("--model:dcb:sf:isc:all -model:dcb:sf:qzs:all --model:dcb:sf:qzs:all \\\n");
	printf("-model:dcb:sf:qzs:c1c --model:dcb:sf:qzs:c1c -model:dcb:sf:qzs:isc:all \\\n");
	printf("--model:dcb:sf:qzs:isc:all -model:dcb:sf:qzs:isc:l1cd --model:dcb:sf:qzs:isc:l1cd \\\n");
	printf("-model:dcb:sf:qzs:isc:l1cp --model:dcb:sf:qzs:isc:l1cp -model:dcb:sf:qzs:isc:l2c \\\n");
	printf("--model:dcb:sf:qzs:isc:l2c -model:dcb:sf:qzs:isc:l5i5 --model:dcb:sf:qzs:isc:l5i5 \\\n");
	printf("-model:dcb:sf:qzs:isc:l5q5 --model:dcb:sf:qzs:isc:l5q5 -model:dgnss:maxage \\\n");
	printf("-model:dgnss:maxcorrval -model:dgnss:measprc -model:dgnss:measprclist \\\n");
	printf("-model:dgnss:sigmainflation --model:dgnss:sigmainflation -model:earthrotinflight \\\n");
	printf("--model:earthrotinflight -model:geoacqtime -model:geoadqtime \\\n");
	printf("-model:geofallback --model:geofallback -model:geoswitch \\\n");
	printf("--model:geoswitch -model:globrdcintstep -model:ignoretype0 \\\n");
	printf("--model:ignoretype0 -model:initcoordnpa --model:initcoordnpa \\\n");
	printf("-model:iono --model:iono -model:ionorms \\\n");
	printf("-model:khnpa -model:khpa -model:kvnpa \\\n");
	printf("-model:kvpa -model:maintaingeo --model:maintaingeo \\\n");
	printf("-model:maxurabrdc --model:maxurabrdc -model:mixedgeo \\\n");
	printf("--model:mixedgeo -model:nodeltaudre --model:nodeltaudre \\\n");
	printf("-model:noenroutesigma --model:noenroutesigma -model:nofastcor \\\n");
	printf("--model:nofastcor -model:nofastdeg --model:nofastdeg \\\n");
	printf("-model:nofastsigma --model:nofastsigma -model:noionocor \\\n");
	printf("--model:noionocor -model:noionosigma --model:noionosigma \\\n");
	printf("-model:nomt10 --model:nomt10 -model:nomt2728 \\\n");
	printf("--model:nomt2728 -model:norrccor --model:norrccor \\\n");
	printf("-model:norrcsigma --model:norrcsigma -model:noslowcor \\\n");
	printf("--model:noslowcor -model:noslowsigma --model:noslowsigma \\\n");
	printf("-model:notroposigma --model:notroposigma -model:orb:deg \\\n");
	printf("-model:orbit:deg -model:orbmaxgaps --model:orbmaxgaps \\\n");
	printf("-model:orbprevsample --model:orbprevsample -model:orbtotmaxgaps \\\n");
	printf("--model:orbtotmaxgaps -model:radomestrict --model:radomestrict \\\n");
	printf("-model:recphasecenter --model:recphasecenter -model:recphasevar \\\n");
	printf("--model:recphasevar -model:relclock --model:relclock \\\n");
	printf("-model:relpath --model:relpath -model:satclocks \\\n");
	printf("--model:satclocks -model:satellitehealth --model:satellitehealth \\\n");
	printf("-model:sathealth --model:sathealth -model:satmovinflight \\\n");
	printf("--model:satmovinflight -model:satphasecenter --model:satphasecenter \\\n");
	printf("-model:satphasevar --model:satphasevar -model:sbasdfmc:anymeas \\\n");
	printf("--model:sbasdfmc:anymeas -model:sbasdfmc:austestbed --model:sbasdfmc:austestbed \\\n");
	printf("-model:sbasdfmc:ccorr -model:sbasdfmc:ccovariance -model:sbasdfmc:cer \\\n");
	printf("-model:sbasdfmc:deltadfre -model:sbasdfmc:deltarcorr -model:sbasdfmc:dfrei \\\n");
	printf("-model:sbasdfmc:dfreilist -model:sbasdfmc:icorr -model:sbasdfmc:mt37v04 \\\n");
	printf("--model:sbasdfmc:mt37v04 -model:sbasdfmc:mt3940v04 --model:sbasdfmc:mt3940v04 \\\n");
	printf("-model:sbasdfmc:mt42v07 --model:sbasdfmc:mt42v07 -model:sbasdfmc:mt47v04 \\\n");
	printf("--model:sbasdfmc:mt47v04 -model:sbasdfmc:rcorr -model:sbasdfmc:sigmatropo \\\n");
	printf("-model:sbasdfmc:sigmauire -model:sbasdfmc:sigmpathfactor -model:sbasmaritime \\\n");
	printf("-model:sbasmode -model:sbasmodeswitch --model:sbasmodeswitch \\\n");
	printf("-model:sbasreceiver -model:sbassignalflighttime -model:sbastmout \\\n");
	printf("-model:sbastmoutfc -model:sbastmoutfcnpa -model:sbastmoutfcpa \\\n");
	printf("-model:sbastmoutnpa -model:sbastmoutpa -model:sbastmoutrrc \\\n");
	printf("-model:sbastmoutrrcnpa -model:sbastmoutrrcpa -model:selectbestgeo \\\n");
	printf("--model:selectbestgeo -model:sigdiv -model:sigfltnomt10offset \\\n");
	printf("-model:sigmpath -model:signoise -model:skipunhealthy \\\n");
	printf("--model:skipunhealthy -model:skipunhealthymarg --model:skipunhealthymarg \\\n");
	printf("-model:solidtides --model:solidtides -model:strictradome \\\n");
	printf("--model:strictradome -model:switchtime -model:trop \\\n");
	printf("--model:trop -model:trop:mapping -model:trop:nominal \\\n");
	printf("-model:tropo --model:tropo -model:udreithreshold \\\n");
	printf("--model:udreithreshold -model:usealarmmsgcorr --model:usealarmmsgcorr \\\n");
	printf("-model:windup --model:windup -numthreads \\\n");
	printf("-onlyconvert -output:antenna -output:corrections \\\n");
	printf("-output:ems -output:file --output:file \\\n");
	printf("-output:kml -output:kml:egm96geoid --output:kml:egm96geoid \\\n");
	printf("-output:kml:refsta --output:kml:refsta -output:kml:tstamp \\\n");
	printf("--output:kml:tstamp -output:kml:tstampdec -output:kml:tstamprange \\\n");
	printf("-output:kml0 -output:pegasus -output:pegfilealign \\\n");
	printf("-output:pegspace -output:pegstrictrinex -output:refpos \\\n");
	printf("-output:refpos:caltime -output:refpos:dgnssonly --output:refpos:dgnssonly \\\n");
	printf("-output:refpos:doy -output:refpos:geodetic --output:refpos:geodetic \\\n");
	printf("-output:refpos:gpsweek -output:rinex -output:rinexb \\\n");
	printf("-output:rinexversion -output:satvel -output:sbasavailplots \\\n");
	printf("-output:sbascombdopplots -output:sbasdir -output:sbasgdopplots \\\n");
	printf("-output:sbashdopplots -output:sbasionoplots -output:sbaspdopplots \\\n");
	printf("-output:sbasriskdisc -output:sbasriskmarplots -output:sbasriskplots \\\n");
	printf("-output:sp3 -output:sp3:dgnssonly --output:sp3:dgnssonly \\\n");
	printf("-output:sp3:letter -output:sp3:prn -output:stfdesa \\\n");
	printf("-output:stfdesaloi -pre:allcsoff --pre:allcsoff \\\n");
	printf("-pre:allcson --pre:allcson -pre:availf \\\n");
	printf("-pre:checkcodejumps --pre:checkcodejumps -pre:cs:bw \\\n");
	printf("--pre:cs:bw -pre:cs:bw:kfactor -pre:cs:bw:max \\\n");
	printf("-pre:cs:bw:min -pre:cs:bw:samples -pre:cs:bw:siginit \\\n");
	printf("-pre:cs:bw:sigmin -pre:cs:bw:slope -pre:cs:bw:timewindow \\\n");
	printf("-pre:cs:datagap -pre:cs:igf --pre:cs:igf \\\n");
	printf("-pre:cs:igf:allowcodes --pre:cs:igf:allowcodes -pre:cs:igf:freq \\\n");
	printf("-pre:cs:igf:freqdgnss -pre:cs:igf:freqlist -pre:cs:igf:freqlistdgnss \\\n");
	printf("-pre:cs:igf:max -pre:cs:igf:maxjump -pre:cs:igf:meas \\\n");
	printf("-pre:cs:igf:measdgnss -pre:cs:igf:measlist -pre:cs:igf:measlistdgnss \\\n");
	printf("-pre:cs:igf:minnoise --pre:cs:igf:minnoise -pre:cs:igf:noautofill \\\n");
	printf("--pre:cs:igf:noautofill -pre:cs:igf:nooutliers --pre:cs:igf:nooutliers \\\n");
	printf("-pre:cs:igf:samples -pre:cs:igf:t0 -pre:cs:l1c1 \\\n");
	printf("--pre:cs:l1c1 -pre:cs:l1c1:init -pre:cs:l1c1:kfactor \\\n");
	printf("-pre:cs:l1c1:max -pre:cs:l1c1:samples -pre:cs:l1c1:slope \\\n");
	printf("-pre:cs:l1c1:timewindow -pre:cs:l1c1:unconcheck --pre:cs:l1c1:unconcheck \\\n");
	printf("-pre:cs:l1c1:unconcheck:th -pre:cs:l1c1:window -pre:cs:li \\\n");
	printf("--pre:cs:li -pre:cs:li:freq -pre:cs:li:freqdgnss \\\n");
	printf("-pre:cs:li:freqlist -pre:cs:li:freqlistdgnss -pre:cs:li:max \\\n");
	printf("-pre:cs:li:maxjump -pre:cs:li:meas -pre:cs:li:measdgnss \\\n");
	printf("-pre:cs:li:measlist -pre:cs:li:measlistdgnss -pre:cs:li:min \\\n");
	printf("-pre:cs:li:noautofill --pre:cs:li:noautofill -pre:cs:li:nooutliers \\\n");
	printf("--pre:cs:li:nooutliers -pre:cs:li:samples -pre:cs:li:t0 \\\n");
	printf("-pre:cs:lli --pre:cs:lli -pre:cs:mw \\\n");
	printf("--pre:cs:mw -pre:cs:mw:freq -pre:cs:mw:freqdgnss \\\n");
	printf("-pre:cs:mw:freqlist -pre:cs:mw:freqlistdgnss -pre:cs:mw:kfactor \\\n");
	printf("-pre:cs:mw:meas -pre:cs:mw:measdgnss -pre:cs:mw:measlist \\\n");
	printf("-pre:cs:mw:measlistdgnss -pre:cs:mw:noautofill --pre:cs:mw:noautofill \\\n");
	printf("-pre:cs:mw:nooutliers --pre:cs:mw:nooutliers -pre:cs:mw:samples \\\n");
	printf("-pre:cs:mw:siginit -pre:cs:mw:sigmin -pre:cs:mw:timewindow \\\n");
	printf("-pre:cs:ncon --pre:cs:ncon -pre:cs:ncon:min \\\n");
	printf("-pre:cs:noautofill --pre:cs:noautofill -pre:cs:nooutliers \\\n");
	printf("--pre:cs:nooutliers -pre:cs:sf --pre:cs:sf \\\n");
	printf("-pre:cs:sf:freq -pre:cs:sf:freqdgnss -pre:cs:sf:freqlist \\\n");
	printf("-pre:cs:sf:freqlistdgnss -pre:cs:sf:init -pre:cs:sf:kfactor \\\n");
	printf("-pre:cs:sf:meas -pre:cs:sf:measdgnss -pre:cs:sf:measlist \\\n");
	printf("-pre:cs:sf:measlistdgnss -pre:cs:sf:noautofill --pre:cs:sf:noautofill \\\n");
	printf("-pre:cs:sf:samples -pre:cs:sf:timewindow -pre:cs:sf:unconcheck \\\n");
	printf("--pre:cs:sf:unconcheck -pre:cs:sf:unconcheck:th -pre:dec \\\n");
	printf("-pre:dgnss:excludesmoothingconvergenceref --pre:dgnss:excludesmoothingconvergenceref -pre:dgnss:excludesmoothingconvergenceuser \\\n");
	printf("--pre:dgnss:excludesmoothingconvergenceuser -pre:dgnss:smoothmin -pre:eclipse \\\n");
	printf("--pre:eclipse -pre:elevation -pre:endtime \\\n");
	printf("-pre:freqorder -pre:geoexclude -pre:geosel \\\n");
	printf("-pre:intseconds --pre:intseconds -pre:maxsnr \\\n");
	printf("--pre:maxsnr -pre:maxsnrsel -pre:measorder \\\n");
	printf("-pre:measorderdgnss -pre:measorderlist -pre:measorderlistdgnss \\\n");
	printf("-pre:meassel:noblocktypeunsel --pre:meassel:noblocktypeunsel -pre:meassel:pairedmeas \\\n");
	printf("--pre:meassel:pairedmeas -pre:meassel:pairedmeasdgnss --pre:meassel:pairedmeasdgnss \\\n");
	printf("-pre:minsnr --pre:minsnr -pre:minsnrsel \\\n");
	printf("-pre:prealign --pre:prealign -pre:refpos:deg \\\n");
	printf("-pre:sat -pre:setrecpos -pre:setrectype \\\n");
	printf("-pre:setrectypedgnss -pre:smooth --pre:smooth \\\n");
	printf("-pre:smoothauto --pre:smoothauto -pre:smoothmeas \\\n");
	printf("-pre:smoothmeasdgnss -pre:smoothmin -pre:snr \\\n");
	printf("--pre:snr -pre:snrsel -pre:starttime \\\n");
	printf("-pre:usererrorafter --pre:usererrorafter -print:all \\\n");
	printf("-print:allcsdata --print:allcsdata -print:clkns \\\n");
	printf("--print:clkns -print:cs --print:cs \\\n");
	printf("-print:cycleslips --print:cycleslips -print:dgnss \\\n");
	printf("--print:dgnss -print:dgnssunused --print:dgnssunused \\\n");
	printf("-print:epochsat --print:epochsat -print:filter \\\n");
	printf("--print:filter -print:guiprogress -print:igfcsdata \\\n");
	printf("--print:igfcsdata -print:info --print:info \\\n");
	printf("-print:input --print:input -print:licsdata \\\n");
	printf("--print:licsdata -print:meas --print:meas \\\n");
	printf("-print:meas:doppler --print:meas:doppler -print:meas:lli \\\n");
	printf("--print:meas:lli -print:meas:select -print:meas:selectlist \\\n");
	printf("-print:meas:snr --print:meas:snr -print:model \\\n");
	printf("--print:model -print:mwcsdata --print:mwcsdata \\\n");
	printf("-print:none --print:none -print:output \\\n");
	printf("--print:output -print:pa --print:pa \\\n");
	printf("-print:postfit --print:postfit -print:prefit \\\n");
	printf("--print:prefit -print:prefit:unsel --print:prefit:unsel \\\n");
	printf("-print:progress --print:progress -print:progressalways \\\n");
	printf("--print:progressalways -print:sat --print:sat \\\n");
	printf("-print:satdiff --print:satdiff -print:satellites \\\n");
	printf("--print:satellites -print:satpvt --print:satpvt \\\n");
	printf("-print:satsel --print:satsel -print:satstat \\\n");
	printf("--print:satstat -print:satstattot --print:satstattot \\\n");
	printf("-print:sbascor --print:sbascor -print:sbascorr \\\n");
	printf("--print:sbascorr -print:sbasdfmccor --print:sbasdfmccor \\\n");
	printf("-print:sbasdfmccorr --print:sbasdfmccorr -print:sbasdfmcunsel \\\n");
	printf("--print:sbasdfmcunsel -print:sbasdfmcvar --print:sbasdfmcvar \\\n");
	printf("-print:sbasiono --print:sbasiono -print:sbasout \\\n");
	printf("--print:sbasout -print:sbasunsel --print:sbasunsel \\\n");
	printf("-print:sbasunused --print:sbasunused -print:sbasvar \\\n");
	printf("--print:sbasvar -print:sfcsdata --print:sfcsdata \\\n");
	printf("-print:summary --print:summary -print:sumonly \\\n");
	printf("-print:usererror --print:usererror -print:v5format \\\n");
	printf("--print:v5format -referenceposfile --referenceposfile \\\n");
	printf("-rtcmv2conversioninfo --rtcmv2conversioninfo -sbasmapsinfo \\\n");
	printf("--sbasmapsinfo -sbasplots:availstep -sbasplots:availtimestep \\\n");
	printf("-sbasplots:combdopplot --sbasplots:combdopplot -sbasplots:doppercentile \\\n");
	printf("--sbasplots:doppercentile -sbasplots:exclusionarea -sbasplots:gdopplot \\\n");
	printf("--sbasplots:gdopplot -sbasplots:hal -sbasplots:hdopplot \\\n");
	printf("--sbasplots:hdopplot -sbasplots:hourlymaps --sbasplots:hourlymaps \\\n");
	printf("-sbasplots:inclusionarea -sbasplots:ionostep -sbasplots:ionotimestep \\\n");
	printf("-sbasplots:maxlat -sbasplots:maxlon -sbasplots:mingeoelev \\\n");
	printf("--sbasplots:mingeoelev -sbasplots:minlat -sbasplots:minlon \\\n");
	printf("-sbasplots:noavailplot --sbasplots:noavailplot --sbasplots:noionomodel \\\n");
	printf("-sbasplots:noionoplot --sbasplots:noionoplot -sbasplots:noriskmarplot \\\n");
	printf("--sbasplots:noriskmarplot -sbasplots:noriskplot --sbasplots:noriskplot \\\n");
	printf("-sbasplots:pdopplot --sbasplots:pdopplot -sbasplots:percentile \\\n");
	printf("-sbasplots:plotarea -sbasplots:recheight -sbasplots:usegeosat \\\n");
	printf("--sbasplots:usegeosat -sbasplots:val -sbasplots:windowsize \\\n");
	printf("-sbasplots:windowsizemar -sbasplotsinfo --sbasplotsinfo \\\n");
	printf("-sbassummary:hal -sbassummary:percentile -sbassummary:starttime \\\n");
	printf("-sbassummary:stationnetworkname -sbassummary:val -sbassummary:waitfordaystart \\\n");
	printf("--sbassummary:waitfordaystart -sbassummary:windowsize -sbassummary:windowsizemar \\\n");
	printf("-showfaq --showfaq -sigmamultipathfile \\\n");
	printf("--sigmamultipathfile -summary:error3d -summary:errorhor \\\n");
	printf("-summary:errorhv3d -summary:errorperiod3d -summary:errorperiodhor \\\n");
	printf("-summary:errorperiodhv3d -summary:errorperiodver -summary:errorver \\\n");
	printf("-summary:formalerror3d -summary:formalerrorhor -summary:formalerrorperiod3d \\\n");
	printf("-summary:formalerrorperiodhor -summary:formalerrorperiodver -summary:formalerrorver \\\n");
	printf("-summary:hal -summary:percentile -summary:poserror3d \\\n");
	printf("-summary:poserrorhor -summary:poserrorperiod3d -summary:poserrorperiodhor \\\n");
	printf("-summary:poserrorperiodver -summary:poserrorver -summary:starttime \\\n");
	printf("-summary:stationnetworkname -summary:val -summary:waitfordaystart \\\n");
	printf("--summary:waitfordaystart -summary:windowsize -summary:windowsizemar \\\n");
	printf("-usererrorfile --usererrorfile \\\n");
	printf("'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    else\n");
    printf("      comptopt -o filenames 2>/dev/null\n");
    printf("      COMPREPLY=( $(compgen -o filenames -o plusdirs -f -- ${cur}) )\n");
    printf("    fi\n");
    printf("}\n\n");
	printf("#Completion script for graph (plotting tool):\n\n");
	printf("_graph_completion()\n");
	printf("{\n");
	printf("    local cur prev cmd args\n\n");
	printf("    COMPREPLY=()\n");
	printf("    cur=${COMP_WORDS[COMP_CWORD]}\n");
	printf("    prev=${COMP_WORDS[COMP_CWORD-1]}\n");
	printf("    prev2=${COMP_WORDS[COMP_CWORD-2]}\n");
	printf("    cmd=${COMP_WORDS[0]}\n\n");
    printf("    if [[ \"${prev}\" == \"--lp\" ]] || [[ \"${prev}\" == \"--labelpos\" ]] || [[ \"${prev}\" == \"--labelPos\" ]]\n");
    printf("    then\n");
    printf("      args='tl tc tr bl bc br cl c cr'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"-s\" ]] || [[ \"${prev}\" == \"--style\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--stanetdefaultmarkertype\" ]] || [[ \"${prev}\" == \"--staNetDefaultMarkerType\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--stanetmarkertype\" ]] || [[ \"${prev}\" == \"--staNetworkMarkerType\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinetype\" ]] || [[ \"${prev}\" == \"--FIRLineType\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinetypeeu\" ]] || [[ \"${prev}\" == \"--FIRLineTypeEu\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinetypeconus\" ]] || [[ \"${prev}\" == \"--FIRLineTypeCONUS\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinetypealaska\" ]] || [[ \"${prev}\" == \"--FIRLineTypeAlaska\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinetypecanada\" ]] || [[ \"${prev}\" == \"--FIRLineTypeCanada\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinetypemexico\" ]] || [[ \"${prev}\" == \"--FIRLineTypeMexico\" ]]\n");
    printf("    then\n");
    printf("      args=\"\\'.\\' - -- -. .- \\':\\' , o s p + x \\'^\\' \\'>\\' \\'<\\' v \\'*\\' h H D d \\'|\\' _ 1 2 3 4 \"\n");
    printf("      COMPREPLY=( $( compgen -o nosort -W \"${args}\" -- $cur ) )\n");
    printf("    elif [[ \"${prev}\" == \"--color\" ]] || [[ \"${prev}\" == \"--cl\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--continentColor\" ]] || [[ \"${prev}\" == \"--cc\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--lakeColor\" ]] || [[ \"${prev}\" == \"--lc\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--boundaryColor\" ]] || [[ \"${prev}\" == \"--bc\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--stanetdefaultmarkercolor\" ]] || [[ \"${prev}\" == \"--staNetDefaultMarkerColor\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--stanetmarkercolor\" ]] || [[ \"${prev}\" == \"--staNetworkMarkerColor\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--stanetnamecolor\" ]] || [[ \"${prev}\" == \"--staNetNameColor\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--notavailbincolor\" ]] || [[ \"${prev}\" == \"--NotAvailBinColor\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinecolor\" ]] || [[ \"${prev}\" == \"--FIRLineColor\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinecoloreu\" ]] || [[ \"${prev}\" == \"--FIRLineColorEu\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinecolorconus\" ]] || [[ \"${prev}\" == \"--FIRLineColorCONUS\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinecoloralaska\" ]] || [[ \"${prev}\" == \"--FIRLineColorAlaska\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinecolorcanada\" ]] || [[ \"${prev}\" == \"--FIRLineColorCanada\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--firlinecolormexico\" ]] || [[ \"${prev}\" == \"--FIRLineColorMexico\" ]]\n");
    printf("    then\n");
    printf("      args='b g r c m y k w blue green red cyan magenta yellow black black'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${prev}\" == \"-g\" ]] || [[ \"${prev}\" == \"--grid\" ]]\n");
 	printf("    then\n");
    printf("      args='on off no'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${prev}\" == \"--projection\" ]] || [[ \"${prev}\" == \"--pj\" ]]\n");
 	printf("    then\n");
    printf("      args='lcc lambert'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${prev}\" == \"--mapres\" ]] || [[ \"${prev}\" == \"--MapResolution\" ]]\n");
 	printf("    then\n");
    printf("      args='c l i h f'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${prev}\" == \"--stanetdefaultnamealign\" ]] || [[ \"${prev}\" == \"--staNetDefaultNameAlign\" ]] ||\n");
	printf("	  [[ \"${prev}\" == \"--stanetnamealign\" ]] || [[ \"${prev}\" == \"--staNetNameAlign\" ]]\n");
 	printf("    then\n");
    printf("      args='left right center'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${prev2}\" == \"--stanetdefaultnamealign\" ]] || [[ \"${prev2}\" == \"--staNetDefaultNameAlign\" ]] ||\n");
	printf("	  [[ \"${prev2}\" == \"--stanetnamealign\" ]] || [[ \"${prev2}\" == \"--staNetNameAlign\" ]]\n");
 	printf("    then\n");
    printf("      args='top bottom center baseline'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
	printf("    elif [[ \"${cur}\" == -* ]]\n");
 	printf("    then\n");
	printf("      args='--adjusttomargin --AdjustToMargin \\\n");
	printf("--al --AL --atm \\\n");
	printf("--availbincolors --AvailBinColors --availcbartitle \\\n");
	printf("--AvailCbarTitle --availcontourlevels --AvailContourLevels \\\n");
	printf("--availcontourlines --AvailContourLines --availepochpos \\\n");
	printf("--AvailEpochPos --availmapbins --AvailMapBins \\\n");
	printf("--availmapbinstext --AvailMapBinsText --bineqcond \\\n");
	printf("--BinEqCond --binequalcondition --BinEqualCondition \\\n");
	printf("--boundaryColor,--bc -c --cbarInterval,--cbarN,--cn \\\n");
	printf("--cbarlabel --CbarLabel --cbarMax,--cbarmax,--cmax \\\n");
	printf("--cbarMin,--cbarmin,--cmin --cl --clean \\\n");
	printf("--color --colormap --ColorMap \\\n");
	printf("--cond --continentColor,--cc --contriskaspercentage \\\n");
	printf("--ContRiskAsPercentage --contriskbincolors --ContRiskBinColors \\\n");
	printf("--contriskcbartitle --ContRiskCbarTitle --contriskcontourlevels \\\n");
	printf("--ContRiskContourLevels --contriskcontourlines --ContRiskContourLines \\\n");
	printf("--contriskmapbins --ContRiskMapBins --contriskmapbinstext \\\n");
	printf("--ContRiskMapBinsText --contriskmarbincolors --ContRiskMarBinColors \\\n");
	printf("--contriskmarcbartitle --ContRiskMarCbarTitle --contriskmarcontourlevels \\\n");
	printf("--ContRiskMarContourLevels --contriskmarcontourlines --ContRiskMarContourLines \\\n");
	printf("--contriskmarmapbins --ContRiskMarMapBins --contriskmarmapbinstext \\\n");
	printf("--ContRiskMarMapBinsText --countries --Countries \\\n");
	printf("--disablebineqcond --DisableBinEqCond --disablebinequalcondition \\\n");
	printf("--DisableBinEqualCondition --disablenotavailbin --DisableNotAvailBin \\\n");
	printf("--doppercentileplot --DOPPercentilePlot -f \\\n");
	printf("--file --firalaska --FIRAlaska \\\n");
	printf("--fircanada --FIRCanada --firconus \\\n");
	printf("--FIRCONUS --firdegradation --FIRDegradation \\\n");
	printf("--firdegtext --FIRDegText --firdegtextalaska \\\n");
	printf("--FIRDegTextAlaska --firdegtextbins --FIRDegTextBins \\\n");
	printf("--firdegtextbinsalaska --FIRDegTextBinsAlaska --firdegtextbinscanada \\\n");
	printf("--FIRDegTextBinsCanada --firdegtextbinsconus --FIRDegTextBinsCONUS \\\n");
	printf("--firdegtextbinseu --FIRDegTextBinsEu --firdegtextbinsmexico \\\n");
	printf("--FIRDegTextBinsMexico --firdegtextcanada --FIRDegTextCanada \\\n");
	printf("--firdegtextcolor --FIRDegTextColor --firdegtextcoloralaska \\\n");
	printf("--FIRDegTextColorAlaska --firdegtextcolorcanada --FIRDegTextColorCanada \\\n");
	printf("--firdegtextcolorconus --FIRDegTextColorCONUS --firdegtextcoloreu \\\n");
	printf("--FIRDegTextColorEu --firdegtextcolorfirsum --FIRDegTextColorFIRSum \\\n");
	printf("--firdegtextcolormexico --FIRDegTextColorMexico --firdegtextconus \\\n");
	printf("--FIRDegTextCONUS --firdegtexteu --FIRDegTextEu \\\n");
	printf("--firdegtextfirsum --FIRDegTextFIRSum --firdegtextfooter \\\n");
	printf("--FIRDegTextFooter --firdegtextfooteralaska --FIRDegTextFooterAlaska \\\n");
	printf("--firdegtextfootercanada --FIRDegTextFooterCanada --firdegtextfooterconus \\\n");
	printf("--FIRDegTextFooterCONUS --firdegtextfootereu --FIRDegTextFooterEu \\\n");
	printf("--firdegtextfooterfirsum --FIRDegTextFooterFIRSum --firdegtextfootermexico \\\n");
	printf("--FIRDegTextFooterMexico --firdegtextheader --FIRDegTextHeader \\\n");
	printf("--firdegtextheaderalaska --FIRDegTextHeaderAlaska --firdegtextheadercanada \\\n");
	printf("--FIRDegTextHeaderCanada --firdegtextheaderconus --FIRDegTextHeaderCONUS \\\n");
	printf("--firdegtextheadereu --FIRDegTextHeaderEu --firdegtextheaderfirsum \\\n");
	printf("--FIRDegTextHeaderFIRSum --firdegtextheadermexico --FIRDegTextHeaderMexico \\\n");
	printf("--firdegtextmexico --FIRDegTextMexico --firdegtextmonospacefont \\\n");
	printf("--FIRDegTextMonospaceFont --firdegtextposition --FIRDegTextPosition \\\n");
	printf("--firdegtextpositionalaska --FIRDegTextPositionAlaska --firdegtextpositioncanada \\\n");
	printf("--FIRDegTextPositionCanada --firdegtextpositionconus --FIRDegTextPositionCONUS \\\n");
	printf("--firdegtextpositioneu --FIRDegTextPositionEu --firdegtextpositionfirsum \\\n");
	printf("--FIRDegTextPositionFIRSum --firdegtextpositionmexico --FIRDegTextPositionMexico \\\n");
	printf("--firdegtextsize --FIRDegTextSize --firdegtextsizealaska \\\n");
	printf("--FIRDegTextSizeAlaska --firdegtextsizecanada --FIRDegTextSizeCanada \\\n");
	printf("--firdegtextsizeconus --FIRDegTextSizeCONUS --firdegtextsizeeu \\\n");
	printf("--FIRDegTextSizeEu --firdegtextsizefirsum --FIRDegTextSizeFIRSum \\\n");
	printf("--firdegtextsizemexico --FIRDegTextSizeMexico --firdegtexttable \\\n");
	printf("--FIRDegTextTable --fireu --FIREu \\\n");
	printf("--FIREU --firlinecolor --FIRLineColor \\\n");
	printf("--firlinecoloralaska --FIRLineColorAlaska --firlinecolorcanada \\\n");
	printf("--FIRLineColorCanada --firlinecolorconus --FIRLineColorCONUS \\\n");
	printf("--firlinecoloreu --FIRLineColorEu --firlinecolormexico \\\n");
	printf("--FIRLineColorMexico --firlinetype --FIRLineType \\\n");
	printf("--firlinetypealaska --FIRLineTypeAlaska --firlinetypecanada \\\n");
	printf("--FIRLineTypeCanada --firlinetypeconus --FIRLineTypeCONUS \\\n");
	printf("--firlinetypeeu --FIRLineTypeEu --firlinetypemexico \\\n");
	printf("--FIRLineTypeMexico --firlinewidth --FIRLineWidth \\\n");
	printf("--firlinewidthalaska --FIRLineWidthAlaska --firlinewidthcanada \\\n");
	printf("--FIRLineWidthCanada --firlinewidthconus --FIRLineWidthCONUS \\\n");
	printf("--firlinewidtheu --FIRLineWidthEu --firlinewidthmexico \\\n");
	printf("--FIRLineWidthMexico --firmarkersize --FIRMarkerSize \\\n");
	printf("--firmarkersizealaska --FIRMarkerSizeAlaska --firmarkersizecanada \\\n");
	printf("--FIRMarkerSizeCanada --firmarkersizeconus --FIRMarkerSizeCONUS \\\n");
	printf("--firmarkersizeeu --FIRMarkerSizeEu --firmarkersizemexico \\\n");
	printf("--FIRMarkerSizeMexico --firmexico --FIRMexico \\\n");
	printf("--firsumdeg --FIRSumDeg --firsumdegalaska \\\n");
	printf("--FIRSumDegAlaska --firsumdegcanada --FIRSumDegCanada \\\n");
	printf("--firsumdegconus --FIRSumDegCONUS --firsumdegeu \\\n");
	printf("--FIRSumDegEu --firsumdegmexico --FIRSumDegMexico \\\n");
	printf("--firsumdeguserfir --FIRSumDegUserFIR --firuser \\\n");
	printf("--FIRUser --ft --ftitle \\\n");
	printf("--Ftitle -g --gdopbincolors \\\n");
	printf("--GDOPBinColors --gdopcbartitle --GDOPCbarTitle \\\n");
	printf("--gdopmapbins --GDOPMapBins --gdopmapbinstext \\\n");
	printf("--GDOPMapBinsText --grid -h \\\n");
	printf("--hal --HAL --hdopbincolors \\\n");
	printf("--HDOPBinColors --hdopcbartitle --HDOPCbarTitle \\\n");
	printf("--hdopmapbins --HDOPMapBins --hdopmapbinstext \\\n");
	printf("--HDOPMapBinsText --help --hmiepochpos \\\n");
	printf("--HMIEpochPos --ionoavailbincolors --IonoAvailBinColors \\\n");
	printf("--ionoavailcbartitle --IonoAvailCbarTitle --ionoavailmapbins \\\n");
	printf("--IonoAvailMapBins --ionoavailmapbinstext --IonoAvailMapBinsText \\\n");
	printf("-l --label --labelpos \\\n");
	printf("--labelPos --lakeColor --lc \\\n");
	printf("--linewidth --lp --lw \\\n");
	printf("--map --Map --mapres \\\n");
	printf("--MapResolution --markersize --miavailepochpos \\\n");
	printf("--MIAvailEpochPos --miavailpochpos --mih \\\n");
	printf("--MIH --miunavailepochpos --MIUnAvailEpochPos \\\n");
	printf("--miunavailpochpos --miv --MIV \\\n");
	printf("--ms --nocbarpercent --NoCbarPercent \\\n");
	printf("--nocontourlevels --NoContourLevels --nocontourlines \\\n");
	printf("--NoContourLines --noepochsintitle --NoEpochsInTitle \\\n");
	printf("--nofirborder --NoFIRBorder --nofirborderalaska \\\n");
	printf("--NoFIRBorderAlaska --nofirbordercanada --NoFIRBorderCanada \\\n");
	printf("--nofirborderconus --NoFIRBorderCONUS --nofirbordereu \\\n");
	printf("--NoFIRBorderEu --nofirbordermexico --NoFIRBorderMexico \\\n");
	printf("--nofirdegtext --NoFIRDegText --nofirdegtextalaska \\\n");
	printf("--NoFIRDegTextAlaska --nofirdegtextcanada --NoFIRDegTextCanada \\\n");
	printf("--nofirdegtextconus --NoFIRDegTextCONUS --nofirdegtexteu \\\n");
	printf("--NoFIRDegTextEu --nofirdegtextmexico --NoFIRDegTextMexico \\\n");
	printf("--nogeometriesintitle --NoGeometriesInTitle --no-lock-file \\\n");
	printf("--notavailbincolor --NotAvailBinColor --notavailbintext \\\n");
	printf("--NotAvailBinText --npl --numpointslabel \\\n");
	printf("--onlyprintfirdegtext --OnlyPrintFIRDegText --pdopbincolors \\\n");
	printf("--PDOPBinColors --pdopcbartitle --PDOPCbarTitle \\\n");
	printf("--pdopmapbins --PDOPMapBins --pdopmapbinstext \\\n");
	printf("--PDOPMapBinsText --percentilex --percentileX \\\n");
	printf("--percentilexlist --percentileXList --percentiley \\\n");
	printf("--percentileY --percentileylist --percentileYList \\\n");
	printf("--pj --plotlabel --printfirdegtext \\\n");
	printf("--PrintFIRDegText --prntext --PRNtext \\\n");
	printf("--prntextnewline --PRNtextnewline --projection \\\n");
	printf("--ratioH --ratioV --rh \\\n");
	printf("--RH --rv --RV \\\n");
	printf("-s --save --sbas \\\n");
	printf("--SBAS --sbasbottomfiguremargin --SBASBottomFigureMargin \\\n");
	printf("--sbasleftfiguremargin --SBASLeftFigureMargin --sbasplotsize \\\n");
	printf("--SBASPlotSize --sbasrightfiguremargin --SBASRightFigureMargin \\\n");
	printf("--sbasservicebinaryformat --SBASServiceBinaryFormat --sbasserviceformat \\\n");
	printf("--SBASServiceFormat --sbasservicemaritimebinaryformat --SBASServiceMaritimeBinaryFormat \\\n");
	printf("--sbasservicemaritimeformat --SBASServiceMaritimeFormat --sbassystemname \\\n");
	printf("--SBASSystemname --sbastopfiguremargin --SBASTopFigureMargin \\\n");
	printf("--sf --sfesa --sfesawithepochs \\\n");
	printf("--sfESAWithEpochs --sfesawithregions --sfESAWithRegions \\\n");
	printf("--sn --SN --sp \\\n");
	printf("--spesa --staName --stanet,--staNetwork \\\n");
	printf("--stanetautolabel --stanetAutoLabel --stanetdefaultlabel \\\n");
	printf("--staNetDefaultLabel --stanetdefaultmarkercolor --staNetDefaultMarkerColor \\\n");
	printf("--stanetdefaultmarkersize --staNetDefaultMarkerSize --stanetdefaultmarkertype \\\n");
	printf("--staNetDefaultMarkerType --stanetdefaultnamealign --staNetDefaultNameAlign \\\n");
	printf("--stanetdefaultnamecolor --staNetDefaultNameColor --stanetdefaultnamesize \\\n");
	printf("--staNetDefaultNameSize --stanetlabel --stanetlabelnumsta \\\n");
	printf("--staNetLabelNumSta --stanetmarkercolor --stanetmarkersize \\\n");
	printf("--stanetmarkertype --stanetnamealign --staNetNameAlign \\\n");
	printf("--stanetnamecolor --staNetNameColor --stanetnamesize \\\n");
	printf("--staNetNameSize --stanetwithmarkers --staNetWithMarkers \\\n");
	printf("--stanetwithnames --staNetWithNames --staNetwork \\\n");
	printf("--staNetworkLabel --staNetworkMarkerColor --staNetworkMarkerSize \\\n");
	printf("--staNetworkMarkerType --stanford --stanfordESA \\\n");
	printf("--style --sv -t \\\n");
	printf("--textmark --textmarkc --textmarkcolor \\\n");
	printf("--textmarkp --textmarkposition --textmarks \\\n");
	printf("--textmarksize --tit --title \\\n");
	printf("--unavailepochpos --UnAvailEpochPos --usastates \\\n");
	printf("--USAStates --val --VAL \\\n");
	printf("--version --watermark --watermarkcolor \\\n");
	printf("--watermarkposition --watermarksize --wir \\\n");
	printf("--WIR --wm --wmc \\\n");
	printf("--wmp --wms --writetofilefirdegtext \\\n");
	printf("--WriteToFileFIRDegText -x -X \\\n");
	printf("--Xcol --xl --xlab \\\n");
	printf("--Xlabel --xmax --Xmax \\\n");
	printf("--xmin --Xmin --xn \\\n");
	printf("--xr --xresolution --xt \\\n");
	printf("--xticks --Xticks --xtickslist \\\n");
	printf("--XTicksList --xticksstep --XticksStep \\\n");
	printf("--xtl --xts --xx \\\n");
	printf("-y -Y --Ycol \\\n");
	printf("--yl --ylab --Ylabel \\\n");
	printf("--ymax --Ymax --ymin \\\n");
	printf("--Ymin --yn --yr \\\n");
	printf("--yresolution --yt --yticks \\\n");
	printf("--Yticks --ytickslist --YTicksList \\\n");
	printf("--yticksstep --YticksStep --ytl \\\n");
	printf("--yts --yx'\n");
    printf("      COMPREPLY=( $( compgen -W \"${args}\" -- $cur ) )\n");
    printf("    else\n");
    printf("      comptopt -o filenames 2>/dev/null\n");
    printf("      COMPREPLY=( $(compgen -o filenames -o plusdirs -f -- ${cur}) )\n");
    printf("    fi\n");
    printf("}\n\n");
    printf("complete -o filenames -F _glab_completion glab gLAB gLAB.exe gLAB_linux.exe gLAB_linux gLAB_mac gLAB_MultiThread.exe gLAB_linux_MultiThread.exe gLAB_linux_MultiThread gLAB_mac_MultiThread\n\n");
    printf("complete -o filenames -F _graph_completion graph.exe graphcl.exe graph.py graph graphcl\n");
}


/*****************************************************************************
 * Name        : checkIfNextParameter
 * Description : Check if argument is a new gLAB parameter or it is another
 *               argument of the current parameter
 * Parameters  :
 * Name                                    |Da|Unit|Description
 * char *str                                I  N/A  Value (the string argument) to be checked
 * Returned value (int)                     O  N/A  Status of the function
 *                                                    0 => Argument for current parameter
 *                                                    1 => New gLAB parameter
 *****************************************************************************/
int checkIfNextParameter(char *str) {
	if (strncmp(str,"--",2)==0) {
		if (strlen(str)>2) 	return 1;
		else return 0;
	}
	else if (strncasecmp(str,"-input",6)==0) return 1;
	else if (strncasecmp(str,"-pre",4)==0) return 1;
	else if (strncasecmp(str,"-model",6)==0) return 1;
	else if (strncasecmp(str,"-filter",7)==0) return 1;
	else if (strncasecmp(str,"-output",7)==0) return 1;
	else if (strncasecmp(str,"-print",6)==0) return 1;
	else if (strncasecmp(str,"-summary",8)==0) return 1;
	else if (strncasecmp(str,"-sbas",5)==0) return 1;
	else if (strncasecmp(str,"-dateconv",9)==0) return 1;
	else if (strncasecmp(str,"-coordconv",10)==0) return 1;
	else if (strcasecmp(str,"-onlyconvert")==0) return 1;
	else if (strcasecmp(str,"-numthreads")==0) return 1;
	else if (strcasecmp(str,"-help")==0) return 1;
	else if (strncasecmp(str,"-messages",9)==0) return 1;
	else if (strcasecmp(str,"-examples")==0) return 1;
	else if (strcasecmp(str,"-faq")==0) return 1;
	else if (strcasecmp(str,"-autofillscript")==0) return 1;
	else if (strcasecmp(str,"-config")==0) return 1;
	else if (strcasecmp(str,"-usererrorfile")==0) return 1;
	else if (strcasecmp(str,"-sigmamultipathfile")==0) return 1;
	else if (strcasecmp(str,"-rtcmv2conversioninfo")==0) return 1;
	else if (strcasecmp(str,"-referenceposfile")==0) return 1;
	else if (strcasecmp(str,"-sbasplotsinfo")==0) return 1;
	return 0;
}

/*****************************************************************************
 * Name        : parseSatellitelist
 * Description : Read the PRN numbers and ranges from user string for the
 *               current parameter.
 * Parameters  :
 * Name                                    |Da|Unit|Description
 * char *str                                I  N/A  Value (the string parameter) to be read
 * int endtype                              I  N/A  0 -> No data at the end of the string
 *                                                  1 -> Data at the end of the string (auto detect
 *                                                        end of PRN numbers)
 * int *removeMeas                          O  N/A  0 -> A '+' or no sign provided at the start of string
 *                                                  1 -> A '-' sign provided at the start of the string
 * int *lastCharac                          O  N/A  Position of the last character with PRN data in string (before the last '-')
 * int *GNSSused                            O  N/A  Vector with 1's on the position of the GNSS read
 * int *PRNused                             O  N/A  Vector with 1's on the position of the PRN read
 *****************************************************************************/
void parseSatellitelist (char *str, int endtype, int *removeMeas, int *lastCharac, int *GNSSused, int *PRNused, TOptions *options) {
	
	int		i,j,k;
	int		initPRN;
	int 	aux=0,aux2,aux3,aux4,aux5;
	char 	*p,*p2,*p3,*p4,*p5;


	for(i=0;i<MAX_GNSS;i++) {
		GNSSused[i]=0;
	}
	for(i=0;i<MAX_SATELLITES_PER_GNSS;i++) {
		PRNused[i]=0;
	}
	*removeMeas=0;
	//Check for sign at start of string
	if(str[0]=='+') {
		aux=1;
	} else if (str[0]=='-') {
		aux=1;
		*removeMeas=1;
	}
	//Check constellation. If it is a zero, select all constellations
	if(str[aux]=='0') {
		for(i=0;i<MAX_GNSS;i++) {
			GNSSused[i]=1;
		}
	} else {
		aux2=aux;	
		while(str[aux]>65) { //65 is ASCII character 'A'
			if (checkConstellationChar(str[aux])==0) {
				sprintf(messagestr,"Invalid Constellation '%c'",str[aux]);
				printError(messagestr,options);
			}
			GNSSused[gnsschar2gnsstype(str[aux])]=1;
			aux++;
		}
		if(aux2==aux) {
			sprintf(messagestr,"No constellation letter provided in '%s'",str);
			printError(messagestr,options);
		}
	}
	//Check if character after constellation letter is a number
	if (str[aux]<48 || str[aux]>57) { //48 is ASCII 0 and 57 is ASCII 9
		//Not a number
		sprintf(messagestr,"Character after constellation letters must be a PRN number, but in '%s' it is not a number",str);
		printError(messagestr,options);
	}
	//First look for hyphen separating the PRN list from the measurement
	p=strchr(&str[aux],'-');
	aux5=0;
	while(p!=NULL) {
		aux5++;
		p++;
		if(*p=='\0' && endtype==1) {
			sprintf(messagestr,"Missing values in parameter '%s'",str);
			printError(messagestr,options);
		} else if (*p=='\0' && endtype==0) {
			*lastCharac=p-str-1;
			break;
		}
		if((*p>=48 && *p<=57)) { //48 is ASCCI '0' and 57 is ASCII '9'
			//It is a number. It is a PRN range
			p=strchr(p,'-');
			if(p==NULL && endtype==1) {
				sprintf(messagestr,"Missing values in parameter '%s'",str);
				printError(messagestr,options);
			}
			continue;
		} else {
			//Measurement name
			p2=p-1;
			*p2='\0';
			*lastCharac=p2-str-1;
			break;
		}
	}
	if(aux5==0 && endtype==1) {
		//Missing data after satellites
		sprintf(messagestr,"Missing measurement data in parameter '%s'",str);
		printError(messagestr,options);
	}
	if(p==NULL && endtype==0) {
		*lastCharac=(int)strlen(str)-1;
	}
	//Count number of PRN ranges
	aux2=0;
	p3=strchr(&str[aux],'.');
	while(p3!=NULL) {
		aux2++;
		p3++;
		p3=strchr(p3,'.');
	}
	aux2++;
	p4=&str[aux];
	p3=strchr(p4,'.');
	if (p3!=NULL) *p3='\0';
	//Read all PRN ranges
	for(i=0;i<aux2;i++) {
		if(strlen(p4)==0) {
			sprintf(messagestr,"Empty PRN value set in '%s.'",str);
			printError(messagestr,options);
		}
		p5=strchr(p4,'-');
		for(j=0;j<2;j++) {
			if(j==0) {
				if (p5!=NULL) {
					aux3=1;
					*p5='\0';
				} else {
					aux3=0;
				}
			} else {
				if (aux3==1) {
					*p5='-';
					p4=p5+1;
				} else {
					break;
				}
			}
			aux4=atoi(p4);
			if (aux4<0 || aux4>=MAX_SATELLITES_PER_GNSS) {
				sprintf(messagestr,"Invalid PRN number '%s'",p4);
				printError(messagestr,options);
			}
			if(aux4==0) {
				if (aux3==1) {
					*p5='-';
					sprintf(messagestr,"Satellite ranges must start at number 1 or later, but user provided range '%s'. For selecting all satellites, set the range as '%.*s'",str,(int)(p5-str),str);
					printError(messagestr,options);
				}
				for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
					PRNused[k]=1;
				}
			} else {
				if(aux3==1) {
					if(j==0) {
						initPRN=aux4;
					} else {
						if (initPRN<=aux4) {
							for(k=initPRN;k<=aux4;k++) {
								PRNused[k]=1;
							}
						} else {
							//Reversed order
							for(k=aux4;k<=initPRN;k++) {
								PRNused[k]=1;
							}
						}
					}
				} else {
					PRNused[aux4]=1;
				}
			}
		}
		if (i<(aux2-1)) {
			if (p3!=NULL) {
				*p3='.';
				p4=p3+1;
				p3=strchr(p4,'.');
				if (p3!=NULL) *p3='\0';
			}
		}
	}
	if (endtype==1) {
		*p2='-';
	}
}

/*****************************************************************************
 * Name        : parseMeasurements
 * Description : Read the measurements from user parameters to internal gLAB
 *               format
 * Parameters  :
 * Name                           |Da|Unit|Description
 * enum parseMeasType mode         I  N/A  Type of data to parse
 * int staType                     I  N/A  0 -> Data for rover
 *                                         1 -> Data for reference station
 * int roundMode                   I  N/A  0 -> Function called from 'processOptions'
 *                                         1 -> Function call in main, after setting 
 *                                               default measurements. In this mode,
 *                                               a few checks regarding satellite
 *                                               selection are disabled
 * TSupportOptions  *sopt          O  N/A  TSupportOptions structure
 * TOptions  *options              O  N/A  TOptions structure
 *****************************************************************************/
void parseMeasurements (enum parseMeasType mode, int staType, int roundMode, TSupportOptions *sopt, TOptions *options) {

	int						h,i,j,k,l,m,n,o,q;
	int						aux1,aux2,aux3,aux4,auxlen;
	int						autoSingleMeas,noMoreMeas;
	int						auxsort[10], lastCharac;
	int						freq[4],freq2[4],freq3[4],freqAutoSmooth;
	int						userMeas,userMeasSmooth,quadmeas;
	int						numMeasComb,numMeasCombSmooth,removeMeas,removeMeasSmooth;
	int						numMeasRead,filterMeasPosition;
	int						startfilterMeas,EndfilterMeas;
	int						typesused[MEASTYPELISTS]; //0 is code measurement, 1 is phase measurement, 2 is for Doppler
	int						GNSSused[MAX_GNSS],PRNused[MAX_SATELLITES_PER_GNSS],freqused[MAX_FREQUENCIES_PER_GNSS];
	int						attrused[MAXLETTERSDICTIONARY]; //26 is the maximum number of letter available in the dictionary
	int						moduloValue,flagLLI;
	int						ComboPhaseAndCode=0;
	int						autoMeasGNSS=0,autoMeasSmoothGNSS=0;
	enum MeasurementType 	meas,meas2,meas3,meas4,measSmooth,measaux;
	enum MeasurementType 	measlist[4],measlistSmooth[4];
	enum FilterMeasType		meastype,meastypeAlt,meastypeSmooth;
	enum MeasurementKind	measKind[4],measKindSmooth[4];
	char					c;
	char					*p,*p2,*p3;
	char					**measText,**measTextSat;
	char					auxstr[41],auxstr2[41],auxstr3[41],auxstr4[41],auxstr5[41];
	char					measstr[4][10];
	char					attrlist[MAXLETTERSDICTIONARY+1];
	const char				meastypeletters[4]={'C','L','D','\0'};

	//////////////////////////////////////////////
	////// Parsing MEAS print measurement list

	if (mode==parsePrintMeasList) {
		numMeasRead=sopt->numprintMeastext;
		measText=sopt->printMeastext;
		auxstr[1]='\0';
		for(i=0;i<numMeasRead;i++) {
			//Search for hyphen separating satellites from measurements
			parseSatellitelist(measText[i],1,&removeMeas,&lastCharac,GNSSused,PRNused,options);
			p=&measText[i][lastCharac]+2; //lastCharac points to the position before the '-'
			if(*p=='\0') {
				sprintf(messagestr,"Data missing for list of measurements for MEAS print in '%s'",measText[i]);
				printError(messagestr,options);
			}
			aux2=0;
			p3=strchr(p,'-');
			while(p3!=NULL) {
				aux2++;
				p3++;
				p3=strchr(p3,'-');
			}
			aux2++;
			p3=strchr(p,'-');
			if (p3!=NULL) *p3='\0';
			for(j=0;j<aux2;j++) {
				//Check if measurement exists
				aux1=(int)strlen(p);
				for(k=0;k<aux1;k++) {
					c=toupper(p[k]); //Transform to upper case characters
					auxstr[k]=c;
				}
				auxstr[k]='\0';
				meas=measstr2meastype(auxstr);
				flagLLI=0;
				if (meas==NA) {
					//Check if measurement is LLI flag
					if (strncasecmp(auxstr,"LLI",3)==0 && aux1==5) {
						//LLI measurement
						auxstr[2]='L';
						meas=measstr2meastype(&auxstr[2]);
						auxstr[2]='I';
						if (meas==NA) {
							sprintf(messagestr,"Unknown measurement '%s' in '%s'",p,measText[i]);
							printError(messagestr,options);
						}
						flagLLI=1;
					} else {
						sprintf(messagestr,"Unknown measurement '%s' in '%s'",p,measText[i]);
						printError(messagestr,options);
					}
				} else if (meas>ENDMEAS) {
					sprintf(messagestr,"Measurement '%s' in '%s' cannot be a combination",p,measText[i]);
					printError(messagestr,options);
				}
				//Save measurement list
				for(k=0;k<MAX_GNSS;k++) {
					if(GNSSused[k]==0) continue;
					for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
						if(PRNused[l]==0) continue;
						if (options->includeSatellite[k][l]==0) continue;
						if (removeMeas==0) {
							if (options->printMeasNumMeas[k][l]==MAX_MEASUREMENTS_PER_SATELLITE) {
								sprintf(messagestr,"Maximum number of measurements to be printed in MEAS message is '%d', but %s %2d has %d or more measurements",MAX_MEASUREMENTS_PER_SATELLITE,gnsstype2gnssstr(k),l,MAX_MEASUREMENTS_PER_SATELLITE+1);
								printError(messagestr,options);
							}
							//Check that measurement is not already in list
							for(m=0;m<options->printMeasNumMeas[k][l];m++) {
								if (options->printMeasLLIFlag[k][l][m]==flagLLI && options->printMeasListMeas[k][l][m]==meas) {
									//Measurement already in list
									break;
								}
							}
							if (m<options->printMeasNumMeas[k][l]) continue; 
							options->printMeasLLIFlag[k][l][options->printMeasNumMeas[k][l]]=flagLLI;
							options->printMeasListMeas[k][l][options->printMeasNumMeas[k][l]]=meas;
							if (options->printMeasStr[k][l][0]=='\0') {
								if (flagLLI==1) {
									aux3=sprintf(options->printMeasStr[k][l],"LLI-%2s",&auxstr[3]);
								} else if (meas>=I1) {
									aux3=sprintf(options->printMeasStr[k][l],"%2s",meastype2measstr(meas));
								} else {
									aux3=sprintf(options->printMeasStr[k][l],"%3s",meastype2measstr(meas));
								}
							} else {
								aux3=strlen(options->printMeasStr[k][l]);
								if (flagLLI==1) {
									aux3+=sprintf(&options->printMeasStr[k][l][aux3],":LLI-%2s",&auxstr[3]);
								} else if (meas>=I1) {
									aux3+=sprintf(&options->printMeasStr[k][l][aux3],":%2s",meastype2measstr(meas));
								} else {
									aux3+=sprintf(&options->printMeasStr[k][l][aux3],":%3s",meastype2measstr(meas));
								}
							}
							options->printMeasNumMeas[k][l]++;
							if (aux3>options->printMeasMaxN) {
								options->printMeasMaxN=aux3;
							}
							options->printMeasUserDefinedMeas[k][l]=1;
						} else {
							for(m=0;m<options->printMeasNumMeas[k][l];m++) {
								if (options->printMeasLLIFlag[k][l][m]==flagLLI && options->printMeasListMeas[k][l][m]==meas) {
									//Meas found. Remove it from list
									for(n=m;n<options->printMeasNumMeas[k][l]-1;n++) {
										options->printMeasLLIFlag[k][l][n]=options->printMeasLLIFlag[k][l][n+1];
										options->printMeasListMeas[k][l][n]=options->printMeasListMeas[k][l][n+1];
									}
									options->printMeasNumMeas[k][l]--;
									//The print string has to be rebuild entirely in order to remove the measurement
									if (options->printMeasLLIFlag[k][l][0]==1) {
										aux3=sprintf(options->printMeasStr[k][l],"LLI-%2s",&meastype2measstr(options->printMeasListMeas[k][l][0])[1]);
									} else {
										aux3=sprintf(options->printMeasStr[k][l],"%3s",meastype2measstr(options->printMeasListMeas[k][l][0]));
									}
									for(m=1;m<options->printMeasNumMeas[k][l];m++) {
										if (options->printMeasLLIFlag[k][l][m]==1) {
											aux3+=sprintf(&options->printMeasStr[k][l][aux3],":LLI-%2s",&meastype2measstr(options->printMeasListMeas[k][l][m])[1]);
										} else {
											aux3+=sprintf(&options->printMeasStr[k][l][aux3],":%3s",meastype2measstr(options->printMeasListMeas[k][l][m]));
										}
									}
									break;
								}
							}
						}
					}
				}

				if (removeMeas==1) {
					//If a measurement was removed, we need to recompute all string lengths, so the
					//maximum value is still correct and not too big due to the removed meas
					options->printMeasMaxN=0;
					for(k=0;k<MAX_GNSS;k++) {
						for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
							if(options->printMeasUserDefinedMeas[k][l]==0) continue;
							if (options->includeSatellite[k][l]==0) continue;
							aux3=strlen(options->printMeasStr[k][l]);
							if (aux3>options->printMeasMaxN) {
								options->printMeasMaxN=aux3;
							}
						}
					}
				}

				if (j<(aux2-1)) {
					if (p3!=NULL) {
						*p3='-';
						p=p3+1;
						p3=strchr(p,'-');
						if (p3!=NULL) *p3='\0';
					}
				}
			}
		}


	//////////////////////////////////////////////
	////// Parsing measurement priority table list

	} else if (mode==parseMeasTableList) {
		//Reading order of measurements priority
		numMeasRead=sopt->numMeasTableText[staType];
		//Reading list of measurements for the filter
		measText=sopt->measTableText[staType];
		auxstr[3]='\0'; //Used later for creating the measurement text name
		for(i=0;i<numMeasRead;i++) {
			userMeas=0;
			quadmeas=0;
			for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
				freqused[j]=0;
			}
			for(j=0;j<MAXLETTERSDICTIONARY;j++) {
				attrused[j]=0;
			}
			typesused[0]=typesused[1]=typesused[2]=0;
			parseSatellitelist(measText[i],1,&removeMeas,&lastCharac,GNSSused,PRNused,options);
			p=&measText[i][lastCharac]+2;
			p2=strchr(p,'-');
			if(p2==NULL) {
				sprintf(messagestr,"Missing attribute letter in '%s'",measText[i]);
				printError(messagestr,options);
			}
			*p2='\0';
			//Read meas type
			if(*p=='\0' || *(p+1)=='\0') {
				sprintf(messagestr,"Missing measurement type and frequencies in '%s'",measText[i]);
				printError(messagestr,options);
			}
			*p=toupper(*p);
			*(p+1)=toupper(*(p+1));
			if (*(p+2)!='\0') *(p+2)=toupper(*(p+2));
			if ((*(p+2)!='\0') && ((*p=='C' && *(p+1)=='L' && *(p+2)=='D') || (*p=='L' && *(p+1)=='C' && *(p+2)=='D') ||
				(*p=='C' && *(p+1)=='D' && *(p+2)=='L') || (*p=='L' && *(p+1)=='D' && *(p+2)=='C') || 
				(*p=='D' && *(p+1)=='C' && *(p+2)=='L') || (*p=='D' && *(p+1)=='L' && *(p+2)=='C')) ) {
				typesused[0]=typesused[1]=typesused[2]=1;
				p+=3;
			} else if( (*p=='C' && *(p+1)=='L')||(*p=='L' && *(p+1)=='C')) {
				typesused[0]=typesused[1]=1;
				p+=2;
			} else if( (*p=='C' && *(p+1)=='D')||(*p=='D' && *(p+1)=='C')) {
				typesused[0]=typesused[2]=1;
				p+=2;
			} else if( (*p=='D' && *(p+1)=='L')||(*p=='L' && *(p+1)=='D')) {
				typesused[1]=typesused[2]=1;
				p+=2;
			} else {
				if(*p=='C') {
					typesused[0]=1;
					p++;
				} else if (*p=='L') {
					typesused[1]=1;
					p++;
				} else if (*p=='D') {
					typesused[2]=1;
					p++;
				} else {
					sprintf(messagestr,"Missing measurement type letter ('C', 'L', 'D' or any combination of these three) in '%s'",measText[i]);
					printError(messagestr,options);
				}
			}
			//Read frequencies
			aux1=0;
			while((*p)!='\0') {
				if (*p<48 || *p>57) { //48 is ASCII '0' and 57 is ASCII '9'
					sprintf(messagestr,"Invalid frequency number in '%s'",measText[i]);
					printError(messagestr,options);
				}
				freqused[*p-48]=1;
				p++;
				aux1++;
			}
			if (aux1==0) {
				sprintf(messagestr,"Missing frequencies in '%s'",measText[i]);
				printError(messagestr,options);
			}
			//Read attribute list
			*p2='-';
			p++;
			if(*p=='\0') {
				sprintf(messagestr,"Missing measurement type in '%s'",measText[i]);
				printError(messagestr,options);
			}
			aux1=0;
			while(*p!='\0') {
				*p=toupper(*p);
				k=(int)(*p-65);
				if(k>=MAXLETTERSDICTIONARY) {
					sprintf(messagestr,"Invalid attribute letter '%c' in '%s'",*p,measText[i]);
					printError(messagestr,options);
				}
				if(attrAvail[k]==0) {
					sprintf(messagestr,"Attribute letter '%c' in '%s' is not supported in gLAB",*p,measText[i]);
					printError(messagestr,options);
				}
				if(attrused[k]==1) {
					sprintf(messagestr,"Attribute letter '%c' is repeated in '%s'",*p,measText[i]);
					printError(messagestr,options);
				}
				attrused[k]=1;
				attrlist[aux1]=*p;
				aux1++;
				p++;
			}
			//No need to check for aux1 value, as the number of entries will be limited to only the
			//letter attributes supported in gLAB and values cannot be repeated
			//Save attribute list
			for(j=0;j<MAX_GNSS;j++) {
				if(GNSSused[j]==0) continue;
				for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
					if(PRNused[k]==0) continue;
					for(l=0;l<MAX_FREQUENCIES_PER_GNSS;l++) {
						if(freqused[l]==0) continue;
						auxstr[1]=48+l; //48 is ASCII '0'
						for(m=0;m<MEASTYPELISTS;m++) { //Loop for code, phase and Doppler
							if(typesused[m]==0) continue;
							if (removeMeas==0) {
								//Reset number of measurements in table
								options->numMeasOrder[staType][j][k][l][m]=0;
								auxstr[0]=meastypeletters[m];
								for(n=0;n<aux1;n++) {
									auxstr[2]=attrlist[n];
									options->MeasOrder[staType][j][k][l][m][options->numMeasOrder[staType][j][k][l][m]]=measstr2meastype(auxstr);
									options->numMeasOrder[staType][j][k][l][m]++;
								}
								//Remove measurements from list in empty spaces
								for(n=options->numMeasOrder[staType][j][k][l][m];n<MAX_MEAS_TYPES_PER_FREQUENCY;n++) {
									options->MeasOrder[staType][j][k][l][m][n]=NA;
								}
							} else {
								auxstr[0]=meastypeletters[m];
								for(n=0;n<aux1;n++) {
									auxstr[2]=attrlist[n];
									meas=measstr2meastype(auxstr);
									//Search for measurement in the list. If found remove it
									//and move one position upwards the remaining elements
									for(o=0;o<options->numMeasOrder[staType][j][k][l][m];o++) {
										if (options->MeasOrder[staType][j][k][l][m][o]==meas) {
											break;
										}
									}
									if (o<options->numMeasOrder[staType][j][k][l][m]) {
										//Measurement found, remove it
										options->numMeasOrder[staType][j][k][l][m]--;
										for(;o<options->numMeasOrder[staType][j][k][l][m];o++) {
											options->MeasOrder[staType][j][k][l][m][o]=options->MeasOrder[staType][j][k][l][m][o+1];
										}
										options->MeasOrder[staType][j][k][l][m][o+1]=NA;
									}
								}
							}
						}
					}
				}
			}

		}

	/////////////////////////////////////
	////// Parsing CS input measurements

	} else if (mode<=parsecsIGFmeas) {
		switch(mode) {
			case parsecsSFmeas:
				//Reading measurements for SF CS detector
				numMeasRead=sopt->numcsSFtext[staType];
				measText=sopt->csSFtext[staType];
				moduloValue=NUMMEASCSSF;
				strcpy(auxstr2,"single frequency");
				break;
			case parsecsMWmeas:
				//Reading measurements for MW CS detector
				numMeasRead=sopt->numcsMWtext[staType];
				measText=sopt->csMWtext[staType];
				strcpy(auxstr2,"Melbourne-Wubbena");
				strcpy(auxstr3,"MW");
				strcpy(auxstr4,"PN");
				strcpy(auxstr5,"LW");
				moduloValue=NUMMEASCSMW;
				break;
			case parsecsLImeas:
				//Reading measurements for LI CS detector
				numMeasRead=sopt->numcsLItext[staType];
				measText=sopt->csLItext[staType];
				strcpy(auxstr2,"LI");
				strcpy(auxstr3,"LI");
				auxstr3[4]='\0';
				moduloValue=NUMMEASCSLI;
				break;
			default:	//parsecsIGFmeas
				//Reading measurements for IGF CS detector
				numMeasRead=sopt->numcsIGFtext[staType];
				measText=sopt->csIGFtext[staType];
				strcpy(auxstr2,"IGF");
				strcpy(auxstr3,"IGF");
				strcpy(auxstr4,"LC");
				strcpy(auxstr5,"LC");
				auxstr3[7]='\0';
				moduloValue=NUMMEASCSIGF;
				break;
		}
		auxstr[1]='\0';
		for(i=0;i<numMeasRead;i++) {
			//Search for hyphen separating satellites from measurements
			parseSatellitelist(measText[i],1,&removeMeas,&lastCharac,GNSSused,PRNused,options);
			p=&measText[i][lastCharac]+2; //lastCharac points to the position before the '-'
			if(*p=='\0') {
				sprintf(messagestr,"Data missing for list of measurements for %s cycle-slip detector in '%s'",auxstr2,measText[i]);
				printError(messagestr,options);
			}
			aux2=0;
			p3=strchr(p,'-');
			while(p3!=NULL) {
				aux2++;
				p3++;
				p3=strchr(p3,'-');
			}
			aux2++;
			if((mode==parsecsSFmeas || mode==parsecsLImeas) && (aux2%2)!=0 ) {
				sprintf(messagestr,"List of measurements for %s cycle-slip detector in '%s' must be provided in pairs",auxstr2,measText[i]);
				printError(messagestr,options);
			} else if ((mode==parsecsMWmeas) && (aux2%4)!=0 ) {
				sprintf(messagestr,"List of measurements for %s cycle-slip detector in '%s' must be provided in groups of four",auxstr2,measText[i]);
				printError(messagestr,options);
			} else if (mode==parsecsIGFmeas) {
				if (options->csIGFminNoise==1) {
					 if ((aux2%3)!=0 && (aux2%4)!=0 ) {
						sprintf(messagestr,"List of measurements for %s cycle-slip detector in '%s' must be provided in groups of three or four  (when option '-pre:cs:igf:minnoise' is set)",auxstr2,measText[i]);
						printError(messagestr,options);
					 }
					 if((aux2%3)==0) {
						 moduloValue=NUMMEASCSIGF-1;
					 }
				} else {
					 if ((aux2%4)!=0 ) {
						sprintf(messagestr,"List of measurements for %s cycle-slip detector in '%s' must be provided in groups of four",auxstr2,measText[i]);
						printError(messagestr,options);
					 }
				}
			}
			p3=strchr(p,'-');
			if (p3!=NULL) *p3='\0';
			for(j=0;j<aux2;j++) {
				//Check if measurement exists
				aux1=(int)strlen(p);
				for(k=0;k<aux1;k++) {
					c=toupper(p[k]); //Transform to upper case characters
					auxstr[k]=c;
				}
				auxstr[k]='\0';
				meas=measstr2meastype(auxstr);
				if (meas==NA) {
					sprintf(messagestr,"Unknown measurement '%s' in '%s'",p,measText[i]);
					printError(messagestr,options);
				} else if (meas>ENDMEAS) {
					sprintf(messagestr,"Measurement '%s' in '%s' cannot be a combination",p,measText[i]);
					printError(messagestr,options);
				}
				aux1=j%moduloValue;
				measlist[aux1]=meas;
				measKind[aux1]=whatIs(meas);
				freq[aux1]=getFrequencyInt(meas);
				if(measKind[aux1]!=CarrierPhase && measKind[aux1]!=Pseudorange) {
					sprintf(messagestr,"Measurement '%s' in '%s' cannot be a SNR or Doppler",p,measText[i]);
					printError(messagestr,options);
				}

				if (mode==parsecsIGFmeas && (moduloValue==NUMMEASCSIGF-1) && ((j+1)%moduloValue)) {
					//For the case we are reading measurements in groups of three, 
					//it is processed as groups of four, so we need to copy the first measurement
					measlist[3]=measlist[0];
					measKind[3]=measKind[0];
					freq[3]=freq[0];
				}

				if((j+1)%moduloValue==0) {
					switch(mode) {
						case parsecsSFmeas:
							if(measKind[0]==measKind[1]) {
								sprintf(messagestr,"Measurements in '%s' for single frequency CS detector must be a pseudorange and a carrier phase",measText[i]);
								printError(messagestr,options);
							} else if (freq[0]!=freq[1]) {
								sprintf(messagestr,"Measurements in '%s' for single frequency CS detector must have the same frequency",measText[i]);
								printError(messagestr,options);
							}
							if(measKind[0]==CarrierPhase) {
								//Swap order, first measurement saved is the pseudorange. Frequencies are the same, no need to swap them
								measaux=measlist[0];
								measlist[0]=measlist[1];
								measlist[1]=measaux;
							}
							for(k=0;k<MAX_GNSS;k++) {
								if(GNSSused[k]==0) continue;
								if (availGNSSFreq[k][freq[0]]==0) {
									options->unselUnavailGNSSFreqCS[k][freq[0]]=1;
									continue;
								}
								for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
									if(PRNused[l]==0) continue;
									if (options->includeSatellite[k][l]==0) continue;
									if (options->usableFreq[k][l][freq[0]]==0) {
										//Frequency disabled by the user
										sprintf(messagestr,"Selected measurement with frequency %d for satellite %s %d for single frequency cycle-slip detector in parameter '%s', but user has set the frequency as not usable",freq[0],gnsstype2gnssstr(k),l,measText[i]);
										printError(messagestr,options);
									}
									//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
									for(m=0;m<options->numcsSFMeasList[staType][k][l];m++) {
										if (options->csSFMeasList[staType][k][l][m][0]==measlist[0] && options->csSFMeasList[staType][k][l][m][1]==measlist[1] ) {
											//Measurements already saved. Skip repeated measurements
											break;
										}
									}
									if (m==options->numcsSFMeasList[staType][k][l] && removeMeas==0) {
										//Measurement not found and we need to save it
										if (m==MAX_CS_LIST) {
											sprintf(messagestr,"Maximum number of single frequency cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",staType==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
											printError(messagestr,options);
										}
										options->csSFMeasList[staType][k][l][m][0]=measlist[0];
										options->csSFMeasList[staType][k][l][m][1]=measlist[1];
										options->csSFMeasFreq[staType][k][l][m][0]=freq[0];
										options->csSFMeasFreq[staType][k][l][m][1]=freq[1];
										options->csSFWithMeas[staType][k][l][m]=1;
										options->csSFMeasSelected[staType][k][l][m]=1;
										options->numcsSFMeasList[staType][k][l]++;
									} else if (m<options->numcsSFMeasList[staType][k][l] && removeMeas==1) {
										for(n=m+1;n<options->numcsSFMeasList[staType][k][l];n++) {
											//Measurement found and we need to remove it
											options->csSFMeasList[staType][k][l][n-1][0]=options->csSFMeasList[staType][k][l][n][0];
											options->csSFMeasList[staType][k][l][n-1][1]=options->csSFMeasList[staType][k][l][n][1];
											options->csSFMeasFreq[staType][k][l][n-1][0]=options->csSFMeasFreq[staType][k][l][n][0];
											options->csSFMeasFreq[staType][k][l][n-1][1]=options->csSFMeasFreq[staType][k][l][n][1];
											options->csSFWithMeas[staType][k][l][n-1]=options->csSFWithMeas[staType][k][l][n];
											options->csSFMeasSelected[staType][k][l][n-1]=options->csSFMeasSelected[staType][k][l][n];

										}
										options->numcsSFMeasList[staType][k][l]--;
									}
								}
							}
							break;
						case parsecsMWmeas:
							//Check that we have two pseudoranges and two carrier phases
							aux3=aux4=0;
							for(k=0;k<NUMMEASCSMW;k++) {
								if(measKind[k]==Pseudorange) {
									aux3++;
								} else {
									aux4++;
								}
							}
							if (aux3!=aux4) {
								sprintf(messagestr,"Measurements in '%s' for MW CS detector must be two pseudoranges and two carrier phases",measText[i]);
								printError(messagestr,options);
							}
							//Check that measurements are from two different frequencies
							for(k=0;k<NUMMEASCSMW;k++) {
								freq2[k]=freq[k];
							}
							qsort(freq2,NUMMEASCSMW,sizeof(int),qsort_compare_int);
							if(freq2[0]!=freq2[1] || freq2[2]!=freq2[3] || freq2[0]==freq2[2]) {
								sprintf(messagestr,"Measurements in '%s' for MW CS detector must be from two different frequencies, but frequencies are %d, %d, %d and %d",measText[i],freq[0],freq[1],freq[2],freq[3]);
								printError(messagestr,options);
							}							
							//Sort measurements by type. First the pseudoranges and then the carrier phases
							//After this ordering,the measurement type is not needed any more
							for(k=0;k<2;k++) {
								if(measKind[k]==CarrierPhase) {
									//Look for first pseudorange and swap it for the current position
									for(j=k+1;j<NUMMEASCSMW;j++) {
										if (measKind[j]==Pseudorange) {
											aux3=freq[k];
											freq[k]=freq[j];
											freq[j]=aux3;
											aux3=measlist[k];
											measlist[k]=measlist[j];
											measlist[j]=aux3;
											aux3=(int)measKind[k];
											measKind[k]=measKind[j];
											measKind[j]=(enum MeasurementKind)aux3;
											break;
										}
									}
								}
							}
							//Sort each measurement type by frequencies
							if (freq[0]==0 || (freq[0]>0 && freq[0]>freq[1])) {
								aux3=freq[0];
								freq[0]=freq[1];
								freq[1]=aux3;
								aux3=measlist[0];
								measlist[0]=measlist[1];
								measlist[1]=aux3;
							}
							if (freq[2]==0 || (freq[2]>0 && freq[2]>freq[3])) {
								aux3=freq[2];
								freq[2]=freq[3];
								freq[3]=aux3;
								measaux=measlist[2];
								measlist[2]=measlist[3];
								measlist[3]=measaux;
							}
							auxstr3[2]='0'+freq[0];
							auxstr3[3]='0'+freq[1];
							auxstr3[4]='\0';
							meas2=measstr2meastype(auxstr3);
							auxstr4[2]='0'+freq[0];
							auxstr4[3]='0'+freq[1];
							auxstr4[4]='\0';
							meas3=measstr2meastype(auxstr4);
							auxstr5[2]='0'+freq[0];
							auxstr5[3]='0'+freq[1];
							auxstr5[4]='\0';
							meas4=measstr2meastype(auxstr5);
							for(k=0;k<MAX_GNSS;k++) {
								if(GNSSused[k]==0) continue;
								for(m=0;m<NUMMEASCSMW;m++) {
									if (availGNSSFreq[k][freq[m]]==0) {
										options->unselUnavailGNSSFreqCS[k][freq[m]]=1;
										break;
									}
								}
								if(m<NUMMEASCSMW) continue;
								for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
									if(PRNused[l]==0) continue;
									if (options->includeSatellite[k][l]==0) continue;
									for(m=0;m<NUMMEASCSMW;m++) {
										if (options->usableFreq[k][l][freq[m]]==0) {
											//Frequency disabled by the user
											sprintf(messagestr,"Selected frequency %d for satellite %s %d for MW cycle-slip detector in parameter '%s', but user has set the frequency as not usable",freq[m],gnsstype2gnssstr(k),l,measText[i]);
											printError(messagestr,options);
										}
									}
									//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
									for(m=0;m<options->numcsMWMeasList[staType][k][l];m++) {
										if (options->csMWMeasList[staType][k][l][m][2]==measlist[0] && options->csMWMeasList[staType][k][l][m][3]==measlist[1]
										    && options->csMWMeasList[staType][k][l][m][5]==measlist[2] && options->csMWMeasList[staType][k][l][m][6]==measlist[3] ) {
											//Maasurements already saved. Skip repeated measurements
											break;
										}
									}
									if (m==options->numcsMWMeasList[staType][k][l] && removeMeas==0) {
										//Measurement not found and we need to save it
										if (m==MAX_CS_LIST) {
											sprintf(messagestr,"Maximum number of Melbourne-Wubbena cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",staType==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
											printError(messagestr,options);
										}
										options->csMWMeasList[staType][k][l][m][0]=meas2;
										options->csMWMeasList[staType][k][l][m][1]=meas3;
										options->csMWMeasList[staType][k][l][m][2]=measlist[0];
										options->csMWMeasList[staType][k][l][m][3]=measlist[1];
										options->csMWMeasList[staType][k][l][m][4]=meas4;
										options->csMWMeasList[staType][k][l][m][5]=measlist[2];
										options->csMWMeasList[staType][k][l][m][6]=measlist[3];
										options->csMWMeasFreq[staType][k][l][m][0]=freq[0];
										options->csMWMeasFreq[staType][k][l][m][1]=freq[1];
										options->csMWMeasFreq[staType][k][l][m][2]=freq[2];
										options->csMWMeasFreq[staType][k][l][m][3]=freq[3];
										options->csMWWithMeas[staType][k][l][m]=1;
										options->csMWMeasSelected[staType][k][l][m]=1;
										options->numcsMWMeasList[staType][k][l]++;
									} else if (m<options->numcsMWMeasList[staType][k][l] && removeMeas==1) {
										for(n=m+1;n<options->numcsMWMeasList[staType][k][l];n++) {
											//Measurement found and we need to remove it
											options->csMWMeasList[staType][k][l][n-1][0]=options->csMWMeasList[staType][k][l][n][0];
											options->csMWMeasList[staType][k][l][n-1][1]=options->csMWMeasList[staType][k][l][n][1];
											options->csMWMeasList[staType][k][l][n-1][2]=options->csMWMeasList[staType][k][l][n][2];
											options->csMWMeasList[staType][k][l][n-1][3]=options->csMWMeasList[staType][k][l][n][3];
											options->csMWMeasList[staType][k][l][n-1][4]=options->csMWMeasList[staType][k][l][n][4];
											options->csMWMeasList[staType][k][l][n-1][5]=options->csMWMeasList[staType][k][l][n][5];
											options->csMWMeasList[staType][k][l][n-1][6]=options->csMWMeasList[staType][k][l][n][6];
											options->csMWMeasFreq[staType][k][l][n-1][0]=options->csMWMeasFreq[staType][k][l][n][0];
											options->csMWMeasFreq[staType][k][l][n-1][1]=options->csMWMeasFreq[staType][k][l][n][1];
											options->csMWMeasFreq[staType][k][l][n-1][2]=options->csMWMeasFreq[staType][k][l][n][2];
											options->csMWMeasFreq[staType][k][l][n-1][3]=options->csMWMeasFreq[staType][k][l][n][3];
											options->csMWWithMeas[staType][k][l][n-1]=options->csMWWithMeas[staType][k][l][n];
											options->csMWMeasSelected[staType][k][l][n-1]=options->csMWMeasSelected[staType][k][l][n];
										}
										options->numcsMWMeasList[staType][k][l]--;
									}
								}
							}
							break;
						case parsecsLImeas:
							if(measKind[0]!=measKind[1] || measKind[0]==Pseudorange) {
								sprintf(messagestr,"Measurements in '%s' for LI CS detector must be both carrier phases",measText[i]);
								printError(messagestr,options);
							}
							//Measurements may be from the same frequency (for instance L2C and L2W), so no need to check frequencies
							//Order frequencies
							if (freq[0]==0 || (freq[0]>0 && freq[0]>freq[1])) {
								aux3=freq[0];
								freq[0]=freq[1];
								freq[1]=aux3;
								measaux=measlist[0];
								measlist[0]=measlist[1];
								measlist[1]=measaux;
							}
							auxstr3[2]='0'+freq[0];
							auxstr3[3]='0'+freq[1];
							auxstr3[4]='\0';
							meas2=measstr2meastype(auxstr3);
							for(k=0;k<MAX_GNSS;k++) {
								if(GNSSused[k]==0) continue;
								for(m=0;m<NUMMEASCSLI;m++) {
									if (availGNSSFreq[k][freq[m]]==0) {
										options->unselUnavailGNSSFreqCS[k][freq[m]]=1;
										break;
									}
								}
								if(m<NUMMEASCSLI) continue;
								for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
									if(PRNused[l]==0) continue;
									if (options->includeSatellite[k][l]==0) continue;
									for(m=0;m<NUMMEASCSLI;m++) {
										if (options->usableFreq[k][l][freq[m]]==0) {
											//Frequency disabled by the user
											sprintf(messagestr,"Selected measurement with frequency %d for satellite %s %d for LI cycle-slip detector in parameter '%s', but user has set the frequency as not usable",freq[m],gnsstype2gnssstr(k),l,measText[i]);
											printError(messagestr,options);
										}
									}
									//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
									for(m=0;m<options->numcsLIMeasList[staType][k][l];m++) {
										if (options->csLIMeasList[staType][k][l][m][1]==measlist[0] && options->csLIMeasList[staType][k][l][m][2]==measlist[1] ) {
											//Maasurements already saved. Skip repeated measurements
											break;
										}
									}
									if (m==options->numcsLIMeasList[staType][k][l] && removeMeas==0) {
										//Measurement not found and we need to save it
										if (m==MAX_CS_LIST) {
											sprintf(messagestr,"Maximum number of LI cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",staType==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
											printError(messagestr,options);
										}
										options->csLIMeasList[staType][k][l][m][0]=meas2;
										options->csLIMeasList[staType][k][l][m][1]=measlist[0];
										options->csLIMeasList[staType][k][l][m][2]=measlist[1];
										options->csLIMeasFreq[staType][k][l][m][0]=freq[0];
										options->csLIMeasFreq[staType][k][l][m][1]=freq[1];
										options->csLIWithMeas[staType][k][l][m]=1;
										options->csLIMeasSelected[staType][k][l][m]=1;
										options->numcsLIMeasList[staType][k][l]++;
									} else if (m<options->numcsLIMeasList[staType][k][l] && removeMeas==1) {
										for(n=m+1;n<options->numcsLIMeasList[staType][k][l];n++) {
											//Measurement found and we need to remove it
											options->csLIMeasList[staType][k][l][n-1][0]=options->csLIMeasList[staType][k][l][n][0];
											options->csLIMeasList[staType][k][l][n-1][1]=options->csLIMeasList[staType][k][l][n][1];
											options->csLIMeasList[staType][k][l][n-1][2]=options->csLIMeasList[staType][k][l][n][2];
											options->csLIMeasFreq[staType][k][l][n-1][0]=options->csLIMeasFreq[staType][k][l][n][0];
											options->csLIMeasFreq[staType][k][l][n-1][1]=options->csLIMeasFreq[staType][k][l][n][1];
											options->csLIWithMeas[staType][k][l][n-1]=options->csLIWithMeas[staType][k][l][n];
											options->csLIMeasSelected[staType][k][l][n-1]=options->csLIMeasSelected[staType][k][l][n];
										}
										options->numcsLIMeasList[staType][k][l]--;
									}
								}
							}
							break;
						default:	//parsecsIGFmeas
							//Check that all measurements are carrier phases
							aux3=0;
							if (options->csIGFallowCodes==0) {
								for(k=0;k<NUMMEASCSIGF;k++) {
									if(measKind[k]==CarrierPhase) {
										aux3++;
									}
								}
								if(aux3!=NUMMEASCSIGF) {
									sprintf(messagestr,"Measurements in '%s' for IGF CS detector must be all carrier phases",measText[i]);
									printError(messagestr,options);
								}
							} else {
								aux4=0;
								for(k=0;k<NUMMEASCSIGF;k++) {
									if(measKind[k]==CarrierPhase) {
										aux3++;
									} else if(measKind[k]==Pseudorange) {
										aux4++;
									}
								}
								if(aux3!=NUMMEASCSIGF && aux4!=NUMMEASCSIGF) {
									sprintf(messagestr,"Measurements in '%s' for IGF CS detector must be all carrier phases or pseudoranges",measText[i]);
									printError(messagestr,options);
								}
							}
							//Check that there are three or four frequencies. To do it, sort the frequency numbers first
							for(k=0;k<NUMMEASCSIGF;k++) {
								freq2[k]=freq[k];
							}
							qsort(freq2,NUMMEASCSIGF,sizeof(int),qsort_compare_int);
							if (freq2[0]!=freq2[1] && freq2[0]!=freq2[2] && freq2[0]!=freq2[3] && freq2[1]!=freq2[2] && freq2[1]!=freq2[3] && freq2[2]!=freq2[3] ) {
								//4 different frequencies
								quadmeas=1;
							} else if (freq2[0]==freq2[1] && freq2[0]!=freq2[2] && freq2[0]!=freq2[3]) {
								//3 different frequencies
								quadmeas=0;
							} else if (freq2[0]!=freq2[1] && freq2[1]==freq2[2] && freq2[1]!=freq2[3]) {
								//3 different frequencies
								quadmeas=0;
							} else if (freq2[0]!=freq2[1] && freq2[1]!=freq2[2] && freq2[2]==freq2[3]) {
								//3 different frequencies
								quadmeas=0;
							} else {
								sprintf(messagestr,"Invalid frequencies in '%s'. For IGF cycle-slip detector, there must be three or four different frequencies",measText[i]);
								printError(messagestr,options);
							}
							if (quadmeas==1 && options->csIGFminNoise==1) {
								sprintf(messagestr,"If option '-pre:cs:igf:minnoise' is set, IGF combination can only be built with three frequencies, but user set four different frequencies in '%s'",measText[i]);
								printError(messagestr,options);
							}
							//Order frequencies
							for(k=0;k<NUMMEASCSIGF;k++){
								auxstr3[3+k]='0' + (unsigned int)freq[k];
							}
							meas = measstr2meastype(auxstr3);
							if(meas==NA) {
								for(n=0;n<2;n++) {
									if(n==1 && quadmeas==1) break;
									for(m=0;m<2;m++) {
										if(m==1) {
											//In second loop, swap order of the combinations
											aux3=freq[0];
											freq[0]=freq[2];
											freq[2]=aux3;
											aux3=freq[1];
											freq[1]=freq[3];
											freq[3]=aux3;
											aux3=measlist[0];
											measlist[0]=measlist[2];
											measlist[2]=aux3;
											measaux=measlist[1];
											measlist[1]=measlist[3];
											measlist[3]=measaux;
											aux3=(int)auxstr3[3];
											auxstr3[3]=auxstr3[5];
											auxstr3[5]=(char)aux3;
											aux3=(int)auxstr3[4];
											auxstr3[4]=auxstr3[6];
											auxstr3[6]=(char)aux3;
											meas = measstr2meastype(auxstr3);
											if (meas!=NA) break;
										}
										for(k=0;k<3;k++) {
											if(k==0) {
												//Swap first 2 frequency numbers
												aux3=freq[1];
												freq[1]=freq[0];
												freq[0]=aux3;
												measaux=measlist[0];
												measlist[0]=measlist[1];
												measlist[1]=measaux;
												aux3=(int)auxstr3[4];
												auxstr3[4]=auxstr3[3];
												auxstr3[3]=(char)aux3;
											} else if (k==1) {
												//Swap last 2 frequency numbers (leaving the first 2 numbers swapped)
												aux3=freq[3];
												freq[3]=freq[2];
												freq[2]=aux3;
												measaux=measlist[2];
												measlist[2]=measlist[3];
												measlist[3]=measaux;
												aux3=(int)auxstr3[6];
												auxstr3[6]=auxstr3[5];
												auxstr3[5]=(char)aux3;
											} else {
												//Swap first 2 frequency numbers (so they are as in original position) and leave last 2 numbers swapped
												aux3=freq[1];
												freq[1]=freq[0];
												freq[0]=aux3;
												measaux=measlist[0];
												measlist[0]=measlist[1];
												measlist[1]=measaux;
												aux3=(int)auxstr3[4];
												auxstr3[4]=auxstr3[3];
												auxstr3[3]=(char)aux3;
											}
											meas = measstr2meastype(auxstr3);
											if (meas!=NA) break;
										}
										if (meas!=NA) break;
									}
									if (meas!=NA) break;
									else if (quadmeas==0) {
										//In the case of three frequencies, the repeated frequency may be set
										//toguether at the beginning or at the end (example 1123 or 2311)
										//Swap second and third frequency number so there are two pairo od
										//frequencies with the different frequencies
										aux3=freq[1];
										freq[1]=freq[2];
										freq[2]=aux3;
										measaux=measlist[1];
										measlist[1]=measlist[2];
										measlist[2]=measaux;
										aux3=(int)auxstr3[4];
										auxstr3[4]=auxstr3[5];
										auxstr3[5]=(char)aux3;
									}
								}
								if (meas==NA) {
									sprintf(messagestr,"Invalid frequencies '%s' in '%s' for IGF cycle-slip detector",p,measText[i]);
									printError(messagestr,options);
								}
							}
							auxstr4[2]='0'+freq[0];
							auxstr4[3]='0'+freq[1];
							auxstr4[4]='\0';
							meas3=measstr2meastype(auxstr4);
							auxstr5[2]='0'+freq[2];
							auxstr5[3]='0'+freq[3];
							auxstr5[4]='\0';
							meas4=measstr2meastype(auxstr5);
							for(k=0;k<MAX_GNSS;k++) {
								if(GNSSused[k]==0) continue;
								for(m=0;m<NUMMEASCSIGF;m++) {
									if (availGNSSFreq[k][freq[m]]==0) {
										options->unselUnavailGNSSFreqCS[k][freq[m]]=1;
										break;
									}
								}
								if(m<NUMMEASCSIGF) continue;
								for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
									if(PRNused[l]==0) continue;
									if (options->includeSatellite[k][l]==0) continue;
									for(m=0;m<NUMMEASCSIGF;m++) {
										if (options->usableFreq[k][l][freq[m]]==0) {
											//Frequency disabled by the user
											sprintf(messagestr,"Selected measurement with frequency %d for satellite %s %d for IGF cycle-slip detection in parameter '%s', but user has set the frequency as not usable",freq[m],gnsstype2gnssstr(k),l,measText[i]);
											printError(messagestr,options);
										}
									}
									//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
									for(m=0;m<options->numcsIGFMeasList[staType][k][l];m++) {
										if (options->csIGFMeasList[staType][k][l][m][2]==measlist[0] && options->csIGFMeasList[staType][k][l][m][3]==measlist[1] 
												&& options->csIGFMeasList[staType][k][l][m][5]==measlist[2] && options->csIGFMeasList[staType][k][l][m][6]==measlist[3]) {
											//Maasurements already saved. Skip repeated measurements
											break;
										}
									}
									if (m==options->numcsIGFMeasList[staType][k][l] && removeMeas==0) {
										//Measurement not found and we need to save it
										if (m==MAX_CS_LIST) {
											sprintf(messagestr,"Maximum number of IGF cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",staType==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
											printError(messagestr,options);
										}
										options->csIGFMeasList[staType][k][l][m][0]=meas;
										options->csIGFMeasList[staType][k][l][m][1]=meas3;
										options->csIGFMeasList[staType][k][l][m][2]=measlist[0];
										options->csIGFMeasList[staType][k][l][m][3]=measlist[1];
										options->csIGFMeasList[staType][k][l][m][4]=meas4;
										options->csIGFMeasList[staType][k][l][m][5]=measlist[2];
										options->csIGFMeasList[staType][k][l][m][6]=measlist[3];
										options->csIGFMeasFreq[staType][k][l][m][0]=freq[0];
										options->csIGFMeasFreq[staType][k][l][m][1]=freq[1];
										options->csIGFMeasFreq[staType][k][l][m][2]=freq[2];
										options->csIGFMeasFreq[staType][k][l][m][3]=freq[3];
										options->csIGFWithMeas[staType][k][l][m]=1;
										options->csIGFMeasSelected[staType][k][l][m]=1;
										options->numcsIGFMeasList[staType][k][l]++;
									} else if (m<options->numcsIGFMeasList[staType][k][l] && removeMeas==1) {
										for(n=m+1;n<options->numcsIGFMeasList[staType][k][l];n++) {
											//Measurement found and we need to remove it
											options->csIGFMeasList[staType][k][l][n-1][0]=options->csIGFMeasList[staType][k][l][n][0];
											options->csIGFMeasList[staType][k][l][n-1][1]=options->csIGFMeasList[staType][k][l][n][1];
											options->csIGFMeasList[staType][k][l][n-1][2]=options->csIGFMeasList[staType][k][l][n][2];
											options->csIGFMeasList[staType][k][l][n-1][3]=options->csIGFMeasList[staType][k][l][n][3];
											options->csIGFMeasList[staType][k][l][n-1][4]=options->csIGFMeasList[staType][k][l][n][4];
											options->csIGFMeasList[staType][k][l][n-1][5]=options->csIGFMeasList[staType][k][l][n][5];
											options->csIGFMeasList[staType][k][l][n-1][6]=options->csIGFMeasList[staType][k][l][n][6];
											options->csIGFMeasFreq[staType][k][l][n-1][0]=options->csIGFMeasFreq[staType][k][l][n][0];
											options->csIGFMeasFreq[staType][k][l][n-1][1]=options->csIGFMeasFreq[staType][k][l][n][1];
											options->csIGFMeasFreq[staType][k][l][n-1][2]=options->csIGFMeasFreq[staType][k][l][n][2];
											options->csIGFMeasFreq[staType][k][l][n-1][3]=options->csIGFMeasFreq[staType][k][l][n][3];
											options->csIGFWithMeas[staType][k][l][n-1]=options->csIGFWithMeas[staType][k][l][n];
											options->csIGFMeasSelected[staType][k][l][n-1]=options->csIGFMeasSelected[staType][k][l][n];
										}
										options->numcsIGFMeasList[staType][k][l]--;
									}
								}
							}
							break;
					}
				}
				
				if (j<(aux2-1)) {
					if (p3!=NULL) {
						*p3='-';
						p=p3+1;
						p3=strchr(p,'-');
						if (p3!=NULL) *p3='\0';
					}
				}
			}
		}


	/////////////////////////////////////
	////// Parsing CS input frequencies

	} else if (mode<=parsecsIGFfreq) {
		switch(mode) {
			case parsecsSFfreq:
				//Reading frequencies for SF CS detector
				numMeasRead=sopt->numcsSFfreqtext[staType];
				measText=sopt->csSFfreqtext[staType];
				strcpy(auxstr2,"single frequency");
				break;
			case parsecsMWfreq:
				//Reading frequencies for MW CS detector
				numMeasRead=sopt->numcsMWfreqtext[staType];
				measText=sopt->csMWfreqtext[staType];
				strcpy(auxstr2,"Melbourne-Wubbena");
				strcpy(auxstr3,"MW");
				auxstr3[4]='\0';
				break;
			case parsecsLIfreq:
				//Reading frequencies for LI CS detector
				numMeasRead=sopt->numcsLIfreqtext[staType];
				measText=sopt->csLIfreqtext[staType];
				strcpy(auxstr2,"LI");
				strcpy(auxstr3,"LI");
				auxstr3[4]='\0';
				break;
			default:
				//Reading frequencies for IGF CS detector
				numMeasRead=sopt->numcsIGFfreqtext[staType];
				measText=sopt->csIGFfreqtext[staType];
				strcpy(auxstr2,"IGF");
				strcpy(auxstr3,"IGF");
				auxstr3[7]='\0';
				break;
		}
		auxstr[1]='\0';
		for(i=0;i<numMeasRead;i++) {
			//Search for hyphen separating satellites from frequencies (it will be the last hyphen)
			p=strrchr(measText[i],'-');
			if(p==NULL) {
				sprintf(messagestr,"Data missing for list of frequencies for %s cycle-slip detector in '%s'",auxstr2,measText[i]);
				printError(messagestr,options);
			}
			*p='\0';
			parseSatellitelist(measText[i],0,&removeMeas,&lastCharac,GNSSused,PRNused,options);
			*p='-';
			p=&measText[i][lastCharac]+2; //lastCharac points to the position before the '-'
			if(*p=='\0') {
				sprintf(messagestr,"Data missing for list of frequencies for %s cycle-slip detector in '%s'",auxstr2,measText[i]);
				printError(messagestr,options);
			}
			aux1=(int)strlen(p);
			//Count number of frequencies
			aux2=0;
			p3=strchr(p,'.');
			while(p3!=NULL) {
				aux2++;
				p3++;
				p3=strchr(p3,'.');
			}
			aux2++;
			p3=strchr(p,'.');
			if (p3!=NULL) *p3='\0';
			for(j=0;j<aux2;j++) {
				if(mode==parsecsSFfreq && strlen(p)>1) {
					sprintf(messagestr,"List of frequencies for single frequency cycle-slip detector in '%s' must be separated by dots ('.')",measText[i]);
					printError(messagestr,options);
				} else if ((mode==parsecsMWfreq || mode==parsecsLIfreq) && strlen(p)!=2) {
					sprintf(messagestr,"List of frequencies for %s cycle-slip detector in '%s' must be separated by dots ('.'), placing two frequencies between each dot",auxstr2,measText[i]);
					printError(messagestr,options);
				} else if (mode==parsecsIGFfreq) {
					auxlen=strlen(p);
					if (options->csIGFminNoise==1) { 
						if (auxlen!=4 && auxlen!=3) {
							sprintf(messagestr,"List of frequencies for triple frequency cycle-slip detector in '%s' must be separated by dots ('.'), placing three or four frequencies between each dot (when option '-pre:cs:igf:minnoise' is set)",measText[i]);
							printError(messagestr,options);
						}
					} else {
						if (auxlen!=4) {
							sprintf(messagestr,"List of frequencies for triple/quadruple frequency cycle-slip detector in '%s' must be separated by dots ('.'), placing four frequencies between each dot",measText[i]);
							printError(messagestr,options);
						}
					}
				}
				if (mode==parsecsSFfreq) {
					//SF detector frequencies
					if (*p=='\0') {
						sprintf(messagestr,"Missing frequency for %s cycle-slip detector in '%s'",auxstr2,measText[i]);
						printError(messagestr,options);
					} else if(*p<48 || *p>57) { //48 is ASCCI '0' and 57 is ASCII '9'
						sprintf(messagestr,"Invalid frequency '%c' for %s cycle-slip detector in '%s'",*p,auxstr2,measText[i]);
						printError(messagestr,options);
					}
					auxstr[0]=*p;
					aux3=atoi(auxstr);
					for(k=0;k<MAX_GNSS;k++) {
						if(GNSSused[k]==0) continue;
						if (availGNSSFreq[k][aux3]==0) {
							options->unselUnavailGNSSFreqCS[k][aux3]=1;
							continue;
						}
						for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
							if(PRNused[l]==0) continue;
							if (options->includeSatellite[k][l]==0) continue;
							if (options->usableFreq[k][l][aux3]==0) {
								//Frequency disabled by the user
								sprintf(messagestr,"Selected frequency %d for satellite %s %d for single frequency cycle-slip detector in parameter '%s', but user has set the frequency as not usable",aux3,gnsstype2gnssstr(k),l,measText[i]);
								printError(messagestr,options);
							}
							//Search for repeated frequencies, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
							for(m=0;m<options->numcsSFfreq[staType][k][l];m++) {
								if (options->csSFfreq[staType][k][l][m]==aux3) {
									//Frequency already saved. 
									break;
								}
							}
							if (m==options->numcsSFfreq[staType][k][l] && removeMeas==0) {
								//Frequency not found and we need to add it
								//Check that there is not any measurement with this frequency. If this frequency is already processed, skip it
								for(n=0;n<options->numcsSFMeasList[staType][k][l];n++) {
									if(options->csSFMeasFreq[staType][k][l][n][0]==aux3) {
										break;
									}
								}
								if (n==options->numcsSFMeasList[staType][k][l]) {
									//Frequency not parsed. Save it
									options->csSFfreq[staType][k][l][options->numcsSFfreq[staType][k][l]]=aux3;
									options->numcsSFfreq[staType][k][l]++;

								}
							} else if (m<options->numcsSFfreq[staType][k][l] && removeMeas==1) {
								//Frequency found and we need to remove it
								for(n=m+1;n<options->numcsSFfreq[staType][k][l];n++) {
									options->csSFfreq[staType][k][l][n-1]=options->csSFfreq[staType][k][l][n];
								}
								options->numcsSFfreq[staType][k][l]--;
							}
						}
					}
				} else if (mode==parsecsMWfreq || mode==parsecsLIfreq) {
					//MW/LI detector frequencies
					for(k=0;k<2;k++){
						if (p[k]=='\0') {
							sprintf(messagestr,"Missing frequencies for %s cycle-slip detector in '%s'",auxstr2,measText[i]);
							printError(messagestr,options);
						} else if(p[k]<48 || p[k]>57) { //48 is ASCCI '0' and 57 is ASCII '9'
							sprintf(messagestr,"Invalid frequency '%c' for %s cycle-slip detector in '%s'",p[k],auxstr2,measText[i]);
							printError(messagestr,options);
						}
					}
					if (p[0]==p[1]) {
						sprintf(messagestr,"Frequencies in '%s' for %s cycle-slip detector must be different",measText[i],auxstr2);
						printError(messagestr,options);
					}

					auxstr[0]=p[0];
					freq[0]=atoi(auxstr);
					auxstr[0]=p[1];
					freq[1]=atoi(auxstr);
					//Order measurements from smallest frequency to highest
					if (freq[0]==0 || (freq[0]>0 && freq[0]>freq[1])) {
						aux3=freq[0];
						freq[0]=freq[1];
						freq[1]=aux3;
					}
					
					for(k=0;k<MAX_GNSS;k++) {
						if(GNSSused[k]==0) continue;
						for(l=0;l<2;l++) {
							if (availGNSSFreq[k][freq[l]]==0) {
								options->unselUnavailGNSSFreqCS[k][freq[l]]=1;
								break;
							}
						}
						if(l<2) continue;
						for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
							if(PRNused[l]==0) continue;
							if (options->includeSatellite[k][l]==0) continue;
							for(m=0;m<2;m++) {
								if (options->usableFreq[k][l][freq[m]]==0) {
									//Frequency disabled by the user
									sprintf(messagestr,"Selected frequency %d for satellite %s %d for %s cycle-slip detector in parameter '%s', but user has set the frequency as not usable",freq[m],gnsstype2gnssstr(k),l,mode==parsecsMWfreq?"MW":"LI",measText[i]);
									printError(messagestr,options);
								}
							}
							if(mode==parsecsMWfreq) {
								//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
								for(m=0;m<options->numcsMWfreq[staType][k][l];m++) {
									if (options->csMWfreq[staType][k][l][m][0]==freq[0] && options->csMWfreq[staType][k][l][m][1]==freq[1]) {
										//Combination already saved
										break;
									}
								}
								if (m==options->numcsMWfreq[staType][k][l] && removeMeas==0) {
									//Combination not found and we need to add it
									//Check that there is not any measurement with these frequencies. If this frequencies are already processed, skip them
									for(n=0;n<options->numcsMWMeasList[staType][k][l];n++) {
										if(options->csMWMeasFreq[staType][k][l][n][0]==freq[0] && options->csMWMeasFreq[staType][k][l][n][1]==freq[1]) {
											break;
										}
									}
									if (n==options->numcsMWMeasList[staType][k][l]) {
										if (m==MAX_CS_LIST) {
											sprintf(messagestr,"Maximum number of Melbourne-Wubbena cycle-slip combinations per satellite and detection type are %d, but satellite %s %2d has %d combinations",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
											printError(messagestr,options);
										}
										options->csMWfreq[staType][k][l][options->numcsMWfreq[staType][k][l]][0]=freq[0];
										options->csMWfreq[staType][k][l][options->numcsMWfreq[staType][k][l]][1]=freq[1];
										options->numcsMWfreq[staType][k][l]++;

									}
								} else if (m<options->numcsMWfreq[staType][k][l] && removeMeas==1) {
									//Combination found and we need to remove it
									for(n=m+1;n<options->numcsMWfreq[staType][k][l];n++) {
										options->csMWfreq[staType][k][l][n-1][0]=options->csMWfreq[staType][k][l][n][0];
										options->csMWfreq[staType][k][l][n-1][1]=options->csMWfreq[staType][k][l][n][1];
									}
									options->numcsMWfreq[staType][k][l]--;
								}
							} else if (mode==parsecsLIfreq) {
								for(m=0;m<options->numcsLIfreq[staType][k][l];m++) {
									//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
									if (options->csLIfreq[staType][k][l][m][0]==freq[0] && options->csLIfreq[staType][k][l][m][1]==freq[1]) {
										break;
										//Combination already saved
									}
								}
								if (m==options->numcsLIfreq[staType][k][l] && removeMeas==0) {
									//Combination not found and we need to add it
									//Check that there is not any measurement with these frequencies. If this frequencies are already processed, skip them
									for(n=0;n<options->numcsLIMeasList[staType][k][l];n++) {
										if(options->csLIMeasFreq[staType][k][l][n][0]==freq[0] && options->csLIMeasFreq[staType][k][l][n][1]==freq[1]) {
											break;
										}
									}
									if (n==options->numcsLIMeasList[staType][k][l]) {
										if (m==MAX_CS_LIST) {
											sprintf(messagestr,"Maximum number of LI cycle-slip combinations per satellite and detection type are %d, but satellite %s %2d has %d combinations",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
											printError(messagestr,options);
										}
										options->csLIfreq[staType][k][l][options->numcsLIfreq[staType][k][l]][0]=freq[0];
										options->csLIfreq[staType][k][l][options->numcsLIfreq[staType][k][l]][1]=freq[1];
										options->numcsLIfreq[staType][k][l]++;
									}
								} else if (m<options->numcsLIfreq[staType][k][l] && removeMeas==1) {
									//Combination found and we need to remove it
									for(n=m+1;n<options->numcsLIfreq[staType][k][l];n++) {
										options->csLIfreq[staType][k][l][n-1][0]=options->csLIfreq[staType][k][l][n][0];
										options->csLIfreq[staType][k][l][n-1][1]=options->csLIfreq[staType][k][l][n][1];
									}
									options->numcsLIfreq[staType][k][l]--;
								}
							}
						}
					}
				} else {
					//IGF detector frequencies
					for(k=0;k<auxlen;k++){
						if (p[k]=='\0') {
							sprintf(messagestr,"Missing frequencies for %s cycle-slip detector in '%s'",auxstr2,measText[i]);
							printError(messagestr,options);
						} else if(p[k]<48 || p[k]>57) { //48 is ASCCI '0' and 57 is ASCII '9'
							sprintf(messagestr,"Invalid frequency '%c' for %s cycle-slip detector in '%s'",p[k],auxstr2,measText[i]);
							printError(messagestr,options);
						}
					}
					for(k=0;k<auxlen;k++){
						auxstr[0]=p[k];
						freq[k]=freq2[k]=atoi(auxstr);
					}
					if (auxlen!=NUMMEASCSIGF) {
						freq[3]=freq2[3]=freq[0];
					}
					//Check that there are three or four frequencies. To do it, sort the frequency numbers first
					qsort(&freq2,NUMMEASCSIGF,sizeof(int),qsort_compare_int);
					if (freq2[0]!=freq2[1] && freq2[0]!=freq2[2] && freq2[0]!=freq2[3] && freq2[1]!=freq2[2] && freq2[1]!=freq2[3] && freq2[2]!=freq2[3] ) {
						//4 different frequencies
						quadmeas=1;
					} else if (freq2[0]==freq2[1] && freq2[0]!=freq2[2] && freq2[0]!=freq2[3]) {
						//3 different frequencies
						quadmeas=0;
					} else if (freq2[0]!=freq2[1] && freq2[1]==freq2[2] && freq2[1]!=freq2[3]) {
						//3 different frequencies
						quadmeas=0;
					} else if (freq2[0]!=freq2[1] && freq2[1]!=freq2[2] && freq2[2]==freq2[3]) {
						//3 different frequencies
						quadmeas=0;
					} else {
						sprintf(messagestr,"Invalid frequencies in '%s'. For IGF cycle-slip detector, there must be three or four different frequencies",measText[i]);
						printError(messagestr,options);
					}
					for(k=0;k<NUMMEASCSIGF;k++){
						auxstr3[3+k]='0' + (unsigned int)freq[k];
					}
					if (quadmeas==1 && options->csIGFminNoise==1) {
						sprintf(messagestr,"If option '-pre:cs:igf:minnoise' is set, IGF combination can only be built with three frequencies, but user set four different frequencies in '%s'",measText[i]);
						printError(messagestr,options);
					}
					meas = measstr2meastype(auxstr3);
					if(meas==NA) {
						for(n=0;n<2;n++) {
							if(n==1 && quadmeas==1) break;
							for(m=0;m<2;m++) {
								if(m==1) {
									//In second loop, swap order of the combinations
									aux3=freq[0];
									freq[0]=freq[2];
									freq[2]=aux3;
									aux3=freq[1];
									freq[1]=freq[3];
									freq[3]=aux3;
									aux3=(int)auxstr3[3];
									auxstr3[3]=auxstr3[5];
									auxstr3[5]=(char)aux3;
									aux3=(int)auxstr3[4];
									auxstr3[4]=auxstr3[6];
									auxstr3[6]=(char)aux3;
									meas = measstr2meastype(auxstr3);
									if (meas!=NA) break;
								}
								for(k=0;k<3;k++) {
									if(k==0) {
										//Swap first 2 frequency numbers
										aux3=freq[1];
										freq[1]=freq[0];
										freq[0]=aux3;
										aux3=(int)auxstr3[4];
										auxstr3[4]=auxstr3[3];
										auxstr3[3]=(char)aux3;
									} else if (k==1) {
										//Swap last 2 frequency numbers (leaving the first 2 numbers swapped)
										aux3=freq[3];
										freq[3]=freq[2];
										freq[2]=aux3;
										aux3=(int)auxstr3[6];
										auxstr3[6]=auxstr3[5];
										auxstr3[5]=(char)aux3;
									} else {
										//Swap first 2 frequency numbers (so they are as in original position) and leave last 2 numbers swapped
										aux3=freq[1];
										freq[1]=freq[0];
										freq[0]=aux3;
										aux3=(int)auxstr3[4];
										auxstr3[4]=auxstr3[3];
										auxstr3[3]=(char)aux3;
									}
									meas = measstr2meastype(auxstr3);
									if (meas!=NA) break;
								}
								if (meas!=NA) break;
							}
							if (meas!=NA) break;
							else if (quadmeas==0) {
								//In the case of three frequencies, the repeated frequency may be set
								//toguether at the beginning or at the end (example 1123 or 2311)
								//Swap second and third frequency number so there are two pairo od
								//frequencies with the different frequencies
								aux3=freq[1];
								freq[1]=freq[2];
								freq[2]=aux3;
								aux3=(int)auxstr3[4];
								auxstr3[4]=auxstr3[5];
								auxstr3[5]=(char)aux3;
							}
						}
						if (meas==NA) {
							sprintf(messagestr,"Invalid frequencies '%s' in '%s' for IGF cycle-slip detector",p,measText[i]);
							printError(messagestr,options);
						}
					}
					for(k=0;k<MAX_GNSS;k++) {
						if(GNSSused[k]==0) continue;
						for(l=0;l<NUMMEASCSIGF;l++) {
							if (availGNSSFreq[k][freq[l]]==0) {
								options->unselUnavailGNSSFreqCS[k][freq[l]]=1;
								break;
							}
						}
						if(l<NUMMEASCSIGF) continue;
						for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
							if(PRNused[l]==0) continue;
							if (options->includeSatellite[k][l]==0) continue;
							for(m=0;m<NUMMEASCSIGF;m++) {
								if (options->usableFreq[k][l][freq[m]]==0) {
									//Frequency disabled by the user
									sprintf(messagestr,"Selected frequency %d for satellite %s %d for IGF cycle-slip detector in parameter '%s', but user has set the frequency as not usable",freq[m],gnsstype2gnssstr(k),l,measText[i]);
									printError(messagestr,options);
								}
							}
							//Search for repeated combinations, and if already saved, skip it (to avoid having duplicates), or remove it if it is to be removed
							for(m=0;m<options->numcsIGFfreq[staType][k][l];m++) {
								if (options->csIGFfreq[staType][k][l][m][0]==freq[0] && options->csIGFfreq[staType][k][l][m][1]==freq[1] 
										&& options->csIGFfreq[staType][k][l][m][2]==freq[2] && options->csIGFfreq[staType][k][l][m][3]==freq[3] ) {
									//Frequencies already saved. Skip repeated frequencies
									break;
								}
							}
							if (m==options->numcsIGFfreq[staType][k][l] && removeMeas==0) {
								//Combination not found and we need to add it
								//Check that there is not any measurement with these frequencies. If this frequencies are already processed, skip them
								for(n=0;n<options->numcsIGFMeasList[staType][k][l];n++) {
									if(options->csIGFMeasFreq[staType][k][l][n][0]==freq[0] && options->csIGFMeasFreq[staType][k][l][n][1]==freq[1]
											&& options->csIGFMeasFreq[staType][k][l][n][2]==freq[2] && options->csIGFMeasFreq[staType][k][l][n][3]==freq[3]) {
										break;
									}
								}
								if (n==options->numcsIGFMeasList[staType][k][l]) {
									if (m==MAX_CS_LIST) {
										sprintf(messagestr,"Maximum number of IGF cycle-slip combinations per satellite and detection type are %d, but satellite %s %2d has %d combinations",MAX_CS_LIST,gnsstype2gnssstr(k),l,MAX_CS_LIST+1);
										printError(messagestr,options);
									}
									options->csIGFfreq[staType][k][l][options->numcsIGFfreq[staType][k][l]][0]=freq[0];
									options->csIGFfreq[staType][k][l][options->numcsIGFfreq[staType][k][l]][1]=freq[1];
									options->csIGFfreq[staType][k][l][options->numcsIGFfreq[staType][k][l]][2]=freq[2];
									options->csIGFfreq[staType][k][l][options->numcsIGFfreq[staType][k][l]][3]=freq[3];
									options->numcsIGFfreq[staType][k][l]++;
								}
							} else if (m<options->numcsIGFfreq[staType][k][l] && removeMeas==1) {
								//Combination found and we need to remove it
								for(n=m+1;n<options->numcsIGFfreq[staType][k][l];n++) {
									options->csIGFfreq[staType][k][l][n-1][0]=options->csIGFfreq[staType][k][l][n][0];
									options->csIGFfreq[staType][k][l][n-1][1]=options->csIGFfreq[staType][k][l][n][1];
									options->csIGFfreq[staType][k][l][n-1][2]=options->csIGFfreq[staType][k][l][n][2];
									options->csIGFfreq[staType][k][l][n-1][3]=options->csIGFfreq[staType][k][l][n][3];
								}
								options->numcsIGFfreq[staType][k][l]--;
							}
						}
					}
				}
				if (j<(aux2-1)) {
					if (p3!=NULL) {
						*p3='.';
						p=p3+1;
						p3=strchr(p,'.');
						if (p3!=NULL) *p3='\0';
					}
				}
			}
		}


	////////////////////////////////////////////////////////////////////////////
	////// Parsing filter measurements, smoothing measurements and weight modes

	} else {
		switch (mode) {
			case parseFiltermeas:
				//Reading list of measurements for the filter
				numMeasRead=sopt->numMeasFilterText[staType];
				measText=sopt->measFilterText[staType];
				break;
			case parseSmoothFiltermeas:
				//Reading list of measurements to be smoothed
				numMeasRead=sopt->numSmoothMeasFilterText[staType];
				measText=sopt->smoothMeasFilterText[staType];
				break;
			case parseDopplermeas:
				//Reading list of doppler measurements for speed computation
				numMeasRead=sopt->numMeasDopplerText[staType];
				measText=sopt->measDopplerText[staType];
				break;
			case parseWeightFiltermeas:
				//Reading measurement weight types
				numMeasRead=sopt->numweightText;
				measText=sopt->weightText;
				measTextSat=sopt->weightTextSat;
				break;
			case parseWeightCombFiltermeas:
				//Reading measurement weight combination modes
				numMeasRead=sopt->numweightTextComb;
				measText=sopt->weightTextComb;
				measTextSat=sopt->weightTextCombSat;
				break;
			default:
				//Reading measurement weight modes
				numMeasRead=sopt->numweightTextMode;
				measText=sopt->weightTextMode;
				measTextSat=sopt->weightTextModeSat;
				break;
		}
		for(i=0;i<numMeasRead;i++) {
			filterMeasPosition=-1;
			autoMeasGNSS=0;
			autoMeasSmoothGNSS=0;
			for(h=0;h<2;h++) {
				if(h==0) {
					for(j=0;j<MAX_GNSS;j++) {
						GNSSused[j]=0;
					}
					for(j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
						PRNused[j]=0;
					}
					if (mode==parseSmoothFiltermeas) measText=sopt->smoothMeasFilterText[staType];
				} else {
					if(mode!=parseSmoothFiltermeas) break; //Loop twice only when reading smooth measurements (as we have the measurement to smooth and the measurement to smooth with)
					//Save measurement decoded. Now decode measurement to smooth with
					for(j=0;j<4;j++) {
						measlistSmooth[j]=measlist[j];
						measKindSmooth[j]=measKind[j];
					}
					numMeasCombSmooth=numMeasComb;
					measSmooth=meas;	
					meastypeSmooth=meastype;
					userMeasSmooth=userMeas;
					measText=sopt->smoothWithMeasFilterText[staType];
					removeMeasSmooth=removeMeas;
				}
				userMeas=0;
				quadmeas=0;
				ComboPhaseAndCode=0;

				if (mode==parseSmoothFiltermeas && h==1 && (measText[i][0]=='+' || measText[i][0]=='-') ) {
					sprintf(messagestr,"When entering measurements to smooth with, no sign ('+' or '-') must be provided, but user provided '%s'",measText[i]);
					printError(messagestr,options);
				}
				// When reading measurements for smoothing, in old mode the first item was the position in the filter list
				if(mode==parseSmoothFiltermeas && h==0 && strlen(measText[i])==1) {
					if(measText[i][0]<=48 || measText[i][0]>57) { //48 is ASCII '0' and 57 is ASCII '9'
						sprintf(messagestr,"Position '%s' is not a valid number for the measurement filter position in the '-pre:smoothmeas' option",measText[i]);
						printError(messagestr,options);
					}
					filterMeasPosition=atoi(measText[i])-1; //Measurement positions start at 0, but filter measurement number start at 1
					GNSSused[GPS]=1;
					continue;
				}
				//When setting weights, they might be given in the old mode (position of the measurement)
				if (mode>=parseWeightFiltermeas && h==0 && strlen(measText[i])==1) {
					if(measText[i][0]<48 || measText[i][0]>57) { //48 is ASCII '0' and 57 is ASCII '9'
						sprintf(messagestr,"Position '%s' is not a valid number for the measurement filter position for the weighting modes options",measText[i]);
						printError(messagestr,options);
					}
					if (measText[i][0]=='0') {
						startfilterMeas=0;
						EndfilterMeas=MAX_FILTER_MEASUREMENTS_SAT-1;
					} else {
						startfilterMeas=EndfilterMeas=atoi(measText[i])-1; //Measurement positions start at 0, but filter measurement number start at 1
					}
					if (measTextSat[i][0]!='\0') {
						parseSatellitelist(measTextSat[i],0,&removeMeas,&lastCharac,GNSSused,PRNused,options);
					} else {
						GNSSused[GPS]=1;
						for(j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
							PRNused[j]=1;
						}
					}
					for(j=0;j<MAX_GNSS;j++) {
						if(GNSSused[j]==0) continue;
						for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
							if(PRNused[k]==0) continue;
							if (options->includeSatellite[j][k]==0) continue;
							for(l=startfilterMeas;l<=EndfilterMeas;l++) {
								if (mode==parseWeightFiltermeas) { 
									options->weightMode[j][k][l]=sopt->weightMode[i];
									options->WeightConstantsValues[j][k][l][0]=sopt->WeightConstantsValues[i][0];
									options->WeightConstantsValues[j][k][l][1]=sopt->WeightConstantsValues[i][1];
									options->WeightConstantsValues[j][k][l][2]=sopt->WeightConstantsValues[i][2];
									if (sopt->WeightConstantsValues[i][0]==0.&& sopt->WeightConstantsValues[i][1]==0.) {
										sprintf(messagestr,"Constants 'a' and 'b' cannot be both 0 for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
										printError(messagestr,options);
									} else if (sopt->WeightConstantsValues[i][0]==-2 && sopt->navMode==NMppp) {
										sprintf(messagestr,"URA value for weights cannot be used in PPP mode for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
											printError(messagestr,options);
									}
								} else if (mode==parseWeightCombFiltermeas) {
									options->SNRweightComb[j][k][l]=sopt->SNRweightComb[i];
									options->SNRweightCombVal[j][k][l][0]=sopt->SNRweightCombVal[i][0];
									options->SNRweightCombVal[j][k][l][1]=sopt->SNRweightCombVal[i][1];
									options->SNRweightCombVal[j][k][l][2]=sopt->SNRweightCombVal[i][2];
									options->SNRweightCombVal[j][k][l][3]=sopt->SNRweightCombVal[i][3];
								} else { 
									if (sopt->CombineWeightMode[i]==ComputedOnly) {
										if (options->SBAScorrections>=SBAS1Fused) {
											options->weightMode[j][k][l]=SBASOnlyWeight;
										} else if (options->DGNSS==1) {
											options->weightMode[j][k][l]=DGNSSOnlyWeight;
										}
									} else if(sopt->CombineWeightMode[i]==ComputedPlusUser) {
										if (options->SBAScorrections>=SBAS1Fused && options->weightMode[j][k][l]!=UnknownWeight) {
											options->weightMode[j][k][l]=SBASFixedWeight+options->weightMode[j][k][l];
										} else if (options->DGNSS==1 && options->weightMode[j][k][l]!=UnknownWeight) {
											options->weightMode[j][k][l]=DGNSSFixedWeight+options->weightMode[j][k][l];
										}
									}
								}
							}
						}	
					}
					continue;
				//Search first for measurements set as in previous versions
				} else if (strlen(measText[i])==2||strlen(measText[i])==3) {
					removeMeas=0;
					userMeas=1;
					if (strcasecmp(measText[i],"PN")==0) {
						meas=PN12;
						meastype=OTHER_MEAS;
						numMeasComb=2;
						measlist[0]=C1P;
						measlist[1]=C2P;
						measKind[0]=Pseudorange;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Narrow lane combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"PI")==0) {
						meas=PI12;
						meastype=OTHER_MEAS;
						numMeasComb=2;
						measlist[0]=C1P;
						measlist[1]=C2P;
						measKind[0]=Pseudorange;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Geometry free combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"PC")==0) {
						meas=PC12;
						meastype=IonoFreeCombCode;
						numMeasComb=2;
						measlist[0]=C1P;
						measlist[1]=C2P;
						measKind[0]=Pseudorange;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Code ionosphere free combination '%s' is not valid for Doppler. Use 'IF12' instead",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"PCC")==0) {
						if(mode==parseSmoothFiltermeas && h==1) {
							sprintf(messagestr,"Measurement '%s' is not valid for smoothing",measText[i]);
							printError(messagestr,options);
						}
						meas=PC12;
						meastype=IonoFreeCombCode;
						numMeasComb=2;
						measlist[0]=C1C;
						measlist[1]=C2P;
						measKind[0]=Pseudorange;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Code ionosphere free combination '%s' is not valid for Doppler. Use 'IF12' instead",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"LC")==0) {
						meas=LC12;
						meastype=IonoFreeCombPhase;
						numMeasComb=2;
						measlist[0]=L1P;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseFiltermeas) options->usePhase=1;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Carrier phase ionosphere free combination '%s' is not valid for Doppler. Use 'IF12' instead",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"LW")==0) {
						meas=LW12;
						meastype=OTHER_MEAS;
						numMeasComb=2;
						measlist[0]=L1P;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Wide lane combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"LI")==0) {
						meas=LI12;
						meastype=OTHER_MEAS;
						numMeasComb=2;
						measlist[0]=L1P;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Geometry free combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"MW")==0) {
						meas=MW12;
						meastype=OTHER_MEAS;
						numMeasComb=4;
						measlist[0]=C1P;
						measlist[1]=C2P;
						measlist[2]=L1P;
						measlist[3]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseDopplermeas) {
							sprintf(messagestr,"Melbourne Wubenna combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"IF")==0) {
						meas=IF12;
						meastype=IonoFreeCombPhase;
						numMeasComb=2;
						measlist[0]=L1P;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseFiltermeas) options->usePhase=1;
					} else if (strcasecmp(measText[i],"DF")==0) {
						meas=DF12;
						meastype=DivergenceFreePhase;
						numMeasComb=2;
						measlist[0]=L1P;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=2;
						if (mode==parseFiltermeas) options->usePhase=1;
					} else if (strcasecmp(measText[i],"G1C")==0) {
						meas=G1;
						meastype=GraphicComb;
						numMeasComb=2;
						measlist[0]=C1C;
						measlist[1]=L1P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=1;
						if (mode==parseFiltermeas) options->usePhase=1;
						else if (mode==parseDopplermeas) {
							sprintf(messagestr,"Graphic combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"G1P")==0) {
						meas=G1;
						meastype=GraphicComb;
						numMeasComb=2;
						measlist[0]=C1P;
						measlist[1]=L1P;
						measKind[0]=CarrierPhase;
						freq[0]=1;
						freq[1]=1;
						if (mode==parseFiltermeas) options->usePhase=1;
						else if (mode==parseDopplermeas) {
							sprintf(messagestr,"Graphic combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"G2C")==0) {
						meas=G2;
						meastype=GraphicComb;
						numMeasComb=2;
						measlist[0]=C2C;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=2;
						freq[1]=2;
						if (mode==parseFiltermeas) options->usePhase=1;
						else if (mode==parseDopplermeas) {
							sprintf(messagestr,"Graphic combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(measText[i],"G2P")==0) {
						meas=G2;
						meastype=GraphicComb;
						numMeasComb=2;
						measlist[0]=C2P;
						measlist[1]=L2P;
						measKind[0]=CarrierPhase;
						freq[0]=2;
						freq[1]=2;
						if (mode==parseFiltermeas) options->usePhase=1;
						else if (mode==parseDopplermeas) {
							sprintf(messagestr,"Graphic combination '%s' is not valid for Doppler",measText[i]);
							printError(messagestr,options);
						}
					} else if ((strlen(measText[i])==2 && (measText[i][0]=='G'||measText[i][0]=='g') && (measText[i][1]>=48 && measText[i][1]<=57)) ) {
						//This case are Graphic combination G1,G2,G3,..G0
						if (h==0) {
							if (mode==parseDopplermeas) {
								sprintf(messagestr,"Graphic combination '%s' is not valid for Doppler",measText[i]);
								printError(messagestr,options);
							}
					  		//These can only be set in the new format, not just only G0 (when set to the filter),
							//as it could confuse the combination G0 with satellite selection G0 (being all GPS satellites)
							sprintf(messagestr,"Graphic combination for the filter must be provided with the satellites to be used (for instance 'GE0-%s'), but user only provided '%s'",measText[i],measText[i]);
							printError(messagestr,options);
						} else {
							//For the smoothing G1, G2, G3, ... can be set
							auxstr[0]=toupper(measText[i][0]);
							auxstr[1]=measText[i][1];
							auxstr[2]='\0';
							meas=measstr2meastype(auxstr);
							meastype=GraphicComb;
							numMeasComb=2;
							measKind[0]=CarrierPhase;
							freq[0]=freq[1]=getFrequencyInt(meas);
							userMeas=0;
						}
					} else {
						//Look for RINEX 2/3 measurements (C1,P1,L1,C1C,L1P,...)
						//Check first it is not a graphic combination such as '+G1'
						if ((strlen(measText[i])==3 && (measText[i][0]=='+'||measText[i][0]=='-') && (measText[i][1]=='G'||measText[i][1]=='g') 
									&& (measText[i][2]>=48 && measText[i][2]<=57)) ) {
							if (h==0) {
					  			//These can only be set in the new format, not just only G0 (when set to the filter),
								//as it could confuse the combination G0 with satellite selection G0 (being all GPS satellites)
								sprintf(messagestr,"Graphic combination for the filter must be provided with the satellites to be used (for instance '%cGE0-%s'), but user only provided '%s'",measText[i][0],&measText[i][1],measText[i]);
								printError(messagestr,options);
							} else {
								sprintf(messagestr,"When entering measurements to smooth with, no sign ('+' or '-') must be provided, but user provided '%s'",measText[i]);
								printError(messagestr,options);
							}
						}
						for(j=0;j<(int)strlen(measText[i]);j++) {
							auxstr[j]=toupper(measText[i][j]); //Transform to upper case characters
						}
						auxstr[j]='\0';
						meas=measstr2meastype(auxstr);
						numMeasComb=1;
						measlist[0]=meas;
						if (meas==NA) {
							sprintf(messagestr,"Unknown measurement '%s'",measText[i]);
							printError(messagestr,options);
						}
						measKind[0]=whatIs(meas);
						if(h==0) {
							if (mode==parseDopplermeas) {
								if (measKind[0]!=Doppler) {
									sprintf(messagestr,"Measurement '%s' is not a Doppler measurement",measText[i]);
									printError(messagestr,options);
								}
							} else if ( (measKind[0]!=Pseudorange && measKind[0]!=CarrierPhase) || (meas>=I1 && meas<=MW) ) {
								sprintf(messagestr,"Measurement '%s' is not valid for navigation",measText[i]);
								printError(messagestr,options);
							}
						} else {
							if ( (measKind[0]!=CarrierPhase) || (meas>=I1 && meas<=MW) ) {
								sprintf(messagestr,"Measurement '%s' is not valid for smoothing",measText[i]);
								printError(messagestr,options);
							}
						}
						if (measKind[0]==Pseudorange) {
							meastype=SinglePseudorange;
						} else if (measKind[0]==Doppler) {
							meastype=SingleDoppler;
						} else {
							meastype=SingleCarrierPhase;
							if (mode==parseFiltermeas) options->usePhase=1;
						}
						getFrequencyIntCombinations(meas,freq);
					}
					if (mode!=parseSmoothFiltermeas && meastype==OTHER_MEAS) {
						sprintf(messagestr,"Measurement type '%s' is not a valid measurement for the filter",measText[i]);
						printError(messagestr,options);
					} else if (mode==parseSmoothFiltermeas && h==1 && ( meastype==OTHER_MEAS || measKind[0]!=CarrierPhase)) {
						sprintf(messagestr,"Measurement '%s' is not valid for smoothing",measText[i]);
						printError(messagestr,options);
					}
					if (mode==parseWeightFiltermeas && measTextSat[i][0]!='\0') {
						parseSatellitelist(measTextSat[i],0,&removeMeas,&lastCharac,GNSSused,PRNused,options);
					} else if (h==0) {
						GNSSused[GPS]=1;
						for(j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
							PRNused[j]=1;
						}
					}
					for(j=0;j<MAX_GNSS;j++) {
						if(GNSSused[j]==0) continue;
						for(k=0;k<numMeasComb;k++) {
							if (availGNSSFreq[j][freq[k]]==0) {
								options->unselUnavailGNSSFreqFilter[j][freq[k]]=1;
								GNSSused[j]=0;
							}
						}
						if(roundMode==0) {
							for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
								if(PRNused[k]==0) continue;
								if (options->includeSatellite[j][k]==0) continue;
								for(l=0;l<numMeasComb;l++) {
									if (options->usableFreq[j][k][freq[l]]==0) {
										//Frequency disabled by the user
										sprintf(messagestr,"Selected frequency %d for satellite %s %d for filter measurement in parameter '%s', but user has set the frequency as not usable",freq[l],gnsstype2gnssstr(j),k,measText[i]);
										printError(messagestr,options);
									}
								}
							}
						}
					}
					if (mode==parseFiltermeas) {
						for(j=1;j<MAX_SATELLITES_PER_GNSS;j++) {
							if (options->includeSatellite[GPS][j]==0) continue;
							//Check that measurement is not in the list (avoid repeating measurements)
							for(k=0;k<options->numfilterMeasList[staType][GPS][j];k++) {
								if (options->filterMeasTypeList[staType][GPS][j][k]==meastype && 
										options->filterMeasKind[staType][GPS][j][k]==measKind[0] &&
										options->filterMeasList[staType][GPS][j][k][0]==meas &&
										options->filterListWithMeas[staType][GPS][j][k]==userMeas) 
								{
									aux3=0;
									for(m=0;m<numMeasComb;m++) {
										if(options->filterMeasList[staType][GPS][j][k][m+1]==measlist[m]) {
											aux3++;
										} else {
											break;
										}
									}
									if (aux3==numMeasComb) { 
										//Measurement already in list
										break;
									}
								}
							}
							if (k==options->numfilterMeasList[staType][GPS][j]) {
								if (k==MAX_FILTER_MEASUREMENTS_SAT) {
									sprintf(messagestr,"Maximum number of measurements per satellite are %d, but satellite GPS %2d has %d measurements",MAX_FILTER_MEASUREMENTS_SAT,j,MAX_FILTER_MEASUREMENTS_SAT+1);
									printError(messagestr,options);
								}
								options->filterMeasList[staType][GPS][j][k][0]=meas;
								options->filterMeasTypeList[staType][GPS][j][k]=meastype;
								options->filterMeasKind[staType][GPS][j][k]=measKind[0];
								options->filterListWithMeas[staType][GPS][j][k]=userMeas;
								options->filterListMeasSelected[staType][GPS][j][k]=userMeas;
								options->numCombfilterMeas[staType][GPS][j][k]=numMeasComb;
								for(l=0;l<numMeasComb;l++) {
									options->filterMeasList[staType][GPS][j][k][l+1]=measlist[l];
								}
								for(l=0;l<4;l++) {
									options->filterMeasfreq[staType][GPS][j][k][l]=freq[l];
								}
								options->numfilterMeasList[staType][GPS][j]++;
							}
						}
					} else if (mode==parseSmoothFiltermeas) {
						if(h==0) {
							//Save first frequency (only to be used for single automatic measurements)
							freqAutoSmooth=freq[0];
							continue;
						}
						if (filterMeasPosition==-1) {
							//Search for provided measurement in the filter. If found, save the measurement to smoothWith
							for(j=0;j<MAX_GNSS;j++) {
								if(GNSSused[j]==0) continue;
								for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
									if(PRNused[k]==0) continue;
									if (options->includeSatellite[GPS][j]==0) continue;
									for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
										if (options->filterMeasTypeList[staType][j][k][l]==meastypeSmooth 
												&& options->filterMeasKind[staType][j][k][l]==measKindSmooth[0] 
												&& options->filterListWithMeas[staType][j][k][l]==userMeasSmooth 
												&& options->filterMeasList[staType][j][k][l][0]==measSmooth) {
											if (measSmooth==NA) {
												//In the case of automatic measurement, we need to check the frequency,
												if (options->filterMeasfreq[staType][j][k][l][0]!=freqAutoSmooth) {
													//Frequencies don't match. They are different measurements
													continue;
												}
											}
											if(userMeasSmooth==1) {
												aux3=0;
												for(m=0;m<numMeasCombSmooth;m++) {
													if(options->filterMeasList[staType][j][k][l][m+1]==measlistSmooth[m]) {
														aux3++;
													} else {
														break;
													}
												}
											} else {
												aux3=numMeasCombSmooth;
											}
											if (aux3==numMeasCombSmooth) { 
												//All measurements match 
												if (options->filterMeasKind[staType][j][k][l]!=Pseudorange) {
													if (options->filterMeasList[staType][j][k][l][0]==NA) {
														sprintf(messagestr,"Automatic carrier phase measurement from frequency %d (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",options->filterMeasfreq[staType][j][k][l][0],gnsstype2gnssstr(j),k);
													} else {
														sprintf(messagestr,"%s carrier phase measurement (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",meastype2measstr(options->filterMeasList[staType][j][k][l][0]),gnsstype2gnssstr(j),k);
													}
													printError(messagestr,options);
												}
												if(removeMeasSmooth==0) {
													//Save smoothing measurements
													options->filterSmoothMeasList[staType][j][k][l][0]=meas;
													options->filterMeasSmoothed[staType][j][k][l]=1;
													options->filterSmoothListWithMeas[staType][j][k][l]=userMeas;
													options->filterSmoothListMeasSelected[staType][j][k][l]=userMeas;
													options->numCombfilterSmoothMeas[staType][j][k][l]=numMeasComb;
													options->filterMeasTypeList[staType][j][k][l]++;
													for(m=1;m<=numMeasComb;m++) {
														options->filterSmoothMeasList[staType][j][k][l][m]=measlist[m-1];
													}
													for(m=0;m<4;m++) {
														options->filterSmoothMeasfreq[staType][j][k][l][m]=freq[m];
													}
												} else {
													//Remove smoothing from measurement
													options->filterMeasSmoothed[staType][j][k][l]=0;
													options->filterMeasTypeList[staType][j][k][l]--;
												}
												break;
											}
										}
									}
								}
							}	
						} else {
							//Compatibility mode where the position of the measurement in the list was given
							for(j=1;j<MAX_SATELLITES_PER_GNSS;j++) {
								if (options->includeSatellite[GPS][j]==0) continue;
								if(options->filterMeasKind[staType][GPS][j][filterMeasPosition]!=Pseudorange) {
									if (options->filterMeasList[staType][GPS][j][filterMeasPosition][0]==NA) {
										sprintf(messagestr,"Automatic carrier phase measurement from frequency %d (for GPS %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",options->filterMeasfreq[staType][GPS][j][filterMeasPosition][0],j);
									} else {
										sprintf(messagestr,"%s carrier phase measurement (for GPS %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",meastype2measstr(options->filterMeasList[staType][GPS][j][filterMeasPosition][0]),j);
									}
									printError(messagestr,options);
								}
								//Save smoothing measurements
								if (filterMeasPosition<options->numfilterMeasList[staType][j][k]) { //Check that PRN has as much measurements as the position points to
									options->filterSmoothMeasList[staType][GPS][j][filterMeasPosition][0]=meas;
									options->filterSmoothListWithMeas[staType][GPS][j][filterMeasPosition]=userMeas;
									options->filterSmoothListMeasSelected[staType][GPS][j][filterMeasPosition]=userMeas;
									options->numCombfilterSmoothMeas[staType][GPS][j][filterMeasPosition]=numMeasComb;
									options->filterMeasTypeList[staType][GPS][j][filterMeasPosition]++;
									for(l=1;l<=numMeasComb;l++) {
										options->filterSmoothMeasList[staType][GPS][j][filterMeasPosition][l]=measlist[l-1];
									}
									for(l=0;l<4;l++) {
										options->filterSmoothMeasfreq[staType][GPS][j][filterMeasPosition][l]=freq[l];
									}
								}
							}	
						}
					} else if (mode==parseDopplermeas) {
						//Save Doppler measurements
						for(j=1;j<MAX_SATELLITES_PER_GNSS;j++) {
							if (options->includeSatellite[GPS][j]==0) continue;
							//Check that measurement is not in the list (avoid repeating measurements)
							for(k=0;k<options->numDopplerMeasList[staType][GPS][j];k++) {
								if (options->DopplerMeasTypeList[staType][GPS][j][k]==meastype && 
										measKind[0]==Doppler &&
										options->DopplerMeasList[staType][GPS][j][k][0]==meas &&
										options->DopplerListWithMeas[staType][GPS][j][k]==userMeas) 
								{
									aux3=0;
									for(m=0;m<numMeasComb;m++) {
										if(options->DopplerMeasList[staType][GPS][j][k][m+1]==measlist[m]) {
											aux3++;
										} else {
											break;
										}
									}
									if (aux3==numMeasComb) { 
										//Measurement already in list
										break;
									}
								}
							}
							if (k==options->numDopplerMeasList[staType][GPS][j]) {
								if (k==MAX_FILTER_MEASUREMENTS_SAT) {
									sprintf(messagestr,"Maximum number of measurements per satellite are %d, but satellite GPS %2d has %d measurements",MAX_FILTER_MEASUREMENTS_SAT,j,MAX_FILTER_MEASUREMENTS_SAT+1);
									printError(messagestr,options);
								}
								options->DopplerMeasList[staType][GPS][j][k][0]=meas;
								options->DopplerMeasTypeList[staType][GPS][j][k]=meastype;
								options->DopplerListWithMeas[staType][GPS][j][k]=userMeas;
								options->DopplerListMeasSelected[staType][GPS][j][k]=userMeas;
								options->numCombDopplerMeas[staType][GPS][j][k]=numMeasComb;
								for(l=0;l<numMeasComb;l++) {
									options->DopplerMeasList[staType][GPS][j][k][l+1]=measlist[l];
								}
								for(l=0;l<4;l++) {
									options->DopplerMeasfreq[staType][GPS][j][k][l]=freq[l];
								}
								options->numDopplerMeasList[staType][GPS][j]++;
							}
						}
					} else {
						//Search for provided measurement in the filter. If found, save the weight
						for(j=0;j<MAX_GNSS;j++) {
							if(GNSSused[j]==0) continue;
							for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
								if(PRNused[k]==0) continue;
								if (options->includeSatellite[j][k]==0) continue;
								for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
									if (options->filterMeasTypeList[staType][j][k][l]<DivergenceFreeCodeSmoothed && options->filterMeasTypeList[staType][j][k][l]!=OTHER_MEAS) {
										meastypeSmooth=meastype+1;
									} else {
										meastypeSmooth=meastype;
									}
									if ( (options->filterMeasTypeList[staType][j][k][l]==meastype || options->filterMeasTypeList[staType][j][k][l]==meastypeSmooth)
											&& options->filterMeasKind[staType][j][k][l]==measKind[0] 
											&& options->filterListWithMeas[staType][j][k][l]==userMeas 
											&& options->filterMeasList[staType][j][k][l][0]==meas) {
										if(userMeas==1) {
											aux3=0;
											for(m=0;m<numMeasComb;m++) {
												if(options->filterMeasList[staType][j][k][l][m+1]==measlist[m]) {
													aux3++;
												} else {
													break;
												}
											}
										} else {
											aux3=numMeasComb;
										}
										if (aux3==numMeasComb) { 
											//All measurements match, save weight modes
											if (mode==parseWeightFiltermeas){
												options->weightMode[j][k][l]=sopt->weightMode[i];
												options->WeightConstantsValues[j][k][l][0]=sopt->WeightConstantsValues[i][0];
												options->WeightConstantsValues[j][k][l][1]=sopt->WeightConstantsValues[i][1];
												options->WeightConstantsValues[j][k][l][2]=sopt->WeightConstantsValues[i][2];
												if (sopt->WeightConstantsValues[i][0]==0.&& sopt->WeightConstantsValues[i][1]==0.) {
													sprintf(messagestr,"Constants 'a' and 'b' cannot be both 0 for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
													printError(messagestr,options);
												} else if (sopt->WeightConstantsValues[i][0]==-2 && sopt->navMode==NMppp) {
													sprintf(messagestr,"URA value for weights cannot be used in PPP mode for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
														printError(messagestr,options);
												}
											} else if (mode==parseWeightCombFiltermeas) {
												options->SNRweightComb[j][k][l]=sopt->SNRweightComb[i];
												options->SNRweightCombVal[j][k][l][0]=sopt->SNRweightCombVal[i][0];
												options->SNRweightCombVal[j][k][l][1]=sopt->SNRweightCombVal[i][1];
												options->SNRweightCombVal[j][k][l][2]=sopt->SNRweightCombVal[i][2];
												options->SNRweightCombVal[j][k][l][3]=sopt->SNRweightCombVal[i][3];
											} else {
												if (sopt->CombineWeightMode[i]==ComputedOnly) {
													if (options->SBAScorrections>=SBAS1Fused) {
														options->weightMode[j][k][l]=SBASOnlyWeight;
													} else if (options->DGNSS==1) {
														options->weightMode[j][k][l]=DGNSSOnlyWeight;
													}
												} else if(sopt->CombineWeightMode[i]==ComputedPlusUser) {
													if (options->SBAScorrections>=SBAS1Fused && options->weightMode[j][k][l]!=UnknownWeight) {
														options->weightMode[j][k][l]=SBASFixedWeight+options->weightMode[j][k][l];
													} else if (options->DGNSS==1 && options->weightMode[j][k][l]!=UnknownWeight) {
														options->weightMode[j][k][l]=DGNSSFixedWeight+options->weightMode[j][k][l];
													}
												}
											}
											break;
										}
									}
								}
							}	
						}
					}
					continue;
				} else {
					//Check for measurements in new mode
					autoSingleMeas=0;
					if(h==0) {
						parseSatellitelist(measText[i],1,&removeMeas,&lastCharac,GNSSused,PRNused,options);
						p=&measText[i][lastCharac]+2; //lastCharac points to the position before the '-'
						if(*p=='\0') {
							sprintf(messagestr,"Unknown measurement '%s'",measText[i]);
							printError(messagestr,options);
						}
						p2=strchr(p,'-');
						if(p2!=NULL) {
							*p2='\0';
							userMeas=1;
						}
					} else {
						//Second measurement read to smooth with. In this second measurement satellite range or constellation is not provided
						p2=strchr(measText[i],'-');
						if(p2!=NULL) {
							*p2='\0';
							userMeas=1;
						}
						p=measText[i];
					}
					//Check if measurement is a "auto", "Code" or "Phase"
					if (strcasecmp(p,"auto")==0) {
						for(j=0;j<MAX_GNSS;j++) {
							if(GNSSused[j]==0) continue;
							for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
								if(PRNused[k]==0) continue;
								if(h==0) {
									if (options->autoMeasSatByUser[j][k]==0) {
										sprintf(messagestr,"Satellite %c%02d cannot be set to both automatic and manual selection of measurements",gnsstype2char(j),k);
										printError(messagestr,options);
									}
									options->numAutoMeasSatByUser++;
									options->autoMeasSatByUser[j][k]=1;
									autoMeasGNSS=1;
								} else {
									if (options->autoMeasSmoothSatByUser[j][k]==0) {
										sprintf(messagestr,"Satellite %c%02d cannot be set to both automatic and manual smoothing",gnsstype2char(j),k);
										printError(messagestr,options);
									}
									options->numAutoMeasSmoothSatByUser++;
									options->autoMeasSmoothSatByUser[j][k]=1;
									autoMeasSmoothGNSS=1;
								}
							}
						}
						continue;
					} else if (strcasecmp(p,"Pseudorange")==0||strcasecmp(p,"Code")==0) {
						autoSingleMeas=1;
						measKind[0]=Pseudorange;
						meastype=SinglePseudorange;
						meas=NA;
						numMeasComb=1;
						measlist[0]=NA;
						if (h==1) {
							sprintf(messagestr,"Code measurements are not valid for smoothing as stated in argument '%s'",measText[i]);
							printError(messagestr,options);
						}
					} else if (strcasecmp(p,"CarrierPhase")==0||strcasecmp(p,"Phase")==0) {
						autoSingleMeas=1;
						measKind[0]=CarrierPhase;
						meastype=SingleCarrierPhase;
						meas=NA;
						numMeasComb=1;
						measlist[0]=NA;
						if (mode==parseFiltermeas) options->usePhase=1;
					} else if (strcasecmp(p,"CodePhase")==0||strcasecmp(p,"PhaseCode")==0||strcasecmp(p,"CoPh")==0||strcasecmp(p,"PhCo")==0) {
						//Special word to add both code and phase in one iteration
						//To add both, first the code measurement and the carrier phase will be added
						autoSingleMeas=1;
						ComboPhaseAndCode=1;
						measKind[0]=Pseudorange;
						meastype=SinglePseudorange;
						meastypeAlt=SingleCarrierPhase;
						meas=NA;
						numMeasComb=1;
						measlist[0]=NA;
						if (h==1) {
							sprintf(messagestr,"Code measurements are not valid for smoothing as stated in argument '%s'",measText[i]);
							printError(messagestr,options);
						}
						if (mode==parseFiltermeas) options->usePhase=1;
					} else if (strcasecmp(p,"Doppler")==0) {
						autoSingleMeas=1;
						measKind[0]=Doppler;
						meastype=SingleDoppler;
						meas=NA;
						numMeasComb=1;
						measlist[0]=NA;
					}
					if (autoMeasGNSS==1 && autoMeasSmoothGNSS==0) {
						sprintf(messagestr,"It is not possible to apply specific smoothing measurements to automatic selected measurement in argument '%s'",measText[i]);
						printError(messagestr,options);
					}

					if (autoSingleMeas==1) {
						if (userMeas==0) {
							sprintf(messagestr,"When selecting single measurement in automatic mode, the frequency number must be provided at the end after a hyphen ('-'), but in '%s' it is missing",measText[i]);
							printError(messagestr,options);
						}
						*p2='-';
						p=p2+1;
						if (strlen(p)!=1) {
							sprintf(messagestr,"Invalid frequency in '%s' for single measurement in automatic mode",measText[i]);
							printError(messagestr,options);
						}
						freq3[0]=atoi(p);
						if(h==0) {
							//Save first frequency (only to be used for single automatic measurements)
							freqAutoSmooth=freq3[0];
						}
						userMeas=0;
					} else {
						//Read measurement type
						strcpy(auxstr,p);
						aux1=(int)strlen(auxstr);
						if(aux1>=4 && aux1<8) {
							//Measurement is a combination. Order numbers in ascendent order (but with '0' at the end)
							aux2=0;
							//Search for the last numbers in the string and put them in an integer vector (using the ASCII integer code)
							for (j=aux1-1;j>=0;j--) {
								if (auxstr[j]<48 || auxstr[j]>57) break; //48 is ASCII '0' and 57 is ASCII '9'
								auxsort[aux2]=(int)auxstr[j];
								aux2++;
							}
							//Order the numbers
							if (aux1==7) {
								if (aux2!=4) {
									//Not a valid triple/quadruple frequency combination
									sprintf(messagestr,"Unknown measurement '%s'",auxstr);
									printError(messagestr,options);
								}
								//Check if it is a triple or quadruple frequency combination
								if (auxsort[0]!=auxsort[1] && auxsort[0]!=auxsort[2] && auxsort[0]!=auxsort[3] && auxsort[1]!=auxsort[2] && auxsort[1]!=auxsort[3] && auxsort[2]!=auxsort[3] ) {
									//Quadruple frequency combination
									quadmeas=1;
								} else {
									//Triple frequency combination. Numbers have to be sorted in group of two
									//Check if there is a 0. In that case, put it at the end
									if (auxsort[0]==48 || (auxsort[0]>auxsort[1] && auxsort[1]!=48)) { //48 is ASCII '0'	
										aux4=auxsort[0];
										auxsort[0]=auxsort[1];
										auxsort[1]=aux4;
									}
									if (auxsort[2]==48 || (auxsort[2]>auxsort[3] && auxsort[3]!=48)) { //48 is ASCII '0'	
										aux4=auxsort[2];
										auxsort[2]=auxsort[3];
										auxsort[3]=aux4; 
									}
									//Put the sorted numbers back in the measurement string
									for(j=aux1-aux2,k=0;j<aux1;j++,k++) {
										auxstr[j]=(char)auxsort[k];
									}
								}
							} else {
								//Dual frequency combination
								if ((auxstr[0]=='D' || auxstr[0]=='d') && ((auxstr[1]=='F' || auxstr[1]=='f')) ) {
									//Do not reorder, as DF combination is different depending on the
									//frequency order
								} else {
									qsort(&auxsort,aux2,sizeof(int),qsort_compare_int);
									//Check if there is a 0. In that case, put it at the end
									if (auxsort[0]==48) { //48 is ASCII '0'	
										for(j=0;j<(aux2-1);j++) {
											auxsort[j]=auxsort[j+1];
										}
										auxsort[aux2-1]=48; //48 is ASCII '0'
									}
									//Put the sorted numbers back in the measurement string
									for(j=aux1-aux2,k=0;j<aux1;j++,k++) {
										auxstr[j]=(char)auxsort[k];
									}
								}
							}
						}
						for(j=0;j<aux1;j++) {
							c=toupper(auxstr[j]); //Transform to upper case characters
							auxstr[j]=c;
						}
						meas = measstr2meastype(auxstr);
						if (meas == NA && aux1==7) {
							//Triple or quadruple frequency combination. Try changing order of pair of frequencies
							for(n=0;n<2;n++) {
								if(n==1 && quadmeas==1) break;
								for(m=0;m<2;m++) {
									if(m==1) {
										//In second loop, swap order of the combinations
										aux4=(int)auxstr[3];
										auxstr[3]=auxstr[5];
										auxstr[5]=(char)aux4;
										aux4=(int)auxstr[4];
										auxstr[4]=auxstr[6];
										auxstr[6]=(char)aux4;
										meas = measstr2meastype(auxstr);
										if (meas!=NA) break;
									}
									for(k=0;k<3;k++) {
										if(k==0) {
											//Swap first 2 frequency numbers
											aux4=(int)auxstr[4];
											auxstr[4]=auxstr[3];
											auxstr[3]=(char)aux4;
										} else if (k==1) {
											//Swap last 2 frequency numbers (leaving the first 2 numbers swapped)
											aux4=(int)auxstr[6];
											auxstr[6]=auxstr[5];
											auxstr[5]=(char)aux4;
										} else {
											//Swap first 2 frequency numbers (so they are as in original position) and leave last 2 numbers swapped
											aux4=(int)auxstr[4];
											auxstr[4]=auxstr[3];
											auxstr[3]=(char)aux4;
										}
										meas = measstr2meastype(auxstr);
										if (meas!=NA) break;
									}
									if (meas!=NA) break;
								}
								if (meas!=NA) break;
								else if (quadmeas==0) {
									//In the case of three frequencies, the repeated frequency may be set
									//toguether at the beginning or at the end (example 1123 or 2311)
									//Swap second and third frequency number so there are two pairo od
									//frequencies with the different frequencies
									aux4=(int)auxstr[4];
									auxstr[4]=auxstr[5];
									auxstr[5]=(char)aux4;
								}
							}
						}
					}

					noMoreMeas=0;
					if (meas == NA) {
						if (autoSingleMeas==0) {
							sprintf(messagestr,"Unknown measurement '%s'",p);
							printError(messagestr,options);
						}
					} else if (meas<ENDMEAS) {
						//Single measurement. Check it is a valid type
						measKind[0]=whatIs(meas);
						if (mode==parseDopplermeas) {
							if (measKind[0]!=Doppler) {
								sprintf(messagestr,"Measurement '%s' is not a Doppler measurement",p);
								printError(messagestr,options);
							}
						} else if (measKind[0]!=Pseudorange && measKind[0]!=CarrierPhase) {
							sprintf(messagestr,"Measurement '%s' is not valid for navigation",p);
							printError(messagestr,options);
						}
						if (measKind[0]==Pseudorange) {
							meastype=SinglePseudorange;
						} else if (measKind[0]==Doppler) {
							meastype=SingleDoppler;
						} else {
							meastype=SingleCarrierPhase;
							if (mode==parseFiltermeas) options->usePhase=1;
						}
						numMeasComb=1;
						measlist[0]=meas;
						noMoreMeas=1;
						userMeas=1;
						freq3[0]=getFrequencyInt(meas);
					//Check measurement is not a combination or Ionosphere/Channel measurement not suitable for navigation
					} else if (meas<=G0) {
						meastype=GraphicComb;
						measKind[0]=CarrierPhase;
						numMeasComb=2;
						if (mode==parseFiltermeas) options->usePhase=1;
						if (strcasecmp(p,"G1C")==0) {
							measlist[0]=C1C;
							measlist[1]=L1P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=1;
						} else if (strcasecmp(p,"G1P")==0) {
							measlist[0]=C1P;
							measlist[1]=L1P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=1;
						} else if (strcasecmp(p,"G2C")==0) {
							measlist[0]=C2C;
							measlist[1]=L2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=2;
							freq3[1]=2;
						} else if (strcasecmp(p,"G2P")==0) {
							measlist[0]=C2P;
							measlist[1]=L2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=2;
							freq3[1]=2;
						}
					} else if (meas<IF12) {
						if (meas<LW12) {
							meastype=IonoFreeCombCode;
						} else {
							meastype=IonoFreeCombPhase;
							if (mode==parseFiltermeas) options->usePhase=1;
						}
						measKind[0]=whatIs(meas);
						numMeasComb=2;
						if (strcasecmp(p,"PCC")==0) {
							measlist[0]=C1C;
							measlist[1]=C2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=2;
						} else if (strcasecmp(p,"PC")==0) {
							measlist[0]=C1P;
							measlist[1]=C2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=2;
						} else if (strcasecmp(p,"LC")==0) {
							measlist[0]=L1P;
							measlist[1]=L2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=2;
						}
					} else if (meas<DF12) {
						meastype=IonoFreeCombPhase;
						numMeasComb=2;
						measKind[0]=CarrierPhase;
						if (strcasecmp(p,"IF")==0) {
							measKind[0]=CarrierPhase;
							measlist[0]=L1P;
							measlist[1]=L2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=2;
						}
						if (mode==parseFiltermeas) options->usePhase=1;
					} else if (meas<IGF1012) {
						meastype=DivergenceFreePhase;
						numMeasComb=2;
						measKind[0]=CarrierPhase;
						if (strcasecmp(p,"DF")==0) {
							measKind[0]=CarrierPhase;
							measlist[0]=L1P;
							measlist[1]=L2P;
							userMeas=1;
							noMoreMeas=1;
							freq3[0]=1;
							freq3[1]=2;
						}
						if (mode==parseFiltermeas) options->usePhase=1;
					} else {
						meastype=SecondIonoFreePhase;
						measKind[0]=CarrierPhase; //Default type for triple/quadruple combinations is carrier phase
						numMeasComb=4;
						if (mode==parseFiltermeas) options->usePhase=1;
					}

					if(h==0) {
						if (mode==parseDopplermeas) {
							if ( (meas>=I1 && meas<=MW) || (meas>=G1 && meas<=PI90) || (meas>=LW12 && meas <=LI90) || (meas>=IGF1012 && meas<=IGF8990) || (meas>=IGF1234 && meas<=IGF9067) ) {
								sprintf(messagestr,"Measurement '%s' is not valid for Doppler",p);
								printError(messagestr,options);
							} else if (meas>=PC12 && meas<=PC90) {
								sprintf(messagestr,"Code ionosphere free combination '%s' is not valid for Doppler. Use 'IF12' instead",p);
								printError(messagestr,options);
							} else if (meas>=LC12 && meas<=LC90) {
								sprintf(messagestr,"Carrier phase ionosphere free combination '%s' is not valid for Doppler. Use 'IF12' instead",p);
								printError(messagestr,options);
							}
						} else {
							if ( (meas>=I1 && meas<=MW) || (meas>=PN12 && meas<=PI90) || (meas>=LW12 && meas<=LI90) || (meas>=MW12 && meas<=MW90) || (meas>=IGF1012 && meas<=IGF8990) || (meas>=IGF1234 && meas<=IGF9078) ) {
								sprintf(messagestr,"Measurement '%s' is not valid for navigation",p);
								printError(messagestr,options);
							}
						}
					} else {
						if ( (measKind[0]!=CarrierPhase) || (meas>=I1 && meas<=MW) || (meas>=PN12 && meas<=LI90) || (meas>=MW12 && meas<=MW90) || (meas>=IGF1012 && meas<=IGF8990) || (meas>=IGF1234 && meas<=IGF9078) ) {
							sprintf(messagestr,"Measurement '%s' is not valid for smoothing",p);
							printError(messagestr,options);
						}
					}
					//Read measurement list (if provided)
					if (userMeas==1) {
						if(meas<I1 && noMoreMeas==0) {
							sprintf(messagestr,"Measurement '%s' is not a combination. Only one measurement must be provided",p);
							printError(messagestr,options);
						}
						if (p2!=NULL && noMoreMeas==1) {
							if (meas<I1) {
								sprintf(messagestr,"Measurement '%s' only needs one measurement, but more than one provided",p);
								printError(messagestr,options);
							} else {
								sprintf(messagestr,"Combination '%s' is provided with old format, so measurements must not be provided, but user provided them",p);
								printError(messagestr,options);
							}
						}
						if (noMoreMeas==0) {
							for(j=0;j<numMeasComb;j++) {
								*p2='-';
								p=p2+1;
								p2=strchr(p,'-');
								//Check number of measurements provided
								if(p2==NULL && j<(numMeasComb-1)) {
									//Check if instead of measurements, only provide measurement kind
									if (p2==NULL && j==0 && meas>=IF12) {
										if (strcasecmp(p,"Code")==0||strcasecmp(p,"Pseudorange")==0) {
											measKind[0]=Pseudorange;
											if(meas>=IGF1012) {
												meastype=SecondIonoFreeCode;
											} else if (meas>=DF12) {
												meastype=DivergenceFreeCode;
											} else {
												meastype=IonoFreeCombCode;
											}
											userMeas=0;
											if (mode==parseDopplermeas) {
												sprintf(messagestr,"Code measurement '%s' is not valid for Doppler",measText[i]);
												printError(messagestr,options);
											}
											if(h==1) {
												sprintf(messagestr,"Measurement '%s' is not valid for smoothing",measText[i]);
												printError(messagestr,options);
											}
											break;
										} else if (strcasecmp(p,"Phase")==0 || strcasecmp(p,"CarrierPhase")==0) {
											measKind[0]=CarrierPhase;
											if(meas>=IGF1012) {
												meastype=SecondIonoFreePhase;
											} else if (meas>=DF12) {
												meastype=DivergenceFreeCode;
											} else {
												meastype=IonoFreeCombCode;
											}
											userMeas=0;
											if (mode==parseDopplermeas) {
												sprintf(messagestr,"Carrier phase measurement '%s' is not valid for Doppler",measText[i]);
												printError(messagestr,options);
											}
											if (mode==parseFiltermeas) options->usePhase=1;
											break;
										} else if (strcasecmp(p,"CodePhase")==0||strcasecmp(p,"PhaseCode")==0||strcasecmp(p,"CoPh")==0||strcasecmp(p,"PhCo")==0) {
											ComboPhaseAndCode=1;
											measKind[0]=Pseudorange;
											if(meas>=IGF1012) {
												meastype=SecondIonoFreeCode;
												meastypeAlt=SecondIonoFreePhase;
											} else if (meas>=DF12) {
												meastype=DivergenceFreeCode;
												meastypeAlt=DivergenceFreePhase;
											} else {
												meastype=IonoFreeCombCode;
												meastypeAlt=IonoFreeCombPhase;
											}
											userMeas=0;
											if (mode==parseDopplermeas) {
												sprintf(messagestr,"Code measurement '%s' is not valid for Doppler",measText[i]);
												printError(messagestr,options);
											}
											if(h==1) {
												sprintf(messagestr,"Measurement '%s' is not valid for smoothing",measText[i]);
												printError(messagestr,options);
											}
											if (mode==parseFiltermeas) options->usePhase=1;
											break;
										} else if (strcasecmp(p,"Doppler")==0) {
											measKind[0]=Doppler;
											if(meas>=IGF1012) {
												meastype=SecondIonoFreeDoppler;
											} else if (meas>=DF12) {
												meastype=DivergenceFreeDoppler;
											} else {
												meastype=IonoFreeCombDoppler;
											}
											if (mode==parseFiltermeas) {
												sprintf(messagestr,"Doppler Measurement '%s' is not valid for navigation",measText[i]);
												printError(messagestr,options);
											} else if (mode==parseSmoothFiltermeas) {
												sprintf(messagestr,"Doppler Measurement '%s' is not valid for smoothing",measText[i]);
												printError(messagestr,options);
											}
										}
									}
									if (meas>=IGF1012) {
										sprintf(messagestr,"For triple or quadruple frequency, either set the type of combination (with words '-code' or '-phase' or '-codephase' or '-phasecode') after the combination name or provide the 4 measurements for the combination");
									} else {
										sprintf(messagestr,"Combination '%s' requires %d measurements, but only %d provided",auxstr,numMeasComb,j+1);
									}
									printError(messagestr,options);
								} else if (p2!=NULL) {
									*p2='\0';
								}
								for(k=0;k<(int)strlen(p);k++) {
									c=toupper(p[k]); //Transform to upper case characters
									p[k]=c;
								}
								measlist[j]=measstr2meastype(p);
								//Check it is a valid measurement
								if (measlist[j] == NA) {
									if (strcasecmp(p,"CodePhase")==0||strcasecmp(p,"PhaseCode")==0||strcasecmp(p,"CoPh")==0||strcasecmp(p,"PhCo")==0) {
										*p2='-';
										sprintf(messagestr,"When 'CodePhase' or 'PhaseCode' measurement type is provided, no measurements have to be provided, as in '%s'",measText[i]);
									} else {
										sprintf(messagestr,"Unknown measurement '%s'",p);
									}
									printError(messagestr,options);
								} else {
									strcpy(measstr[j],p); //No need to check sizes as invalid measurements will have already given an error
									//Check measurement is a pseudorange or carrierphase
									measKind[j]=whatIs(measlist[j]);
									if (mode==parseDopplermeas) {
										if (measKind[j]!=Doppler) {
											sprintf(messagestr,"Measurement '%s' is not Doppler",measstr[j]);
											printError(messagestr,options);
										}
									} else {
										if (measKind[j]!=Pseudorange && measKind[j]!=CarrierPhase) {
											sprintf(messagestr,"Measurement '%s' is not a Pseudorange or Carrierphase",measstr[j]);
											printError(messagestr,options);
										}
									}
									if (meas>=G1 && meas<=G0) {
										//For Graphic combination, a pseudorange and a carrier phase must be provided
										if (j==1) {
											if (measKind[0]==measKind[1]) {
												sprintf(messagestr,"In Graphic combination, measurements provided must be a pseudorange and a carrier phase (provided '%s' and '%s')",measstr[0],measstr[1]);
												printError(messagestr,options);
											}
											//Order measurements. First the code and then the carrier phase
											if (measKind[0]==CarrierPhase) {
												//First measurement is carrier phase. Swap order
												measaux=measlist[0];
												measlist[0]=measlist[1];
												measlist[1]=measaux;
											} else {
												//measKind[0] will be used to set the measurement kind in the filter buffer
												measKind[0]=CarrierPhase;
											}
											//Check that both measurements are from the same frequency
											freq[0]=getFrequencyInt(meas);
											freq3[0]=getFrequencyInt(measlist[0]);
											freq3[1]=getFrequencyInt(measlist[1]);
											if (freq3[0]!=freq3[1]) {
												sprintf(messagestr,"In Graphic combination, both measurements must be from the same frequency, but measurements '%s' and '%s' are from frequencies %d and %d",measstr[0],measstr[1],freq3[0],freq3[1]);
												printError(messagestr,options);
											} else if (freq3[0]!=freq[0]) {
												sprintf(messagestr,"In Graphic combination, both measurements must be from the same frequency as the graphic combination, but measurements '%s' and '%s' are from frequency %d while the graphic combination is from frequency %d",measstr[0],measstr[1],freq3[0],freq[0]);
												printError(messagestr,options);
											}
										}
									} else {
										if(meas<IGF1012) {
											//Dual frequency combination. 2 measurements
											if (j==1) {
												//Check measurements are pseudoranges or carrier phases
												if (measKind[0]!=measKind[1]) {
													sprintf(messagestr,"Dual frequency combination measurements must all be pseudoranges, carrier phases or Doppler (provided '%s' and '%s')",measstr[0],measstr[1]);
													printError(messagestr,options);
												}
												//Check that the measurements given are pseudoreanges or carrier phases according to the combination type
												if ( meas<LW12 && measKind[0]==CarrierPhase) {
													sprintf(messagestr,"Dual frequency combination '%s' is done with pseudoranges, but measurements provided ('%s' and '%s') are carrier phases",auxstr,measstr[0],measstr[1]);
													printError(messagestr,options);
												} else if (meas>=LW12 && meas<IF12 && measKind[0]==Pseudorange) {
													sprintf(messagestr,"Dual frequency combination '%s' is done with carrier phases, but measurements provided ('%s' and '%s') are pseudoranges",auxstr,measstr[0],measstr[1]);
													printError(messagestr,options);
												}
												freq[0]=getFrequencyInt(measlist[0]);
												freq[1]=getFrequencyInt(measlist[1]);
												//Check that there are two frequencies
												if (freq[0]==freq[1]) {
													sprintf(messagestr,"In dual frequency combination, both measurements must be from different frequencies, but measurements '%s' and '%s' are from frequency %d",measstr[0],measstr[1],freq[0]);
													printError(messagestr,options);
												}
												if (meas<DF21) {
													//Order measurements from smallest frequency to highest
													if (freq[0]==0 || (freq[0]>0 && freq[0]>freq[1])) {
														measaux=measlist[0];
														measlist[0]=measlist[1];
														measlist[1]=measaux;
														freq2[0]=freq[0];
														freq[0]=freq[1];
														freq[1]=freq2[0];
													}
												} else {
													//Order measurements from highest frequency to smallest
													if (freq[0]==0 || (freq[0]>0 && freq[0]>freq[1])) {
														//Do nothing, already ordered
													} else {
														measaux=measlist[0];
														measlist[0]=measlist[1];
														measlist[1]=measaux;
														freq2[0]=freq[0];
														freq[0]=freq[1];
														freq[1]=freq2[0];
													}
												}
												//Check that frequencies in measurements match with the given combination
												getFrequencyIntCombinations(meas,freq3);
												if(freq[0]!=freq3[0] || freq[1]!=freq3[1]) {
													sprintf(messagestr,"Provided measurements ('%s' and '%s') have frequencies %d and %d, which do not match with the frequencies provided in the combination '%s' (frequencies %d and %d)",measstr[0],measstr[1],freq[0],freq[1],auxstr,freq3[0],freq3[1]);
													printError(messagestr,options);
												}
												if (meas>=DF12) {
													if (mode==parseDopplermeas) {
														if (measKind[0]==Doppler) {
															meastype=DivergenceFreeDoppler;
														} else {
															sprintf(messagestr,"Measurements provided '%s' and '%s' are not Doppler measurements",measstr[0],measstr[1]);
															printError(messagestr,options);
														}
													} else {
														if (measKind[0]==Doppler) {
															sprintf(messagestr,"Measurements provided '%s' and '%s' cannot be Doppler measurements",measstr[0],measstr[1]);
															printError(messagestr,options);
														}
														if (measKind[0]==Pseudorange) {
															meastype=DivergenceFreeCode;
															if(mode==parseSmoothFiltermeas) {
																sprintf(messagestr,"Pseudorange measurements '%s' and '%s' are not valid for smoothing",measstr[0],measstr[1]);
															}
														}
													}
												} else if (meas>=IF12) {
													if (mode==parseDopplermeas) {
														if (measKind[0]==Doppler) {
															meastype=IonoFreeCombDoppler;
														} else {
															sprintf(messagestr,"Measurements provided '%s' and '%s' are not Doppler measurements",measstr[0],measstr[1]);
															printError(messagestr,options);
														}
													} else {
														if (measKind[0]==Doppler) {
															sprintf(messagestr,"Measurements provided '%s' and '%s' cannot be Doppler measurements",measstr[0],measstr[1]);
															printError(messagestr,options);
														}
														if (measKind[0]==Pseudorange) {
															meastype=IonoFreeCombCode;
															if(mode==parseSmoothFiltermeas) {
																sprintf(messagestr,"Pseudorange measurements '%s' and '%s' are not valid for smoothing",measstr[0],measstr[1]);
															}
														}
													}
												}
											}
										} else if (meas<IGF1234) {
											//Triple frequency combination. 4 measurements
											if(j==3) {
												//Check measurements are pseudoranges or carrier phases
												if (measKind[0]!=measKind[1] || measKind[0]!=measKind[2] || measKind[0]!=measKind[3]) {
													sprintf(messagestr,"Triple frequency combination measurements must all be pseudoranges, carrier phases or Doppler (provided '%s', '%s', '%s' and '%s')",measstr[0],measstr[1],measstr[2],measstr[3]);
													printError(messagestr,options);
												}
												if (mode==parseDopplermeas) {
													if (measKind[0]==Doppler) {
														meastype=SecondIonoFreeDoppler;
													} else {
														sprintf(messagestr,"Measurements provided '%s', '%s', '%s' and '%s' are not Doppler measurements",measstr[0],measstr[1],measstr[2],measstr[3]);
														printError(messagestr,options);
													}
												} else {
													if (measKind[0]==Doppler) {
														sprintf(messagestr,"Measurements provided '%s', '%s', '%s' and '%s' cannot be Doppler measurements",measstr[0],measstr[1],measstr[2],measstr[3]);
														printError(messagestr,options);
													} else if (measKind[0]==Pseudorange) {
														meastype=SecondIonoFreeCode;
													} else {
														meastype=SecondIonoFreePhase;
													}
												}
												freq[0]=freq2[0]=getFrequencyInt(measlist[0]);
												freq[1]=freq2[1]=getFrequencyInt(measlist[1]);
												freq[2]=freq2[2]=getFrequencyInt(measlist[2]);
												freq[3]=freq2[3]=getFrequencyInt(measlist[3]);
												//Check that there are three frequencies. To do it, sort the frequency numbers first
												qsort(&freq2,4,sizeof(int),qsort_compare_int);
												if (freq2[0]==freq2[1] && freq2[0]!=freq2[2] && freq2[0]!=freq2[3]) {
													//Do nothing, 3 different frequencies
												} else if (freq2[0]!=freq2[1] && freq2[1]==freq2[2] && freq2[1]!=freq2[3]) {
													//Do nothing, 3 different frequencies
												} else if (freq2[0]!=freq2[1] && freq2[1]!=freq2[2] && freq2[2]==freq2[3]) {
													//Do nothing, 3 different frequencies
												} else {
													sprintf(messagestr,"In triple frequency combination, there must be three different frequencies, but measurements '%s', '%s', '%s' and '%s' are from frequencies %d, %d, %d and %d",measstr[0],measstr[1],measstr[2],measstr[3],freq[0],freq[1],freq[2],freq[3]);
													printError(messagestr,options);
												}
												//Check that frequencies in measurements match with the given combination
												getFrequencyIntCombinations(meas,freq3);
												qsort(&freq3,4,sizeof(int),qsort_compare_int);
												if(freq3[0]!=freq2[0] || freq3[1]!=freq2[1] || freq3[2]!=freq2[2] || freq3[3]!=freq2[3]) {
													sprintf(messagestr,"Provided measurements ('%s', '%s', '%s' and '%s') have frequencies %d, %d, %d and %d, which do not match with the frequencies provided in the combination '%s' (frequencies %d, %d, %d and %d)",measstr[0],measstr[1],measstr[2],measstr[3],freq[0],freq[1],freq[2],freq[3],auxstr,freq3[0],freq3[1],freq3[2],freq3[3]);
													printError(messagestr,options);
												}
												getFrequencyIntCombinations(meas,freq3);
												//Sort the measurements in the same order as the frequencies in the combination order
												for(j=0;j<3;j++) {
													if (freq3[j]!=freq[j]) {
														for(k=(j+1);k<4;k++) {
															if(freq3[j]==freq[k]) {
																measaux=measlist[j];
																measlist[j]=measlist[k];
																measlist[k]=measaux;
																freq2[0]=freq[j];
																freq[j]=freq[k];
																freq[k]=freq2[0];
																break;
															}
														}
													}
												}
											}
										} else {
											//Quadruple frequency combination. 4 measurements
											if(j==3) {
												if (measKind[0]!=measKind[1] || measKind[0]!=measKind[2] || measKind[0]!=measKind[3]) {
													sprintf(messagestr,"Quadruple frequency combination measurements must all be pseudoranges, carrier phases or Doppler (provided '%s', '%s', '%s' and '%s')",measstr[0],measstr[1],measstr[2],measstr[3]);
													printError(messagestr,options);
												}
												if (mode==parseDopplermeas) {
													if (measKind[0]==Doppler) {
														meastype=SecondIonoFreeDoppler;
													} else {
														sprintf(messagestr,"Measurements provided '%s', '%s', '%s' and '%s' are not Doppler measurements",measstr[0],measstr[1],measstr[2],measstr[3]);
														printError(messagestr,options);
													}
												} else {
													if (measKind[0]==Doppler) {
														sprintf(messagestr,"Measurements provided '%s', '%s', '%s' and '%s' cannot be Doppler measurements",measstr[0],measstr[1],measstr[2],measstr[3]);
														printError(messagestr,options);
													} else if (measKind[0]==Pseudorange) {
														meastype=SecondIonoFreeCode;
													} else {
														meastype=SecondIonoFreePhase;
													}
												}
												freq[0]=getFrequencyInt(measlist[0]);
												freq[1]=getFrequencyInt(measlist[1]);
												freq[2]=getFrequencyInt(measlist[2]);
												freq[3]=getFrequencyInt(measlist[3]);
												//Check that there are four frequencies.
												if (freq[0]!=freq[1] && freq[0]!=freq[2] && freq[0]!=freq[3] && freq[1]!=freq[2] && freq[1]!=freq[3] && freq[2]!=freq[3] ) {
													//Do nothing, 4 different frequencies
												} else {
													sprintf(messagestr,"In quadruple frequency combination, there must be four different frequencies, but measurements '%s', '%s', '%s' and '%s' are from frequencies %d, %d, %d and %d",measstr[0],measstr[1],measstr[2],measstr[3],freq[0],freq[1],freq[2],freq[3]);
													printError(messagestr,options);
												}
												//Check that frequencies in measurements match with the given combination
												//For quadruple frequency combination, we need to assume that first and second frequency are from one combination
												//and that third and fourth frequency are for the other combination
												//If frequency pair had been swapped when too
												getFrequencyIntCombinations(meas,freq3);
												for(n=0;n<5;n++) {
													if (freq3[0]==freq[0] && freq3[1]==freq[1] && freq3[2]==freq[2] && freq3[3]==freq[3]) {
														//Do nothing, the 4 frequencies match
														break;
													}
													if(n>0) {
														//Reset to initial order
														measlist[0]=measstr2meastype(measstr[0]);
														measlist[1]=measstr2meastype(measstr[1]);
														measlist[2]=measstr2meastype(measstr[2]);
														measlist[3]=measstr2meastype(measstr[3]);
														freq[0]=getFrequencyInt(measlist[0]);
														freq[1]=getFrequencyInt(measlist[1]);
														freq[2]=getFrequencyInt(measlist[2]);
														freq[3]=getFrequencyInt(measlist[3]);
														if(n==1) {
															//Swap first and third measurements
															aux4=measlist[0];
															measlist[0]=measlist[2];
															measlist[2]=aux4;
															aux4=freq[0];
															freq[0]=freq[2];
															freq[2]=aux4;
														} else if (n==2) {
															//Swap second and fourth measurements
															aux4=measlist[1];
															measlist[1]=measlist[3];
															measlist[3]=aux4;
															aux4=freq[1];
															freq[1]=freq[3];
															freq[3]=aux4;
														} else if (n==3) {
															//Swap first and last measurements
															aux4=measlist[0];
															measlist[0]=measlist[3];
															measlist[3]=aux4;
															aux4=freq[0];
															freq[0]=freq[3];
															freq[3]=aux4;
														} else {
															//Swap second and third measurements
															aux4=measlist[1];
															measlist[1]=measlist[2];
															measlist[2]=aux4;
															aux4=freq[1];
															freq[1]=freq[2];
															freq[2]=aux4;
														}
													}
													for(m=0;m<2;m++) {
														if (freq3[0]==freq[0] && freq3[1]==freq[1] && freq3[2]==freq[2] && freq3[3]==freq[3]) {
															//Do nothing, the 4 frequencies match
															break;
														}
														if (m==1) {
															//Pair of frequencies have been swapped
															aux4=measlist[0];
															measlist[0]=measlist[2];
															measlist[2]=aux4;
															aux4=measlist[1];
															measlist[1]=measlist[3];
															measlist[3]=aux4;
															aux4=freq[0];
															freq[0]=freq[2];
															freq[2]=aux4;
															aux4=freq[1];
															freq[1]=freq[3];
															freq[3]=aux4;
														}
														if (freq3[0]==freq[1] && freq3[1]==freq[0] && freq3[2]==freq[2] && freq3[3]==freq[3]) {
															//The 4 frequencies match, but need to order the first two measurements
															measaux=measlist[0];
															measlist[0]=measlist[1];
															measlist[1]=measaux;
															freq2[0]=freq[0];
															freq[0]=freq[1];
															freq[1]=freq2[0];
														} else if (freq3[0]==freq[0] && freq3[1]==freq[1] && freq3[2]==freq[3] && freq3[3]==freq[2]) {
															//The 4 frequencies match, but need to order the last two measurements
															measaux=measlist[2];
															measlist[2]=measlist[3];
															measlist[3]=measaux;
															freq2[0]=freq[2];
															freq[2]=freq[3];
															freq[3]=freq2[0];
														} else if (freq3[0]==freq[1] && freq3[1]==freq[0] && freq3[2]==freq[3] && freq3[3]==freq[2]) {
															//The 4 frequencies match, but need to order the first and last two measurements
															measaux=measlist[0];
															measlist[0]=measlist[1];
															measlist[1]=measaux;
															freq2[0]=freq[0];
															freq[0]=freq[1];
															freq[1]=freq2[0];
															measaux=measlist[2];
															measlist[2]=measlist[3];
															measlist[3]=measaux;
															freq2[0]=freq[2];
															freq[2]=freq[3];
															freq[3]=freq2[0];
														} else {
															if(n==4 && m>0) {
																freq[0]=getFrequencyInt(measstr2meastype(measstr[0]));
																freq[1]=getFrequencyInt(measstr2meastype(measstr[1]));
																freq[2]=getFrequencyInt(measstr2meastype(measstr[2]));
																freq[3]=getFrequencyInt(measstr2meastype(measstr[3]));
																sprintf(messagestr,"Provided measurements ('%s', '%s', '%s' and '%s') have frequencies %d, %d, %d and %d, which do not match with the frequencies provided in the combination '%s' (frequencies %d, %d, %d and %d)",measstr[0],measstr[1],measstr[2],measstr[3],freq[0],freq[1],freq[2],freq[3],auxstr,freq3[0],freq3[1],freq3[2],freq3[3]);
																printError(messagestr,options);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}

						if (userMeas==1) { //We need to check again for the case it is provided only measurement combination type ("Code" or "phase")
							for(j=0;j<MAX_GNSS;j++) {
								if(GNSSused[j]==0) continue;
								for(k=0;k<numMeasComb;k++) {
									if (availGNSSFreq[j][freq3[k]]==0) {
										options->unselUnavailGNSSFreqFilter[j][freq3[k]]=1;
										GNSSused[j]=0;
									}
								}
								if(roundMode==0) {
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										for(l=0;l<numMeasComb;l++) {
											if (options->usableFreq[j][k][freq3[l]]==0) {
												//Frequency disabled by the user
												sprintf(messagestr,"Selected frequency %d for satellite %s %d for filter measurement in parameter '%s', but user has set the frequency as not usable",freq3[l],gnsstype2gnssstr(j),k,measText[i]);
												printError(messagestr,options);
											}
										}
									}
								}
							}
							if(mode==parseFiltermeas) {
								//Save measurements read
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										options->autoMeasSatByUser[j][k]=0;
										//Check that measurement is not in the list (avoid repeating measurements)
										for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
											if (options->filterMeasTypeList[staType][j][k][l]==meastype && 
													options->filterMeasKind[staType][j][k][l]==measKind[0] &&
													options->filterMeasList[staType][j][k][l][0]==meas &&
													options->filterListWithMeas[staType][j][k][l]==1) 
											{
												aux3=0;
												for(m=0;m<numMeasComb;m++) {
													if(options->filterMeasList[staType][j][k][l][m+1]==measlist[m]) {
														aux3++;
													} else {
														break;
													}
												}
												if (aux3==numMeasComb) { 
													//Measurement already in list
													break;
												}
											}
										}
										if (l==options->numfilterMeasList[staType][j][k] && removeMeas==0) {
											if (l==MAX_FILTER_MEASUREMENTS_SAT) {
												sprintf(messagestr,"Maximum number of measurements per satellite are %d, but satellite %3s %2d has %d measurements",MAX_FILTER_MEASUREMENTS_SAT,gnsstype2gnssstr(j),k,MAX_FILTER_MEASUREMENTS_SAT+1);
												printError(messagestr,options);
											}
											for(m=0;m<numMeasComb;m++) {
												options->filterMeasList[staType][j][k][l][m+1]=measlist[m];
											}
											for(m=0;m<4;m++) {
												options->filterMeasfreq[staType][j][k][l][m]=freq3[m];
											}
											options->filterMeasList[staType][j][k][l][0]=meas;
											options->filterMeasTypeList[staType][j][k][l]=meastype;
											options->filterMeasKind[staType][j][k][l]=measKind[0];
											options->filterListWithMeas[staType][j][k][l]=1;
											options->filterListMeasSelected[staType][j][k][l]=1;
											options->numCombfilterMeas[staType][j][k][l]=numMeasComb;
											options->numfilterMeasList[staType][j][k]++;
										} else if (l<options->numfilterMeasList[staType][j][k] && removeMeas==1) {
											//All measurements match, remove measurement and move the following measurements one position up
											for(m=l+1;m<options->numfilterMeasList[staType][j][k];m++) {
												for(n=0;n<5;n++) {
													options->filterMeasList[staType][j][k][m-1][n]=options->filterMeasList[staType][j][k][m][n];
												}
												for(n=0;n<4;n++) {
													options->filterMeasfreq[staType][j][k][m-1][n]=options->filterMeasfreq[staType][j][k][m][n];
												}
												options->filterMeasTypeList[staType][j][k][m-1]=options->filterMeasTypeList[staType][j][k][m];
												options->filterMeasKind[staType][j][k][m-1]=options->filterMeasKind[staType][j][k][m];
												options->filterListWithMeas[staType][j][k][m-1]=options->filterListWithMeas[staType][j][k][m];
												options->numCombfilterMeas[staType][j][k][m-1]=options->numCombfilterMeas[staType][j][k][m];
												options->filterListMeasSelected[staType][j][k][m-1]=options->filterListMeasSelected[staType][j][k][m];
											}
											options->numfilterMeasList[staType][j][k]--;
										}
									}
								}
							} else if (mode==parseSmoothFiltermeas) {
								if(h==0) continue;
								//Search for provided measurement in the filter. If found, save the measurement to smoothWith
								if (filterMeasPosition==-1) {
									for(j=0;j<MAX_GNSS;j++) {
										if(GNSSused[j]==0) continue;
										for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
											if(PRNused[k]==0) continue;
											if (options->includeSatellite[j][k]==0) continue;
											for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
												if (options->filterMeasTypeList[staType][j][k][l]==meastypeSmooth 
														&& options->filterMeasKind[staType][j][k][l]==measKindSmooth[0] 
														&& options->filterListWithMeas[staType][j][k][l]==userMeasSmooth 
														&& options->filterMeasList[staType][j][k][l][0]==measSmooth) {
													if (measSmooth==NA) {
														if(options->filterMeasfreq[staType][j][k][l][0]!=freqAutoSmooth) {
															continue;
														}
													}
													if(userMeasSmooth==1) {
														aux3=0;
														for(m=0;m<numMeasCombSmooth;m++) {
															if(options->filterMeasList[staType][j][k][l][m+1]==measlistSmooth[m]) {
																aux3++;
															} else {
																break;
															}
														}
													} else {
														aux3=numMeasCombSmooth;
													}
													if (aux3==numMeasCombSmooth) { 
														//All measurements match 
														if (options->filterMeasKind[staType][j][k][l]!=Pseudorange) {
															if (options->filterMeasList[staType][j][k][l][0]==NA) {
																sprintf(messagestr,"Automatic carrier phase measurement from frequency %d (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",options->filterMeasfreq[staType][j][k][l][0],gnsstype2gnssstr(j),k);
															} else {
																sprintf(messagestr,"%s carrier phase measurement (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",meastype2measstr(options->filterMeasList[staType][j][k][l][0]),gnsstype2gnssstr(j),k);
															}
															printError(messagestr,options);
														}
														if(removeMeasSmooth==0) {
															//Save smoothing measurements
															options->filterSmoothMeasList[staType][j][k][l][0]=meas;
															options->filterMeasSmoothed[staType][j][k][l]=1;
															options->filterSmoothListWithMeas[staType][j][k][l]=1;
															options->filterSmoothListMeasSelected[staType][j][k][l]=1;
															options->numCombfilterSmoothMeas[staType][j][k][l]=numMeasComb;
															options->filterMeasTypeList[staType][j][k][l]++;
															for(m=1;m<=numMeasComb;m++) {
																options->filterSmoothMeasList[staType][j][k][l][m]=measlist[m-1];
															}
															for(m=0;m<4;m++) {
																options->filterSmoothMeasfreq[staType][j][k][l][m]=freq3[m];
															}
														} else {
															//Remove smoothing from measurement
															options->filterMeasSmoothed[staType][j][k][l]=0;
															options->filterMeasTypeList[staType][j][k][l]--;
														}
														break;
													}
												}
											}
										}
									}
								} else {
									//Compatibility mode where the position of the measurement in the list was given
									for(j=0;j<MAX_GNSS;j++) {
										if(GNSSused[j]==0) continue;
										for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
											if(PRNused[k]==0) continue;
											if (options->includeSatellite[j][k]==0) continue;
											if(options->filterMeasKind[staType][j][k][filterMeasPosition]!=Pseudorange) {
												if (options->filterMeasList[staType][j][k][filterMeasPosition][0]==NA) {
													sprintf(messagestr,"Automatic carrier phase measurement from frequency %d (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",options->filterMeasfreq[staType][j][k][filterMeasPosition][0],gnsstype2gnssstr(j),k);
												} else {
													sprintf(messagestr,"%s carrier phase measurement (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",meastype2measstr(options->filterMeasList[staType][j][k][filterMeasPosition][0]),gnsstype2gnssstr(j),k);
												}
												printError(messagestr,options);
											}
											//Save smoothing measurements
											if (filterMeasPosition<options->numfilterMeasList[staType][j][k]) { //Check that PRN has as much measurements as the position points to
												options->filterSmoothMeasList[staType][j][k][filterMeasPosition][0]=meas;
												options->filterSmoothListWithMeas[staType][j][k][filterMeasPosition]=1;
												options->filterSmoothListMeasSelected[staType][j][k][filterMeasPosition]=1;
												options->numCombfilterSmoothMeas[staType][j][k][filterMeasPosition]=numMeasComb;
												options->filterMeasTypeList[staType][j][k][filterMeasPosition]++;
												for(m=1;m<=numMeasComb;m++) {
													options->filterSmoothMeasList[staType][j][k][filterMeasPosition][m]=measlist[m-1];
												}
												for(m=0;m<4;m++) {
													options->filterSmoothMeasfreq[staType][j][k][filterMeasPosition][m]=freq3[m];
												}
											}
										}
									}
								}
							} else if (mode==parseDopplermeas) {
								//Save measurements read
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										options->autoMeasSatByUser[j][k]=0;
										//Check that measurement is not in the list (avoid repeating measurements)
										for(l=0;l<options->numDopplerMeasList[staType][j][k];l++) {
											if (options->DopplerMeasTypeList[staType][j][k][l]==meastype && 
													measKind[0]==Doppler &&
													options->DopplerMeasList[staType][j][k][l][0]==meas &&
													options->DopplerListWithMeas[staType][j][k][l]==1) 
											{
												aux3=0;
												for(m=0;m<numMeasComb;m++) {
													if(options->DopplerMeasList[staType][j][k][l][m+1]==measlist[m]) {
														aux3++;
													} else {
														break;
													}
												}
												if (aux3==numMeasComb) { 
													//Measurement already in list
													break;
												}
											}
										}
										if (l==options->numDopplerMeasList[staType][j][k] && removeMeas==0) {
											if (l==MAX_FILTER_MEASUREMENTS_SAT) {
												sprintf(messagestr,"Maximum number of measurements per satellite are %d, but satellite %3s %2d has %d measurements",MAX_FILTER_MEASUREMENTS_SAT,gnsstype2gnssstr(j),k,MAX_FILTER_MEASUREMENTS_SAT+1);
												printError(messagestr,options);
											}
											for(m=0;m<numMeasComb;m++) {
												options->DopplerMeasList[staType][j][k][l][m+1]=measlist[m];
											}
											for(m=0;m<4;m++) {
												options->DopplerMeasfreq[staType][j][k][l][m]=freq3[m];
											}
											options->DopplerMeasList[staType][j][k][l][0]=meas;
											options->DopplerMeasTypeList[staType][j][k][l]=meastype;
											options->DopplerListWithMeas[staType][j][k][l]=1;
											options->DopplerListMeasSelected[staType][j][k][l]=1;
											options->numCombDopplerMeas[staType][j][k][l]=numMeasComb;
											options->numDopplerMeasList[staType][j][k]++;
										} else if (l<options->numDopplerMeasList[staType][j][k] && removeMeas==1) {
											//All measurements match, remove measurement and move the following measurements one position up
											for(m=l+1;m<options->numDopplerMeasList[staType][j][k];m++) {
												for(n=0;n<5;n++) {
													options->DopplerMeasList[staType][j][k][m-1][n]=options->DopplerMeasList[staType][j][k][m][n];
												}
												for(n=0;n<4;n++) {
													options->DopplerMeasfreq[staType][j][k][m-1][n]=options->DopplerMeasfreq[staType][j][k][m][n];
												}
												options->DopplerMeasTypeList[staType][j][k][m-1]=options->DopplerMeasTypeList[staType][j][k][m];
												options->DopplerListWithMeas[staType][j][k][m-1]=options->DopplerListWithMeas[staType][j][k][m];
												options->numCombDopplerMeas[staType][j][k][m-1]=options->numCombDopplerMeas[staType][j][k][m];
												options->DopplerListMeasSelected[staType][j][k][m-1]=options->DopplerListMeasSelected[staType][j][k][m];
											}
											options->numDopplerMeasList[staType][j][k]--;
										}
									}
								}
							} else {
								//Search for provided measurement in the filter. If found, save the weight
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										options->autoMeasSatByUser[j][k]=0;
										for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
											if (options->filterMeasTypeList[staType][j][k][l]<DivergenceFreeCodeSmoothed && options->filterMeasTypeList[staType][j][k][l]!=OTHER_MEAS) {
												meastypeSmooth=meastype+1;
											} else {
												meastypeSmooth=meastype;
											}
											if ((options->filterMeasTypeList[staType][j][k][l]==meastype || options->filterMeasTypeList[staType][j][k][l]==meastypeSmooth)
													&& options->filterMeasKind[staType][j][k][l]==measKind[0] 
													&& options->filterListWithMeas[staType][j][k][l]==userMeas 
													&& options->filterMeasList[staType][j][k][l][0]==meas) {
												if(userMeas==1) {
													aux3=0;
													for(m=0;m<numMeasComb;m++) {
														if(options->filterMeasList[staType][j][k][l][m+1]==measlist[m]) {
															aux3++;
														} else {
															break;
														}
													}
												} else {
													aux3=numMeasComb;
												}
												if (aux3==numMeasComb) { 
													//All measurements match, save weight modes
													if (mode==parseWeightFiltermeas) {
														options->weightMode[j][k][l]=sopt->weightMode[i];
														options->WeightConstantsValues[j][k][l][0]=sopt->WeightConstantsValues[i][0];
														options->WeightConstantsValues[j][k][l][1]=sopt->WeightConstantsValues[i][1];
														options->WeightConstantsValues[j][k][l][2]=sopt->WeightConstantsValues[i][2];
														if (sopt->WeightConstantsValues[i][0]==0.&& sopt->WeightConstantsValues[i][1]==0.) {
															sprintf(messagestr,"Constants 'a' and 'b' cannot be both 0 for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
															printError(messagestr,options);
														} else if (sopt->WeightConstantsValues[i][0]==-2 && sopt->navMode==NMppp) {
															sprintf(messagestr,"URA value for weights cannot be used in PPP mode for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
																printError(messagestr,options);
														}
													} else if (mode==parseWeightCombFiltermeas) {
														options->SNRweightComb[j][k][l]=sopt->SNRweightComb[i];
														options->SNRweightCombVal[j][k][l][0]=sopt->SNRweightCombVal[i][0];
														options->SNRweightCombVal[j][k][l][1]=sopt->SNRweightCombVal[i][1];
														options->SNRweightCombVal[j][k][l][2]=sopt->SNRweightCombVal[i][2];
														options->SNRweightCombVal[j][k][l][3]=sopt->SNRweightCombVal[i][3];
													} else {
														if (sopt->CombineWeightMode[i]==ComputedOnly) {
															if (options->SBAScorrections>=SBAS1Fused) {
																options->weightMode[j][k][l]=SBASOnlyWeight;
															} else if (options->DGNSS==1) {
																options->weightMode[j][k][l]=DGNSSOnlyWeight;
															}
														} else if(sopt->CombineWeightMode[i]==ComputedPlusUser) {
															if (options->SBAScorrections>=SBAS1Fused && options->weightMode[j][k][l]!=UnknownWeight) {
																options->weightMode[j][k][l]=SBASFixedWeight+options->weightMode[j][k][l];
															} else if (options->DGNSS==1 && options->weightMode[j][k][l]!=UnknownWeight) {
																options->weightMode[j][k][l]=DGNSSFixedWeight+options->weightMode[j][k][l];
															}
														}
													}
													break;
												}
											}
										}
									}	
								}
							}
						}
					}
					if (userMeas==0) { 
						if (meas!=NA) getFrequencyIntCombinations(meas,freq3);
						for(j=0;j<MAX_GNSS;j++) {
							if(GNSSused[j]==0) continue;
							for(k=0;k<numMeasComb;k++) {
								if (availGNSSFreq[j][freq3[k]]==0) {
									options->unselUnavailGNSSFreqFilter[j][freq3[k]]=1;
									GNSSused[j]=0;
								}
							}
							if(roundMode==0) {
								for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
									if(PRNused[k]==0) continue;
									if (options->includeSatellite[j][k]==0) continue;
									for(l=0;l<numMeasComb;l++) {
										if (options->usableFreq[j][k][freq3[l]]==0) {
											//Frequency disabled by the user
											sprintf(messagestr,"Selected frequency %d for satellite %s %d for filter measurement in parameter '%s', but user has set the frequency as not usable",freq3[l],gnsstype2gnssstr(j),k,measText[i]);
											printError(messagestr,options);
										}
									}
								}
							}
						}
						if(mode==parseFiltermeas) {
							//Save measurements read
							for(q=0;q<=ComboPhaseAndCode;q++) {
								if (q==1) {
									//This is the case where both code and phase have been selected
									//First iteration is for code and second fo pseudorange
									meastype=meastypeAlt;
									measKind[0]=CarrierPhase;
								}
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										options->autoMeasSatByUser[j][k]=0;
										//Check that measurement is not in the list (avoid repeating measurements)
										for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
											if (options->filterMeasTypeList[staType][j][k][l]==meastype && 
													options->filterMeasKind[staType][j][k][l]==measKind[0] &&
													options->filterMeasList[staType][j][k][l][0]==meas &&
													options->filterListWithMeas[staType][j][k][l]==0) 
											{
												if (meas!=NA) {
													//Measurement already in list
													break;
												} else {
													if (options->filterMeasfreq[staType][j][k][l][0]==freq3[0]) {
														//Measurement already in list
														break;
													}
												}
											}
										}
										if (l==options->numfilterMeasList[staType][j][k] && removeMeas==0) {
											if (l==MAX_FILTER_MEASUREMENTS_SAT) {
												sprintf(messagestr,"Maximum number of measurements per satellite are %d, but satellite %3s %2d has %d measurements",MAX_FILTER_MEASUREMENTS_SAT,gnsstype2gnssstr(j),k,MAX_FILTER_MEASUREMENTS_SAT+1);
												printError(messagestr,options);
											}
											for(m=0;m<4;m++) {
												options->filterMeasfreq[staType][j][k][l][m]=freq3[m];
											}
											options->filterMeasList[staType][j][k][l][0]=meas;
											options->filterMeasTypeList[staType][j][k][l]=meastype;
											options->filterMeasKind[staType][j][k][l]=measKind[0];
											options->numCombfilterMeas[staType][j][k][l]=numMeasComb;
											options->filterListWithMeas[staType][j][k][l]=0; 
											options->filterListMeasSelected[staType][j][k][l]=0;
											options->numfilterMeasList[staType][j][k]++;
										} else if (l<options->numfilterMeasList[staType][j][k] && removeMeas==1) {
											//All parameters match, remove measurement and move the following measurements one position up
											for(m=l+1;m<options->numfilterMeasList[staType][j][k];m++) {
												for(n=0;n<5;n++) {
													options->filterMeasList[staType][j][k][m-1][n]=options->filterMeasList[staType][j][k][m][n];
												}
												for(n=0;n<4;n++) {
													options->filterMeasfreq[staType][j][k][m-1][n]=options->filterMeasfreq[staType][j][k][m][n];
												}
												options->filterMeasTypeList[staType][j][k][m-1]=options->filterMeasTypeList[staType][j][k][m];
												options->filterMeasKind[staType][j][k][m-1]=options->filterMeasKind[staType][j][k][m];
												options->filterListWithMeas[staType][j][k][m-1]=options->filterListWithMeas[staType][j][k][m];
												options->filterListMeasSelected[staType][j][k][m-1]=options->filterListMeasSelected[staType][j][k][m];
												options->numCombfilterMeas[staType][j][k][m-1]=options->numCombfilterMeas[staType][j][k][m];
											}
											options->numfilterMeasList[staType][j][k]--;
										}
									}
								}
							}
						} else if (mode==parseDopplermeas) {
							//Save measurements read
							for(j=0;j<MAX_GNSS;j++) {
								if(GNSSused[j]==0) continue;
								for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
									if(PRNused[k]==0) continue;
									if (options->includeSatellite[j][k]==0) continue;
									options->autoMeasSatByUser[j][k]=0;
									//Check that measurement is not in the list (avoid repeating measurements)
									for(l=0;l<options->numDopplerMeasList[staType][j][k];l++) {
										if (options->DopplerMeasTypeList[staType][j][k][l]==meastype && 
												measKind[0]==Doppler &&
												options->DopplerMeasList[staType][j][k][l][0]==meas &&
												options->DopplerListWithMeas[staType][j][k][l]==0) 
										{
											if (meas!=NA) {
												//Measurement already in list
												break;
											} else {
												if (options->filterMeasfreq[staType][j][k][l][0]==freq3[0]) {
													//Measurement already in list
													break;
												}
											}
										}
									}
									if (l==options->numDopplerMeasList[staType][j][k] && removeMeas==0) {
										if (l==MAX_FILTER_MEASUREMENTS_SAT) {
											sprintf(messagestr,"Maximum number of measurements per satellite are %d, but satellite %3s %2d has %d measurements",MAX_FILTER_MEASUREMENTS_SAT,gnsstype2gnssstr(j),k,MAX_FILTER_MEASUREMENTS_SAT+1);
											printError(messagestr,options);
										}
										for(m=0;m<4;m++) {
											options->DopplerMeasfreq[staType][j][k][l][m]=freq3[m];
										}
										options->DopplerMeasList[staType][j][k][l][0]=meas;
										options->DopplerMeasTypeList[staType][j][k][l]=meastype;
										options->numCombDopplerMeas[staType][j][k][l]=numMeasComb;
										options->DopplerListWithMeas[staType][j][k][l]=0; 
										options->DopplerListMeasSelected[staType][j][k][l]=0;
										options->numDopplerMeasList[staType][j][k]++;
									} else if (l<options->numDopplerMeasList[staType][j][k] && removeMeas==1) {
										//All parameters match, remove measurement and move the following measurements one position up
										for(m=l+1;m<options->numDopplerMeasList[staType][j][k];m++) {
											for(n=0;n<5;n++) {
												options->DopplerMeasList[staType][j][k][m-1][n]=options->DopplerMeasList[staType][j][k][m][n];
											}
											for(n=0;n<4;n++) {
												options->DopplerMeasfreq[staType][j][k][m-1][n]=options->DopplerMeasfreq[staType][j][k][m][n];
											}
											options->DopplerMeasTypeList[staType][j][k][m-1]=options->DopplerMeasTypeList[staType][j][k][m];
											options->DopplerListWithMeas[staType][j][k][m-1]=options->DopplerListWithMeas[staType][j][k][m];
											options->DopplerListMeasSelected[staType][j][k][m-1]=options->DopplerListMeasSelected[staType][j][k][m];
											options->numCombDopplerMeas[staType][j][k][m-1]=options->numCombDopplerMeas[staType][j][k][m];
										}
										options->numDopplerMeasList[staType][j][k]--;
									}
								}
							}
						} else if (mode==parseSmoothFiltermeas) {
							if(h==0) {
								if (meas!=NA && meas<ENDMEAS) userMeas=1;
								continue;
							}
							//Search for provided measurement in the filter. If found, save the measurement to smoothWith
							if (filterMeasPosition==-1) {
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
											if (options->filterMeasTypeList[staType][j][k][l]==meastypeSmooth 
													&& options->filterMeasKind[staType][j][k][l]==measKindSmooth[0] 
													&& options->filterListWithMeas[staType][j][k][l]==userMeasSmooth 
													&& options->filterMeasList[staType][j][k][l][0]==measSmooth) {

												if (measSmooth==NA) {
													if(options->filterMeasfreq[staType][j][k][l][0]!=freqAutoSmooth) {
														continue;
													}
												}
												if(userMeasSmooth==1) {
													aux3=0;
													for(m=0;m<numMeasCombSmooth;m++) {
														if(options->filterMeasList[staType][j][k][l][m+1]==measlistSmooth[m]) {
															aux3++;
														} else {
															break;
														}
													}
												} else {
													aux3=numMeasCombSmooth;
												}
												if (aux3==numMeasCombSmooth) { 
													//All measurements match 
													if (options->filterMeasKind[staType][j][k][l]!=Pseudorange) {
														if (options->filterMeasList[staType][j][k][l][0]==NA) {
															sprintf(messagestr,"Automatic carrier phase measurement from frequency %d (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",options->filterMeasfreq[staType][j][k][l][0],gnsstype2gnssstr(j),k);
														} else {
															sprintf(messagestr,"%s carrier phase measurement (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",meastype2measstr(options->filterMeasList[staType][j][k][l][0]),gnsstype2gnssstr(j),k);
														}
														printError(messagestr,options);
													}
													if(removeMeasSmooth==0) {
														//Save smoothing measurements
														options->filterSmoothMeasList[staType][j][k][l][0]=meas;
														options->filterMeasSmoothed[staType][j][k][l]=1;
														options->filterSmoothListWithMeas[staType][j][k][l]=0;
														options->filterSmoothListMeasSelected[staType][j][k][l]=0;
														options->numCombfilterSmoothMeas[staType][j][k][l]=numMeasComb;
														options->filterMeasTypeList[staType][j][k][l]++;
														for(m=0;m<4;m++) {
															options->filterSmoothMeasfreq[staType][j][k][l][m]=freq3[m];
														}
													} else {
														//Remove smoothing from measurement
														options->filterMeasSmoothed[staType][j][k][l]=0;
														options->filterMeasTypeList[staType][j][k][l]--;
													}
													break;
												}
											}
										}
									}
								}
							} else {
								//Compatibility mode where the position of the measurement in the list was given
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										if(options->filterMeasKind[staType][j][k][filterMeasPosition]!=Pseudorange) {
											if (options->filterMeasList[staType][j][k][filterMeasPosition][0]==NA) {
												sprintf(messagestr,"Automatic carrier phase measurement from frequency %d (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",options->filterMeasfreq[staType][j][k][filterMeasPosition][0],gnsstype2gnssstr(j),k);
											} else {
												sprintf(messagestr,"%s carrier phase measurement (for %s %d) selected for smoothing, but smoothing can only be applied to pseudorange measurements",meastype2measstr(options->filterMeasList[staType][j][k][filterMeasPosition][0]),gnsstype2gnssstr(j),k);
											}
											printError(messagestr,options);
										}
										//Save smoothing measurements
										if (filterMeasPosition<options->numfilterMeasList[staType][j][k]) { //Check that PRN has as much measurements as the position points to
											options->filterSmoothMeasList[staType][j][k][filterMeasPosition][0]=meas;
											options->filterSmoothListWithMeas[staType][j][k][filterMeasPosition]=0;
											options->filterSmoothListMeasSelected[staType][j][k][filterMeasPosition]=0;
											options->numCombfilterSmoothMeas[staType][j][k][filterMeasPosition]=numMeasComb;
											options->filterMeasTypeList[staType][j][k][filterMeasPosition]++;
											for(m=0;m<4;m++) {
												options->filterSmoothMeasfreq[staType][j][k][filterMeasPosition][m]=freq3[m];
											}
										}
									}
								}
							}
						} else {
							//Search for provided measurement in the filter. If found, save the weight
							for(q=0;q<=ComboPhaseAndCode;q++) {
								if (q==1) {
									//This is the case where both code and phase have been selected
									//First iteration is for code and second fo pseudorange
									meastype=meastypeAlt;
									measKind[0]=CarrierPhase;
								}
								for(j=0;j<MAX_GNSS;j++) {
									if(GNSSused[j]==0) continue;
									for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
										if(PRNused[k]==0) continue;
										if (options->includeSatellite[j][k]==0) continue;
										for(l=0;l<options->numfilterMeasList[staType][j][k];l++) {
											if (options->filterMeasTypeList[staType][j][k][l]<DivergenceFreeCodeSmoothed && options->filterMeasTypeList[staType][j][k][l]!=OTHER_MEAS) {
												meastypeSmooth=meastype+1;
											} else {
												meastypeSmooth=meastype;
											}
											if ((options->filterMeasTypeList[staType][j][k][l]==meastype || options->filterMeasTypeList[staType][j][k][l]==meastypeSmooth)
												&& options->filterMeasKind[staType][j][k][l]==measKind[0] 
												&& options->filterListWithMeas[staType][j][k][l]==userMeas 
												&& options->filterMeasList[staType][j][k][l][0]==meas) {

												if (meas==NA) {
													if (options->filterMeasfreq[staType][j][k][l][0]!=freq3[0]) {
														//Measurement not in list
														continue;
													}
												}

												if (mode==parseWeightFiltermeas) {
													options->weightMode[j][k][l]=sopt->weightMode[i];
													options->WeightConstantsValues[j][k][l][0]=sopt->WeightConstantsValues[i][0];
													options->WeightConstantsValues[j][k][l][1]=sopt->WeightConstantsValues[i][1];
													options->WeightConstantsValues[j][k][l][2]=sopt->WeightConstantsValues[i][2];
													if (sopt->WeightConstantsValues[i][0]==0.&& sopt->WeightConstantsValues[i][1]==0.) {
														sprintf(messagestr,"Constants 'a' and 'b' cannot be both 0 for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
														printError(messagestr,options);
													} else if (sopt->WeightConstantsValues[i][0]==-2) {
													   if (sopt->navMode==NMppp) {
															sprintf(messagestr,"URA value for weights cannot be used in PPP mode for '%s' weight mode, %s %d and filter measurement '%s'",WeightModeNum2WeightModestr(sopt->weightMode[i]),gnsstype2gnssstr(j),k,sopt->weightText[i]);
															printError(messagestr,options);
													   } else if (j==GLONASS) {
															sprintf(messagestr,"URA value for weights cannot be used with %s constellation, as its RINEX navigation message does not contain an URA value. Change filter measurement '%s'",gnsstype2gnssstr(j),sopt->weightText[i]);
															printError(messagestr,options);
													   }
													}
												} else if (mode==parseWeightCombFiltermeas) {
													options->SNRweightComb[j][k][l]=sopt->SNRweightComb[i];
													options->SNRweightCombVal[j][k][l][0]=sopt->SNRweightCombVal[i][0];
													options->SNRweightCombVal[j][k][l][1]=sopt->SNRweightCombVal[i][1];
													options->SNRweightCombVal[j][k][l][2]=sopt->SNRweightCombVal[i][2];
													options->SNRweightCombVal[j][k][l][3]=sopt->SNRweightCombVal[i][3];
												} else {
													if (sopt->CombineWeightMode[i]==ComputedOnly) {
														if (options->SBAScorrections>=SBAS1Fused) {
															options->weightMode[j][k][l]=SBASOnlyWeight;
														} else if (options->DGNSS==1) {
															options->weightMode[j][k][l]=DGNSSOnlyWeight;
														}
													} else if(sopt->CombineWeightMode[i]==ComputedPlusUser) {
														if (options->SBAScorrections>=SBAS1Fused && options->weightMode[j][k][l]!=UnknownWeight) {
															options->weightMode[j][k][l]=SBASFixedWeight+options->weightMode[j][k][l];
														} else if (options->DGNSS==1 && options->weightMode[j][k][l]!=UnknownWeight) {
															options->weightMode[j][k][l]=DGNSSFixedWeight+options->weightMode[j][k][l];
														}
													}
												}
												break;
											}
										}
									}	
								}
							}
						}
					}
				} //End if looking manually for old meas
			} //for(h=0;h<2;h++) 
		} //for(i=0;i<numMeasRead;i++) 


	}
	return;
	
}

/*****************************************************************************
 * Name        : parseOption
 * Description : Parse an option from a vector of strings into the options or
 *               support options
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TSupportOptions  *sopt          O  N/A  TSupportOptions structure
 * TOptions  *options              O  N/A  TOptions structure
 * char  *argv[]                   I  N/A  Vector of strings to be parsed
 * Returned value (int)            O  N/A  Status of the function
 *                                         -4 => Parameter length too long
 *                                         -3 => Missing second parameter                                        
 *                                         -2 => Parameter value not valid
 *                                         -1 => Parameter name unknown
 *                                          0 => Help/examples message (end program)
 *                                         >0 => Number of strings parsed
 *****************************************************************************/
int parseOption (TSupportOptions *sopt, TOptions *options, char *argv[]) {
	int						aux1,aux2,aux3,aux4,aux5,aux6,aux7,aux8,aux9;
	double					auxd,auxd2,auxd3;
	double					auxdarray[4];
	int						i,j,k,l,m,n;
	int						removeMeas,lastCharac;
	int						GNSSused[MAX_GNSS],PRNused[MAX_SATELLITES_PER_GNSS];
	int						staType,len1,len2;
	char					*p,*p2,*p3,*p4;
	char					auxstr[41];
	enum MeasurementType	meas;
	enum MeasurementKind	measType;
	enum ReceiverType		recType;
	enum GenericDCBModel	dcbType;
	struct tm   			tm;

	if (strcasecmp(argv[0],"-help")==0 || strcasecmp(argv[0],"--help")==0) {
		showHelp();
		return 0;
	} else if (strcasecmp(argv[0],"-examples")==0 || strcasecmp(argv[0],"--examples")==0) {
		showExamples();
		return 0;
	} else if (strcasecmp(argv[0],"-config")==0 || strcasecmp(argv[0],"--config")==0) {
		showConfig();
		return 0;
	} else if (strcasecmp(argv[0],"-messages")==0 || strcasecmp(argv[0],"--messages")==0) {
		showMessages();
		return 0;
	} else if (strcasecmp(argv[0],"-messagesv5")==0 || strcasecmp(argv[0],"--messagesv5")==0) {
		showMessagesv5();
		return 0;
	} else if (strcasecmp(argv[0],"-usererrorfile")==0 || strcasecmp(argv[0],"--usererrorfile")==0) {
		showusererrorfile();
		return 0;
	} else if (strcasecmp(argv[0],"-sigmamultipathfile")==0 || strcasecmp(argv[0],"--sigmamultipathfile")==0) {
		showsigmamultipathfile();
		return 0;
	} else if (strcasecmp(argv[0],"-rtcmv2conversioninfo")==0 || strcasecmp(argv[0],"--rtcmv2conversioninfo")==0) {
		showRTCMv2ConversionInfo();
		return 0;
	} else if (strcasecmp(argv[0],"-referenceposfile")==0 || strcasecmp(argv[0],"--referenceposfile")==0) {
		showReferencePositionFileInfo();
		return 0;
	} else if (strcasecmp(argv[0],"-sbasplotsinfo")==0 || strcasecmp(argv[0],"--sbasplotsinfo")==0 || 
			strcasecmp(argv[0],"-sbasmapsinfo")==0 || strcasecmp(argv[0],"--sbasmapsinfo")==0) {
		showSBASPlotsInfo();
		return 0;
	} else if (strcasecmp(argv[0],"-showfaq")==0 || strcasecmp(argv[0],"--showfaq")==0 ||
			strcasecmp(argv[0],"-faq")==0 || strcasecmp(argv[0],"--faq")==0) {
		showFAQ();
		return 0;
	} else if (strcasecmp(argv[0],"-autofillscript")==0 || strcasecmp(argv[0],"--autofillscript")==0 ) {
		showBashAutoCompleteScript();
		return 0;
	} else if (strcasecmp(argv[0],"-onlyconvert")==0 ) {
		options->onlyconvertSBAS=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:file")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->outFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"--output:file")==0) {
		sopt->outFile[0]='\0';
		return 1;
	} else if (strcasecmp(argv[0],"-output:kml")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->kmlFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:kml0")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->kml0File,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:kml:egm96geoid")==0) {
		options->KMLEGM96height=1;
		return 1;
	} else if (strcasecmp(argv[0],"--output:kml:egm96geoid")==0) {
		options->KMLEGM96height=0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:kml:refsta")==0) {
		options->referenceStations=1;
		return 1;
	} else if (strcasecmp(argv[0],"--output:kml:refsta")==0) {
		options->referenceStations=0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:kml:tstamp")==0) {
		options->KMLTimeStamps=1;
		return 1;
	} else if (strcasecmp(argv[0],"--output:kml:tstamp")==0) {
		options->KMLTimeStamps=0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:kml:tstampdec")==0) {
		if (argv[1]==NULL) return -3;
		options->KMLTimeStamps=1;
		auxd=atof(argv[1]);
		if(auxd<0.) return -2;
		if(auxd>1.) auxd=(double)((int)(auxd)); //If decimation is greater than 1, eliminate decimals
		options->KMLTimeStampDec=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-output:kml:tstamprange")==0) {
		if (argv[1]==NULL||argv[2]==NULL) return -3;
		options->KMLTimeStamps=1;
		if(strcmp(argv[1],"-")==0) {
			auxd3=1.; //Flag to indicate 'Start of file'
			auxd=0.;
		} else {
			auxd3=0.; 
			auxd=atof(argv[1]);
			if(auxd<0.) return -2;
		}
		if(strcmp(argv[2],"-")==0) {
			auxd2=9999999999999.;
		} else {
			auxd2=atof(argv[2]);
			if(auxd2<0.) return -2;
		}
		//Check if ranges already exist (this is because this function is called several times,
		//so we need to avoid loading the same ranges multiple times
		for(i=0;i<options->numKMLTimeRanges;i++) {
			if (options->KMLtimeranges[i][0]==auxd && options->KMLtimeranges[i][1]==auxd2 && options->KMLtimeranges[i][2]==auxd3) {
				//Range found
				return 3;
			}
		}
		options->KMLtimeranges=realloc(options->KMLtimeranges,sizeof(double*)*(options->numKMLTimeRanges+1));
		options->KMLtimeranges[options->numKMLTimeRanges]=malloc(sizeof(double)*3);
		options->KMLtimeranges[options->numKMLTimeRanges][0]=auxd;
		options->KMLtimeranges[options->numKMLTimeRanges][1]=auxd2;
		options->KMLtimeranges[options->numKMLTimeRanges][2]=auxd3; 
		options->numKMLTimeRanges++;
		return 3;
	} else if (strcasecmp(argv[0],"-output:sp3")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->SP3OutputFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:sp3:letter")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])!=1) return -2;
		options->SP3Letter=argv[1][0];
		return 2;
	} else if (strcasecmp(argv[0],"-output:sp3:prn")==0) {
		if (argv[1]==NULL) return -3;
		aux1=atoi(argv[1]);
		if(aux1<0 || aux1>=100 ) return -2;
		options->SP3PRN=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sp3:dgnssonly")==0) {
		options->WriteSPPsolInDGNSSmodeSP3=0;
		return 1;
	} else if (strcasecmp(argv[0],"--output:sp3:dgnssonly")==0) {
		options->WriteSPPsolInDGNSSmodeSP3=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:refpos")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->RefPosOutputFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:refpos:doy")==0) {
		options->YearSoDRefFile=1;
		options->GPSWeekRefFile=0;
		options->CalendarTimeRefFile=0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:refpos:gpsweek")==0) {
		options->YearSoDRefFile=0;
		options->GPSWeekRefFile=1;
		options->CalendarTimeRefFile=0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:refpos:caltime")==0) {
		options->YearSoDRefFile=0;
		options->GPSWeekRefFile=0;
		options->CalendarTimeRefFile=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:refpos:geodetic")==0) {
		options->GeodeticCoordRefFile=1;
		return 1;
	} else if (strcasecmp(argv[0],"--output:refpos:geodetic")==0) {
		options->GeodeticCoordRefFile=0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:refpos:dgnssonly")==0) {
		options->WriteSPPsolInDGNSSmodeRefFile=0;
		return 1;
	} else if (strcasecmp(argv[0],"--output:refpos:dgnssonly")==0) {
		options->WriteSPPsolInDGNSSmodeRefFile=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:rinex")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4; 
		strcpy(sopt->rnxFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:antenna")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->antennaASCIIFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:corrections")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->dataASCIIFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:rinexversion")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 != 2 && aux1 != 3 ) return -2;
		options->rinexVersion = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-output:satvel")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"inertial")==0) {
			options->satVel = svINERTIAL;
			return 2;
		} else if (strcasecmp(argv[1],"itrf")==0) {
			options->satVel = svITRF;
			return 2;
		} else return -2;
	} else if (strcasecmp(argv[0],"-output:rinexb")==0) {
		options->writeRinexBfile=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:ems")==0) {
		options->writeEMSfile=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:pegasus")==0) {
		options->writePegasusfile=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:pegspace")==0) {
		options->pegasusfs=' ';
		return 1;
	} else if (strcasecmp(argv[0],"-output:sbasdir")==0) {
		if (argv[1]==NULL) return -3;
		if (argv[1][0]=='\0') return -2;
		if(strlen(argv[1])>MAX_INPUT_LINE-20) return -4; //MAX_INPUT_LINE-20 to fit output file name and slash
		strcpy(options->sbasdir,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-output:pegstrictrinex")==0) {
		options->pegasuspurerinex=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:pegfilealign")==0) {
		options->pegasusaligned=1;
		return 1;
	} else if (strcasecmp(argv[0],"-output:stfdesa")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->stanfordESAFile,argv[1]);
		options->stanfordesa=1;
		return 2;
	} else if (strcasecmp(argv[0],"-output:stfdesaLOI")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->stanfordESALOIFile,argv[1]);
		options->stanfordesa=1;
		options->stanfordesaLOI=1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:cfg")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->cfgFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:obs")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->obsFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:nav")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numNav<MAX_NAV_FILES) { 
				//We do not copy the name of the file when limit is surpassed to avoid buffer overflow
				strcpy(sopt->navFile[sopt->numNav],argv[l]);
			}
			sopt->numNav++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:navglo")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->glonavFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:navhealth")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numNavHealth<MAX_NAV_FILES) { 
				strcpy(sopt->navHealthFile[sopt->numNavHealth],argv[l]);
			}
			sopt->numNavHealth++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:dgnss")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->dgnssFile,argv[1]);
		options->DGNSS = 1;
		options->RTCMmode = ProcessRINEX;
		return 2;
	} else if (strcasecmp(argv[0],"-input:rtcm")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->rtcmFile,argv[1]);
		options->DGNSS = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:rtcm2")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->rtcm2File,argv[1]);
		options->DGNSS = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:rtcm3")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->rtcm3File,argv[1]);
		options->DGNSS = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:rtcm:initdate")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		aux2 = (int)(aux1/10000);
		if ( aux2 < 1000 || aux2 > 9999 ) return -2;
		options->rtcmYear = aux2;
		aux6 = (int)(aux2/100);
		aux7 = (int)(aux2-aux6*100);
		options->rtcmYearShort = aux7;
		aux3 = (int)(aux1-aux2*10000);
		aux4 = (int)(aux3/100);
		if ( aux4 > 12 ) return -2;
		options->rtcmMonth = aux4;
		aux5 = (int)(aux3-aux4*100);
		if ( aux5 > 31 ) return -2;
		options->rtcmDay = aux5;
		return 2;
	} else if (strcasecmp(argv[0],"-input:rtcm:inithour")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 < 0 || aux1 > 23 ) return -2;
		options->rtcmHour = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:sp3")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numSP3<MAX_SP3_FILES) {  
				//We do not copy the name of the file when limit is surpassed to avoid buffer overflow
				strcpy(sopt->SP3File[sopt->numSP3],argv[l]);
			}
			sopt->numSP3++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:con")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->conFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:orb")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numOrb<MAX_SP3_FILES) { 
				//We do not copy the name of the file when limit is surpassed to avoid buffer overflow
				strcpy(sopt->orbFile[sopt->numOrb],argv[l]);
			}
			sopt->numOrb++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:clk")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numClk<MAX_SP3_FILES) {
				//We do not copy the name of the file when limit is surpassed to avoid buffer overflow
				strcpy(sopt->clkFile[sopt->numClk],argv[l]);
			}
			sopt->numClk++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:ant")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->antFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:antrec")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numAntRec<MAX_RECV_ANTEX_FILES) {
				//We do not copy the name of the file when limit is surpassed to avoid buffer overflow
				strcpy(sopt->antrecFile[sopt->numAntRec],argv[l]);
			}
			sopt->numAntRec++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:antsatblock")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->antsatblockFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:klb")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->klbFile,argv[1]);
		sopt->ionoModel = KlobucharIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:bei")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->beiFile,argv[1]);
		sopt->ionoModel = BeiDouIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:bds")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->beiFile,argv[1]);
		sopt->ionoModel = BeiDouIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:inx")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->inxFile,argv[1]);
		sopt->ionoModel = IONEXIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:fpp")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->fppFile,argv[1]);
		sopt->ionoModel = FPPPIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:neq")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->neqFile,argv[1]);
		sopt->ionoModel = neQuickIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:SBASiono")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->SBASIONOFile,argv[1]);
		sopt->ionoModel = SBASIonoModel;
		return 2;
	} else if (strcasecmp(argv[0],"-input:dcb")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if(strlen(argv[l])>MAX_INPUT_LINE-1) return -4;
			if(sopt->numTGD<MAX_DCB_FILE_SOURCES) {
				strcpy(sopt->tgdFile[sopt->numTGD],argv[l]);
			}
			sopt->numTGD++;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-input:rec")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->recFile,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-input:snx")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->snxFile,argv[1]);
		options->receiverPositionSource = rpSINEX;
		options->recPosProvided=1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:sbas")==0||strcasecmp(argv[0],"-input:sbas1f")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1-20) return -4; //The 20 characters is because we will use this name to generate an automatic output filename
		strcpy(sopt->sbasFile,argv[1]);
		sopt->SBAScorrections=SBAS1Fused;
		options->SBASFreqPosToProcess=SBAS1FFREQPOS;
		options->SBASmodePos=SBAS1FMODEPOS;
		sopt->sbas1FfileProvided=1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:sbasdfmc")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1-20) return -4; //The 20 characters is because we will use this name to generate an automatic output filename
		strcpy(sopt->sbasFile,argv[1]);
		sopt->SBAScorrections=SBASDFMCused;
		options->SBASFreqPosToProcess=SBASDFMCFREQPOS;
		options->SBASmodePos=SBASDFMCMODEPOS;
		sopt->sbasDFMCfileProvided=1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:sigmpath")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sigmamultipathFile,argv[1]);
		options->usersigmamultipath=1;
		options->airborneReceiverType=0;
		return 2;
	} else if (strcasecmp(argv[0],"-input:usererror")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->addederrorFile,argv[1]);
		options->useraddednoise=1;
		return 2;
	} else if (strcasecmp(argv[0],"-input:refpos")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->posReferenceFile,argv[1]);
		if (options->receiverPositionSource==rpUNKNOWN) {
			//User has not set any mode. Set the default mode with reference file
			options->receiverPositionSource = rpCALCULATEREF;
		}
		options->recPosProvided=1;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:usererrorafter")==0) {
		options->useraddednoisepreprocess=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:usererrorafter")==0) {
		options->useraddednoisepreprocess=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:elevation")==0) {
		if (argv[1]==NULL) return -3;
		options->elevationMask = atof(argv[1])*d2r;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:eclipse")==0) {
		sopt->discardEclipsedSatellites = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:eclipse")==0) {
		sopt->discardEclipsedSatellites = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:dec")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<0.) return -2;
		if (auxd>=1.) auxd=(double)((int)(auxd+.00005)); //If decimation is greater than 1, eliminate decimals
		options->decimate = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:prealign")==0) {
		options->prealignCP = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:prealign")==0) {
		options->prealignCP = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:checkcodejumps")==0) {
		options->checkPhaseCodeJumps = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:checkcodejumps")==0) {
		options->checkPhaseCodeJumps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:datagap")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		if( auxd>=1.) auxd = (double)((int)(auxd));
		options->csDataGap = auxd;
		options->csDataGapSizeMode = csDataGapSizeUser;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:lli")==0) {
		sopt->csLLI = 1;
		sopt->csLLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:lli")==0) {
		sopt->csLLI = 0;
		sopt->csLLIPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:ncon")==0) {
	  options->csNcon = 1;
	  return 1;
   } else if (strcasecmp(argv[0],"--pre:cs:ncon")==0) {
	  options->csNcon = 0;
	  return 1;
   }  else if (strcasecmp(argv[0],"-pre:cs:ncon:min")==0) {
	  if (argv[1]==NULL) return -3;
	  aux1 = atoi(argv[1]);
	  if ( aux1 < 0 ) return -2;
	  else if ( aux1 < 2 ) {
		  options->csNcon = 0;
	  } else {
		  options->csNconMin = -1 * ( aux1 - 1 );
		  options->csNcon = 1;
	  }
	  return 2;
   } else if (strcasecmp(argv[0],"-pre:cs:li")==0) {
		sopt->csLI = 1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:li")==0) {
		sopt->csLI = 0;
		sopt->csLIPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:li:freq")==0||strcasecmp(argv[0],"-pre:cs:li:freqlist")==0||
			strcasecmp(argv[0],"-pre:cs:li:freqdgnss")==0||strcasecmp(argv[0],"-pre:cs:li:freqlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:li:freq")==0||strcasecmp(argv[0],"-pre:cs:li:freqlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:li:freq")==0||strcasecmp(argv[0],"-pre:cs:li:freqdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csLIfreqtext[staType]=realloc(sopt->csLIfreqtext[staType],sizeof(char *)*(sopt->numcsLIfreqtext[staType]+i));
					sopt->csLIfreqtext[staType][sopt->numcsLIfreqtext[staType]+i-1]=NULL;
					sopt->csLIfreqtext[staType][sopt->numcsLIfreqtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csLIfreqtext[staType][sopt->numcsLIfreqtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsLIfreqtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:li:freqlist")==0||strcasecmp(argv[0],"-pre:cs:li:freqlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csLIfreqtext[staType]=realloc(sopt->csLIfreqtext[staType],sizeof(char *)*(sopt->numcsLIfreqtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csLIfreqtext[staType][sopt->numcsLIfreqtext[staType]+i]=NULL;
				sopt->csLIfreqtext[staType][sopt->numcsLIfreqtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csLIfreqtext[staType][sopt->numcsLIfreqtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsLIfreqtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:li:meas")==0||strcasecmp(argv[0],"-pre:cs:li:measlist")==0||
			strcasecmp(argv[0],"-pre:cs:li:measdgnss")==0||strcasecmp(argv[0],"-pre:cs:li:measlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:li:meas")==0||strcasecmp(argv[0],"-pre:cs:li:measlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:li:meas")==0||strcasecmp(argv[0],"-pre:cs:li:measdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csLItext[staType]=realloc(sopt->csLItext[staType],sizeof(char *)*(sopt->numcsLItext[staType]+i));
					sopt->csLItext[staType][sopt->numcsLItext[staType]+i-1]=NULL;
					sopt->csLItext[staType][sopt->numcsLItext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csLItext[staType][sopt->numcsLItext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsLItext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:li:measlist")==0||strcasecmp(argv[0],"-pre:cs:li:measlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csLItext[staType]=realloc(sopt->csLItext[staType],sizeof(char *)*(sopt->numcsLItext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csLItext[staType][sopt->numcsLItext[staType]+i]=NULL;
				sopt->csLItext[staType][sopt->numcsLItext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csLItext[staType][sopt->numcsLItext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsLItext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:li:min")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:li:min' is deprecated\n");
		}
		options->deprecatedMode = 1;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:li:maxjump")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csLImaxjump = auxd;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:li:max")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csLImax = auxd;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:li:t0")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csLIt = auxd;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:li:samples")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csLIsamples = aux1;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:li:nooutliers")==0) {
		options->csLIenableOutlier = 0;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:li:nooutliers")==0) {
		options->csLIenableOutlier = 1;
		sopt->csLI=1;
		sopt->csLIPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:bw")==0) {
		sopt->csMW = 1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw' is deprecated. Use '-pre:cs:mw' instead\n");
		}
		options->deprecatedMode = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:bw")==0) {
		sopt->csMW = 0;
		sopt->csMWPosOff = sopt->csPos;
		sopt->csPos++;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '--pre:cs:bw' is deprecated. Use '--pre:cs:mw' instead\n");
		}
		options->deprecatedMode = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:mw")==0) {
		sopt->csMW = 1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:mw")==0) {
		sopt->csMW = 0;
		sopt->csMWPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:freq")==0||strcasecmp(argv[0],"-pre:cs:mw:freqlist")==0||
			strcasecmp(argv[0],"-pre:cs:mw:freqdgnss")==0||strcasecmp(argv[0],"-pre:cs:mw:freqlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:mw:freq")==0||strcasecmp(argv[0],"-pre:cs:mw:freqlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:mw:freq")==0||strcasecmp(argv[0],"-pre:cs:mw:freqdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csMWfreqtext[staType]=realloc(sopt->csMWfreqtext[staType],sizeof(char *)*(sopt->numcsMWfreqtext[staType]+i));
					sopt->csMWfreqtext[staType][sopt->numcsMWfreqtext[staType]+i-1]=NULL;
					sopt->csMWfreqtext[staType][sopt->numcsMWfreqtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csMWfreqtext[staType][sopt->numcsMWfreqtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsMWfreqtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:mw:freqlist")==0||strcasecmp(argv[0],"-pre:cs:mw:freqlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csMWfreqtext[staType]=realloc(sopt->csMWfreqtext[staType],sizeof(char *)*(sopt->numcsMWfreqtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csMWfreqtext[staType][sopt->numcsMWfreqtext[staType]+i]=NULL;
				sopt->csMWfreqtext[staType][sopt->numcsMWfreqtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csMWfreqtext[staType][sopt->numcsMWfreqtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsMWfreqtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:mw:meas")==0||strcasecmp(argv[0],"-pre:cs:mw:measlist")==0||
			strcasecmp(argv[0],"-pre:cs:mw:measdgnss")==0||strcasecmp(argv[0],"-pre:cs:mw:measlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:mw:meas")==0||strcasecmp(argv[0],"-pre:cs:mw:measlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:mw:meas")==0||strcasecmp(argv[0],"-pre:cs:mw:measdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csMWtext[staType]=realloc(sopt->csMWtext[staType],sizeof(char *)*(sopt->numcsMWtext[staType]+i));
					sopt->csMWtext[staType][sopt->numcsMWtext[staType]+i-1]=NULL;
					sopt->csMWtext[staType][sopt->numcsMWtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csMWtext[staType][sopt->numcsMWtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsMWtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:mw:measlist")==0||strcasecmp(argv[0],"-pre:cs:mw:measlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csMWtext[staType]=realloc(sopt->csMWtext[staType],sizeof(char *)*(sopt->numcsMWtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csMWtext[staType][sopt->numcsMWtext[staType]+i]=NULL;
				sopt->csMWtext[staType][sopt->numcsMWtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csMWtext[staType][sopt->numcsMWtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsMWtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:bw:min")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:min' is deprecated\n");
		}
		options->deprecatedMode = 1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:max")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:max' is deprecated\n");
		}
		options->deprecatedMode = 1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:siginit")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:siginit' is deprecated, the updated one is '-pre:cs:mw:siginit'\n");
		}
		options->deprecatedMode = 1;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csMWInitStd = auxd;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:siginit")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csMWInitStd = auxd;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:sigmin")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:sigmin' is deprecated, the updated one is '-pre:cs:mw:sigmin'\n");
		}
		options->deprecatedMode = 1;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csMWmin = auxd;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:sigmin")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csMWmin = auxd;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:timewindow")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:timewindow' is deprecated, the updated one is '-pre:cs:mw:timewindow'\n");
		}
		options->deprecatedMode = 1;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csMWwindow = aux1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:timewindow")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csMWwindow = aux1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:kfactor")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:kfactor' is deprecated, the updated one is '-pre:cs:mw:kfactor'\n");
		}
		options->deprecatedMode = 1;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csMWkfactor = auxd;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:kfactor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csMWkfactor = auxd;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:slope")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:slope' is deprecated, the updated one is '-pre:cs:mw:kfactor'. It has been set to its default value\n");
		}
		options->deprecatedMode = 1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:bw:samples")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:bw:samples' is deprecated, the updated one is '-pre:cs:mw:samples'\n");
		}
		options->deprecatedMode = 1;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csMWsamples = aux1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:samples")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csMWsamples = aux1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:nooutliers")==0) {
		options->csMWenableOutlier = 0;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:mw:nooutliers")==0) {
		options->csMWenableOutlier = 1;
		sopt->csMW=1;
		sopt->csMWPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1' is deprecated, the updated one is '-pre:cs:sf'.\n");
		}
		options->deprecatedMode = 1;
		sopt->csSF = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:sf")==0) {
		sopt->csSF = 1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:l1c1")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '--pre:cs:l1c1' is deprecated, the updated one is '--pre:cs:sf'.\n");
		}
		options->deprecatedMode = 1;
		sopt->csSF = 0;
		sopt->csSFPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:sf")==0) {
		sopt->csSF = 0;
		sopt->csSFPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:freq")==0||strcasecmp(argv[0],"-pre:cs:sf:freqlist")==0||
			strcasecmp(argv[0],"-pre:cs:sf:freqdgnss")==0||strcasecmp(argv[0],"-pre:cs:sf:freqlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:sf:freq")==0||strcasecmp(argv[0],"-pre:cs:sf:freqlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:sf:freq")==0||strcasecmp(argv[0],"-pre:cs:sf:freqdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csSFfreqtext[staType]=realloc(sopt->csSFfreqtext[staType],sizeof(char *)*(sopt->numcsSFfreqtext[staType]+i));
					sopt->csSFfreqtext[staType][sopt->numcsSFfreqtext[staType]+i-1]=NULL;
					sopt->csSFfreqtext[staType][sopt->numcsSFfreqtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csSFfreqtext[staType][sopt->numcsSFfreqtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsSFfreqtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:sf:freqlist")==0||strcasecmp(argv[0],"-pre:cs:sf:freqlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csSFfreqtext[staType]=realloc(sopt->csSFfreqtext[staType],sizeof(char *)*(sopt->numcsSFfreqtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csSFfreqtext[staType][sopt->numcsSFfreqtext[staType]+i]=NULL;
				sopt->csSFfreqtext[staType][sopt->numcsSFfreqtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csSFfreqtext[staType][sopt->numcsSFfreqtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsSFfreqtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:sf:meas")==0||strcasecmp(argv[0],"-pre:cs:sf:measlist")==0||
			strcasecmp(argv[0],"-pre:cs:sf:measdgnss")==0||strcasecmp(argv[0],"-pre:cs:sf:measlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:sf:meas")==0||strcasecmp(argv[0],"-pre:cs:sf:measlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:sf:meas")==0||strcasecmp(argv[0],"-pre:cs:sf:measdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csSFtext[staType]=realloc(sopt->csSFtext[staType],sizeof(char *)*(sopt->numcsSFtext[staType]+i));
					sopt->csSFtext[staType][sopt->numcsSFtext[staType]+i-1]=NULL;
					sopt->csSFtext[staType][sopt->numcsSFtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csSFtext[staType][sopt->numcsSFtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsSFtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:sf:measlist")==0||strcasecmp(argv[0],"-pre:cs:sf:measlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csSFtext[staType]=realloc(sopt->csSFtext[staType],sizeof(char *)*(sopt->numcsSFtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csSFtext[staType][sopt->numcsSFtext[staType]+i]=NULL;
				sopt->csSFtext[staType][sopt->numcsSFtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csSFtext[staType][sopt->numcsSFtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsSFtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:unconcheck")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:unconcheck' is deprecated, the updated one is '-pre:cs:sf:unconcheck'.\n");
		}
		options->deprecatedMode = 1;
		options->csUnconsistencyCheck = 1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:unconcheck")==0) {
		options->csUnconsistencyCheck = 1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:l1c1:unconcheck")==0) {
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '--pre:cs:l1c1:unconcheck' is deprecated, the updated one is '--pre:cs:sf:unconcheck'.\n");
		}
		options->deprecatedMode = 1;
		options->csUnconsistencyCheck = 0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:sf:unconcheck")==0) {
		options->csUnconsistencyCheck = 0;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:kfactor")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:kfactor' is deprecated, the updated one is '-pre:cs:sf:kfactor'.\n");
		}
		options->deprecatedMode = 1;
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csSFkfactor = auxd;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:kfactor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csSFkfactor = auxd;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:unconcheck:th")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:unconcheck:th' is deprecated, the updated one is '-pre:cs:sf:unconcheck:th'.\n");
		}
		options->deprecatedMode = 1;
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd <=0. ) return -2;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		options->csUnconsistencyCheck = 1;
		options->csUnconsistencyCheckThreshold = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:unconcheck:th")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd <=0. ) return -2;
		options->csUnconsistencyCheck = 1;
		options->csUnconsistencyCheckThreshold = auxd;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:slope")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:slope' is deprecated, the updated one is '-pre:cs:sf:kfactor'. It has been set to its default value\n");
		}
		options->deprecatedMode = 1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:window")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:window' is deprecated, the updated one is '-pre:cs:sf:timewindow'. It has been set to its default value\n");
		}
		options->deprecatedMode = 1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:max")==0) {
		if (argv[1]==NULL) return -3;
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:max' is deprecated\n");
		}
		options->deprecatedMode = 1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:timewindow")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:timewindow' is deprecated, the updated one is '-pre:cs:sf:timewindow'.\n");
		}
		options->deprecatedMode = 1;
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csSFwindow = aux1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:timewindow")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csSFwindow = aux1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:init")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:init' is deprecated, the updated one is '-pre:cs:sf:init'.\n");
		}
		options->deprecatedMode = 1;
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csSFinit = auxd;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:init")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csSFinit = auxd;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:l1c1:samples")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Cycle-slip option '-pre:cs:l1c1:samples' is deprecated, the updated one is '-pre:cs:sf:samples'.\n");
		}
		options->deprecatedMode = 1;
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csSFsamples = aux1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:samples")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csSFsamples = aux1;
		sopt->csSF=1;
		sopt->csSFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:igf")==0) {
		sopt->csIGF = 1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:igf")==0) {
		sopt->csIGF = 0;
		sopt->csIGFPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:minnoise")==0) {
		options->csIGFminNoise = 1;
		sopt->csIGF = 1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:igf:minnoise")==0) {
		options->csIGFminNoise = 0;
		sopt->csIGF = 1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:allowcodes")==0) {
		options->csIGFallowCodes = 1;
		sopt->csIGF = 1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:igf:allowcodes")==0) {
		options->csIGFallowCodes = 0;
		sopt->csIGF = 1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:freq")==0||strcasecmp(argv[0],"-pre:cs:igf:freqlist")==0||
			strcasecmp(argv[0],"-pre:cs:igf:freqdgnss")==0||strcasecmp(argv[0],"-pre:cs:igf:freqlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:igf:freq")==0||strcasecmp(argv[0],"-pre:cs:igf:freqlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:igf:freq")==0||strcasecmp(argv[0],"-pre:cs:igf:freqdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csIGFfreqtext[staType]=realloc(sopt->csIGFfreqtext[staType],sizeof(char *)*(sopt->numcsIGFfreqtext[staType]+i));
					sopt->csIGFfreqtext[staType][sopt->numcsIGFfreqtext[staType]+i-1]=NULL;
					sopt->csIGFfreqtext[staType][sopt->numcsIGFfreqtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csIGFfreqtext[staType][sopt->numcsIGFfreqtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsIGFfreqtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:igf:freqlist")==0||strcasecmp(argv[0],"-pre:cs:igf:freqlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csIGFfreqtext[staType]=realloc(sopt->csIGFfreqtext[staType],sizeof(char *)*(sopt->numcsIGFfreqtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csIGFfreqtext[staType][sopt->numcsIGFfreqtext[staType]+i]=NULL;
				sopt->csIGFfreqtext[staType][sopt->numcsIGFfreqtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csIGFfreqtext[staType][sopt->numcsIGFfreqtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsIGFfreqtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:igf:meas")==0||strcasecmp(argv[0],"-pre:cs:igf:measlist")==0 ||
			strcasecmp(argv[0],"-pre:cs:igf:measdgnss")==0||strcasecmp(argv[0],"-pre:cs:igf:measlistdgnss")==0) {
		if (argv[1]==NULL) return -3;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		if (strcasecmp(argv[0],"-pre:cs:igf:meas")==0||strcasecmp(argv[0],"-pre:cs:igf:measlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		if (strcasecmp(argv[0],"-pre:cs:igf:meas")==0||strcasecmp(argv[0],"-pre:cs:igf:measdgnss")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->csIGFtext[staType]=realloc(sopt->csIGFtext[staType],sizeof(char *)*(sopt->numcsIGFtext[staType]+i));
					sopt->csIGFtext[staType][sopt->numcsIGFtext[staType]+i-1]=NULL;
					sopt->csIGFtext[staType][sopt->numcsIGFtext[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->csIGFtext[staType][sopt->numcsIGFtext[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numcsIGFtext[staType]+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-pre:cs:igf:measlist")==0 || strcasecmp(argv[0],"-pre:cs:igf:measlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->csIGFtext[staType]=realloc(sopt->csIGFtext[staType],sizeof(char *)*(sopt->numcsIGFtext[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->csIGFtext[staType][sopt->numcsIGFtext[staType]+i]=NULL;
				sopt->csIGFtext[staType][sopt->numcsIGFtext[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->csIGFtext[staType][sopt->numcsIGFtext[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numcsIGFtext[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:cs:igf:maxjump")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csIGFmaxjump = auxd;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:max")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csIGFmax = auxd;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:t0")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if ( auxd <= 0. ) return -2;
		options->csIGFt = auxd;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:samples")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if ( aux1 <= 0 ) return -2;
		options->csIGFsamples = aux1;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:nooutliers")==0) {
		options->csLIenableOutlier = 0;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:igf:nooutliers")==0) {
		options->csIGFenableOutlier = 1;
		sopt->csIGF=1;
		sopt->csIGFPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:sf:noautofill")==0) {
		options->autoFillcsSF=0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:sf:noautofill")==0) {
		options->autoFillcsSF=1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:mw:noautofill")==0) {
		options->autoFillcsMW=0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:mw:noautofill")==0) {
		options->autoFillcsMW=1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:li:noautofill")==0) {
		options->autoFillcsLI=0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:li:noautofill")==0) {
		options->autoFillcsLI=1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:igf:noautofill")==0) {
		options->autoFillcsIGF=0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:igf:noautofill")==0) {
		options->autoFillcsIGF=1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:noautofill")==0) {
		options->autoFillcsSF=0;
		options->autoFillcsMW=0;
		options->autoFillcsLI=0;
		options->autoFillcsIGF=0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:noautofill")==0) {
		options->autoFillcsSF=1;
		options->autoFillcsMW=1;
		options->autoFillcsLI=1;
		options->autoFillcsIGF=1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:cs:nooutliers")==0) {
		options->csMWenableOutlier = 0;
		options->csLIenableOutlier = 0;
		options->csIGFenableOutlier = 0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:cs:nooutliers")==0) {
		options->csMWenableOutlier = 1;
		options->csLIenableOutlier = 1;
		options->csIGFenableOutlier = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:allcson")==0 || strcasecmp(argv[0],"--pre:allcsoff")==0) {
		sopt->csAllPosOn = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:allcsoff")==0 || strcasecmp(argv[0],"--pre:allcson")==0) {
		sopt->csAllPosOff = sopt->csPos;
		sopt->csPos++;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:setrectype")==0||strcasecmp(argv[0],"-pre:setrectypedgnss")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"gpsrt")==0) {
			recType=rtNA;
		} else if (strcasecmp(argv[1],"0")==0) {
			recType=rtUNKNOWN;
		} else if (strcasecmp(argv[1],"1")==0) {
			recType=rtCROSS;
		} else if (strcasecmp(argv[1],"2")==0) {
			recType=rtNOP1;
		} else if (strcasecmp(argv[1],"3")==0) {
			recType=rtNOMINAL;
		} else return -2;
		if (strcasecmp(argv[0],"-pre:setrectype")==0) {
			sopt->setRecType[ROVERPOS]=recType;
		} else {
			sopt->setRecType[REFSTAPOS]=recType;
		}
		return 2;
	} else if (strcasecmp(argv[0],"-filter:meas")==0||strcasecmp(argv[0],"-filter:meastype")==0) {
		if (argv[1]==NULL) return -3;
		if(strcasecmp(argv[0],"-filter:meas")==0){
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:meas' is deprecated, the updated one is '-filter:meastype'.\n");
			}
			options->deprecatedMode = 1;
		}
		if (strcasecmp(argv[1],"pseudorange")==0) {
			sopt->navObservables = NTpseudorange;
		} else if (strcasecmp(argv[1],"carrierphase")==0) {
			sopt->navObservables = NTcarrierphase;
		} else return -2;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:combtype")==0) {
		if (argv[1]==NULL) return -3;
		if(strcasecmp(argv[1],"auto")==0){
			options->CombTypeAutoSelection = CombTypeAutoSelectionAutomatic;
		} else if(strcasecmp(argv[1],"singlefreq")==0) {
			options->CombTypeAutoSelection = CombTypeAutoSelectionSingleFreq;
		} else if(strcasecmp(argv[1],"dualfreq")==0) {
			options->CombTypeAutoSelection = CombTypeAutoSelectionDualFreq;
		} else if(strcasecmp(argv[1],"graphic")==0) {
			options->CombTypeAutoSelection = CombTypeAutoSelectionGraphic;
		} else return -2;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:select")==0 || strcasecmp(argv[0],"-filter:selectlist")==0 || 
			strcasecmp(argv[0],"-model:dgnss:measprc")==0 || strcasecmp(argv[0],"-model:dgnss:measprclist")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:select")==0 || strcasecmp(argv[0],"-filter:selectlist")==0) {
			staType=0;
		} else {
			staType=1;
		}
		sopt->userFilterMeas[staType]=1;
		if (strcasecmp(argv[0],"-filter:select")==0||strcasecmp(argv[0],"-model:dgnss:measprc")==0) {
			aux1=atoi(argv[1]);
			if (aux1>0) {
				aux2=sopt->numMeasFilterText[staType];
				sopt->numMeasFilterText[staType] += aux1;
				if (sopt->numMeasFilterText[staType]<=0) return -2;
				sopt->measFilterText[staType]=realloc(sopt->measFilterText[staType],sopt->numMeasFilterText[staType]*sizeof(char *));
				for (i=0;i<aux1;i++) {
					if (argv[2+i]==NULL) return -3;
					if(strlen(argv[2+i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->measFilterText[staType][aux2+i]=NULL;
					sopt->measFilterText[staType][aux2+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->measFilterText[staType][aux2+i],argv[2+i]);
				}
				return 2+aux1;
			} else if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->measFilterText[staType]=realloc(sopt->measFilterText[staType],sizeof(char *)*(sopt->numMeasFilterText[staType]+i));
					sopt->measFilterText[staType][sopt->numMeasFilterText[staType]+i-1]=NULL;
					sopt->measFilterText[staType][sopt->numMeasFilterText[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->measFilterText[staType][sopt->numMeasFilterText[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numMeasFilterText[staType]+=i-1;
				return i;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-filter:selectlist")==0 || strcasecmp(argv[0],"-model:dgnss:measprclist")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->measFilterText[staType]=realloc(sopt->measFilterText[staType],sizeof(char *)*(sopt->numMeasFilterText[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->measFilterText[staType][sopt->numMeasFilterText[staType]+i]=NULL;
				sopt->measFilterText[staType][sopt->numMeasFilterText[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->measFilterText[staType][sopt->numMeasFilterText[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numMeasFilterText[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:starttime")==0||strcasecmp(argv[0],"-pre:endtime")==0) {
		if (argv[1]==NULL||argv[2]==NULL) return -3;
		len1=(int)strlen(argv[1]);
		len2=(int)strlen(argv[2]);
		//Check date format
		if (strchr(argv[2],':')!=NULL) {
			//Time has ":" symbol. 
			if (len2!=8) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			//Check that input date has correct length
			if (strchr(argv[1],'/')!=NULL) {
				if (len1!=10) return -2;
			} else {
				if (len1!=8) return -2;
			}
			getstr(auxstr,argv[1],len1,0,4);
			aux1 = atoi(auxstr);
			if (aux1<1970) return -2;
			tm.tm_year=aux1-1900;
			if (strchr(argv[1],'/')!=NULL) {
				//Date has "/" symbol. It is YYYY/MM/DD HH:MM:SS format
				getstr(auxstr,argv[1],len1,5,2);
			} else {
				getstr(auxstr,argv[1],len1,4,2);
			}
			aux1=atoi(auxstr);
			if (aux1<1|| aux1>12) return -2;
			tm.tm_mon=aux1-1;
			if (strchr(argv[1],'/')!=NULL) {
				//Date has "/" symbol. It is YYYY/MM/DD HH:MM:SS format
				getstr(auxstr,argv[1],len1,8,2);
			} else {
				getstr(auxstr,argv[1],len1,6,2);
			}
			aux1=atoi(auxstr);
			if (aux1<1|| aux1>31) return -2;
			tm.tm_mday = aux1;
			//Get hour in HH:MM:SS format
			getstr(auxstr,argv[2],len2,0,2);
			aux1=atoi(auxstr);
			if (aux1<0|| aux1>24) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			tm.tm_hour = aux1;
			getstr(auxstr,argv[2],len2,3,2);
			aux1=atoi(auxstr);
			if (aux1<0|| aux1>60) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			tm.tm_min  = aux1;
			getstr(auxstr,argv[2],len2,6,2);
			aux1=atoi(auxstr);
			if (aux1<0|| aux1>60) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			tm.tm_sec  = aux1;
			if (strcasecmp(argv[0],"-pre:starttime")==0) {
				options->StartEpoch.MJDN=MJDN(&tm);
				options->StartEpoch.SoD=(double)(tm.tm_hour*3600 + tm.tm_min*60 + tm.tm_sec);
				if(options->StartEpoch.SoD>=86400.) {
					options->StartEpoch.MJDN++;
					options->StartEpoch.SoD-=86400.;
				}
			} else {
				options->EndEpoch.MJDN=MJDN(&tm);
				options->EndEpoch.SoD=(double)(tm.tm_hour*3600 + tm.tm_min*60 + tm.tm_sec);
				if(options->EndEpoch.SoD>=86400.) {
					options->EndEpoch.MJDN++;
					options->EndEpoch.SoD-=86400.;
				}
			}
		} else {
			if (strchr(argv[1],'/')!=NULL) {
				//Time is in Year/DoY SoD format
				aux1=len1;
				if (aux1<6 || aux1>8) return -2;
				getstr(auxstr,argv[1],len1,0,4);
				aux1=atoi(auxstr);
				if(aux1<1970) return -2;
				aux2=atoi(&argv[1][5]);
				if(aux2<1||aux2>366) return -2;
				auxd=atof(argv[2]);
				if(auxd<0.||auxd>86400.) {
					strcpy (argv[1],argv[2]); // This is for a proper error control
					return -2;
				}
				if (strcasecmp(argv[0],"-pre:starttime")==0) {
					options->StartEpoch.MJDN=(int)yeardoy2MJDN(aux1,aux2,auxd);
					options->StartEpoch.SoD=auxd;
					if(options->StartEpoch.SoD>=86400.) {
						options->StartEpoch.SoD-=86400.;
					}
				} else {
					options->EndEpoch.MJDN=(int)yeardoy2MJDN(aux1,aux2,auxd);
					options->EndEpoch.SoD=auxd;
					if(options->EndEpoch.SoD>=86400.) {
						options->EndEpoch.SoD-=86400.;
					}
				}
			} else {
				//Time is in GPSWeek SoW format
				aux1=atoi(argv[1]);
				if(aux1<1) return -2;
				auxd=atof(argv[2]);
				if(auxd<0.||auxd>604800.) {
					strcpy (argv[1],argv[2]); // This is for a proper error control
					return -2;
				}
				if (strcasecmp(argv[0],"-pre:starttime")==0) {
					options->StartEpoch=gpsws2ttime(aux1,auxd);
				} else {
					options->EndEpoch=gpsws2ttime(aux1,auxd);
				}
			}
		}
		return 3;
	} else if (strcasecmp(argv[0],"-pre:sat")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			aux2=0;
			p=strchr(argv[l],',');
			while(p!=NULL) {
				aux2++;
				p++;
				p=strchr(p,',');
			}
			aux2++;
			p2=argv[l];
			p3=strchr(p2,',');
			if (p3!=NULL) *p3='\0';
			for(k=0;k<aux2;k++) {
				parseSatellitelist(p2,0,&aux1,&aux3,GNSSused,PRNused,options);
				if (p2[0]=='+') {
					aux1=1;
				} else {
					aux1=0;
				}
				for(i=0;i<MAX_GNSS;i++) {
					if(GNSSused[i]==0) continue;
					for(j=1;j<MAX_SATELLITES_PER_GNSS;j++) {
						if(PRNused[j]==0) continue;
							options->includeSatellite[i][j] = aux1;
					}
				}
				if (k<(aux2-1)) {
					if (p3!=NULL) {
						*p3=',';
						p2=p3+1;
						p3=strchr(p2,',');
						if (p3!=NULL) *p3='\0';
					}
				}
			}
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-pre:GEOexclude")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			p2=argv[l];
			p=strchr(argv[l],',');
			while(p!=NULL) {
				*p='\0';
				aux1 = atoi(p2);
				if (aux1<MINGEOPRN || aux1>MAXGEOPRN) return -2;
				options->GEOPRNunsel[aux1]=1;
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
			}
			aux1 = atoi(p2);
			if (aux1<MINGEOPRN || aux1>MAXGEOPRN) return -2;
			options->GEOPRNunsel[aux1]=1;
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-pre:GEOsel")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		else if ( (aux1>2 && aux1<MINGEOPRN) || aux1>MAXGEOPRN) return -2;
		else options->GEOPRN=options->GEOPRNSelected=aux1;
		if(aux1==0)  options->mixedGEOdata=1;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:SmoothMin")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->excludeSmoothingConvergence = aux1;
		sopt->anySmoothOptionSetByUser=1;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:dgnss:smoothMin")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->excludeSmoothingConvergenceDGNSS = aux1;
		sopt->anySmoothOptionSetByUser=1;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:snr")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Preprocess option '-pre:snr' is deprecated, use '-pre:minsnr' instead.\n");
		}
		options->deprecatedMode = 1;
		options->SNRminfilter=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:snr")==0) {
		j=(int)strlen(sopt->deprecatedMessages);
		if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
			sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Preprocess option '--pre:snr' is deprecated, use '--pre:minsnr' instead.\n");
		}
		options->deprecatedMode = 1;
		options->SNRminfilter=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:minsnr")==0) {
		options->SNRminfilter=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:minsnr")==0) {
		options->SNRminfilter=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:maxsnr")==0) {
		options->SNRmaxfilter=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:maxsnr")==0) {
		options->SNRmaxfilter=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:snrsel")==0|| strcasecmp(argv[0],"-pre:minsnrsel")==0 || strcasecmp(argv[0],"-pre:maxsnrsel")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-pre:snrsel")==0) {
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Preprocess option '-pre:snrsel' is deprecated, use '-pre:minsnrsel' instead.\n");
			}
			options->deprecatedMode = 1;
			options->SNRminfilter=1;
			aux4=0;
		} else if (strcasecmp(argv[0],"-pre:minsnrsel")==0) {
			aux4=0;
			options->SNRminfilter=1;
		} else {
			aux4=1;
			options->SNRmaxfilter=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			aux2=0;
			for(j=0;j<3;j++) {
				if (argv[i+j]==NULL) {
					if(j==2) break;
					else return -3;
				}
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0||j==2) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;

				if (j==2) {
					if (argv[i+j][0]>=48 && argv[i+j][0]<=57) { //48 is ASCCI '0' and 57 is ASCII '9'
						aux2=1;
						break;
					} else {
						k=0;
						while (argv[i+j][k]!='\0' && argv[i+j][k]!='-' && k<3) {
							auxstr[k]=argv[i+j][k];
							k++;
						}
						auxstr[k]='\0';
						meas=measstr2meastype(auxstr);
						if (meas!=NA && meas<ENDMEAS) {
							aux2=1;
						}
						break;
					}
				}
			}
			if(j==0) break;

			//Case where all measurements from several satellites have the SNR threshold applied
			parseSatellitelist(argv[i],0,&aux1,&aux3,GNSSused,PRNused,options);
			auxd = atof(argv[i+1]);
			if(auxd<=0.) return -2;
			if (aux2==0) {
				for(j=0;j<MAX_GNSS;j++) {
					if(GNSSused[j]==0) continue;
					for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
						if(PRNused[k]==0) continue;
						for(l=0;l<MAX_MEASUREMENTS_NO_COMBINATIONS;l++) {
							if(aux4==0) {
								options->SNRminvalues[j][k][l] = auxd;
							} else {
								options->SNRmaxvalues[j][k][l] = auxd;
							}
						}
					}
				}
			} else {
				p=strchr(argv[i+2],'-');
				aux5=0;
				while(p!=NULL) {
					aux5++;
					p++;
					p=strchr(p,'-');
				}
				aux5++;
				p2=argv[i+2];
				p=strchr(p2,'-');
				if (p!=NULL) *p='\0';
				for(j=0;j<aux5;j++) {
					if (p2[0]>=48 && p2[0]<=57) { //48 is ASCCI '0' and 57 is ASCII '9'
						//Case where all measurements from a certain frequency from several satellites have the SNR threshold applied
						p3=strchr(p2,'.');
						aux6=0;
						while(p3!=NULL) {
							aux6++;
							p3++;
							p3=strchr(p3,'.');
						}
						aux6++;
						p3=p2;
						p4=strchr(p3,'.');
						if (p4!=NULL) *p4='\0';
						for(k=0;k<aux6;k++) {
							if (strlen(p3)!=1) {
								strcpy (argv[1],argv[i+2]); // This is for a proper error control
								return -2;
							}
							aux7=atoi(p3);
							if (aux7==0) aux7=9;
							else aux7--;
							for(l=0;l<MAX_GNSS;l++) {
								if(GNSSused[l]==0) continue;
								for(m=1;m<MAX_SATELLITES_PER_GNSS;m++) {
									if(PRNused[m]==0) continue;
									for(n=1+(aux7*MAX_MEAS_TYPES_PER_FREQUENCY*4);n<1+((aux7+1)*MAX_MEAS_TYPES_PER_FREQUENCY*4);n++) {
										if(aux4==0) {
											options->SNRminvalues[l][m][n] = auxd;
										} else {
											options->SNRmaxvalues[l][m][n] = auxd;
										}
									}
								}
							}
							if(k<(aux6-1)) {
								if(p3!=NULL) {
									*p4='.';
									p3=p4+1;
									p4=strchr(p3,'.');
									if (p4!=NULL) *p4='\0';
								}
							}
						}
					} else {
						//Case where user defined measurements from several satellites have the SNR threshold applied
						meas=measstr2meastype(p2);
						if (meas==NA) {
							strcpy (argv[1],argv[i+2]); // This is for a proper error control
							return -2;
						}
						if (meas>=ENDMEAS) {
							strcpy (argv[1],argv[i+2]); // This is for a proper error control
							return -2;
						}
						measType=whatIs(meas);
						if (measType!=Pseudorange && measType!=CarrierPhase && measType!=Doppler) {
							strcpy (argv[1],argv[i+2]); // This is for a proper error control
							return -2;
						}
						if (measType==Pseudorange) {
							aux8=1; //To convert to the carrier phase measurement of the same type
							aux9=2; //To convert to the doppler measurement of the same type
						} else if (measType==CarrierPhase) {
							aux8=-1; //To convert to the pseudorange measurement of the same type
							aux9=1; //To convert to the doppler measurement of the same type
						} else if (measType==Doppler) {
							aux8=-2; //To convert to the pseudorange measurement of the same type
							aux9=-1; //To convert to the carrier phase measurement of the same type
						}
						for(k=0;k<MAX_GNSS;k++) {
							if(GNSSused[k]==0) continue;
							for(l=1;l<MAX_SATELLITES_PER_GNSS;l++) {
								if(PRNused[l]==0) continue;
								if(aux4==0) {
									options->SNRminvalues[k][l][meas] = auxd;
									options->SNRminvalues[k][l][meas+aux8] = auxd;
									options->SNRminvalues[k][l][meas+aux9] = auxd;
								} else {
									options->SNRmaxvalues[k][l][meas] = auxd;
									options->SNRmaxvalues[k][l][meas+aux8] = auxd;
									options->SNRmaxvalues[k][l][meas+aux9] = auxd;
								}
							}
						}
					}
					if(j<(aux5-1)) {
						*p='-';
						p2=p+1;
						p=strchr(p2,'-');
						if (p!=NULL) *p='\0';
					}
				}
			}
			i+=2+aux2;
		}
		return i;
	} else if (strcasecmp(argv[0],"-pre:availf")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			aux6=0;
			p=strchr(argv[l],',');
			while(p!=NULL) {
				aux6++;
				p++;
				p=strchr(p,',');
			}
			aux6++;
			p2=argv[l];
			p3=strchr(p2,',');
			if (p3!=NULL) *p3='\0';
			for(m=0;m<aux6;m++) {
				aux3=(int)strlen(p2);
				if (aux3<=1) return -2;
				aux2=aux1=0;
				if (p2[0]=='-') {
					p4=strrchr(&p2[1],'-');
				} else {
					p4=strrchr(p2,'-');
				}
				if (p4==NULL) {
					//Old mode, no PRN provided
					for(i=0;i<MAX_GNSS;i++) {
						GNSSused[i]=0;
						for(k=0;k<MAX_SATELLITES_PER_GNSS;k++) {
							PRNused[k]=0;
						}
					}
					aux7=0;
					//Check for sign at start of string
					if(p2[0]=='+') {
						aux1=1;
						aux7=1;
					} else if (p2[0]=='-') {
						aux1=1;
						aux2=1;
					}
					//Check constellation. If it is a zero, select all constellations
					if(p2[aux1]=='0') {
						for(i=0;i<MAX_GNSS;i++) {
							GNSSused[i]=1;
							for(k=0;k<MAX_SATELLITES_PER_GNSS;k++) {
								PRNused[k]=1;
							}
						}
					} else {
						aux4=aux1;	
						while(p2[aux1]>65) { //65 is ASCII character 'A'
							if (checkConstellationChar(p2[aux1])==0) return -2;
							GNSSused[gnsschar2gnsstype(p2[aux1])]=1;
							for(k=0;k<MAX_SATELLITES_PER_GNSS;k++) {
								PRNused[k]=1;
							}
							aux1++;
						}
						if(aux4==aux1) return -2;
					}
					if (aux3<=aux1) return -2;
				} else {
					//New mode, PRN list provided
					*p4='\0';
					parseSatellitelist(p2,0,&removeMeas,&lastCharac,GNSSused,PRNused,options);
					*p4='-';
					//Check for sign at start of string
					if(p2[0]=='+') {
						aux1=1;
					} else if (p2[0]=='-') {
						aux1=1;
						aux2=1;
					}
					aux1=p4-p2+1;
				}

				auxstr[1] = '\0';
				for(i=aux1;i<aux3;i++) {
					for(j=0;j<MAX_GNSS;j++) {
						if(GNSSused[j]==0) continue;
						for(k=1;k<MAX_SATELLITES_PER_GNSS;k++) {
							if(PRNused[k]==0) continue;
							// If this option is set and it is to add frequencies, only present frequencies will be set
							if (aux2==0) {
								if(i==aux1 && aux7==0) { //Only remove all frequencies is '+' sign is not given
									for (n=0;n<MAX_FREQUENCIES_PER_GNSS;n++) {
										options->usableFreq[j][k][n] = 0;
									}
								}
								auxstr[0] = p2[i];
								aux5 = atoi(auxstr);
								options->usableFreq[j][k][aux5] = 1;
							} else {
								auxstr[0] = p2[i];
								aux5 = atoi(auxstr);
								options->usableFreq[j][k][aux5] = 0;
							}
						}
					}
				}
				if (m<(aux6-1)) {
					if (p3!=NULL) {
						*p3=',';
						p2=p3+1;
						p3=strchr(p2,',');
						if (p3!=NULL) *p3='\0';
					}
				}
			}
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-pre:smooth")==0) {
		if (argv[1]==NULL) return -3;
		options->smoothEpochs = atoi(argv[1]);
		sopt->anySmoothOptionSetByUser=1;
		return 2;
	} else if (strcasecmp(argv[0],"--pre:smooth")==0) {
		options->smoothEpochs = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:smoothauto")==0) {
		sopt->smoothAuto=1;
		sopt->anySmoothOptionSetByUser=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:smoothauto")==0) {
		sopt->smoothAuto=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:smoothmeas")==0||strcasecmp(argv[0],"-pre:smoothmeasdgnss")==0) {
		i=0;
		sopt->anySmoothOptionSetByUser=1;
		if (strcasecmp(argv[0],"-pre:smoothmeas")==0) {
			staType=0;
		} else {
			staType=1;
		}
		sopt->userFilterSmoothMeas[staType]=1;
		aux1=sopt->numSmoothMeasFilterText[staType];
		while(argv[1+2*i]!=NULL) {
			if(strlen(argv[1+2*i])>=(MAX_INPUT_LINE-1)) return -4;
			if (checkIfNextParameter(argv[1+2*i])==1) break; //Next parameter. Stop reading
			if (argv[1+2*i+1]==NULL) return -3;//Parameters given not paired (measToSmooth and measForSmoothing)
			if(strlen(argv[1+2*i+1])>=(MAX_INPUT_LINE-1)) return -4;
			if (checkIfNextParameter(argv[1+2*i+1])==1) return -3; //One parameter is missing
			sopt->smoothMeasFilterText[staType]=realloc(sopt->smoothMeasFilterText[staType],(aux1+i+1)*sizeof(char *));
			sopt->smoothWithMeasFilterText[staType]=realloc(sopt->smoothWithMeasFilterText[staType],(aux1+i+1)*sizeof(char *));
			sopt->smoothMeasFilterText[staType][aux1+i]=NULL;
			sopt->smoothWithMeasFilterText[staType][aux1+i]=NULL;
			sopt->smoothMeasFilterText[staType][aux1+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->smoothWithMeasFilterText[staType][aux1+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
			strcpy(sopt->smoothMeasFilterText[staType][aux1+i],argv[1+2*i]);
			strcpy(sopt->smoothWithMeasFilterText[staType][aux1+i],argv[1+2*i+1]);
			i++;
		}
		if(i==0) return -3; //Insufficient number of parameters 
		sopt->numSmoothMeasFilterText[staType] += i;
		return 1+2*i;
	} else if (strcasecmp(argv[0],"-pre:freqorder")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			aux1=0;
			p=strchr(argv[l],',');
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[l];
			p3=strchr(p2,',');
			if (p3!=NULL) *p3='\0';
			for(m=0;m<aux1;m++) {
				p4=strrchr(p2,'-');
				if(p4==NULL) {
					strcpy(argv[1],p2); // This is for a proper error control
					return -2;
				} else {
					*p4='\0';
					parseSatellitelist(p2,0,&removeMeas,&lastCharac,GNSSused,PRNused,options);
					*p4='-';
					p4++;
					aux2=(int)strlen(p4);
					if(aux2==0) {
						strcpy(argv[1],p2); // This is for a proper error control
						return -2;
					}
					if(removeMeas==0) {
						for(i=0;i<MAX_GNSS;i++) {
							if (GNSSused[i]==0) continue;
							for(j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
								if (PRNused[j]==0) continue;
								for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
									options->defaultFreq[i][j][k]=-1;
								}
							}
						}
					}
					auxstr[1]='\0';
					for(n=0;n<aux2;n++) {
						if (p4[n]<48 || p4[n]>57) {  //48 is ASCCI '0' and 57 is ASCII '9'
							strcpy(argv[1],p2); // This is for a proper error control
							return -2;
						}
						auxstr[0]=p4[n];
						aux3=atoi(auxstr);
						if(removeMeas==0) {
							for(i=0;i<MAX_GNSS;i++) {
								if (GNSSused[i]==0) continue;
								for(j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
									if (PRNused[j]==0) continue;
									options->defaultFreq[i][j][n]=aux3;
								}
							}
						} else {
							for(i=0;i<MAX_GNSS;i++) {
								if (GNSSused[i]==0) continue;
								for(j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
									if (PRNused[j]==0) continue;
									for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
										if (options->defaultFreq[i][j][k]==aux3) {
											break;
										}
									}
									if (k<MAX_FREQUENCIES_PER_GNSS) {
										for(k=k+1;k<MAX_FREQUENCIES_PER_GNSS;k++) {
											options->defaultFreq[i][j][k-1]=options->defaultFreq[i][j][k];
										}
										options->defaultFreq[i][j][k]=-1;
									}
								}
							}
						}
					}
				}
				if (m<(aux1-1)) {
					if (p3!=NULL) {
						*p3=',';
						p2=p3+1;
						p3=strchr(p2,',');
						if (p3!=NULL) *p3='\0';
					}
				}
			}
			l++;
		}
		return l;
	} else if (strcasecmp(argv[0],"-pre:measorder")==0||strcasecmp(argv[0],"-pre:measorderlist")==0||
			   strcasecmp(argv[0],"-pre:measorderdgnss")==0||strcasecmp(argv[0],"-pre:measorderlistdgnss")==0) {
		if (strcasecmp(argv[0],"-pre:measorderdgnss")==0||strcasecmp(argv[0],"-pre:measorderlistdgnss")==0) {
			staType=1;
		} else {
			staType=0;
		}
		sopt->userMeasOrderList[staType]=1;
		if (strcasecmp(argv[0],"-pre:measorder")==0||strcasecmp(argv[0],"-pre:measorderdgnss")==0) {
			i=0;
			aux1=sopt->numMeasTableText[staType];
			while(argv[1+i]!=NULL) {
				if(strlen(argv[1+i])>=(MAX_INPUT_LINE-1)) return -4;
				if (checkIfNextParameter(argv[1+i])==1) break; //Next parameter. Stop reading
				sopt->measTableText[staType]=realloc(sopt->measTableText[staType],(aux1+i+1)*sizeof(char *));
				sopt->measTableText[staType][aux1+i]=NULL;
				sopt->measTableText[staType][aux1+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->measTableText[staType][aux1+i],argv[1+i]);
				i++;
			}
			if(i==0) return -3; //Insufficient number of parameters 
			sopt->numMeasTableText[staType] += i;
			return 1+i;
		} else { //strcasecmp(argv[0],"-pre:measorderlist")==0||strcasecmp(argv[0],"-pre:measorderlistdgnss")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->measTableText[staType]=realloc(sopt->measTableText[staType],sizeof(char *)*(sopt->numMeasTableText[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->measTableText[staType][sopt->numMeasTableText[staType]+i]=NULL;
				sopt->measTableText[staType][sopt->numMeasTableText[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->measTableText[staType][sopt->numMeasTableText[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numMeasTableText[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-pre:meassel:pairedmeas")==0) {
		options->DiscardUnpairedMeas[ROVERPOS]=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:meassel:pairedmeas")==0) {
		options->DiscardUnpairedMeas[ROVERPOS]=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:meassel:pairedmeasdgnss")==0) {
		options->DiscardUnpairedMeas[REFSTAPOS]=1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:meassel:pairedmeasdgnss")==0) {
		options->DiscardUnpairedMeas[REFSTAPOS]=0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:meassel:noblocktypeunsel")==0) {
		options->SatBlockMeasDiscard=0;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:meassel:noblocktypeunsel")==0) {
		options->SatBlockMeasDiscard=1;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:setrecpos")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"RINEX")==0) {
			options->receiverPositionSource = rpRINEX;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"SINEX")==0) {
			options->receiverPositionSource = rpSINEX;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"Set")==0||strcasecmp(argv[1],"SetCar")==0) {
			options->receiverPositionSource = rpSET;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"SetGeod")==0) {
			options->receiverPositionSource = rpSET;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[2] = auxd;
			NEU2XYZ(options->aprioriReceiverPositionGeod,options->aprioriReceiverPosition);
			return 5;
		} else if (strcasecmp(argv[1],"SetRef")==0) {
			options->receiverPositionSource = rpSETREF;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"calculate")==0) {
			options->receiverPositionSource = rpCALCULATE;
			return 2;
		} else if (strcasecmp(argv[1],"calculateRINEX")==0) {
			options->receiverPositionSource = rpCALCULATERINEX;
			return 2;
		} else if (strcasecmp(argv[1],"calculateUSER")==0 || strcasecmp(argv[1],"calculateUSERCar")==0 ) {
			options->receiverPositionSource = rpCALCULATEUSER;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"calculateUSERGeod")==0) {
			options->receiverPositionSource = rpCALCULATEUSER;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); ////Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[2] = auxd;
			NEU2XYZ(options->aprioriReceiverPositionGeod,options->aprioriReceiverPosition);
			return 5;
		} else if (strcasecmp(argv[1],"calculateRef")==0) {
			options->receiverPositionSource = rpCALCULATEREF;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"calculateRINEXRef")==0) {
			options->receiverPositionSource = rpCALCULATERINEXREF;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"calculateUSERRef")==0|| strcasecmp(argv[1],"calculateUSERCarRef")==0) {
			options->receiverPositionSource = rpCALCULATEUSERREF;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"calculateUSERGeodRef")==0) {
			options->receiverPositionSource = rpCALCULATEUSERREF;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[2] = auxd;
			NEU2XYZ(options->aprioriReceiverPositionGeod,options->aprioriReceiverPosition);
			return 5;
		} else if (strcasecmp(argv[1],"RTCMbaseline")==0 || strcasecmp(argv[1],"DGNSSbaseline")==0) {
			options->receiverPositionSource = rpRTCMbaseline;
			return 2;
		} else if (strcasecmp(argv[1],"RTCMRinexRover")==0 || strcasecmp(argv[1],"DGNSSRinexRover")==0) {
			options->receiverPositionSource = rpRTCMRINEXROVER;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"RTCMRoverUSER")==0 || strcasecmp(argv[1],"DGNSSRoverUSER")==0 
				|| strcasecmp(argv[1],"RTCMRoverUSERCar")==0 || strcasecmp(argv[1],"DGNSSRoverUSERCar")==0) {
			options->receiverPositionSource = rpRTCMRoverUSER;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"RTCMRoverUSERGeod")==0 || strcasecmp(argv[1],"DGNSSRoverUSERGeod")==0) {
			options->receiverPositionSource = rpRTCMRoverUSER;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[2] = auxd;
			NEU2XYZ(options->aprioriReceiverPositionGeod,options->aprioriReceiverPosition);
			return 5;
		} else if (strcasecmp(argv[1],"RTCMRoverUSERRef")==0 || strcasecmp(argv[1],"DGNSSRoverUSERRef")==0) {
			options->receiverPositionSource = rpRTCMRoverUSERREF;
			options->recPosProvided=1;
			return 2;
		} else if (strcasecmp(argv[1],"RTCMUserRoverRef")==0 || strcasecmp(argv[1],"DGNSSUserRoverRef")==0
				|| strcasecmp(argv[1],"RTCMUserCarRoverRef")==0 || strcasecmp(argv[1],"DGNSSUserCarRoverRef")==0) {
			options->receiverPositionSource = rpRTCMRefUSERRoverREF;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->ReferenceStationPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"RTCMUserGeodRoverRef")==0 || strcasecmp(argv[1],"DGNSSUserGeodRoverRef")==0) {
			options->receiverPositionSource = rpRTCMRefUSERRoverREF;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[2] = auxd;
			NEU2XYZ(options->ReferenceStationPositionGeod,options->ReferenceStationPosition);
			return 5;
		} else if (strcasecmp(argv[1],"RTCMUserbaseline")==0 || strcasecmp(argv[1],"DGNSSUserbaseline")==0
				|| strcasecmp(argv[1],"RTCMUserCarbaseline")==0 || strcasecmp(argv[1],"DGNSSUserCarbaseline")==0) {
			options->receiverPositionSource = rpRTCMUserbaseline;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->ReferenceStationPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"RTCMUserGeodbaseline")==0 || strcasecmp(argv[1],"DGNSSUserGeodbaseline")==0) {
			options->receiverPositionSource = rpRTCMUserbaseline;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[2] = auxd;
			NEU2XYZ(options->ReferenceStationPositionGeod,options->ReferenceStationPosition);
			return 5;
		} else if (strcasecmp(argv[1],"RTCMUserRinexRover")==0 || strcasecmp(argv[1],"DGNSSUserRinexRover")==0
				|| strcasecmp(argv[1],"RTCMUserCarRinexRover")==0 || strcasecmp(argv[1],"DGNSSUserCarRinexRover")==0) {
			options->receiverPositionSource = rpRTCMUserRINEXROVER;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->ReferenceStationPosition[i] = auxd;
			}
			return 5;
		} else if (strcasecmp(argv[1],"RTCMUserGeodRinexRover")==0 || strcasecmp(argv[1],"DGNSSUserGeodRinexRover")==0) {
			options->receiverPositionSource = rpRTCMUserRINEXROVER;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[2] = auxd;
			NEU2XYZ(options->ReferenceStationPositionGeod,options->ReferenceStationPosition);
			return 5;
		} else if (strcasecmp(argv[1],"RTCMRefRoverUSER")==0 || strcasecmp(argv[1],"DGNSSRefRoverUSER")==0 
				|| strcasecmp(argv[1],"RTCMRefCarRoverUSERCar")==0 || strcasecmp(argv[1],"DGNSSRefCarRoverUSERCar")==0) {
			options->receiverPositionSource = rpRTCMRefRoverUSER;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->ReferenceStationPosition[i] = auxd;
			}
			for (i=0;i<3;i++) {
				if (argv[5+i]==NULL) return -3;
				auxd = atof(argv[5+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 8;
		} else if (strcasecmp(argv[1],"RTCMRefGeodRoverUSERGeod")==0 || strcasecmp(argv[1],"DGNSSRefGeodRoverUSERGeod")==0) {
			options->receiverPositionSource = rpRTCMRefRoverUSER;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[2] = auxd;
			NEU2XYZ(options->ReferenceStationPositionGeod,options->ReferenceStationPosition);
			if (argv[5]==NULL||argv[6]==NULL||argv[7]==NULL) return -3;
			auxd = atof(argv[5]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[5]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[6]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[6]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[7]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[7]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[2] = auxd;
			NEU2XYZ(options->aprioriReceiverPositionGeod,options->aprioriReceiverPosition);
			return 8;
		} else if (strcasecmp(argv[1],"RTCMRefCarRoverUSERGeod")==0 || strcasecmp(argv[1],"DGNSSRefCarRoverUSERGeod")==0) {
			options->receiverPositionSource = rpRTCMRefRoverUSER;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[2+i]==NULL) return -3;
				auxd = atof(argv[2+i]);
				options->ReferenceStationPosition[i] = auxd;
			}
			if (argv[5]==NULL||argv[6]==NULL||argv[7]==NULL) return -3;
			auxd = atof(argv[5]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[5]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[6]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[6]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[7]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[7]); // This is for a proper error control
				return -2;
			}
			options->aprioriReceiverPositionGeod[2] = auxd;
			NEU2XYZ(options->aprioriReceiverPositionGeod,options->aprioriReceiverPosition);
			return 8;
		} else if (strcasecmp(argv[1],"RTCMRefGeodRoverUSERCar")==0 || strcasecmp(argv[1],"DGNSSRefGeodRoverUSERCar")==0) {
			options->receiverPositionSource = rpRTCMRefRoverUSER;
			options->recPosProvided=1;
			if (argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
			auxd = atof(argv[2]); //First value is longitude
			if(auxd<-180.||auxd>180.) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[1] = auxd*d2r;
			auxd = atof(argv[3]); //Second value is latitude
			if(auxd<-90.||auxd>90.) {
				strcpy (argv[1],argv[3]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[0] = auxd*d2r;
			auxd = atof(argv[4]); //Third value is height
			if(auxd<-10000) { //Height less than -10Km
				strcpy (argv[1],argv[4]); // This is for a proper error control
				return -2;
			}
			options->ReferenceStationPositionGeod[2] = auxd;
			NEU2XYZ(options->ReferenceStationPositionGeod,options->ReferenceStationPosition);
			for (i=0;i<3;i++) {
				if (argv[5+i]==NULL) return -3;
				auxd = atof(argv[5+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 8;
		} else {  // X Y Z (rpSET)
			options->receiverPositionSource = rpSET;
			options->recPosProvided=1;
			for (i=0;i<3;i++) {
				if (argv[1+i]==NULL) return -3;
				auxd = atof(argv[1+i]);
				options->aprioriReceiverPosition[i] = auxd;
			}
			return 4;
		}
	} else if (strcasecmp(argv[0],"-pre:refpos:deg")==0) {
		if (argv[1]==NULL) return -3;
		aux1=atoi(argv[1]);
		if (aux1<0) return -2;
		options->RefDegInterp=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-pre:dgnss:excludeSmoothingConvergenceUser")==0) {
		options->excludeSmoothingConvergenceUser = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:dgnss:excludeSmoothingConvergenceUser")==0) {
		options->excludeSmoothingConvergenceUser = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-pre:dgnss:excludeSmoothingConvergenceRef")==0) {
		options->excludeSmoothingConvergenceRef = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--pre:dgnss:excludeSmoothingConvergenceRef")==0) {
		options->excludeSmoothingConvergenceRef = 0;
		return 1;
    } else if (strcasecmp(argv[0],"-pre:intseconds")==0) {
        options->integerRINEXObsSeconds=1;
        return 1;
    } else if (strcasecmp(argv[0],"--pre:intseconds")==0) {
        options->integerRINEXObsSeconds=0;
        return 1;
	} else if (strcasecmp(argv[0],"-model:iono")==0) {
		if (argv[1]==NULL) {return -3;}
		if (strcasecmp(argv[1],"no")==0) {
			sopt->ionoModel = NoIonoModel;
		} else if (strcasecmp(argv[1],"Klobuchar")==0) {
			sopt->ionoModel = KlobucharIonoModel;
		} else if (strcasecmp(argv[1],"BeiDou")==0) {
			sopt->ionoModel = BeiDouIonoModel;
		} else if (strcasecmp(argv[1],"IONEX")==0) {
			sopt->ionoModel = IONEXIonoModel;
		} else if (strcasecmp(argv[1],"FPPP")==0) {
			sopt->ionoModel = FPPPIonoModel;
		} else if (strcasecmp(argv[1],"NeQuick")==0) {
			sopt->ionoModel = neQuickIonoModel;
		} else if (strcasecmp(argv[1],"SBAS")==0) {
			sopt->ionoModel = SBASIonoModel;
		} else return -2;
		return 2;
	} else if (strcasecmp(argv[0],"--model:iono")==0) {
		sopt->ionoModel = NoIonoModel;
		return 1;
	} else if (strcasecmp(argv[0],"-model:ionoRMS")==0) {
		if (argv[1]==NULL) {return -3;}
		options->ionoRMS = atof(argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-model:trop")==0||strcasecmp(argv[0],"-model:tropo")==0) {
		sopt->troposphericCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:trop")==0||strcasecmp(argv[0],"--model:tropo")==0) {
		sopt->troposphericCorrection = 0;
		return 1;

	} else if (strcasecmp(argv[0],"-model:trop:nominal")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"Simple")==0) {
			sopt->tropNominal = SimpleNominal;
		} else if (strcasecmp(argv[1],"UNB3")==0) {
			sopt->tropNominal = UNB3Nominal;
		} else return -2;
		return 2;

	} else if (strcasecmp(argv[0],"-model:trop:mapping")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"Simple")==0) {
			sopt->tropMapping = SimpleMapping;
		} else if (strcasecmp(argv[1],"Niell")==0) {
			sopt->tropMapping = NiellMapping;
		} else return -2;
		return 2;

	} else if (strcasecmp(argv[0],"-model:satclocks")==0) {
		options->satelliteClockCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:satclocks")==0) {
		options->satelliteClockCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:relclock")==0) {
		options->relativisticCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:relclock")==0) {
		options->relativisticCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:satmovinflight")==0) {
		options->timeTrans = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:satmovinflight")==0) {
		options->timeTrans = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:earthrotinflight")==0) {
		options->earthRotation = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:earthrotinflight")==0) {
		options->earthRotation = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:satphasecenter")==0) {
		options->satellitePhaseCenter = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:satphasecenter")==0) {
		options->satellitePhaseCenter = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:satphasevar")==0) {
		options->satellitePhaseVar = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:satphasevar")==0) {
		options->satellitePhaseVar = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:recphasecenter")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		i=1;
		while (argv[i]!=NULL) {
			if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
			if(strlen(argv[i])==0) return -3;
			if(checkIfNextParameter(argv[i])==1) break; //Next parameter. Stop reading
			sopt->recPhaseCenterParam=realloc(sopt->recPhaseCenterParam,sizeof(char*)*(sopt->numRecPhaseCenterParam+1));
			sopt->recPhaseCenterParam[sopt->numRecPhaseCenterParam]=NULL;
			sopt->recPhaseCenterParam[sopt->numRecPhaseCenterParam]=malloc(sizeof(char)*MAX_INPUT_LINE);
			strcpy(sopt->recPhaseCenterParam[sopt->numRecPhaseCenterParam],argv[i]);
			sopt->numRecPhaseCenterParam++;
			i++;
		}
		return i;
	} else if (strcasecmp(argv[0],"--model:recphasecenter")==0) {
		options->antennaData = adNONE;
		for(i=0;i<MAX_GNSS;i++) {
			for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
				options->antennaDataGNSS[i][j] = adNONE;
			}
		}
		return 1;
	} else if (strcasecmp(argv[0],"-model:recphasevar")==0) {
		options->receiverPhaseVar = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:recphasevar")==0) {
		options->receiverPhaseVar = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:strictradome")==0 || strcasecmp(argv[0],"-model:radomestrict")==0) {
		options->strictradome = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:strictradome")==0 || strcasecmp(argv[0],"--model:radomestrict")==0) {
		options->strictradome = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:arp")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			options->ARPData = arpNONE;
			return 2;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			options->ARPData = arpRINEX;
			return 2;
		} else {
			options->ARPData = arpSET;
			for (i=0;i<3;i++) {
				if (argv[1+i]==NULL) return -3;
				auxd = atof(argv[1+i]);
				options->receiverARP[i] = auxd;
			}
		}
		return 4;
	} else if (strcasecmp(argv[0],"--model:arp")==0) {
		options->ARPData = arpNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:p1c1")==0 || strcasecmp(argv[0],"-model:dcb:p1c1")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSp1c1DCBModel=GPSp1c1NONE;
		} else if (strcasecmp(argv[1],"flexible")==0) {
			sopt->GPSp1c1DCBModel=GPSp1c1FLEXIBLE;
		} else if (strcasecmp(argv[1],"strict")==0) {
			sopt->GPSp1c1DCBModel=GPSp1c1STRICT;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:p1c1")==0||strcasecmp(argv[0],"--model:dcb:p1c1")==0) {
		sopt->GPSp1c1DCBModel=GPSp1c1NONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:p1p2")==0||strcasecmp(argv[0],"-model:dcb:p1p2")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSp1p2DCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSp1p2DCBModel=DCBRINEX;
		} else if (strcasecmp(argv[1],"DCB")==0||strcasecmp(argv[1],"DCBFILE")==0) {
			sopt->GPSp1p2DCBModel=DCBFILE;
		} else if (strcasecmp(argv[1],"IONEX")==0) {
			sopt->GPSp1p2DCBModel=DCBIONEX;
		} else if (strcasecmp(argv[1],"FPPP")==0) {
			sopt->GPSp1p2DCBModel=DCBFPPP;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:p1p2")==0||strcasecmp(argv[0],"--model:dcb:p1p2")==0) {
		sopt->GPSp1p2DCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:l1ca")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl1caDCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl1caDCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:l1ca")==0) {
		sopt->GPSISCl1caDCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:l1cp")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl1cpDCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl1cpDCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:l1cp")==0) {
		sopt->GPSISCl1cpDCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:l1cd")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl1cdDCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl1cdDCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:l1cd")==0) {
		sopt->GPSISCl1cdDCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:l2c")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl2cDCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl2cDCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:l2c")==0) {
		sopt->GPSISCl2cDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:l5i5")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl5i5DCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl5i5DCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:l5i5")==0) {
		options->GPSISCl5i5DCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:l5q5")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl5q5DCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl5q5DCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:l5q5")==0) {
		sopt->GPSISCl5q5DCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:isc:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSISCl1caDCBModel=DCBNONE;
			sopt->GPSISCl1cpDCBModel=DCBNONE;
			sopt->GPSISCl1cdDCBModel=DCBNONE;
			sopt->GPSISCl2cDCBModel=DCBNONE;
			sopt->GPSISCl5i5DCBModel=DCBNONE;
			sopt->GPSISCl5q5DCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSISCl1caDCBModel=DCBRINEX;
			sopt->GPSISCl1cpDCBModel=DCBRINEX;
			sopt->GPSISCl1cdDCBModel=DCBRINEX;
			sopt->GPSISCl2cDCBModel=DCBRINEX;
			sopt->GPSISCl5i5DCBModel=DCBRINEX;
			sopt->GPSISCl5q5DCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:isc:all")==0) {
		sopt->GPSISCl1caDCBModel=DCBNONE;
		sopt->GPSISCl1cpDCBModel=DCBNONE;
		sopt->GPSISCl1cdDCBModel=DCBNONE;
		sopt->GPSISCl2cDCBModel=DCBNONE;
		sopt->GPSISCl5i5DCBModel=DCBNONE;
		sopt->GPSISCl5q5DCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gps:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GPSp1p2DCBModel = DCBNONE;
			sopt->GPSISCl1caDCBModel=DCBNONE;
			sopt->GPSISCl1cpDCBModel=DCBNONE;
			sopt->GPSISCl1cdDCBModel=DCBNONE;
			sopt->GPSISCl2cDCBModel=DCBNONE;
			sopt->GPSISCl5i5DCBModel=DCBNONE;
			sopt->GPSISCl5q5DCBModel=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GPSp1p2DCBModel = DCBRINEX;
			sopt->GPSISCl1caDCBModel=DCBRINEX;
			sopt->GPSISCl1cpDCBModel=DCBRINEX;
			sopt->GPSISCl1cdDCBModel=DCBRINEX;
			sopt->GPSISCl2cDCBModel=DCBRINEX;
			sopt->GPSISCl5i5DCBModel=DCBRINEX;
			sopt->GPSISCl5q5DCBModel=DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gps:all")==0) {
		sopt->GPSp1c1DCBModel=GPSp1c1NONE;
		sopt->GPSp1p2DCBModel = DCBNONE;
		sopt->GPSISCl1caDCBModel=DCBNONE;
		sopt->GPSISCl1cpDCBModel=DCBNONE;
		sopt->GPSISCl1cdDCBModel=DCBNONE;
		sopt->GPSISCl2cDCBModel=DCBNONE;
		sopt->GPSISCl5i5DCBModel=DCBNONE;
		sopt->GPSISCl5q5DCBModel=DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gal:e1e5a")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GALe1e5aDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GALe1e5aDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gal:e1e5a")==0) {
		sopt->GALe1e5aDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gal:e1e5b")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GALe1e5bDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GALe1e5bDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gal:e1e5b")==0) {
		sopt->GALe1e5bDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:gal:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GALe1e5aDCBModel= DCBNONE;
			sopt->GALe1e5bDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GALe1e5aDCBModel= DCBRINEX;
			sopt->GALe1e5bDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:gal:all")==0) {
		sopt->GALe1e5aDCBModel= DCBNONE;
		sopt->GALe1e5bDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:glo:p1p2")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GLOp1p2DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"DCB")==0||strcasecmp(argv[1],"DCBFILE")==0) {
			sopt->GLOp1p2DCBModel=DCBFILE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GLOp1p2DCBModel= DCBRINEX;
		} else if (strcasecmp(argv[1],"IONEX")==0) {
			sopt->GLOp1p2DCBModel= DCBIONEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:glo:p1p2")==0) {
		sopt->GLOp1p2DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:glo:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->GLOp1p2DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->GLOp1p2DCBModel= DCBRINEX;
		} else if (strcasecmp(argv[1],"IONEX")==0) {
			sopt->GLOp1p2DCBModel= DCBIONEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:glo:all")==0) {
		sopt->GLOp1p2DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:b2b6")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSb2b6DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSb2b6DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:b2b6")==0) {
		sopt->BDSb2b6DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:b7b6")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSb7b6DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSb7b6DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:b7b6")==0) {
		sopt->BDSb7b6DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:b1b6")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSb1b6DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSb1b6DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:b1b6")==0) {
		sopt->BDSb1b6DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:b5b6")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSb5b6DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSb5b6DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:b5b6")==0) {
		sopt->BDSb5b6DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:sp3")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSSP3DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSSP3DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:sp3")==0) {
		sopt->BDSSP3DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:isc:b1cd")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSISCb1cdDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSISCb1cdDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:isc:b1cd")==0) {
		sopt->BDSISCb1cdDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:isc:b2ad")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSISCb2adDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSISCb2adDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:isc:b2ad")==0) {
		sopt->BDSISCb2adDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:isc:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSISCb1cdDCBModel= DCBNONE;
			sopt->BDSISCb2adDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSISCb1cdDCBModel= DCBRINEX;
			sopt->BDSISCb2adDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:isc:all")==0) {
		sopt->BDSISCb1cdDCBModel= DCBNONE;
		sopt->BDSISCb2adDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:bds:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->BDSb2b6DCBModel= DCBNONE;
			sopt->BDSb7b6DCBModel= DCBNONE;
			sopt->BDSb1b6DCBModel= DCBNONE;
			sopt->BDSb5b6DCBModel= DCBNONE;
			sopt->BDSISCb1cdDCBModel= DCBNONE;
			sopt->BDSISCb2adDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->BDSb2b6DCBModel= DCBRINEX;
			sopt->BDSb7b6DCBModel= DCBRINEX;
			sopt->BDSb1b6DCBModel= DCBRINEX;
			sopt->BDSb5b6DCBModel= DCBRINEX;
			sopt->BDSISCb1cdDCBModel= DCBRINEX;
			sopt->BDSISCb2adDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:bds:all")==0) {
		sopt->BDSb2b6DCBModel= DCBNONE;
		sopt->BDSb7b6DCBModel= DCBNONE;
		sopt->BDSSP3DCBModel= DCBNONE;
		sopt->BDSb1b6DCBModel= DCBNONE;
		sopt->BDSb5b6DCBModel= DCBNONE;
		sopt->BDSISCb1cdDCBModel= DCBNONE;
		sopt->BDSISCb2adDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:c1c")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSc1cDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSc1cDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:c1c")==0) {
		sopt->QZSc1cDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:isc:l1cp")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSISCl1cpDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSISCl1cpDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:isc:l1cp")==0) {
		sopt->QZSISCl1cpDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:isc:l1cd")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSISCl1cdDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSISCl1cdDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:isc:l1cd")==0) {
		sopt->QZSISCl1cdDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:isc:l2c")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSISCl2cDCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSISCl2cDCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:isc:l2c")==0) {
		sopt->QZSISCl2cDCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:isc:l5i5")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSISCl5i5DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSISCl5i5DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:isc:l5i5")==0) {
		sopt->QZSISCl5i5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:isc:l5q5")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSISCl5q5DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSISCl5q5DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:isc:l5q5")==0) {
		sopt->QZSISCl5q5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:isc:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSISCl1cpDCBModel= DCBNONE;
			sopt->QZSISCl1cdDCBModel= DCBNONE;
			sopt->QZSISCl2cDCBModel= DCBNONE;
			sopt->QZSISCl5i5DCBModel= DCBNONE;
			sopt->QZSISCl5q5DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSISCl1cpDCBModel= DCBRINEX;
			sopt->QZSISCl1cdDCBModel= DCBRINEX;
			sopt->QZSISCl2cDCBModel= DCBRINEX;
			sopt->QZSISCl5i5DCBModel= DCBRINEX;
			sopt->QZSISCl5q5DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:isc:all")==0) {
		sopt->QZSISCl1cpDCBModel= DCBNONE;
		sopt->QZSISCl1cdDCBModel= DCBNONE;
		sopt->QZSISCl2cDCBModel= DCBNONE;
		sopt->QZSISCl5i5DCBModel= DCBNONE;
		sopt->QZSISCl5q5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:qzs:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->QZSc1cDCBModel= DCBNONE;
			sopt->QZSISCl1cpDCBModel= DCBNONE;
			sopt->QZSISCl1cdDCBModel= DCBNONE;
			sopt->QZSISCl2cDCBModel= DCBNONE;
			sopt->QZSISCl5i5DCBModel= DCBNONE;
			sopt->QZSISCl5q5DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->QZSc1cDCBModel= DCBRINEX;
			sopt->QZSISCl1cpDCBModel= DCBRINEX;
			sopt->QZSISCl1cdDCBModel= DCBRINEX;
			sopt->QZSISCl2cDCBModel= DCBRINEX;
			sopt->QZSISCl5i5DCBModel= DCBRINEX;
			sopt->QZSISCl5q5DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:qzs:all")==0) {
		sopt->QZSc1cDCBModel= DCBNONE;
		sopt->QZSISCl1cpDCBModel= DCBNONE;
		sopt->QZSISCl1cdDCBModel= DCBNONE;
		sopt->QZSISCl2cDCBModel= DCBNONE;
		sopt->QZSISCl5i5DCBModel= DCBNONE;
		sopt->QZSISCl5q5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:irn:c9c5")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->IRNc9c5DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->IRNc9c5DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:irn:c9c5")==0) {
		sopt->IRNc9c5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:irn:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->IRNc9c5DCBModel= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->IRNc9c5DCBModel= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:irn:all")==0) {
		sopt->IRNc9c5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:isc:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			dcbType=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			dcbType=DCBRINEX;
		} else {
			return -2;
		}
		sopt->GPSISCl1caDCBModel=dcbType;
		sopt->GPSISCl1cpDCBModel=dcbType;
		sopt->GPSISCl1cdDCBModel=dcbType;
		sopt->GPSISCl2cDCBModel=dcbType;
		sopt->GPSISCl5i5DCBModel=dcbType;
		sopt->GPSISCl5q5DCBModel=dcbType;
		sopt->BDSISCb1cdDCBModel= dcbType;
		sopt->BDSISCb2adDCBModel= dcbType;
		sopt->QZSISCl1cpDCBModel= dcbType;
		sopt->QZSISCl1cdDCBModel= dcbType;
		sopt->QZSISCl2cDCBModel= dcbType;
		sopt->QZSISCl5i5DCBModel= dcbType;
		sopt->QZSISCl5q5DCBModel= dcbType;
		return 1;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:isc:all")==0) {
		sopt->GPSISCl1caDCBModel=DCBNONE;
		sopt->GPSISCl1cpDCBModel=DCBNONE;
		sopt->GPSISCl1cdDCBModel=DCBNONE;
		sopt->GPSISCl2cDCBModel=DCBNONE;
		sopt->GPSISCl5i5DCBModel=DCBNONE;
		sopt->GPSISCl5q5DCBModel=DCBNONE;
		sopt->BDSISCb1cdDCBModel= DCBNONE;
		sopt->BDSISCb2adDCBModel= DCBNONE;
		sopt->QZSISCl1cpDCBModel= DCBNONE;
		sopt->QZSISCl1cdDCBModel= DCBNONE;
		sopt->QZSISCl2cDCBModel= DCBNONE;
		sopt->QZSISCl5i5DCBModel= DCBNONE;
		sopt->QZSISCl5q5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			dcbType=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			dcbType=DCBRINEX;
		} else {
			return -2;
		}
		sopt->GPSp1p2DCBModel = dcbType;
		sopt->GPSISCl1caDCBModel=dcbType;
		sopt->GPSISCl1cpDCBModel=dcbType;
		sopt->GPSISCl1cdDCBModel=dcbType;
		sopt->GPSISCl2cDCBModel=dcbType;
		sopt->GPSISCl5i5DCBModel=dcbType;
		sopt->GPSISCl5q5DCBModel=dcbType;
		sopt->GALe1e5aDCBModel= dcbType;
		sopt->GALe1e5bDCBModel= dcbType;
		sopt->GLOp1p2DCBModel= dcbType;
		sopt->BDSb2b6DCBModel= dcbType;
		sopt->BDSb7b6DCBModel= dcbType;
		sopt->BDSSP3DCBModel= dcbType;
		sopt->BDSb1b6DCBModel= dcbType;
		sopt->BDSb5b6DCBModel= dcbType;
		sopt->BDSISCb1cdDCBModel= dcbType;
		sopt->BDSISCb2adDCBModel= dcbType;
		sopt->QZSc1cDCBModel= dcbType;
		sopt->QZSISCl1cpDCBModel= dcbType;
		sopt->QZSISCl1cdDCBModel= dcbType;
		sopt->QZSISCl2cDCBModel= dcbType;
		sopt->QZSISCl5i5DCBModel= dcbType;
		sopt->QZSISCl5q5DCBModel= dcbType;
		sopt->IRNc9c5DCBModel= dcbType;
		return 1;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:all")==0) {
		sopt->GPSp1p2DCBModel = DCBNONE;
		sopt->GPSISCl1caDCBModel=DCBNONE;
		sopt->GPSISCl1cpDCBModel=DCBNONE;
		sopt->GPSISCl1cdDCBModel=DCBNONE;
		sopt->GPSISCl2cDCBModel=DCBNONE;
		sopt->GPSISCl5i5DCBModel=DCBNONE;
		sopt->GPSISCl5q5DCBModel=DCBNONE;
		sopt->GALe1e5aDCBModel= DCBNONE;
		sopt->GALe1e5bDCBModel= DCBNONE;
		sopt->GLOp1p2DCBModel= DCBNONE;
		sopt->BDSb2b6DCBModel= DCBNONE;
		sopt->BDSb7b6DCBModel= DCBNONE;
		sopt->BDSSP3DCBModel= DCBNONE;
		sopt->BDSb1b6DCBModel= DCBNONE;
		sopt->BDSb5b6DCBModel= DCBNONE;
		sopt->BDSISCb1cdDCBModel= DCBNONE;
		sopt->BDSISCb2adDCBModel= DCBNONE;
		sopt->QZSc1cDCBModel= DCBNONE;
		sopt->QZSISCl1cpDCBModel= DCBNONE;
		sopt->QZSISCl1cdDCBModel= DCBNONE;
		sopt->QZSISCl2cDCBModel= DCBNONE;
		sopt->QZSISCl5i5DCBModel= DCBNONE;
		sopt->QZSISCl5q5DCBModel= DCBNONE;
		sopt->IRNc9c5DCBModel= DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:df:gps")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->DualFreqDCBModel[GPS]= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->DualFreqDCBModel[GPS]= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:df:gps")==0) {
		sopt->DualFreqDCBModel[GPS] = DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:df:bds")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->DualFreqDCBModel[BDS]= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->DualFreqDCBModel[BDS]= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:df:bds")==0) {
		sopt->DualFreqDCBModel[BDS] = DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:df:qzs")==0 || strcasecmp(argv[0],"-model:dcb:df:qzss")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->DualFreqDCBModel[QZSS]= DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->DualFreqDCBModel[QZSS]= DCBRINEX;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:df:qzs")==0 || strcasecmp(argv[0],"--model:dcb:df:qzss")==0) {
		sopt->DualFreqDCBModel[QZSS] = DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:df:all")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			dcbType=DCBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			dcbType=DCBRINEX;
		} else {
			return -2;
		}
		sopt->DualFreqDCBModel[GPS] = dcbType;
		sopt->DualFreqDCBModel[BDS] = dcbType;
		sopt->DualFreqDCBModel[QZSS] = dcbType;
		return 1;
	} else if (strcasecmp(argv[0],"--model:dcb:df:all")==0) {
		sopt->DualFreqDCBModel[GPS] = DCBNONE;
		sopt->DualFreqDCBModel[BDS] = DCBNONE;
		sopt->DualFreqDCBModel[QZSS] = DCBNONE;
		return 1;
		//SINEX BIAS to be completed
/*	
	} else if (strcasecmp(argv[0],"-model:dcb:sf:obs")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->OSBdcbModel = OSBNONE;
		} else if (strcasecmp(argv[1],"RINEX")==0) {
			sopt->OSBdcbModel = OSBRINEX;
		} else if (strcasecmp(argv[1],"SINEXBIAS")==0) {
			sopt->OSBdcbModel = OSBSINEXBIAS;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:obs")==0) {
		options->OSBdcbModel = OSBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dcb:sf:conv")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"no")==0) {
			sopt->DSBdcbModel = DSBNONE;
		} else if (strcasecmp(argv[1],"SINEXBIAS")==0) {
			sopt->DSBdcbModel = DSBSINEXBIAS;
		} else {
			return -2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--model:dcb:sf:conv")==0) {
		options->DSBdcbModel = DSBNONE;
		return 1;
*/
	} else if (strcasecmp(argv[0],"-model:windup")==0) {
		options->windUpCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:windup")==0) {
		options->windUpCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:solidtides")==0) {
		options->solidTidesCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:solidtides")==0) {
		options->solidTidesCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:relpath")==0) {
		options->gravitationalCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:relpath")==0) {
		options->gravitationalCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:orbit:deg")==0 || strcasecmp(argv[0],"-model:orb:deg")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<=0) return -2;
		options->orbitInterpolationDegree = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:clock:deg")==0 || strcasecmp(argv[0],"-model:clk:deg")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->clockInterpolationDegree = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:orbmaxgaps")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->OrbitsMaxGaps = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"--model:orbmaxgaps")==0) {
		options->OrbitsMaxGaps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:clkmaxgaps")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->ClocksMaxGaps = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"--model:clkmaxgaps")==0) {
		options->ClocksMaxGaps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:orbtotmaxgaps")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->OrbitsToTMaxGaps = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"--model:orbtotmaxgaps")==0) {
		options->OrbitsToTMaxGaps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:clktotmaxgaps")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->ClocksToTMaxGaps = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"--model:clktotmaxgaps")==0) {
		options->ClocksToTMaxGaps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:orbprevsample")==0) {
		options->LastSamplePrevDayOrb = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:orbprevsample")==0) {
		options->LastSamplePrevDayOrb = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:clkprevsample")==0) {
		options->LastSamplePrevDayClk = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:clkprevsample")==0) {
		options->LastSamplePrevDayClk = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:allfilemeas")==0) {
		options->ModelAllMeas = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:allfilemeas")==0) {
		options->ModelAllMeas = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:satellitehealth")==0 || strcasecmp(argv[0],"-model:sathealth")==0) {
		sopt->satelliteHealth=1;
		sopt->allowMarginal=0;
		return 1;
	} else if (strcasecmp(argv[0],"--model:satellitehealth")==0 || strcasecmp(argv[0],"--model:sathealth")==0) {
		sopt->satelliteHealth=0;
		sopt->allowMarginal=1;
		return 1;
	} else if (strcasecmp(argv[0],"-model:allowmarginal")==0) {
		sopt->allowMarginal=1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:allowmarginal")==0) {
		sopt->allowMarginal=0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:skipunhealthymarg")==0) {
		options->brdcHealthSkip[BRDCMarginal]=1;
		options->brdcHealthSkip[BRDCUnhealthy]=1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:skipunhealthymarg")==0) {
		options->brdcHealthSkip[BRDCMarginal]=0;
		options->brdcHealthSkip[BRDCUnhealthy]=0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:skipunhealthy")==0) {
		options->brdcHealthSkip[BRDCUnhealthy]=1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:skipunhealthy")==0) {
		options->brdcHealthSkip[BRDCUnhealthy]=0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:brdctranstime")==0) {
		options->brdcBlockTransTime = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:brdctranstime")==0) {
		options->brdcBlockTransTime = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:maxurabrdc")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<=0) return -2;
		options->MaxURABroadcast = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"--model:maxurabrdc")==0) {
		options->MaxURABroadcast = 9999999.;
		return 1;
	} else if (strcasecmp(argv[0],"-model:globrdcintstep")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<=0) return -2;
		options->GLOintStep=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:brdcpreferagetime")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<=0) return -2;
		options->maxBRDCFreshTimeDiffToc=auxd;
		return 2;
 	} else if (strcasecmp(argv[0],"-model:brdc:gps")==0) {
		if (argv[1]==NULL) return -3;
		p=strchr(argv[1],',');
		if (p==NULL) { //Only one value provided
			if (strcasecmp(argv[1],"PreferLNAV")==0) {
				options->BrdcTypeSel[GPS] = PreferGPSLNAV;
			} else if (strcasecmp(argv[1],"PreferCNAV")==0) {
				options->BrdcTypeSel[GPS] = PreferGPSCNAV;
			} else if (strcasecmp(argv[1],"PreferCNAV2")==0) {
				options->BrdcTypeSel[GPS] = PreferGPSCNAV2;
			} else if (strcasecmp(argv[1],"LNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSLNAVOnly;
			} else if (strcasecmp(argv[1],"CNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSCNAVOnly;
			} else if (strcasecmp(argv[1],"CNAV2")==0) {
				options->BrdcTypeSel[GPS] = GPSCNAV2Only;
			} else if (strcasecmp(argv[1],"AnyCNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSAnyCNAVOnly;
			} else if (strcasecmp(argv[1],"LNAVvsCNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSLNAVvsCNAV;
			} else if (strcasecmp(argv[1],"CNAVvsLNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSCNAVvsLNAV;
			} else if (strcasecmp(argv[1],"LNAVvsCNAV2")==0) {
				options->BrdcTypeSel[GPS] = GPSLNAVvsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsLNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSCNAV2vsLNAV;
			} else if (strcasecmp(argv[1],"CNAVvsCNAV2")==0) {
				options->BrdcTypeSel[GPS] = GPSCNAVvsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsCNAV")==0) {
				options->BrdcTypeSel[GPS] = GPSCNAV2vsCNAV;
			} else {
				return -2;
			} 
		} else { //p!=NULL
			if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
			strcpy(sopt->BRDCTypesList[GPS],argv[1]);
		}
		return 2;
	} else if (strcasecmp(argv[0],"-model:brdc:gal")==0) {
		if (argv[1]==NULL) return -3;
		p=strchr(argv[1],',');
		if (p==NULL) { //Only one value provided
			if (strcasecmp(argv[1],"PreferINAV")==0) {
				options->BrdcTypeSel[Galileo] = PreferGalINAV;
			} else if (strcasecmp(argv[1],"PreferFNAV")==0) {
				options->BrdcTypeSel[Galileo] = PreferGalFNAV;
			} else if (strcasecmp(argv[1],"PreferCNAV")==0) {
				options->BrdcTypeSel[Galileo] = PreferGalCNAV;
			} else if (strcasecmp(argv[1],"PreferGNAV")==0) {
				options->BrdcTypeSel[Galileo] = PreferGalGNAV;
			} else if (strcasecmp(argv[1],"INAV")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVOnly;
			} else if (strcasecmp(argv[1],"INAVE1")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVE1Only;
			} else if (strcasecmp(argv[1],"INAVE5b")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVE5bOnly;
			} else if (strcasecmp(argv[1],"INAVE1E5b")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVE1E5bOnly;
			} else if (strcasecmp(argv[1],"FNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalFNAVOnly;
			} else if (strcasecmp(argv[1],"CNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalCNAVOnly;
			} else if (strcasecmp(argv[1],"GNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalGNAVOnly;
			} else if (strcasecmp(argv[1],"INAVvsFNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVvsFNAV;
			} else if (strcasecmp(argv[1],"FNAVvsINAV")==0) {
				options->BrdcTypeSel[Galileo] = GalFNAVvsINAV;
			} else if (strcasecmp(argv[1],"INAVvsCNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVvsCNAV;
			} else if (strcasecmp(argv[1],"CNAVvsINAV")==0) {
				options->BrdcTypeSel[Galileo] = GalCNAVvsINAV;
			} else if (strcasecmp(argv[1],"INAVvsGNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalINAVvsGNAV;
			} else if (strcasecmp(argv[1],"GNAVvsINAV")==0) {
				options->BrdcTypeSel[Galileo] = GalGNAVvsINAV;
			} else if (strcasecmp(argv[1],"FNAVvsCNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalFNAVvsCNAV;
			} else if (strcasecmp(argv[1],"CNAVvsFNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalCNAVvsFNAV;
			} else if (strcasecmp(argv[1],"FNAVvsGNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalFNAVvsGNAV;
			} else if (strcasecmp(argv[1],"GNAVvsFNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalGNAVvsFNAV;
			} else if (strcasecmp(argv[1],"CNAVvsGNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalCNAVvsGNAV;
			} else if (strcasecmp(argv[1],"GNAVvsCNAV")==0) {
				options->BrdcTypeSel[Galileo] = GalGNAVvsCNAV;
			} else {
				return -2;
			}
		} else { //p!=NULL
			if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
			strcpy(sopt->BRDCTypesList[Galileo],argv[1]);
		}
		return 2;
 	} else if (strcasecmp(argv[0],"-model:brdc:glo")==0) {
		if (argv[1]==NULL) return -3;
		p=strchr(argv[1],',');
		if (p==NULL) { //Only one value provided
			if (strcasecmp(argv[1],"PreferFDMA")==0) {
				options->BrdcTypeSel[GLONASS] = PreferGLOFDMA;
			} else if (strcasecmp(argv[1],"PreferCDMA")==0) {
				options->BrdcTypeSel[GLONASS] = PreferGLOCDMA;
			} else if (strcasecmp(argv[1],"FDMA")==0) {
				options->BrdcTypeSel[GLONASS] = GLOFDMAOnly;
			} else if (strcasecmp(argv[1],"CDMA")==0) {
				options->BrdcTypeSel[GLONASS] = GLOCDMAOnly;
			} else if (strcasecmp(argv[1],"FDMAvsCDMA")==0) {
				options->BrdcTypeSel[GLONASS] = GLOFDMAvsCDMA;
			} else if (strcasecmp(argv[1],"CDMAvsFDMA")==0) {
				options->BrdcTypeSel[GLONASS] = GLOCDMAvsFDMA;
			} else {
				return -2;
			} 
		} else { //p!=NULL
			if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
			strcpy(sopt->BRDCTypesList[GLONASS],argv[1]);
		}
		return 2;
	} else if (strcasecmp(argv[0],"-model:brdc:bds")==0) {
		if (argv[1]==NULL) return -3;
		p=strchr(argv[1],',');
		if (p==NULL) { //Only one value provided
			if (strcasecmp(argv[1],"PreferD1")==0) {
				options->BrdcTypeSel[BDS] = PreferBDSD1;
			} else if (strcasecmp(argv[1],"PreferD2")==0) {
				options->BrdcTypeSel[BDS] = PreferBDSD2;
			} else if (strcasecmp(argv[1],"PreferCNAV1")==0) {
				options->BrdcTypeSel[BDS] = PreferBDSCNAV1;
			} else if (strcasecmp(argv[1],"PreferCNAV2")==0) {
				options->BrdcTypeSel[BDS] = PreferBDSCNAV2;
			} else if (strcasecmp(argv[1],"D1")==0) {
				options->BrdcTypeSel[BDS] = BDSD1Only;
			} else if (strcasecmp(argv[1],"D2")==0) {
				options->BrdcTypeSel[BDS] = BDSD2Only;
			} else if (strcasecmp(argv[1],"CNAV1")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV1Only;
			} else if (strcasecmp(argv[1],"CNAV2")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV2Only;
			} else if (strcasecmp(argv[1],"D1vsD2")==0) {
				options->BrdcTypeSel[BDS] = BDSD1vsD2;
			} else if (strcasecmp(argv[1],"D2vsD1")==0) {
				options->BrdcTypeSel[BDS] = BDSD2vsD1;
			} else if (strcasecmp(argv[1],"D1vsCNAV1")==0) {
				options->BrdcTypeSel[BDS] = BDSD1vsCNAV1;
			} else if (strcasecmp(argv[1],"CNAV1vsD1")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV1vsD1;
			} else if (strcasecmp(argv[1],"D1vsCNAV2")==0) {
				options->BrdcTypeSel[BDS] = BDSD1vsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsD1")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV2vsD1;
			} else if (strcasecmp(argv[1],"D2vsCNAV1")==0) {
				options->BrdcTypeSel[BDS] = BDSD2vsCNAV1;
			} else if (strcasecmp(argv[1],"CNAV1vsD2")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV1vsD2;
			} else if (strcasecmp(argv[1],"D2vsCNAV2")==0) {
				options->BrdcTypeSel[BDS] = BDSD2vsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsD2")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV2vsD2;
			} else if (strcasecmp(argv[1],"CNAV1vsCNAV2")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV1vsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsCNAV1")==0) {
				options->BrdcTypeSel[BDS] = BDSCNAV2vsCNAV1;
			} else {
				return -2;
			} 
		} else { //p!=NULL
			if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
			strcpy(sopt->BRDCTypesList[BDS],argv[1]);
		}
		return 2;
 	} else if (strcasecmp(argv[0],"-model:brdc:qzss")==0 || strcasecmp(argv[0],"-model:brdc:qzs")==0) {
		if (argv[1]==NULL) return -3;
		p=strchr(argv[1],',');
		if (p==NULL) { //Only one value provided
			if (strcasecmp(argv[1],"PreferLNAV")==0) {
				options->BrdcTypeSel[QZSS] = PreferQZSLNAV;
			} else if (strcasecmp(argv[1],"PreferCNAV")==0) {
				options->BrdcTypeSel[QZSS] = PreferQZSCNAV;
			} else if (strcasecmp(argv[1],"PreferCNAV2")==0) {
				options->BrdcTypeSel[QZSS] = PreferQZSCNAV2;
			} else if (strcasecmp(argv[1],"LNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSLNAVOnly;
			} else if (strcasecmp(argv[1],"CNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSCNAVOnly;
			} else if (strcasecmp(argv[1],"CNAV2")==0) {
				options->BrdcTypeSel[QZSS] = QZSCNAV2Only;
			} else if (strcasecmp(argv[1],"AnyCNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSAnyCNAVOnly;
			} else if (strcasecmp(argv[1],"LNAVvsCNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSLNAVvsCNAV;
			} else if (strcasecmp(argv[1],"CNAVvsLNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSCNAVvsLNAV;
			} else if (strcasecmp(argv[1],"LNAVvsCNAV2")==0) {
				options->BrdcTypeSel[QZSS] = QZSLNAVvsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsLNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSCNAV2vsLNAV;
			} else if (strcasecmp(argv[1],"CNAVvsCNAV2")==0) {
				options->BrdcTypeSel[QZSS] = QZSCNAVvsCNAV2;
			} else if (strcasecmp(argv[1],"CNAV2vsCNAV")==0) {
				options->BrdcTypeSel[QZSS] = QZSCNAV2vsCNAV;
			} else {
				return -2;
			} 
		} else { //p!=NULL
			if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
			strcpy(sopt->BRDCTypesList[QZSS],argv[1]);
		}
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasmaritime")==0) {
		options->NoDeltaUDRE = 1;
		options->NoMT10 = 1;
		options->SBASmaritime=1;
		options->ContRiskWindowSize=900;
		options->ContRiskWindowSizeMar=900;
		options->HorAlarmLimit=1E5;
		options->VerAlarmLimit=1E5;
		options->HDOPthreshold = 1;
		options->PDOPthreshold = 1;
		options->HDOPorPDOP = 1;
		options->switchGEO = 1;
		options->maxHDOP = 4.0; 
		options->maxPDOP = 6.0; 
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbassignalflighttime")==0) {
		if (argv[1]==NULL) return -3;
		auxd=atof(argv[1]);
		if (auxd<0.||auxd>0.3) return -2;
		options->SBASmsgFlightTime=auxd;
		options->SBASmsg1MinusFlightTime = 1.-options->SBASmsgFlightTime;
		options->SBASmsg1PlusFlightTime = 1.+options->SBASmsgFlightTime;
		return 2;
	} else if (strcasecmp(argv[0],"-model:alarmmsgtype2")==0||strcasecmp(argv[0],"-model:usealarmmsgcorr")==0) {
		options->useAlarmmessageForCorrections = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:alarmmsgtype2")==0||strcasecmp(argv[0],"--model:usealarmmsgcorr")==0) {
		options->useAlarmmessageForCorrections = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:ignoretype0")==0) {
		options->usetype0messages = 0;
		return 1;
	} else if (strcasecmp(argv[0],"--model:ignoretype0")==0) {
		options->usetype0messages = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:anymeas")==0) {
		options->useAnyMeasSBASDFMC = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:sbasdfmc:anymeas")==0) {
		options->useAnyMeasSBASDFMC = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:austestbed")==0) {
		options->SBASDFMCMT37version = MT37V044;
		options->SBASDFMCMT3940version = MT3940V044;
		options->SBASDFMCMT42version = MT42V071;
		options->SBASDFMCMT47version = MT47V044;
		options->useAlarmmessageForCorrections = 1;
		sopt->DualFreqDCBModel[GPS] = DCBNONE;
		return 1;
	} else if (strcasecmp(argv[0],"--model:sbasdfmc:austestbed")==0) {
		options->SBASDFMCMT37version = MT37V1;
		options->SBASDFMCMT3940version = MT3940V1;
		options->SBASDFMCMT42version = MT42V1;
		options->SBASDFMCMT47version = MT47V1;
		options->useAlarmmessageForCorrections = 0;
		sopt->DualFreqDCBModel[GPS]= DCBRINEX;
		return 1;
	} else if (strcasecmp(argv[0],"-model:udreithreshold")==0) {
		if (argv[1]==NULL) return -3;
		aux1=atoi(argv[1]);
		if (aux1<1||aux1>13) return -2;
		options->UDREIthreshold=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"--model:udreithreshold")==0) {
		options->UDREIthreshold = 999999;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sigfltnomt10offset")==0) {
		if (argv[1]==NULL) return -3;
		auxd=atof(argv[1]);
		if (auxd<0.) return -2;
		options->SigmaOffsetNoMT10=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBASmode")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"PA")==0) {
			options->precisionapproach = PAMODE;
			options->UserForcedNPA=0;
		} else if (strcasecmp(argv[1],"NPA")==0) {
			options->precisionapproach = NPAMODE;
			options->UserForcedNPA=1;
		} else return -2;
		return 2;
	} else if (strcasecmp(argv[0],"-model:maintainGEO")==0) {
		options->MaintainGEO = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:maintainGEO")==0) {
		options->MaintainGEO = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:GEOswitch")==0) {
		options->switchGEO = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:GEOswitch")==0) {
		options->switchGEO = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:selectBestGEO")==0) {
		options->selectBestGEO = 1;
		options->switchGEO = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:selectBestGEO")==0) {
		options->selectBestGEO = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:SBASmodeswitch")==0) {
		options->switchmode = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:SBASmodeswitch")==0) {
		options->switchmode = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:GEOfallback")==0) {
		options->GEOfallback = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:GEOfallback")==0) {
		options->GEOfallback = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:GEOacqtime")==0 || strcasecmp(argv[0],"-model:GEOadqtime")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->adquisitiontime = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:switchtime")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->minimumswitchtime = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutPA")==0) {
		if (argv[1]==NULL || argv[2]==NULL ) return -3;
		aux1 = atoi(argv[1]);
		aux2 = atoi(argv[2]);
		if(aux1<0 || aux1>63) return -2;
		if(aux2<0) return -2;
		if (aux1==39||aux1==40) {
			options->usertmout[PAMODE][39]=aux2;
			options->usertmout[PAMODE][40]=aux2;
		} else if (aux1==34||aux1==35||aux1==36) {
			options->usertmout[PAMODE][34]=aux2;
			options->usertmout[PAMODE][35]=aux2;
			options->usertmout[PAMODE][36]=aux2;
		} else {
			options->usertmout[PAMODE][aux1]=aux2;
		}
		return 3;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutNPA")==0) {
		if (argv[1]==NULL || argv[2]==NULL ) return -3;
		aux1 = atoi(argv[1]);
		aux2 = atoi(argv[2]);
		if(aux1<0 || aux1>63) return -2;
		if(aux2<0) return -2;
		if (aux1==39||aux1==40) {
			options->usertmout[NPAMODE][39]=aux2;
			options->usertmout[NPAMODE][40]=aux2;
		} else if (aux1==34||aux1==35||aux1==36) {
			options->usertmout[NPAMODE][34]=aux2;
			options->usertmout[NPAMODE][35]=aux2;
			options->usertmout[NPAMODE][36]=aux2;
		} else {
			options->usertmout[NPAMODE][aux1]=aux2;
		}
		return 3;
	} else if (strcasecmp(argv[0],"-model:SBAStmout")==0) {
		if (argv[1]==NULL || argv[2]==NULL ) return -3;
		aux1 = atoi(argv[1]);
		aux2 = atoi(argv[2]);
		if(aux1<0 || aux1>63) return -2;
		if(aux2<0) return -2;
		if (aux1==39||aux1==40) {
			options->usertmout[PAMODE][39]=aux2;
			options->usertmout[NPAMODE][39]=aux2;
			options->usertmout[PAMODE][40]=aux2;
			options->usertmout[NPAMODE][40]=aux2;
		} else if (aux1==34||aux1==35||aux1==36) {
			options->usertmout[PAMODE][34]=aux2;
			options->usertmout[NPAMODE][34]=aux2;
			options->usertmout[PAMODE][35]=aux2;
			options->usertmout[NPAMODE][35]=aux2;
			options->usertmout[PAMODE][36]=aux2;
			options->usertmout[NPAMODE][36]=aux2;
		} else {
			options->usertmout[PAMODE][aux1]=aux2;
			options->usertmout[NPAMODE][aux1]=aux2;
		}
		return 3;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutFCPA")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->FCtmout[1]=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutFCNPA")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->FCtmout[0]=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutFC")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->FCtmout[0]=aux1;
		options->FCtmout[1]=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutRRCPA")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->RRCtmout[1]=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutRRCNPA")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->RRCtmout[0]=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:SBAStmoutRRC")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0) return -2;
		options->RRCtmout[0]=aux1;
		options->RRCtmout[1]=aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:mixedGEO")==0) {
		options->mixedGEOdata = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:mixedGEO")==0) {
		options->mixedGEOdata = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:initcoordNPA")==0) {
		options->initcoordNPA = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:initcoordNPA")==0) {
		options->initcoordNPA = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:SBASreceiver")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0 || aux1>4) return -2;
		options->airborneReceiverType = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sigmpath")==0) {
		if (argv[1]==NULL||argv[2]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		options->sigma2multipath[0]=auxd;
		auxd = atof(argv[2]);
		if(auxd<0.) {
			strcpy(argv[1],argv[2]);
			return -2;
		}
		options->sigma2multipath[1]=auxd;
		options->airborneReceiverType=0;
		//Check if third value is provided
		if (argv[3]==NULL) {
			return 3;
		} else {
			//Check that next argument is a number
			if (argv[3][0]=='.' || argv[3][0]=='+' || (argv[3][0]>=48 && argv[3][0]<=57) || //48 is ASCII 0 and 57 is ASCII 9
			   (argv[3][0]=='-' && argv[3][1]!='-' && (argv[3][1]=='.' || (argv[3][1]>=48 && argv[3][1]<=57)) ) ) {
				//Value provided is a number
				auxd = atof(argv[3]);
				if(auxd<=0.) {
					strcpy(argv[1],argv[3]);
					return -2;
				}
				options->sigma2multipath[2]=1./auxd;
				return 4;
			} else {
				return 3;
			}
		}
	} else if (strcasecmp(argv[0],"-model:sigdiv")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		options->sigma2divergence=auxd*auxd;
		options->airborneReceiverType=0;
		return 2;
	} else if (strcasecmp(argv[0],"-model:signoise")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<0.) return -2;
		options->sigma2noise=auxd*auxd;
		options->airborneReceiverType=0;
		return 2;
	} else if (strcasecmp(argv[0],"-model:khpa")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->kfactor[PAMODE][KHORPOS]=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:khnpa")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->kfactor[NPAMODE][KHORPOS]=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:kvpa")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->kfactor[PAMODE][KVERPOS]=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:kvnpa")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->kfactor[NPAMODE][KVERPOS]=auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:nofastcor")==0) {
		options->NoFastCorrection = 1;
		options->NoRRCCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:nofastcor")==0) {
		options->NoFastCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:norrccor")==0) {
		options->NoRRCCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:norrccor")==0) {
		options->NoRRCCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:noslowcor")==0) {
		options->NoSlowCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:noslowcor")==0) {
		options->NoSlowCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:noionocor")==0) {
		options->NoIonoCorrection = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:noionocor")==0) {
		options->NoIonoCorrection = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:nofastsigma")==0) {
		options->NoFastSigma = 1;
		options->NoFastDeg = 1;
		options->NoRRCSigma = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:nofastsigma")==0) {
		options->NoFastSigma = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:nofastdeg")==0) {
		options->NoFastDeg = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:nofastdeg")==0) {
		options->NoFastDeg = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:norrcsigma")==0) {
		options->NoRRCSigma = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:norrcsigma")==0) {
		options->NoRRCSigma= 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:noslowsigma")==0) {
		options->NoSlowSigma = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:noslowsigma")==0) {
		options->NoSlowSigma = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:noionosigma")==0) {
		options->NoIonoSigma = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:noionosigma")==0) {
		options->NoIonoSigma = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:notroposigma")==0) {
		options->NoTropoSigma = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:notroposigma")==0) {
		options->NoTropoSigma = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:noenroutesigma")==0) {
		options->NoEnRouteSigma = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:noenroutesigma")==0) {
		options->NoEnRouteSigma = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:nodeltaudre")==0 || strcasecmp(argv[0],"-model:nomt2728")==0) {
		options->NoDeltaUDRE = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:nodeltaudre")==0 || strcasecmp(argv[0],"--model:nomt2728")==0) {
		options->NoDeltaUDRE = 0;
		return 1;
    } else if (strcasecmp(argv[0],"-model:norrc1prc")==0) {
        options->noRRCwith1PRC = 1;
        return 1;
    } else if (strcasecmp(argv[0],"--model:norrc1prc")==0) {
        options->noRRCwith1PRC = 0;
        return 1;		
	} else if (strcasecmp(argv[0],"-model:nomt10")==0) {
		options->NoMT10 = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:nomt10")==0) {
		options->NoMT10 = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:mt37v04")==0) {
		options->SBASDFMCMT37version = MT37V044;
		return 1;
	} else if (strcasecmp(argv[0],"--model:sbasdfmc:mt37v04")==0) {
		options->SBASDFMCMT37version = MT37V1;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:mt3940v04")==0) {
		options->SBASDFMCMT3940version = MT3940V044;
		return 1;
	} else if (strcasecmp(argv[0],"--model:sbasdfmc:mt3940v04")==0) {
		options->SBASDFMCMT3940version = MT3940V1;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:mt42v07")==0) {
		options->SBASDFMCMT42version = MT42V071;
		return 1;
	} else if (strcasecmp(argv[0],"--model:sbasdfmc:mt42v07")==0) {
		options->SBASDFMCMT42version = MT42V1;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:mt47v04")==0) {
		options->SBASDFMCMT47version = MT47V044;
		return 1;
	} else if (strcasecmp(argv[0],"--model:sbasdfmc:mt47v04")==0) {
		options->SBASDFMCMT47version = MT47V1;
		return 1;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:cer")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCcer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:ccovariance")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCccovariance = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:icorr")==0) {
		if ( argv[1] == NULL ) return -3;
		p=strchr(argv[1],'-');
		p2=p+1;
		if(p==NULL) return -2;
		if(*p2=='\0') return -2;
		auxd=atof(p2);
		if ( auxd < 0. ) return -2;
		*p='\0';
		aux1=strlen(argv[1]);
		for(i=0;i<aux1;i++) {
			if (checkConstellationChar(argv[1][i])==0) return -2;
			options->SBASDFMCicorr[gnsschar2gnsstype(argv[1][i])] = auxd;
		}
		*p='-';
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:ccorr")==0) {
		if ( argv[1] == NULL ) return -3;
		p=strchr(argv[1],'-');
		p2=p+1;
		if(p==NULL) return -2;
		if(*p2=='\0') return -2;
		auxd=atof(p2);
		if ( auxd < 0. ) return -2;
		*p='\0';
		aux1=strlen(argv[1]);
		for(i=0;i<aux1;i++) {
			if (checkConstellationChar(argv[1][i])==0) return -2;
			options->SBASDFMCccorr[gnsschar2gnsstype(argv[1][i])] = auxd;
		}
		*p='-';
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:rcorr")==0) {
		if ( argv[1] == NULL ) return -3;
		p=strchr(argv[1],'-');
		p2=p+1;
		if(p==NULL) return -2;
		if(*p2=='\0') return -2;
		auxd=atof(p2);
		if ( auxd < 0. ) return -2;
		*p='\0';
		aux1=strlen(argv[1]);
		for(i=0;i<aux1;i++) {
			if (checkConstellationChar(argv[1][i])==0) return -2;
			options->SBASDFMCrcorr[gnsschar2gnsstype(argv[1][i])] = auxd;
		}
		*p='-';
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:dfrei")==0) {
		if ( argv[1] == NULL ) return -3;
		if ( argv[2] == NULL ) return -3;
		aux1 = atoi(argv[1]);
		if(aux1<0||aux1>14) return -2;
		auxd = atof(argv[2]);
		if ( auxd < 0. ) {
			strcpy(argv[2],argv[1]); // This is for a proper error control
			return -2;
		}
		options->SBASDFMCdfreiTable[aux1] = auxd;
		return 3;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:dfreilist")==0) {
		if ( argv[1] == NULL ) return -3;
		p=strchr(argv[1],',');
		aux1=0;
		while(p!=NULL) {
			aux1++;
			p++;
			p=strchr(p,',');
		}
		aux1++;
		if (aux1!=15) return -2;
		p2=argv[1];
		p=strchr(p2,',');
		if (p!=NULL) *p='\0';
		for(i=0;i<15;i++) {
			auxd = atof(p2);
			if ( auxd < 0. ) {
				if (p!=NULL) *p=',';
				return -2;
			}
			options->SBASDFMCdfreiTable[i] = auxd;
			if (i<14) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}			
		}
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:deltarcorr")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCdeltaRcorr = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:deltadfre")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCdeltaDFRE = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:sigmauire")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCsigmauire = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:sigmatropo")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCsigmatropo = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:sbasdfmc:sigmpathfactor")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->SBASDFMCsigmaMultipathFactor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:dgnss:sigmainflation")==0) {
		options->sigmaInflation = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--model:dgnss:sigmainflation")==0) {
		options->sigmaInflation = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-model:dgnss:maxage")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->maxAgeDGNSS = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-model:dgnss:maxcorrval")==0) {
		if ( argv[1] == NULL ) return -3;
		auxd = atof(argv[1]);
		if ( auxd < 0. ) return -2;
		options->maxDGNSSPRC = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:velocity")==0) {
		options->computeVelocity = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:velocity")==0) {
		options->computeVelocity = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:dopplermeas")==0 || strcasecmp(argv[0],"-filter:dopplermeaslist")==0 ) { 
		if (argv[1]==NULL) return -3;
		staType=0;
		options->computeVelocity = 1;
		sopt->userDopplerMeas[staType]=1;
		if (strcasecmp(argv[0],"-filter:dopplermeas")==0) {
			aux1=atoi(argv[1]);
			if (aux1>0) {
				aux2=sopt->numMeasDopplerText[staType];
				sopt->numMeasDopplerText[staType] += aux1;
				if (sopt->numMeasDopplerText[staType]<=0) return -2;
				sopt->measDopplerText[staType]=realloc(sopt->measDopplerText[staType],sopt->numMeasDopplerText[staType]*sizeof(char *));
				for (i=0;i<aux1;i++) {
					if (argv[2+i]==NULL) return -3;
					if(strlen(argv[2+i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->measDopplerText[staType][aux2+i]=NULL;
					sopt->measDopplerText[staType][aux2+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->measDopplerText[staType][aux2+i],argv[2+i]);
				}
				return 2+aux1;
			} else if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->measDopplerText[staType]=realloc(sopt->measDopplerText[staType],sizeof(char *)*(sopt->numMeasDopplerText[staType]+i));
					sopt->measDopplerText[staType][sopt->numMeasDopplerText[staType]+i-1]=NULL;
					sopt->measDopplerText[staType][sopt->numMeasDopplerText[staType]+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->measDopplerText[staType][sopt->numMeasDopplerText[staType]+i-1],argv[i]);
					i++;
				}
				sopt->numMeasDopplerText[staType]+=i-1;
				return i;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-filter:dopplermeaslist")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->measDopplerText[staType]=realloc(sopt->measDopplerText[staType],sizeof(char *)*(sopt->numMeasDopplerText[staType]+aux1));
			for(i=0;i<aux1;i++) {
				sopt->measDopplerText[staType][sopt->numMeasDopplerText[staType]+i]=NULL;
				sopt->measDopplerText[staType][sopt->numMeasDopplerText[staType]+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->measDopplerText[staType][sopt->numMeasDopplerText[staType]+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numMeasDopplerText[staType]+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-filter:noambiguities")==0) {
		options->estimateAmbiguities = 0;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:noambiguities")==0) {
		options->estimateAmbiguities = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:trop")==0||strcasecmp(argv[0],"-filter:tropo")==0) {
		sopt->estimateTroposphere = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:trop")==0||strcasecmp(argv[0],"--filter:tropo")==0) {
		sopt->estimateTroposphere = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:iono")==0) {
		options->estimateIono = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:iono")==0) {
		options->estimateIono = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:satdcb")==0) {
		options->estimateSatDCB = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:satdcb")==0) {
		options->estimateSatDCB = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:recdcb")==0) {
		options->estimateRecDCB = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:recdcb")==0) {
		options->estimateRecDCB = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:gloifb")==0) {
		options->estimateGLOIFB = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:gloifb")==0) {
		options->estimateGLOIFB = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:recwindup")==0) {
		options->estimateRecWindUp= 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:recwindup")==0) {
		options->estimateRecWindUp = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:iscb")==0) {
		if (argv[1]==NULL) return -3;
		if (checkIfNextParameter(argv[1])==1) return -3;
		i=1;
		while(argv[i]!=NULL) {
			if (checkIfNextParameter(argv[i])==1) break;
			if (strlen(argv[i])<4) {
			   strcpy(argv[1],argv[i]);
			   return -2;
			}
			if (checkConstellationChar(argv[i][0])!=1 || checkConstellationChar(argv[i][1])!=1) {
			   if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
			   strcpy(argv[1],argv[i]);
			   return -2;
			}
			if (argv[i][2]!='-') {
				if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
				strcpy(argv[1],argv[i]);
				return -2;
			}
			aux1=gnsschar2gnsstype(argv[i][0]);
			aux2=gnsschar2gnsstype(argv[i][1]);
			if (strcasecmp(&argv[i][3],"RINEX")==0) {
				options->GNSSclockSource[aux1][aux2]=ClkSrcRINEX;
			} else if (strcasecmp(&argv[i][3],"estimate")==0) {
				options->GNSSclockSource[aux1][aux2]=ClkSrcCalculate;
			} else {
				if (strlen(argv[i])<6) {
				   strcpy(argv[1],argv[i]);
				   return -2;
				}
				options->GNSSclockSource[aux1][aux2]=ClkSrcUser;
				if (argv[i][4]=='-') {
					auxd=atof(&argv[i][5]);
					if (argv[i][3]=='m' || argv[i][3]=='M') {
						options->GNSSclockValue[aux1][aux2]=auxd;
					} else if (argv[i][3]=='n' || argv[i][3]=='N') {
						auxd*=1E-9*c0;
						options->GNSSclockValue[aux1][aux2]=auxd;
					} else if (argv[i][3]=='s' || argv[i][3]=='S') {
						auxd*=c0;
						options->GNSSclockValue[aux1][aux2]=auxd;
					} else {
						if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
						strcpy(argv[1],argv[i]);
						return -2;
					}
				} else {
					//In default units (metres)
					auxd=atof(&argv[i][3]);
					options->GNSSclockValue[aux1][aux2]=auxd;
				}
				//Add the inverse ISCB conversion with sign changed
				options->GNSSclockSource[aux2][aux1]=ClkSrcUser;
				options->GNSSclockValue[aux2][aux1]=-auxd;
			}
			i++;
		}
		return i;
	} else if (strcasecmp(argv[0],"-filter:nav")==0) {
		if (argv[1]==NULL) return -3;
		if (strcasecmp(argv[1],"static")==0) {
			sopt->navKinematics = NKstatic;
		} else if (strcasecmp(argv[1],"kinematic")==0) {
			sopt->navKinematics = NKkinematic;
		} else if (strcasecmp(argv[1],"randomwalk")==0) {
			sopt->navKinematics = NKrandomWalk;
		} else return -2;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:fixedweight")==0||strcasecmp(argv[0],"-filter:fixedweightsat")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:fixedweight")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:fixedweightsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:fixedweightsat' is deprecated, use '-filter:fixedweight' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(2+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightText=realloc(sopt->weightText,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightTextSat=realloc(sopt->weightTextSat,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightMode=realloc(sopt->weightMode,sizeof(enum WeightMode)*(sopt->numweightText+1));
			sopt->WeightConstantsValues=realloc(sopt->WeightConstantsValues,sizeof(double*)*(sopt->numweightText+1));
			sopt->weightText[sopt->numweightText]=NULL;
			sopt->weightText[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextSat[sopt->numweightText]=NULL;
			sopt->weightTextSat[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->WeightConstantsValues[sopt->numweightText]=NULL;
			sopt->WeightConstantsValues[sopt->numweightText]=malloc(sizeof(double)*3);
			if(aux1==1) {
				strcpy(sopt->weightTextSat[sopt->numweightText],argv[i]);
			} else {
				sopt->weightTextSat[sopt->numweightText][0]='\0';
			}
			strcpy(sopt->weightText[sopt->numweightText],argv[i+aux1]);
			auxd = atof(argv[i+aux1+1]);
			if(strcasecmp(argv[i+aux1+1],"URA")==0) {
				auxd=-2;
			} else if (auxd<0) {
				strcpy (argv[1],argv[i+aux1+1]);
				return -2;
			}
			sopt->weightMode[sopt->numweightText]=FixedWeight;
			sopt->WeightConstantsValues[sopt->numweightText][0]=auxd;
			sopt->WeightConstantsValues[sopt->numweightText][1]=0.;
			sopt->WeightConstantsValues[sopt->numweightText][2]=0.;
			sopt->numweightText++;
			i+=2+aux1;
		}
		return i;
		
   } else if (strcasecmp(argv[0],"-filter:elevweight")==0||strcasecmp(argv[0],"-filter:elevweightsat")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:elevweight")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:elevweightsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:elevweightsat' is deprecated, use '-filter:elevweight' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(4+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightText=realloc(sopt->weightText,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightTextSat=realloc(sopt->weightTextSat,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightMode=realloc(sopt->weightMode,sizeof(enum WeightMode)*(sopt->numweightText+1));
			sopt->WeightConstantsValues=realloc(sopt->WeightConstantsValues,sizeof(double*)*(sopt->numweightText+1));
			sopt->weightText[sopt->numweightText]=NULL;
			sopt->weightText[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextSat[sopt->numweightText]=NULL;
			sopt->weightTextSat[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->WeightConstantsValues[sopt->numweightText]=NULL;
			sopt->WeightConstantsValues[sopt->numweightText]=malloc(sizeof(double)*3);
			if(aux1==1) {
				strcpy(sopt->weightTextSat[sopt->numweightText],argv[i]);
			} else {
				sopt->weightTextSat[sopt->numweightText][0]='\0';
			}
			strcpy(sopt->weightText[sopt->numweightText],argv[i+aux1]);
			auxd = atof(argv[i+aux1+1]);
			if(strcasecmp(argv[i+aux1+1],"URA")==0) {
				auxd=-2;
			} else if (auxd<0) {
				strcpy (argv[1],argv[i+aux1+1]);
				return -2;
			}
			auxd2 = atof(argv[i+aux1+2]);
			if (auxd2<0) {
				if(strlen(argv[i+aux1+2])>MAX_INPUT_LINE-1) return -4;
				strcpy (argv[1],argv[i+aux1+2]);
				return -2;
			}
			auxd3 = atof(argv[i+aux1+3]);
			if (auxd3<=0) {
				if(strlen(argv[i+aux1+3])>MAX_INPUT_LINE-1) return -4;
				strcpy (argv[1],argv[i+aux1+3]);
				return -2;
			}
			sopt->weightMode[sopt->numweightText]=ElevationWeight;
			sopt->WeightConstantsValues[sopt->numweightText][0]=auxd;
			sopt->WeightConstantsValues[sopt->numweightText][1]=auxd2;
			sopt->WeightConstantsValues[sopt->numweightText][2]=auxd3*d2r; //Transform to radians
			sopt->numweightText++;
			i+=4+aux1;
		}
		return i;

    } else if (strcasecmp(argv[0],"-filter:sinelevweight")==0||strcasecmp(argv[0],"-filter:sinelevweightsat")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:sinelevweight")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:elevweightsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:sinelevweightsat' is deprecated, use '-filter:sinelevweight' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(3+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightText=realloc(sopt->weightText,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightTextSat=realloc(sopt->weightTextSat,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightMode=realloc(sopt->weightMode,sizeof(enum WeightMode)*(sopt->numweightText+1));
			sopt->WeightConstantsValues=realloc(sopt->WeightConstantsValues,sizeof(double*)*(sopt->numweightText+1));
			sopt->weightText[sopt->numweightText]=NULL;
			sopt->weightText[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextSat[sopt->numweightText]=NULL;
			sopt->weightTextSat[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->WeightConstantsValues[sopt->numweightText]=NULL;
			sopt->WeightConstantsValues[sopt->numweightText]=malloc(sizeof(double)*3);
			if(aux1==1) {
				strcpy(sopt->weightTextSat[sopt->numweightText],argv[i]);
			} else {
				sopt->weightTextSat[sopt->numweightText][0]='\0';
			}
			strcpy(sopt->weightText[sopt->numweightText],argv[i+aux1]);
			auxd = atof(argv[i+aux1+1]);
			if(strcasecmp(argv[i+aux1+1],"URA")==0) {
				auxd=-2;
			} else if (auxd<0) {
				strcpy (argv[1],argv[i+aux1+1]);
				return -2;
			}
			auxd2 = atof(argv[i+aux1+2]);
			if (auxd2<0) {
				if(strlen(argv[i+aux1+2])>MAX_INPUT_LINE-1) return -4;
				strcpy (argv[1],argv[i+aux1+2]);
				return -2;
			}
			sopt->weightMode[sopt->numweightText]=Elevation2Weight;
			sopt->WeightConstantsValues[sopt->numweightText][0]=auxd;
			sopt->WeightConstantsValues[sopt->numweightText][1]=auxd2;
			sopt->WeightConstantsValues[sopt->numweightText][2]=0.; 
			sopt->numweightText++;
			i+=3+aux1;
		}
		return i;

    } else if (strcasecmp(argv[0],"-filter:snrweight")==0||strcasecmp(argv[0],"-filter:snrweightsat")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:snrweight")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:elevweightsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:snrweightsat' is deprecated, use '-filter:snrweight' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(3+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightText=realloc(sopt->weightText,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightTextSat=realloc(sopt->weightTextSat,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightMode=realloc(sopt->weightMode,sizeof(enum WeightMode)*(sopt->numweightText+1));
			sopt->WeightConstantsValues=realloc(sopt->WeightConstantsValues,sizeof(double*)*(sopt->numweightText+1));
			sopt->weightText[sopt->numweightText]=NULL;
			sopt->weightText[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextSat[sopt->numweightText]=NULL;
			sopt->weightTextSat[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->WeightConstantsValues[sopt->numweightText]=NULL;
			sopt->WeightConstantsValues[sopt->numweightText]=malloc(sizeof(double)*3);
			if(aux1==1) {
				strcpy(sopt->weightTextSat[sopt->numweightText],argv[i]);
			} else {
				sopt->weightTextSat[sopt->numweightText][0]='\0';
			}
			strcpy(sopt->weightText[sopt->numweightText],argv[i+aux1]);
			auxd = atof(argv[i+aux1+1]);
			if(strcasecmp(argv[i+aux1+1],"URA")==0) {
				auxd=-2;
			} else if (auxd<0) {
				strcpy (argv[1],argv[i+aux1+1]);
				return -2;
			}
			auxd2 = atof(argv[i+aux1+2]);
			if (auxd2<0) {
				if(strlen(argv[i+aux1+2])>MAX_INPUT_LINE-1) return -4;
				strcpy (argv[1],argv[i+aux1+2]);
				return -2;
			}
			sopt->weightMode[sopt->numweightText]=SNRWeight;
			sopt->WeightConstantsValues[sopt->numweightText][0]=auxd;
			sopt->WeightConstantsValues[sopt->numweightText][1]=auxd2;
			sopt->WeightConstantsValues[sopt->numweightText][2]=0.; 
			sopt->numweightText++;
			i+=3+aux1;
		}
		return i;


    } else if (strcasecmp(argv[0],"-filter:snrelevweight")==0||strcasecmp(argv[0],"-filter:snrelevweightsat")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:snrelevweight")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:elevweightsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:snrelevweightsat' is deprecated, use '-filter:snrelevweight' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(3+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightText=realloc(sopt->weightText,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightTextSat=realloc(sopt->weightTextSat,sizeof(char *)*(sopt->numweightText+1));
			sopt->weightMode=realloc(sopt->weightMode,sizeof(enum WeightMode)*(sopt->numweightText+1));
			sopt->WeightConstantsValues=realloc(sopt->WeightConstantsValues,sizeof(double*)*(sopt->numweightText+1));
			sopt->weightText[sopt->numweightText]=NULL;
			sopt->weightText[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextSat[sopt->numweightText]=NULL;
			sopt->weightTextSat[sopt->numweightText]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->WeightConstantsValues[sopt->numweightText]=NULL;
			sopt->WeightConstantsValues[sopt->numweightText]=malloc(sizeof(double)*3);
			if(aux1==1) {
				strcpy(sopt->weightTextSat[sopt->numweightText],argv[i]);
			} else {
				sopt->weightTextSat[sopt->numweightText][0]='\0';
			}
			strcpy(sopt->weightText[sopt->numweightText],argv[i+aux1]);
			auxd = atof(argv[i+aux1+1]);
			if(strcasecmp(argv[i+aux1+1],"URA")==0) {
				auxd=-2;
			} else if (auxd<0) {
				strcpy (argv[1],argv[i+aux1+1]);
				return -2;
			}
			auxd2 = atof(argv[i+aux1+2]);
			if (auxd2<0) {
				if(strlen(argv[i+aux1+2])>MAX_INPUT_LINE-1) return -4;
				strcpy (argv[1],argv[i+aux1+2]);
				return -2;
			}
			sopt->weightMode[sopt->numweightText]=SNRElevWeight;
			sopt->WeightConstantsValues[sopt->numweightText][0]=auxd;
			sopt->WeightConstantsValues[sopt->numweightText][1]=auxd2;
			sopt->WeightConstantsValues[sopt->numweightText][2]=0.; 
			sopt->numweightText++;
			i+=3+aux1;
		}
		return i;


    } else if (strcasecmp(argv[0],"-filter:snrweight:comb")==0||strcasecmp(argv[0],"-filter:snrweight:combsat")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:snrweight:comb")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:snrweight:combsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:snrweight:combsat' is deprecated, use '-filter:snrweight:comb' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(2+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightTextComb=realloc(sopt->weightTextComb,sizeof(char *)*(sopt->numweightTextComb+1));
			sopt->weightTextCombSat=realloc(sopt->weightTextCombSat,sizeof(char *)*(sopt->numweightTextComb+1));
			sopt->SNRweightComb=realloc(sopt->SNRweightComb,sizeof(enum SNRWeightComb)*(sopt->numweightTextComb+1));
			sopt->SNRweightCombVal=realloc(sopt->SNRweightCombVal,sizeof(double*)*(sopt->numweightTextComb+1));
			sopt->weightTextComb[sopt->numweightTextComb]=NULL;
			sopt->weightTextComb[sopt->numweightTextComb]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextCombSat[sopt->numweightTextComb]=NULL;
			sopt->weightTextCombSat[sopt->numweightTextComb]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->SNRweightCombVal[sopt->numweightTextComb]=NULL;
			sopt->SNRweightCombVal[sopt->numweightTextComb]=malloc(sizeof(double)*4);
			if(aux1==1) {
				strcpy(sopt->weightTextCombSat[sopt->numweightTextComb],argv[i]);
			} else {
				sopt->weightTextCombSat[sopt->numweightTextComb][0]='\0';
			}
			strcpy(sopt->weightTextComb[sopt->numweightTextComb],argv[i+aux1]);
			auxdarray[0]=auxdarray[1]=auxdarray[2]=auxdarray[3]=0.;
			if (strcasecmp(argv[i+aux1+1],"SNRi")==0) {
				aux2=SNRWeightCombi;
			} else if (strcasecmp(argv[i+aux1+1],"SNRj")==0) {
				aux2=SNRWeightCombj;
			} else if (strcasecmp(argv[i+aux1+1],"SNRk")==0) {
				aux2=SNRWeightCombk;
			} else if (strcasecmp(argv[i+aux1+1],"SNRl")==0) {
				aux2=SNRWeightCombl;
			} else if (strcasecmp(argv[i+aux1+1],"MaxSNR")==0) {
				aux2=SNRWeightCombMax;
			} else if (strcasecmp(argv[i+aux1+1],"MinSNR")==0) {
				aux2=SNRWeightCombMin;
			} else if (strcasecmp(argv[i+aux1+1],"MeanSNR")==0) {
				aux2=SNRWeightCombMean;
			} else {
				//Weights for dual frequency combinations of dual frequency
				aux2=SNRWeightCombUser;
				p=strchr(argv[i+aux1+1],'-');
				if (p==NULL) {
					auxdarray[0]=atof(argv[i+aux1+1]);
					auxdarray[1]=1-auxdarray[0];
					auxdarray[2]=0.;
					auxdarray[3]=0.;
					if (auxdarray[0]<0. || auxdarray[0]>1.) {
						if(strlen(argv[i+aux1+1])>MAX_INPUT_LINE-1) return -4;
						strcpy (argv[1],argv[i+aux1+1]);
						return -2;
					} 
				} else {
					//Weights for three/four frequency combination
					aux3=0;
					while(p!=NULL) {
						aux3++;
						p++;
						p=strchr(p,'-');
					}
					aux3++;
					if(aux3!=4) {
						//Missing weights
						if(strlen(argv[i+aux1+1])>MAX_INPUT_LINE-1) return -4;
						strcpy (argv[1],argv[i+aux1+1]);
						return -2;
					}
					p2=argv[i+aux1+1];
					p=strchr(p2,'-');
					*p='\0';
					auxd=0.;
					for(j=0;j<4;j++) {
						auxdarray[j]=atof(p2);
						if (auxdarray[j]<0. || auxdarray[j]>1.) {
							if(strlen(argv[i+aux1+1])>MAX_INPUT_LINE-1) return -4;
							strcpy (argv[1],argv[i+aux1+1]);
							return -2;
						}
						auxd+=auxdarray[j];
						if(j<3) {
							*p='-';
							p2=p+1;
							p=strchr(p2,'-');
							if(p!=NULL) *p='\0';
						}
					}
					if (auxd!=1.) {
						//Allow some tolerance in decimals in case precision makes values such as 0.9999999
						if (fabs(1.-auxd)>=DIFFEQTHRESHOLD) {
							if(strlen(argv[i+aux1+1])>MAX_INPUT_LINE-1) return -4;
							strcpy (argv[1],argv[i+aux1+1]);
							return -2;
						}
					}
				}
			}
			sopt->SNRweightComb[sopt->numweightTextComb]=aux2;
			sopt->SNRweightCombVal[sopt->numweightTextComb][0]=auxdarray[0];
			sopt->SNRweightCombVal[sopt->numweightTextComb][1]=auxdarray[1];
			sopt->SNRweightCombVal[sopt->numweightTextComb][2]=auxdarray[2];
			sopt->SNRweightCombVal[sopt->numweightTextComb][3]=auxdarray[3];

			sopt->numweightTextComb++;
			i+=2+aux1;
		}
		return i;

	} else if (strcasecmp(argv[0],"-filter:sbasdgnssweightmode")==0) {
		if(argv[1]==NULL) return -3;
		if (strcasecmp(argv[0],"-filter:sbasdgnssweightmode")==0) {
			aux1=0;
		} else {	//strcasecmp(argv[0],"-filter:elevweightsat")==0
			j=(int)strlen(sopt->deprecatedMessages);
			if (j<(MAX_MESSAGE_STR-MAX_DEPRECATED_MSG_SIZE)) { //To avoid buffer overflow in sopt->deprecatedMessages
				sprintf(&sopt->deprecatedMessages[j],"INFO WARNING Filter option '-filter:sbasdgnssweightmodesat' is deprecated, use '-filter:sbasdgnssweightmode' instead.\n");
			}
			options->deprecatedMode = 1;
			aux1=1;
		}
		i=1;
		while(argv[i]!=NULL) {
			for(j=0;j<(2+aux1);j++) {
				if (argv[i+j]==NULL) return -3;
				if (checkIfNextParameter(argv[i+j])==1) {
					if (j==0) break; 
					else return -3;
				}
				if(strlen(argv[i+j])>=(MAX_INPUT_LINE-1)) return -4;
			}
			if(j==0) break;
			sopt->weightTextMode=realloc(sopt->weightTextMode,sizeof(char *)*(sopt->numweightTextMode+1));
			sopt->weightTextModeSat=realloc(sopt->weightTextModeSat,sizeof(char *)*(sopt->numweightTextMode+1));
			sopt->CombineWeightMode=realloc(sopt->CombineWeightMode,sizeof(enum CombineWeightsMode)*(sopt->numweightTextMode+1));
			sopt->weightTextMode[sopt->numweightTextMode]=NULL;
			sopt->weightTextMode[sopt->numweightTextMode]=malloc(sizeof(char)*MAX_INPUT_LINE);
			sopt->weightTextModeSat[sopt->numweightTextMode]=NULL;
			sopt->weightTextModeSat[sopt->numweightTextMode]=malloc(sizeof(char)*MAX_INPUT_LINE);
			if(aux1==1) {
				strcpy(sopt->weightTextModeSat[sopt->numweightTextMode],argv[i]);
			} else {
				sopt->weightTextModeSat[sopt->numweightTextMode][0]='\0';
			}
			strcpy(sopt->weightTextMode[sopt->numweightTextMode],argv[i+aux1]);

			if (strcasecmp(argv[i+aux1+1],"ComputedOnly")==0) {
				aux2=ComputedOnly;
			} else if (strcasecmp(argv[i+aux1+1],"ComputedPlusUser")==0 || strcasecmp(argv[i+aux1+1],"Computed+User")==0) {
				aux2=ComputedPlusUser;
			} else if (strcasecmp(argv[i+aux1+1],"UserOnly")==0) {
				aux2=UserOnly;
			} else {
				if(strlen(argv[i+aux1+1])>MAX_INPUT_LINE-1) return -4;
				strcpy (argv[1],argv[i+aux1+1]);
				return -2;
			}
			sopt->CombineWeightMode[sopt->numweightTextMode]=aux2;

			sopt->numweightTextMode++;
			i+=2+aux1;
		}
		return i;
	} else if (strcasecmp(argv[0],"-filter:dr:randomwalk")==0) {
		options->CoordRandWalk=1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:dr:randomwalk")==0) {
		options->CoordRandWalk=0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:clk:randomwalk")==0) {
		options->ClkRandWalk=1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:clk:randomwalk")==0) {
		options->ClkRandWalk=0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:iscb:randomwalk")==0) {
		options->ISCBRandWalk=1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:iscb:randomwalk")==0) {
		options->ISCBRandWalk=0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:phi:dr")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][DR_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:phi:clk")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][DT_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:phi:iscb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][DT_IS_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:phi:trop")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][TROP_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:phi:amb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][BIAS_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:phi:gloifb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][GLOIFB_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:phi:recwindup")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[PHI_PAR][WUP_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:dr")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][DR_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:clk")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][DT_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:clk:ns")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][DT_UNK] = auxd*c0*c0*1E-9*1E-9;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:iscb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][DT_IS_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:iscb:ns")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][DT_IS_UNK] = auxd*c0*c0*1E-9*1E-9;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:trop")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][TROP_UNK] = auxd/3600.;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:amb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][BIAS_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:gloifb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][GLOIFB_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:q:recwindup")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[Q_PAR][WUP_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:dr")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][DR_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:clk")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][DT_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:clk:ns")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][DT_UNK] = auxd*c0*c0*1E-9*1E-9;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:iscb")==0 ) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][DT_IS_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:iscb:ns")==0 ) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][DT_IS_UNK] = auxd*c0*c0*1E-9*1E-9;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:trop")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][TROP_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:amb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][BIAS_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:gloifb")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][GLOIFB_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:p0:recwindup")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if(auxd<0.) return -2;
		sopt->filterParams[P0_PAR][WUP_UNK] = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:backward")==0) {
		options->filterIterations = 2;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:backward")==0) {
		options->filterIterations = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:stfdesa")==0) {
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:stfdesa")==0) {
		options->stanfordesa = 0;
		options->stanfordesaLOI = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:stfdesaLOI")==0) {
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:stfdesaLOI")==0) {
		options->stanfordesaLOI = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:maxsat")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		if (aux1<4) return -2;
		options->stanfordesaMaxNumSat = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"--filter:stfdesa:maxsat")==0) {
		options->stanfordesaMaxNumSat = 999999;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:hwir")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->WIRHorThreshold = auxd;
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:vwir")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->WIRVerThreshold = auxd;
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:xmax")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		sopt->stfdesaxmax=auxd;
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:ymax")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		sopt->stfdesaymax=auxd;
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:xres")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		sopt->stfdesaxres=auxd;
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:stfdesa:yres")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		sopt->stfdesayres=auxd;
		options->stanfordesa = 1;
		options->stanfordesaLOI = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-filter:maxgdop")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->GDOPthreshold = 1;
		options->maxGDOP = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"--filter:maxgdop")==0) {
		options->GDOPthreshold = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:maxhdop")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->HDOPthreshold = 1;
		options->maxHDOP = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"--filter:maxhdop")==0) {
		options->HDOPthreshold = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:maxpdop")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->PDOPthreshold = 1;
		options->maxPDOP = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"--filter:maxpdop")==0) {
		options->PDOPthreshold = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:hdoporpdop")==0) {
		options->HDOPorPDOP = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:hdoporpdop")==0) {
		options->HDOPorPDOP = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:refclkorder")==0||strcasecmp(argv[0],"-filter:refclkonlyorder")==0) {
		if (argv[1]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		aux2=strlen(argv[1]);
		if (aux2==0) return -2;
		if (aux2>MAX_GNSS) return -2;
		for(i=0;i<aux2;i++) {
			if (checkConstellationChar(argv[1][i])==0) return -2;
			options->ClkRefPriorityList[i]=gnsschar2gnsstype(argv[1][i]);
		}
		if (aux2<MAX_GNSS) {
			//Not all constellation provided. Fill with the default order
			for(i=aux2;i<MAX_GNSS;i++) {
				//Set first the unset positions to -1
				options->ClkRefPriorityList[i]=-1;
			}
			for(i=aux2;i<MAX_GNSS;i++) {
				for(j=0;j<MAX_GNSS;j++) {
					m=0;
					for(k=0;k<i;k++) {
						if (options->ClkRefPriorityList[k]==DefaultClkRefOrder[j]) {
							m=1;
							break;
						}
					}
					if (m==1) continue;
					else if (m==0) break;
				}
				options->ClkRefPriorityList[i]=DefaultClkRefOrder[j];
			}
		}
		if (strcasecmp(argv[0],"-filter:refclkorder")==0) {
			options->numClkRefPriorityList=MAX_GNSS;
		} else {
			options->numClkRefPriorityList=aux2;
		}
		return 2;
	} else if (strcasecmp(argv[0],"-filter:nochangerefclk")==0) {
		options->AllowChangeReferenceGNSSClk=0;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:nochangerefclk")==0) {
		options->AllowChangeReferenceGNSSClk=1;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:SigmaIono")==0) {
		options->useSigmaIono = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:SigmaIono")==0) {
		options->useSigmaIono = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:StepDetector")==0) {
		options->stepdetector = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--filter:StepDetector")==0) {
		options->stepdetector = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:prefitOutliers:Abs")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<0) return -2;
		if (auxd==0.) {
			options->prefitOutlierDetectorAbs = 0;
		} else {
			options->prefitOutlierDetectorAbsThreshold=auxd;
			options->prefitOutlierDetectorAbs = 1;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--filter:prefitOutliers:Abs")==0) {
		options->prefitOutlierDetectorAbs = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-filter:prefitOutliers:Median")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<0) return -2;
		if (auxd==0.) {
			options->prefitOutlierDetectorMedian = 0;
		} else {
			options->prefitOutlierDetectorMedianThreshold=auxd;
			options->prefitOutlierDetectorMedian = 1;
		}
		return 2;
	} else if (strcasecmp(argv[0],"--filter:prefitOutliers:Median")==0) {
		options->prefitOutlierDetectorMedian = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:minlat")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->minLatplots = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:maxlat")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->maxLatplots = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:minlon")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->minLonplots = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:maxlon")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->maxLonplots = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:plotarea")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
		auxd = atof(argv[1]);
		options->minLonplots = auxd;
		auxd = atof(argv[2]);
		options->maxLonplots = auxd;
		auxd = atof(argv[3]);
		options->minLatplots = auxd;
		auxd = atof(argv[4]);
		options->maxLatplots = auxd;
		return 5;
	} else if (strcasecmp(argv[0],"-sbasplots:recheight")==0) {
		if (argv[1]==NULL) return -3;
		options->SBASPlotsRecHeight=atof(argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:VAL")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->VerAlarmLimit = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:HAL")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->HorAlarmLimit = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:AvailStep")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->AvailabilityPlotStep = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:availtimestep")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		options->AvailPlotTimeStep = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:IonoStep")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->IonoPlotStep = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:ionotimestep")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		options->IonoPlotTimeStep = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:windowsize")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		options->ContRiskWindowSize = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:windowsizemar")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		options->ContRiskWindowSizeMar = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:hourlymaps")==0) {
		options->SBASHourlyMaps = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:hourlymaps")==0) {
		options->SBASHourlyMaps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-output:sbasavailplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasAvailplotsFile,argv[1]);
		options->NoAvailabilityPlot = 0;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbasriskmarplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasRiskMarplotsFile,argv[1]);
		options->NoContRiskMarPlot = 0;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbasriskplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasRiskplotsFile,argv[1]);
		options->NoContRiskPlot = 0;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbasriskdisc")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasDiscontinuityFile,argv[1]);
		options->NoContRiskPlot = 0;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbasionoplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasIonoplotsFile,argv[1]);
		sopt->NoIonoPlot = 0;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbashdopplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasHDOPplotsFile,argv[1]);
		options->HDOPPlot = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbaspdopplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasPDOPplotsFile,argv[1]);
		options->HDOPPlot = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbasgdopplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasGDOPplotsFile,argv[1]);
		options->GDOPPlot = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-output:sbascombdopplots")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_INPUT_LINE-1) return -4;
		strcpy(sopt->sbasCombDOPplotsFile,argv[1]);
		options->CombinedDOPPlot = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:noAvailPlot")==0) {
		options->NoAvailabilityPlot = 1;
		options->NoContRiskPlot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:noAvailPlot")==0) {
		options->NoAvailabilityPlot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:noRiskPlot")==0) {
		options->NoContRiskPlot = 1;
		if (options->NoContRiskMarPlot==1) {
			options->ComputeRiskPlots=0;
		}
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:noRiskPlot")==0) {
		options->NoContRiskPlot = 0;
		options->ComputeRiskPlots=1;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:noRiskMarPlot")==0) {
		options->NoContRiskMarPlot = 1;
		if (options->NoContRiskPlot==1) {
			options->ComputeRiskPlots=0;
		}
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:noRiskMarPlot")==0) {
		options->NoContRiskMarPlot = 0;
		options->ComputeRiskPlots=1;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:noIonoPlot")==0) {
		sopt->NoIonoPlot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:noIonoPlot")==0) {
		sopt->NoIonoPlot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:noIonoModel")==0) {
		sopt->ionoModel = NoIonoModel;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:hdopPlot")==0) {
		options->HDOPPlot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:hdopPlot")==0) {
		options->HDOPPlot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:pdopPlot")==0) {
		options->PDOPPlot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:pdopPlot")==0) {
		options->PDOPPlot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:gdopPlot")==0) {
		options->GDOPPlot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:gdopPlot")==0) {
		options->GDOPPlot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:combdopPlot")==0) {
		options->CombinedDOPPlot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:combdopPlot")==0) {
		options->CombinedDOPPlot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:doppercentile")==0) {
		options->DOPPercentile = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:doppercentile")==0) {
		options->DOPPercentile = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:percentile")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->percentile = auxd;
		options->DOPPercentile = 1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbasplots:inclusionarea")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if (argv[l+1]==NULL||argv[l+2]==NULL||argv[l+3]==NULL) return -3;
			for(i=0;i<4;i++) {
				auxdarray[i]=atof(argv[l+i]);
			}
			//Check if area already exist (this is because this function is called several times,
			//so we need to avoid loading the same ranges multiple times
			for(i=0;i<options->NumSBASPlotsInclusionArea;i++) {
				if (options->SBASPlotsInclusionAreaDelimeters[i][0]==auxdarray[0] && options->SBASPlotsInclusionAreaDelimeters[i][1]==auxdarray[1] &&
						options->SBASPlotsInclusionAreaDelimeters[i][2]==auxdarray[2] && options->SBASPlotsInclusionAreaDelimeters[i][3]==auxdarray[3]) {
					//Area found
					break;
				}
			}
			if (i==options->NumSBASPlotsInclusionArea) {
				options->SBASPlotsInclusionAreaDelimeters=realloc(options->SBASPlotsInclusionAreaDelimeters,sizeof(double*)*(options->NumSBASPlotsInclusionArea+1));
				options->SBASPlotsInclusionAreaDelimeters[options->NumSBASPlotsInclusionArea]=malloc(sizeof(double)*4);
				for(i=0;i<4;i++) {
					options->SBASPlotsInclusionAreaDelimeters[options->NumSBASPlotsInclusionArea][i]=auxdarray[i];
				}
				options->NumSBASPlotsInclusionArea++;
			}
			l+=4;
		}
		return l;
	} else if (strcasecmp(argv[0],"-sbasplots:exclusionarea")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL||argv[4]==NULL) return -3;
		if(checkIfNextParameter(argv[1])==1) return -3;
		l=1;
		while (argv[l]!=NULL) {
			if(checkIfNextParameter(argv[l])==1) break;
			if (argv[l+1]==NULL||argv[l+2]==NULL||argv[l+3]==NULL) return -3;
			for(i=0;i<4;i++) {
				auxdarray[i]=atof(argv[l+i]);
			}
			//Check if area already exist (this is because this function is called several times,
			//so we need to avoid loading the same ranges multiple times
			for(i=0;i<options->NumSBASPlotsExclusionArea;i++) {
				if (options->SBASPlotsExclusionAreaDelimeters[i][0]==auxdarray[0] && options->SBASPlotsExclusionAreaDelimeters[i][1]==auxdarray[1] &&
						options->SBASPlotsExclusionAreaDelimeters[i][2]==auxdarray[2] && options->SBASPlotsExclusionAreaDelimeters[i][3]==auxdarray[3]) {
					//Area found
					break;
				}
			}
			if (i==options->NumSBASPlotsExclusionArea) {
				options->SBASPlotsExclusionAreaDelimeters=realloc(options->SBASPlotsExclusionAreaDelimeters,sizeof(double*)*(options->NumSBASPlotsExclusionArea+1));
				options->SBASPlotsExclusionAreaDelimeters[options->NumSBASPlotsExclusionArea]=malloc(sizeof(double)*4);
				for(i=0;i<4;i++) {
					options->SBASPlotsExclusionAreaDelimeters[options->NumSBASPlotsExclusionArea][i]=auxdarray[i];
				}
				options->NumSBASPlotsExclusionArea++;
			}
			l+=4;
		}
		return l;
	} else if (strcasecmp(argv[0],"-sbasplots:mingeoelev")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<0.) return -2;
		options->SBASPlotsMinGEOElev = (float)(auxd*d2r);
		return 2;
	} else if (strcasecmp(argv[0],"--sbasplots:mingeoelev")==0) {
		options->SBASPlotsMinGEOElev = -99.99f;
		return 1;
	} else if (strcasecmp(argv[0],"-sbasplots:usegeosat")==0) {
		options->UseGEOsatsAvailsMaps = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbasplots:usegeosat")==0) {
		options->UseGEOsatsAvailsMaps = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-summary:formalerrorhor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThresholdHor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:formalerrorver")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThresholdVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:formalerror3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThreshold3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:poserrorhor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->positionErrorThresholdHor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:poserrorver")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->positionErrorThresholdVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:poserror3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->positionErrorThreshold3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorhor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThresholdHor = auxd;
		options->positionErrorThresholdHor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorver")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThresholdVer = auxd;
		options->positionErrorThresholdVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:error3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThreshold3D = auxd;
		options->positionErrorThreshold3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:formalerrorperiodhor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErrHor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorhv3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0) return -2;
		options->formalErrorThresholdHor = auxd;
		options->positionErrorThresholdHor = auxd;
		options->formalErrorThreshold3D = auxd;
		options->positionErrorThreshold3D = auxd;
		options->formalErrorThresholdVer = auxd;
		options->positionErrorThresholdVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:formalerrorperiodver")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErrVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:formalerrorperiod3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErr3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:poserrorperiodhor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedPosErrHor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:poserrorperiodver")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedPosErrVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:poserrorperiod3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedPosErr3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorperiodhor")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErrHor = auxd;
		options->minTimeConvergedPosErrHor = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorperiodver")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErrVer = auxd;
		options->minTimeConvergedPosErrVer = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorperiod3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErr3D = auxd;
		options->minTimeConvergedPosErr3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-summary:errorperiodhv3d")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		if (auxd<=0.) return -2;
		options->minTimeConvergedFormalErrHor = auxd;
		options->minTimeConvergedPosErrHor = auxd;
		options->minTimeConvergedFormalErrVer = auxd;
		options->minTimeConvergedPosErrVer = auxd;
		options->minTimeConvergedFormalErr3D = auxd;
		options->minTimeConvergedPosErr3D = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbassummary:VAL")==0||strcasecmp(argv[0],"-summary:VAL")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->VerAlarmLimit = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbassummary:HAL")==0||strcasecmp(argv[0],"-summary:HAL")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->HorAlarmLimit = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbassummary:percentile")==0 || strcasecmp(argv[0],"-summary:percentile")==0) {
		if (argv[1]==NULL) return -3;
		auxd = atof(argv[1]);
		options->percentile = auxd;
		return 2;
	} else if (strcasecmp(argv[0],"-sbassummary:windowsize")==0||strcasecmp(argv[0],"-summary:windowsize")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		options->ContRiskWindowSize = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbassummary:windowsizemar")==0||strcasecmp(argv[0],"-summary:windowsizemar")==0) {
		if (argv[1]==NULL) return -3;
		aux1 = atoi(argv[1]);
		options->ContRiskWindowSizeMar = aux1;
		return 2;
	} else if (strcasecmp(argv[0],"-sbassummary:waitfordaystart")==0||strcasecmp(argv[0],"-summary:waitfordaystart")==0) {
		options->waitForNextDay = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--sbassummary:waitfordaystart")==0||strcasecmp(argv[0],"--summary:waitfordaystart")==0) {
		options->waitForNextDay = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-sbassummary:starttime")==0 ||strcasecmp(argv[0],"-summary:starttime")==0 ) {
		if (argv[1]==NULL||argv[2]==NULL) return -3;
		len1=(int)strlen(argv[1]);
		len2=(int)strlen(argv[2]);
		//Check date format
		if (strchr(argv[2],':')!=NULL) {
			//Time has ":" symbol. 
			if (len2!=8) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			//Check that input date has correct length
			if (strchr(argv[1],'/')!=NULL) {
				if (len1!=10) return -2;
			} else {
				if (len1!=8) return -2;
			}
			getstr(auxstr,argv[1],len1,0,4);
			aux1 = atoi(auxstr);
			if (aux1<1970) return -2;
			tm.tm_year=aux1-1900;
			if (strchr(argv[1],'/')!=NULL) {
				//Date has "/" symbol. It is YYYY/MM/DD HH:MM:SS format
				getstr(auxstr,argv[1],len1,5,2);
			} else {
				getstr(auxstr,argv[1],len1,4,2);
			}
			aux1=atoi(auxstr);
			if (aux1<1|| aux1>12) return -2;
			tm.tm_mon=aux1-1;
			if (strchr(argv[1],'/')!=NULL) {
				//Date has "/" symbol. It is YYYY/MM/DD HH:MM:SS format
				getstr(auxstr,argv[1],len1,8,2);
			} else {
				getstr(auxstr,argv[1],len1,6,2);
			}
			aux1=atoi(auxstr);
			if (aux1<1|| aux1>31) return -2;
			tm.tm_mday = aux1;
			//Get hour in HH:MM:SS format
			getstr(auxstr,argv[2],len2,0,2);
			aux1=atoi(auxstr);
			if (aux1<0|| aux1>24) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			tm.tm_hour = aux1;
			getstr(auxstr,argv[2],len2,3,2);
			aux1=atoi(auxstr);
			if (aux1<0|| aux1>60) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			tm.tm_min  = aux1;
			getstr(auxstr,argv[2],len2,6,2);
			aux1=atoi(auxstr);
			if (aux1<0|| aux1>60) {
				strcpy (argv[1],argv[2]); // This is for a proper error control
				return -2;
			}
			tm.tm_sec  = aux1;
			options->firstEpochSummary.MJDN=MJDN(&tm);
			options->firstEpochSummary.SoD=(double)(tm.tm_hour*3600 + tm.tm_min*60 + tm.tm_sec);
			if(options->firstEpochSummary.SoD>=86400.) {
				options->firstEpochSummary.MJDN--;
				options->firstEpochSummary.SoD-=86400.;
			}
		} else {
			if (strchr(argv[1],'/')!=NULL) {
				//Time is in Year/DoY SoD format
				aux1=len1;
				if (aux1<6 || aux1>8) return -2;
				getstr(auxstr,argv[1],len1,0,4);
				aux1=atoi(auxstr);
				if(aux1<1970) return -2;
				aux2=atoi(&argv[1][5]);
				if(aux2<1||aux2>366) return -2;
				auxd=atof(argv[2]);
				if(auxd<0.||auxd>86400.) {
					strcpy (argv[1],argv[2]); // This is for a proper error control
					return -2;
				}
				options->firstEpochSummary.MJDN=(int)yeardoy2MJDN(aux1,aux2,auxd);
				options->firstEpochSummary.SoD=auxd;
				if(options->EndEpoch.SoD>=86400.) {
					options->firstEpochSummary.MJDN--;
					options->firstEpochSummary.SoD-=86400.;
				}
			} else {
				//Time is in GPSWeek SoW format
				aux1=atoi(argv[1]);
				if(aux1<1) return -2;
				auxd=atof(argv[2]);
				if(auxd<0.||auxd>604800.) {
					strcpy (argv[1],argv[2]); // This is for a proper error control
					return -2;
				}
				options->firstEpochSummary=gpsws2ttime(aux1,auxd);
			}
		}
		return 3;
	} else if (strcasecmp(argv[0],"-sbassummary:stationnetworkname")==0||strcasecmp(argv[0],"-summary:stationnetworkname")==0) {
		if (argv[1]==NULL) return -3;
		if(strlen(argv[1])>MAX_STATION_NAME-1) return -5;
		strcpy(options->StationNetworkName,argv[1]);
		return 2;
	} else if (strcasecmp(argv[0],"-dateconv:calendar")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL) return -3;
		if (argv[4]==NULL||argv[5]==NULL||argv[6]==NULL) return -3;
		aux1=atoi(argv[1]);
		aux2=atoi(argv[2]);
		if(aux2<1||aux2>12) {
			strcpy (argv[1],argv[2]); // This is for a proper error control
			return -2;
		}
		aux3=atoi(argv[3]);
		if(aux3<1||aux3>31) {
			strcpy (argv[1],argv[3]); // This is for a proper error control
			return -2;
		}
		aux4=atoi(argv[4]);
		if(aux4<0||aux4>23) {
			strcpy (argv[1],argv[4]); // This is for a proper error control
			return -2;
		}
		aux5=atoi(argv[5]);
		if(aux5<0||aux5>59) {
			strcpy (argv[1],argv[5]); // This is for a proper error control
			return -2;
		}
		auxd=atof(argv[6]);
		if(auxd<0.||aux2>=60.) {
			strcpy (argv[1],argv[6]); // This is for a proper error control
			return -2;
		}
		options->dateConversionMode=DateConversionModeCalendar;
		options->dateConversionYear=aux1;
		options->dateConversionMonth=aux2;
		options->dateConversionDay=aux3;
		options->dateConversionHour=aux4;
		options->dateConversionMinute=aux5;
		options->dateConversionSeconds=auxd;
		return 7;
	} else if (strcasecmp(argv[0],"-dateconv:doy")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL) return -3;
		aux1=atoi(argv[1]);
		aux2=atoi(argv[2]);
		if(aux2<1||aux2>366) {
			strcpy (argv[1],argv[2]); // This is for a proper error control
			return -2;
		} 
		auxd=atof(argv[3]);
		if(auxd<0.||auxd>86400.) {
			strcpy (argv[1],argv[3]); // This is for a proper error control
			return -2;
		}
		options->dateConversionMode=DateConversionModeDoY;
		options->dateConversionYear=aux1;
		options->dateConversionDoY=aux2;
		options->dateConversionSoD=auxd;
		return 4;
	} else if (strcasecmp(argv[0],"-dateconv:gpsweek")==0) {
		if (argv[1]==NULL||argv[2]==NULL) return -3;
		aux1=atoi(argv[1]);
		if(aux1<0) return -2;
		auxd=atof(argv[2]);
		if(auxd<0.||auxd>604800.) {
			strcpy (argv[1],argv[2]); // This is for a proper error control
			return -2;
		}
		options->dateConversionMode=DateConversionModeGPSWeek;
		options->dateConversionGPSWeek=aux1;
		options->dateConversionSoW=auxd;
		return 3;
	} else if (strcasecmp(argv[0],"-dateconv:mjdn")==0) {
		if (argv[1]==NULL||argv[2]==NULL) return -3;
		aux1=atoi(argv[1]);
		auxd=atof(argv[2]);
		if(auxd<0.||auxd>86400.) {
			strcpy (argv[1],argv[2]); // This is for a proper error control
			return -2;
		}
		options->dateConversionMode=DateConversionModeMJDN;
		options->dateConversionMJDN=aux1;
		options->dateConversionSoD=auxd;
		return 3;
	} else if (strcasecmp(argv[0],"-coordconv:cartesian")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL) return -3;
		auxd=atof(argv[1]);
		auxd2=atof(argv[2]);
		auxd3=atof(argv[3]);
		options->coordConversionMode=CoordConversionModeXYZ;
		options->coordConversionX=auxd;
		options->coordConversionY=auxd2;
		options->coordConversionZ=auxd3;
		return 4;
	} else if (strcasecmp(argv[0],"-coordconv:geodetic")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL) return -3;
		auxd=atof(argv[1]);
		if(auxd<-180.||auxd>180.) return -2;
		auxd2=atof(argv[2]);
		if(auxd2<-90.||auxd2>90.) {
			strcpy (argv[1],argv[2]); // This is for a proper error control
			return -2;
		}
		auxd3=atof(argv[3]);
		if(auxd3<-10000) {
			strcpy (argv[1],argv[3]); // This is for a proper error control
			return -2;
		}
		options->coordConversionMode=CoordConversionModeGeod;
		options->coordConversionLon=auxd;
		options->coordConversionLat=auxd2;
		options->coordConversionHgt=auxd3;
		return 4;
	} else if (strcasecmp(argv[0],"-coordconv:spherical")==0) {
		if (argv[1]==NULL||argv[2]==NULL||argv[3]==NULL) return -3;
		auxd=atof(argv[1]);
		if(auxd<-180.||auxd>180.) return -2;
		auxd2=atof(argv[2]);
		if(auxd2<-90.||auxd2>90.) {
			strcpy (argv[1],argv[2]); // This is for a proper error control
			return -2;
		}
		auxd3=atof(argv[3]);
		if(auxd3<0.) {
			strcpy (argv[1],argv[3]); // This is for a proper error control
			return -2;
		}
		options->coordConversionMode=CoordConversionModeSph;
		options->coordConversionLon=auxd;
		options->coordConversionLat=auxd2;
		options->coordConversionRadius=auxd3;
		return 4;
	} else if (strcasecmp(argv[0],"-print:info")==0) {
		options->printInfo = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:info")==0) {
		options->printInfo = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:model")==0) {
		options->printModel = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:model")==0) {
		options->printModel = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:prefit")==0) {
		options->printPrefit = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:prefit")==0) {
		options->printPrefit = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:prefit:unsel")==0) {
		options->printPrefitUnsel = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:prefit:unsel")==0) {
		options->printPrefitUnsel = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:postfit")==0) {
		options->printPostfit = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:postfit")==0) {
		options->printPostfit = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:filter")==0) {
		options->printFilterSolution = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:filter")==0) {
		options->printFilterSolution = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:cycleslips")==0 || strcasecmp(argv[0],"-print:cs")==0) {
		options->printCycleslips = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:cycleslips")==0 || strcasecmp(argv[0],"--print:cs")==0) {
		options->printCycleslips = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sfcsdata")==0) {
		options->printSFdata=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sfcsdata")==0) {
		options->printSFdata=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:mwcsdata")==0) {
		options->printMWdata=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:mwcsdata")==0) {
		options->printMWdata=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:licsdata")==0) {
		options->printLIdata=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:licsdata")==0) {
		options->printLIdata=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:igfcsdata")==0) {
		options->printIGFdata=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:igfcsdata")==0) {
		options->printIGFdata=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:allcsdata")==0) {
		options->printSFdata=1;
		options->printLIdata=1;
		options->printMWdata=1;
		options->printIGFdata=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:allcsdata")==0) {
		options->printSFdata=0;
		options->printLIdata=0;
		options->printMWdata=0;
		options->printIGFdata=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:satellites")==0 || strcasecmp(argv[0],"-print:epochsat")==0 || strcasecmp(argv[0],"-print:sat")==0) {
		options->printSatellites = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:satellites")==0 || strcasecmp(argv[0],"--print:epochsat")==0 || strcasecmp(argv[0],"--print:sat")==0) {
		options->printSatellites = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:input")==0) {
		options->printInput = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:input")==0) {
		options->printInput = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:meas")==0) {
		options->printMeas = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:meas")==0) {
		options->printMeas = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:meas:snr")==0) {
		options->printMeasSNR = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:meas:snr")==0) {
		options->printMeasSNR = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:meas:lli")==0) {
		options->printMeasLLI = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:meas:lli")==0) {
		options->printMeasLLI = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:meas:doppler")==0) {
		options->printMeasDoppler = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:meas:doppler")==0) {
		options->printMeasDoppler = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:meas:select")==0||strcasecmp(argv[0],"-print:meas:selectlist")==0) {
		if (argv[1]==NULL) return -3;
		options->printMeas = 1;
		if (strcasecmp(argv[0],"-print:meas:select")==0) {
			if (argv[1][0]>=65||argv[1][0]=='+'||argv[1][0]=='-'||argv[1][0]=='0') { //65 is ASCII character 'A'
				i=1;
				while(argv[i]!=NULL) {
					if (checkIfNextParameter(argv[i])==1) break; 
					if(strlen(argv[i])>=(MAX_INPUT_LINE-1)) return -4;
					sopt->printMeastext=realloc(sopt->printMeastext,sizeof(char *)*(sopt->numprintMeastext+i));
					sopt->printMeastext[sopt->numprintMeastext+i-1]=NULL;
					sopt->printMeastext[sopt->numprintMeastext+i-1]=malloc(sizeof(char)*MAX_INPUT_LINE);
					strcpy(sopt->printMeastext[sopt->numprintMeastext+i-1],argv[i]);
					i++;
				}
				sopt->numprintMeastext+=i-1;
				return 1+i-1;
			} else {
				//Not a valid value for number of measurements of meas type
				return -2;
			}
		} else { //strcasecmp(argv[0],"-print:meas:selectlist")==0
			if(strlen(argv[1])>=(MAX_INPUT_LINE-1)) return -4;
			p=strchr(argv[1],',');
			aux1=0;
			while(p!=NULL) {
				aux1++;
				p++;
				p=strchr(p,',');
			}
			aux1++;
			p2=argv[1];
			p=strchr(p2,',');
			if (p!=NULL) *p='\0';
			sopt->printMeastext=realloc(sopt->printMeastext,sizeof(char *)*(sopt->numprintMeastext+aux1));
			for(i=0;i<aux1;i++) {
				sopt->printMeastext[sopt->numprintMeastext+i]=NULL;
				sopt->printMeastext[sopt->numprintMeastext+i]=malloc(sizeof(char)*MAX_INPUT_LINE);
				strcpy(sopt->printMeastext[sopt->numprintMeastext+i],p2);
				if (i<(aux1-1)) {
					*p=',';
					p2=p+1;
					p=strchr(p2,',');
					if (p!=NULL) *p='\0';
				}
			}
			sopt->numprintMeastext+=aux1;
			return 2;
		}
	} else if (strcasecmp(argv[0],"-print:output")==0) {
		options->printOutput = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:output")==0) {
		options->printOutput = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:satsel")==0) {
		options->printSatSel = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:satsel")==0) {
		options->printSatSel = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:satdiff")==0) {
		options->printSatDiff = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:satdiff")==0) {
		options->printSatDiff = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:satstat")==0) {
		options->printSatStat = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:satstat")==0) {
		options->printSatStat = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:satstattot")==0) {
		options->printSatStatTot = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:satstattot")==0) {
		options->printSatStatTot = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:satpvt")==0) {
		options->printSatPvt = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:satpvt")==0) {
		options->printSatPvt = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasout")==0) {
		options->printSBASOUT = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasout")==0) {
		options->printSBASOUT = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbascor")==0 || strcasecmp(argv[0],"-print:sbascorr")==0) {
		options->printSBASCORR = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbascor")==0 || strcasecmp(argv[0],"--print:sbascorr")==0) {
		options->printSBASCORR = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasvar")==0) {
		options->printSBASVAR = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasvar")==0) {
		options->printSBASVAR = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasiono")==0) {
		options->printSBASIONO = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasiono")==0) {
		options->printSBASIONO = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasunsel")==0) {
		options->printSBASUNSEL = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasunsel")==0) {
		options->printSBASUNSEL = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasunused")==0) {
		options->printSBASUNUSED = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasunused")==0) {
		options->printSBASUNUSED = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasdfmccor")==0 || strcasecmp(argv[0],"-print:sbasdfmccorr")==0) {
		options->printSBASDFMCCORR = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasdfmccor")==0 || strcasecmp(argv[0],"--print:sbasdfmccorr")==0) {
		options->printSBASDFMCCORR = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasdfmcvar")==0 ) {
		options->printSBASDFMCVAR = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasdfmcvar")==0 ) {
		options->printSBASDFMCVAR = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sbasdfmcunsel")==0) {
		options->printSBASDFMCUNSEL = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:sbasdfmcunsel")==0) {
		options->printSBASDFMCUNSEL = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:usererror")==0) {
		options->printUserError = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:usererror")==0) {
		options->printUserError = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:dgnss")==0) {
		options->printDGNSS = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:dgnss")==0) {
		options->printDGNSS = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:dgnssunused")==0) {
		options->printSBASUNUSED = 1;
		options->printDGNSSUNUSED = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:dgnssunused")==0) {
		options->printSBASUNUSED = 0;
		options->printDGNSSUNUSED = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:summary")==0) {
		options->printSummary=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:summary")==0) {
		options->printSummary=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:progress")==0) {
		printProgress=1;
		sopt->UserSetPrintProgress=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:progress")==0) {
		printProgress=0;
		sopt->UserSetPrintProgress=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:progressalways")==0||strcasecmp(argv[0],"-print:pa")==0) {
		printProgress=1;
		sopt->UserSetPrintProgress=1;
		sopt->UserForcedPrintProgress=1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:progressalways")==0||strcasecmp(argv[0],"--print:pa")==0) {
		sopt->UserForcedPrintProgress=0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:sumonly")==0) {
		options->printInfo = 0;
		options->printInput = 0;
		options->printMeas = 0;
		options->printCycleslips = 0;
		options->printSFdata = 0;
		options->printMWdata = 0;
		options->printLIdata = 0;
		options->printIGFdata = 0;
		options->printModel = 0;
		options->printSatellites = 0;
		options->printSatSel = 0;
		options->printPrefit = 0;
		options->printFilterSolution = 0;
		options->printPostfit = 0;
		options->printOutput = 0;
		options->printSatDiff = 0;
		options->printSatStat = 0;
		options->printSatStatTot = 0;
		options->printSatPvt = 0;
		options->printSBASOUT = 0;
		options->printSBASCORR = 0;
		options->printSBASVAR = 0;
		options->printSBASIONO = 0;
		options->printSBASUNSEL = 0;
		options->printSBASUNUSED = 0;
		options->printSBASDFMCCORR = 0;
		options->printSBASDFMCVAR = 0;
		options->printSBASDFMCUNSEL = 0;
		options->printUserError = 0;
		options->printDGNSS = 0;
		options->printSummary = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-print:guiprogress")==0) {
		//Note: This is a hidden parameter passed by the GUI
		//It is to print only the progress when the integer part of the
		//percentage completed changes, and the end of line has a '\n',
		//so the GUI handles less messages and can read line by line
		printProgress=1;
		options->ProgressEndCharac='\n';
		sopt->UserSetPrintProgress=1;
		return 1;
	} else if (strcasecmp(argv[0],"-print:all")==0) {
		options->printInfo = 1;
		options->printInput = 1;
		options->printMeas = 1;
		options->printCycleslips = 1;
		options->printSFdata = 1;
		options->printMWdata = 1;
		options->printLIdata = 1;
		options->printIGFdata = 1;
		options->printModel = 1;
		options->printSatellites = 1;
		options->printSatSel = 1;
		options->printPrefit = 1;
		options->printFilterSolution = 1;
		options->printPostfit = 1;
		options->printOutput = 1;
		options->printSatDiff = 1;
		options->printSatStat = 1;
		options->printSatStatTot = 1;
		options->printSatPvt = 1;
		options->printSBASOUT = 1;
		options->printSBASCORR = 1;
		options->printSBASVAR = 1;
		options->printSBASIONO = 1;
		options->printSBASUNSEL = 1;
		options->printSBASUNUSED = 1;
		options->printSBASDFMCCORR = 1;
		options->printSBASDFMCVAR = 1;
		options->printSBASDFMCUNSEL = 1;
		options->printUserError = 1;
		options->printDGNSS = 1;
		options->printSummary = 1;
		return 1;
	} else if (strcasecmp(argv[0],"-print:none")==0||strcasecmp(argv[0],"--print:none")==0) {
		options->printInfo = 0;
		options->printInput = 0;
		options->printMeas = 0;
		options->printCycleslips = 0;
		options->printSFdata = 0;
		options->printMWdata = 0;
		options->printLIdata = 0;
		options->printIGFdata = 0;
		options->printModel = 0;
		options->printSatellites = 0;
		options->printSatSel = 0;
		options->printPrefit = 0;
		options->printFilterSolution = 0;
		options->printPostfit = 0;
		options->printOutput = 0;
		options->printSatDiff = 0;
		options->printSatStat = 0;
		options->printSatStatTot = 0;
		options->printSatPvt = 0;
		options->printSBASOUT = 0;
		options->printSBASCORR = 0;
		options->printSBASVAR = 0;
		options->printSBASIONO = 0;
		options->printSBASUNSEL = 0;
		options->printSBASUNUSED = 0;
		options->printSBASDFMCCORR = 0;
		options->printSBASDFMCVAR = 0;
		options->printSBASDFMCUNSEL = 0;
		options->printUserError = 0;
		options->printDGNSS = 0;
		options->printSummary = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:v5format")==0) {
		options->printV5format = 1;
		options->printMeasSNR=0;
		options->printMeasDoppler=0;
		options->printMeasLLI=0;
		options->printPrefitUnsel = 1;
		return 1;
	} else if (strcasecmp(argv[0],"--print:v5format")==0) {
		options->printV5format = 0;
		return 1;
	} else if (strcasecmp(argv[0],"-print:clkns")==0) {
		options->ClktimeFactor=1.0E9/c0; //conversion factor from metres to nanoseconds
		return 1;
	} else if (strcasecmp(argv[0],"--print:clkns")==0) {
		options->ClktimeFactor=1.; //Neutral conversion factor to print in metres
		return 1;
	} else if (strcasecmp(argv[0],"-numthreads")==0) {
		#if defined _OPENMP
			if (argv[1]==NULL) return -3;
			omp_set_dynamic(0);     // Explicitly disable dynamic teams
			aux1=atoi(argv[1]);
			if (aux1<=0 ) {
				return -2;
			} else if (aux1>omp_get_num_procs()) {
				printf("ERROR Maximum number of threads is the number of CPU cores (%d), but user set %d threads\n",omp_get_num_procs(),aux1);
				exit(-1); 
			}
			omp_set_num_threads(aux1);
			options->numthreads=aux1;
			return 2;
		#else
			//Just ignore the option in non multi-thread version
			if (argv[1]==NULL) return -3;
			return 2;
		#endif
	}

	return -1;
}

/*****************************************************************************
 * Name        : parseAllOptions
 * Description : Parse all options from a vector of strings into the options or 
 *               support options
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TSupportOptions  *sopt          O  N/A  TSupportOptions structure
 * TOptions  *options              O  N/A  TOptions structure
 * int  argc                       I  N/A  Number of strings in argv[]
 * char  *argv[]                   I  N/A  Vector of strings to be parsed
 * Returned value (int)            O  N/A  Status of the function
 *                                         0 => Required program stop 
 *                                              (error, showHelp or showExamples)                                        
 *                                         1 => Normal options lecture
 *****************************************************************************/
int parseAllOptions (TSupportOptions *sopt,TOptions *options, int argc, char *argv[]) {
	char	**ptr;
	int		i;
	int		res;

	i = 1;
	if (argc==1) {
		showHelp();
		return 0;
	}

	while (i<argc) {
		ptr = &argv[i];
		res = parseOption(sopt,options,ptr);

		if (res==-5) { 	// Input name too long (in order to avoid buffer overflow)
			sprintf(messagestr,"One of the parameters is larger than %d characters long. Use shorter paths or filenames.",MAX_STATION_NAME-1);
			printError(messagestr,options);
		} else if (res==-4) { 	// Input string too long (in order to avoid buffer overflow)
			sprintf(messagestr,"One of the parameters is larger than %d characters long. Use shorter paths or filenames.",MAX_INPUT_LINE-1);
			printError(messagestr,options);
			return 0;
		} else if (res==-3) { // Missing parameters
			sprintf(messagestr,"'%s' requires more parameters. Use '-help' for a set of valid options.",*ptr);
			printError(messagestr,options);
			return 0;
		} else if (res==-2) { // Value not valid
			sprintf(messagestr,"'%s' is not a valid value for '%s'. Use '-help' for a set of valid options.",ptr[1],*ptr);
			printError(messagestr,options);
			return 0;
		} else if (res==-1) { // Parameter unknown
			sprintf(messagestr,"'%s' option not recognised. Use '-help' for a set of valid options.",*ptr);
			printError(messagestr,options);
			return 0;
		} else if (res==0) { // Show help/examples/config/messages
			return 0;
		}
		// Increment by the number of parameters readed
		i+=res; 
	}
	return 1;
}

/*****************************************************************************
 * Name        : removeExtension
 * Description : Removes the filename extension
 * Parameters  :
 * Name                           |Da|Unit|Description
 * char* mystr                     I  N/A  String with the filename with extension
 * char *retstr                    O  N/A  String with the filename without extension
 *****************************************************************************/
void removeExtension (char* mystr,char *retstr) {
	char 	*lastdot;
	int		len, lenmystr;

	if ( mystr == NULL ) {
		retstr = NULL;
		return;
	}

	lastdot = strrchr(mystr, '.');
	lenmystr = strlen(mystr);

	if ( lastdot != NULL ) {
		if ( lenmystr == 1 ) {
			strcpy(retstr, mystr);
		} else {
			len = lenmystr - strlen(lastdot);
			//strncpy replaced by memcpy to avoid -Wstringop-overflow warning in GCC 8.2
			//strncpy(retstr, mystr, len);
			memcpy(retstr,mystr,sizeof(char)*len);
			retstr[len] = '\0';
		}
	} else {
		strcpy(retstr, mystr);
	}

	return;
}

/*****************************************************************************
 * Name        : getRTCMpath
 * Description : Gets the input binary RTCM path and returns the output path
 *               for the RINEX file with the first 4 characters according to
 *               the filename standard
 * Parameters  :
 * Name                           |Da|Unit|Description
 * char* mystr                     I  N/A  String with the input binary RTCM
 * char *retstr                    O  N/A  String with the output RINEX file
 *****************************************************************************/
void getRTCMpath (char* mystr,char *retstr) {
	char	*lastslash;
	int		len, lenmystr;

	// Get the path
	if ( mystr == NULL ) {
		retstr = NULL;
		return;
	}

	#if defined (__WIN32__)
		lastslash = strrchr(mystr, '\\');
	#elif defined (__CYGWIN__)
		lastslash = strrchr(mystr, '/');
		// In cygwin, we may have linux or windows pathes
		if ( lastslash == NULL ) lastslash = strrchr(mystr, '\\');
	#else
		lastslash = strrchr(mystr, '/');
	#endif

	lenmystr = strlen(mystr);
	if ( lastslash != NULL ) {
		len = lenmystr - strlen(lastslash) + 5;
		if ( len > lenmystr ) len = lenmystr;
	} else {
		if ( lenmystr < 4 ) len = lenmystr;
		else len = 4;
	}
	strncpy(retstr, mystr, len);
	retstr[len] = '\0';

	return;
}

/*****************************************************************************
 * Name        : processOptions
 * Description : To be called after all the options have been parsed. Read 
 *               options from TSupportOptions and translates it to TOptions
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TSupportOptions  *sopt          I  N/A  TSupportOptions structure
 * TOptions  *options              IO N/A  TOptions structure
 * Returned value (int)            O  N/A  Status of the function
 *                                         0 => Some problems with the options chosen
 *                                              (compatibility or missing critical
 *                                              options)
 *                                         1 => Processing properly done
 *                                         2 => DGNSS file conversion done
 *****************************************************************************/
int processOptions (TSupportOptions *sopt, TOptions *options) {
	int							preciseProductsAvailable;
	int							broadcastProductsAvailable;
	int 						i,j,k,l;
	int							nProd;
	int 						RTCMversion;
	int							sources;
	int							r1,r2;
	int							aux1,aux2,aux3;
	int							strpos;
	int 						ret, doy;
	int							len;
	int							GNSSused[MAX_GNSS];
	int							freqUsed[MAX_FREQUENCIES_PER_GNSS];
	double						auxd;
	char						auxpathRTCMpointer[MAX_INPUT_LINE];
	char						pathRTCMpointer[MAX_INPUT_LINE];
	char   						*filepointer;
	char						*p,*p2;
	char						auxstr[1000],auxstr2[1000],auxstr3[1000];
	char 						*fileASCIIcorrections = NULL;
	char 						*fileASCIIantenna = NULL;
	char 						fileRINEXpointer[MAX_INPUT_LINE];
	char 						strDoy[4];
	char 						strYear[3];
	FILE 						*fdRTCM = NULL;
	FILE 						*fdRTCM2 = NULL;
	FILE 						*fdRTCM3 = NULL;
	struct stat 				stats_stdin,stats_stdout;
	TEpoch 						*epoch = NULL;
	TRTCM2 						*rtcm2 = NULL;
	TRTCM3 						*rtcm3 = NULL;
	enum MeasurementType		meas,meas2,meas3;
	enum fileType				auxft1;

	#if !defined (__WIN32__)
	//Variables for non windows environments check
	pid_t 			fg;
	#endif


	// Number of GNSS product sources available
	nProd = sopt->numNav + sopt->numSP3 + sopt->numOrb;
	
	if (options->ProgressEndCharac=='\r') {
		//'\r' means that we print to terminal
		//Check if output has been redirected to a terminal
		//Look for properties of stdin and stdout
		r1 = fstat(fileno(stdin), &stats_stdin);
		r2 = fstat(fileno(stdout), &stats_stdout);

		if (sopt->UserForcedPrintProgress==1) {
			//User forced to print progress 
			if (r2<0) {
				//If stdout properties cannot be read, assume it is not a terminal
				options->OutputToTerminal=0;
			} else if (S_ISCHR(stats_stdout.st_mode)) {
				options->OutputToTerminal=1;
			} else {
				options->OutputToTerminal=0;
			}
		} else if (r1<0 || r2<0) {
			//Stdin or stdout properties cannot be read.
			//Disable progress print as we cannot now if output is piped
			printProgress=0;
		} else {
			if (S_ISCHR(stats_stdout.st_mode)) {
				options->OutputToTerminal=1;
			} else {
				options->OutputToTerminal=0;
				#if defined (__WIN32__)
					//In Windows, we cannot distinguish if process is run in the background
					//Therefore, if user does not provide parameter -print:progress,
					//disable print progress so it does not mess with terminal when process is in background
					if (sopt->UserSetPrintProgress!=1) {
						printProgress=0;
					}
				#endif
			}

			//Check if standard input is from a terminal (interactive). If it isn't, probably
			//or process in the background or from an automatic process. Disable progress bar
			//NOTE: S_ISCHR(stats_stdin.st_mode) can return true even if process is in background!
			if (!S_ISCHR(stats_stdin.st_mode)) {
				//Stdin not a terminal
				printProgress=0;
			} else {
			#if !defined (__WIN32__)
				if (S_ISFIFO(stats_stdout.st_mode)||S_ISSOCK(stats_stdout.st_mode) ) {
					//Output is a socket or a pipe. Disable print
					printProgress=0;
				} else {
					fg=tcgetpgrp(STDIN_FILENO);
					if (fg==-1) {
						//Stdin is a pipe. Disable progress print
						printProgress=0;
					} else if (fg!=getpgrp()) {
						//We are in the background. Disable progress print
						printProgress=0;
					}
				}
			#else
				if (S_ISFIFO(stats_stdout.st_mode)) {
					//Output is a pipe. Disable print
					printProgress=0;
				}
			#endif
			}
		}
	} else {
		//'\n' means that we print for the GUI
		options->OutputToTerminal=1;
		printProgress=1;
		sopt->disableCursor=0;
	}

	// Output redirection
	if ( sopt->outFile[0] != '\0' ) {
		//Create directory recursively if needed
		ret=mkdir_recursive(sopt->outFile);
		if(ret!=0) {
		   //Error when creating the directory, and it is not due to that the directory already exists
		   sprintf(messagestr,"When creating [%s] folder for writing the output file",sopt->outFile);
		   printError(messagestr,options);
		}
		options->outFileStream=fopen(sopt->outFile,"w");
		if (options->outFileStream==NULL) {
			sprintf(messagestr,"Problem with output file [%s] redirection",sopt->outFile);
			printError(messagestr,options);
		}
		if (printProgress!=0) {
			//User has not set anything about printing progress
			if (options->OutputToTerminal==1) {
				printProgress=1;
			} else {
				#if defined (__WIN32__)
					options->terminalStream=fopen("CON","w");
				#else
					options->terminalStream=fopen("/dev/tty","w");
				#endif
				if (options->terminalStream==NULL) {
					printProgress=0;
				} else {
					printProgress=1;
				}
			}
		}
	} else {
		if (printProgress!=0) {
			if (options->OutputToTerminal==1) {
				printProgress=1;
			} else {
				//User has not set anything about printing progress
				#if defined (__WIN32__)
					options->terminalStream=fopen("CON","w");
				#else
					options->terminalStream=fopen("/dev/tty","w");
				#endif
				if (options->terminalStream==NULL) {
					printProgress=0;
				} else {
					printProgress=1;
				}
			}
		}
	}
	#if !defined (__WIN32__)
		//Disable cursor in Linux to avoid cursor flickering in screen (really annoying!!)
		if (printProgress==1 && sopt->disableCursor==1) {
			fprintf(options->terminalStream,"\033[?25l");
			strcpy(enableCursor,"\033[?25h");
			strcpy(disableCursor,"\033[?25l");
			StdoutStream=options->terminalStream;
		}
	#endif

	//If we are in date or conversion modes, do not continue processing options
	if (options->dateConversionMode!=DateConversionModeNone || options->coordConversionMode!=CoordConversionModeNone) return 1;

	// Print gLAB version in INFO field
	if ( options->onlyconvertSBAS == 0 ) {
		#if defined _OPENMP
			sprintf(messagestr,"gLAB version v%s (with OpenMP multithread), built on %s %s",VERSION,__DATE__,__TIME__);
		#else
			sprintf(messagestr,"gLAB version v%s, built on %s %s",VERSION,__DATE__,__TIME__);
		#endif
		printInfo(messagestr,options);
	} else {
		if (printProgress==1) {
			printProgressConvert=1;	
		}
	}

	//Check number of product sources available
	if ( sopt->numNav> MAX_NAV_FILES ) {
		sprintf(messagestr,"Maximum navigation files is %d, but %d navigation files were given",MAX_NAV_FILES,sopt->numNav);
		printError(messagestr,options);
	} else if ( sopt->numSP3 > MAX_SP3_FILES ) {
		sprintf(messagestr,"Maximum SP3 files is %d, but %d SP3 files were given",MAX_SP3_FILES,sopt->numSP3);
		printError(messagestr,options);
	} else if ( sopt->numOrb > MAX_SP3_FILES ) {
		sprintf(messagestr,"Maximum SP3 orbit files is %d, but %d SP3 orbit files were given",MAX_SP3_FILES,sopt->numOrb);
		printError(messagestr,options);
	} else if ( sopt->numClk > MAX_SP3_FILES ) {
		sprintf(messagestr,"Maximum clock files is %d, but %d clock files were given",MAX_SP3_FILES,sopt->numClk);
		printError(messagestr,options);
	} else if (sopt->numTGD > MAX_DCB_FILE_SOURCES) {
		sprintf(messagestr,"Maximum TGD files is %d, but %d TGD files were given",MAX_DCB_FILE_SOURCES,sopt->numTGD);
		printError(messagestr,options);
	} else if (sopt->numAntRec > MAX_RECV_ANTEX_FILES) {
		sprintf(messagestr,"Maximum Receiver ANTEX files is %d, but %d ANTEX files were given",MAX_RECV_ANTEX_FILES,sopt->numAntRec);
		printError(messagestr,options);
	} else if (sopt->numNavHealth > MAX_NAV_FILES) {
		sprintf(messagestr,"Maximum navigation files for satellite health is %d, but %d navigation files were given",MAX_NAV_FILES,sopt->numNavHealth);
		printError(messagestr,options);
	}

	//Check if Start time is after End time in case both times are given by the user
	if (options->StartEpoch.MJDN!=-1 && options->EndEpoch.MJDN!=-1) {
		if(tdiff(&options->EndEpoch,&options->StartEpoch)<0.) {
			printError("Processing start time must be ahead of processing end time",options);
		}
	}

	//Check if SBAS data has been provided
	if ( sopt->SBAScorrections!=NoSBASdata ) {
		options->SBAScorrections = sopt->SBAScorrections;
	}

	// Check that SBAS and DGNSS are both activated
	if ( options->SBAScorrections >= SBAS1Fused && options->DGNSS == 1 ) {
		printError("SBAS and DGNSS cannot be both set",options);
	}

	// Check if user set a reference position file and a valid receiver position mode for DGNSS
	if (sopt->posReferenceFile[0]!='\0' && options->receiverPositionSource == rpCALCULATEREF && options->DGNSS == 1) {
		//Reference file provided and it is the default mode for a reference file and we are in DGNSS
		options->receiverPositionSource = rpRTCMRoverUSERREF;
	}
	
	// Check a priori position
	if ( options->receiverPositionSource == rpUNKNOWN) {
		if ( options->DGNSS == 1) options->receiverPositionSource = rpRTCMbaseline;
		else {
			options->receiverPositionSource = rpRINEX;
			options->recPosProvided=1;
		}
	} else {
		if (options->DGNSS == 1 && options->receiverPositionSource < rpRTCMbaseline) {
			printError("Receiver position modes in DGNSS must be one of these: 'DGNSSbaseline', 'DGNSSRinexRover', 'DGNSSRoverUSER', 'DGNSSRoverUSERGeod', 'DGNSSRoverUSERRef', 'DGNSSUserRoverRef', 'DGNSSUserRoverRefGeod', 'DGNSSUserbaseline', 'DGNSSUserGeodbaseline',  'DGNSSUserRinexRover', 'DGNSSUserGeodRinexRover', 'DGNSSRefRoverUSER', 'DGNSSRefGeodRoverUSERGeod', 'DGNSSRefCarRoverUSERGeod' or 'DGNSSRefGeodRoverUSERCar'",options);
		} else if ( options->DGNSS == 0 && options->receiverPositionSource > rpCALCULATEUSERREF) {
			printError("Receiver position modes in SPP, PPP or SBAS can only be: 'RINEX', 'SINEX', 'Set', 'SetGeod', 'SetRef', 'calculate', 'calculateRef', 'calculateRINEX', 'calculateRINEXRef', 'calculateUSER', 'calculateUSERGeod', 'calculateUSERRef' or 'calculateUSERGeodRef'",options);
		}
	}
	
	//Save order of navigation messages for GPS (if provided)
	if (sopt->BRDCTypesList[GPS][0]!='\0') {
		options->BrdcTypeSel[GPS]=GPSUserDefined;
		aux2=0;
		p=strchr(sopt->BRDCTypesList[GPS],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[GPS];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"LNAV")==0) {
				aux1=GPSLNAV;
			} else if (strcasecmp(p2,"CNAV")==0) {
				aux1=GPSCNAV;
			} else if (strcasecmp(p2,"CNAV2")==0) {
				aux1=GPSCNAV2;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for GPS is not valid for user defined order. Valid values are 'LNAV', 'CNAV' or 'CNAV2'",p2);
				printError(messagestr,options);
			}
			//Check if message type is already provided
			for(j=0;j<i;j++) {
				if (aux1==options->BRDCSelOrder[GPS][GPSUserDefined][j]) {
					sprintf(messagestr,"Navigation message type selection '%s' for GPS is repeated. Each type should be provided only once",p2);
					printError(messagestr,options);
				}
			}
			options->BRDCSelOrder[GPS][GPSUserDefined][i]=aux1;
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[GPS][GPSUserDefined][MAX_BRDC_TYPES]=aux2;
	}

	//Save order of navigation messages for Galileo (if provided)
	if (sopt->BRDCTypesList[Galileo][0]!='\0') {
		options->BrdcTypeSel[Galileo]=GalUserDefined;
		aux2=0;
		l=0;
		p=strchr(sopt->BRDCTypesList[Galileo],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[Galileo];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"INAV")==0) {
				aux1 = GalINAVANY;
			} else if (strcasecmp(p2,"INAVE1")==0) {
				aux1 = GalINAVE1;
			} else if (strcasecmp(p2,"INAVE5b")==0) {
				aux1 = GalINAVE5b;
			} else if (strcasecmp(p2,"INAVE1E5b")==0) {
				aux1 = GalINAVE1E5b;
			} else if (strcasecmp(p2,"FNAV")==0) {
				aux1 = GalFNAV;
			} else if (strcasecmp(p2,"CNAV")==0) {
				aux1 = GalCNAV;
			} else if (strcasecmp(p2,"GNAV")==0) {
				aux1 = GalGNAV;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for Galileo is not valid for user defined order. Valid values are 'INAV', 'INAVE1', 'INAVE5b', 'INAVE1E5b', 'FNAV', 'CNAV' or 'GNAV'",p2);
				printError(messagestr,options);
			}
			if (aux1==GalINAVANY) {
				//When INAV is provided, we need to set the three INAV possible types
				//Check if message type is already provided
				for(j=0;j<(i+l);j++) {
					if (options->BRDCSelOrder[Galileo][GalUserDefined][j]==GalINAVE1 || options->BRDCSelOrder[Galileo][GalUserDefined][j]==GalINAVE5b
							|| options->BRDCSelOrder[Galileo][GalUserDefined][j]==GalINAVE1E5b) {
						sprintf(messagestr,"Navigation message type selection '%s' for Galileo is repeated. Each type should be provided only once",p2);
						printError(messagestr,options);
					}
				}
				options->BRDCSelOrder[Galileo][GalUserDefined][i+l]=GalINAVE1E5b;
				options->BRDCSelOrder[Galileo][GalUserDefined][i+l+1]=GalINAVE1;
				options->BRDCSelOrder[Galileo][GalUserDefined][i+l+2]=GalINAVE5b;
				l+=2;
			} else {
				//Check if message type is already provided
				for(j=0;j<(i+l);j++) {
					if (aux1==options->BRDCSelOrder[Galileo][GalUserDefined][j]) {
						sprintf(messagestr,"Navigation message type selection '%s' for Galileo is repeated. Each type should be provided only once",p2);
						printError(messagestr,options);
					}
				}
				options->BRDCSelOrder[Galileo][GalUserDefined][i+l]=aux1;
			}
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[Galileo][GalUserDefined][MAX_BRDC_TYPES]=aux2+l;
	}

	//Save order of navigation messages for GLONASS (if provided)
	if (sopt->BRDCTypesList[GLONASS][0]!='\0') {
		options->BrdcTypeSel[GLONASS]=GLOUserDefined;
		aux2=0;
		p=strchr(sopt->BRDCTypesList[GLONASS],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[GLONASS];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"FDMA")==0) {
				aux1=GLOFDMA;
			} else if (strcasecmp(p2,"CDMA")==0) {
				aux1=GLOCDMA;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for GLONASS is not valid for user defined order. Valid values are 'FDMA' or 'CDMA'",p2);
				printError(messagestr,options);
			}
			//Check if message type is already provided
			for(j=0;j<i;j++) {
				if (aux1==options->BRDCSelOrder[GLONASS][GPSUserDefined][j]) {
					sprintf(messagestr,"Navigation message type selection '%s' for GLONASS is repeated. Each type should be provided only once",p2);
					printError(messagestr,options);
				}
			}
			options->BRDCSelOrder[GLONASS][GLOUserDefined][i]=aux1;
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[GLONASS][GLOUserDefined][MAX_BRDC_TYPES]=aux2;
	}

	//Save order of navigation messages for BeiDou (if provided)
	if (sopt->BRDCTypesList[BDS][0]!='\0') {
		options->BrdcTypeSel[BDS]=BDSUserDefined;
		aux2=0;
		p=strchr(sopt->BRDCTypesList[BDS],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[BDS];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"D1")==0) {
				aux1=BDSD1;
			} else if (strcasecmp(p2,"CNAV1")==0) {
				aux1=BDSCNAV1;
			} else if (strcasecmp(p2,"CNAV2")==0) {
				aux1=BDSCNAV2;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for BeiDou is not valid for user defined order. Valid values are 'D1', 'CNAV1' or 'CNAV2'",p2);
				printError(messagestr,options);
			}
			//Check if message type is already provided
			for(j=0;j<i;j++) {
				if (aux1==options->BRDCSelOrder[BDS][BDSUserDefined][j]) {
					sprintf(messagestr,"Navigation message type selection '%s' for BeiDou is repeated. Each type should be provided only once",p2);
					printError(messagestr,options);
				}
			}
			options->BRDCSelOrder[BDS][BDSUserDefined][i]=aux1;
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[BDS][BDSUserDefined][MAX_BRDC_TYPES]=aux2;
	}

	//Save order of navigation messages for QZSS (if provided)
	if (sopt->BRDCTypesList[QZSS][0]!='\0') {
		options->BrdcTypeSel[QZSS]=QZSUserDefined;
		aux2=0;
		p=strchr(sopt->BRDCTypesList[QZSS],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[QZSS];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"LNAV")==0) {
				aux1=QZSLNAV;
			} else if (strcasecmp(p2,"CNAV")==0) {
				aux1=QZSCNAV;
			} else if (strcasecmp(p2,"CNAV2")==0) {
				aux1=QZSCNAV2;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for QZSS is not valid for user defined order. Valid values are 'LNAV', 'CNAV' or 'CNAV2'",p2);
				printError(messagestr,options);
			}
			//Check if message type is already provided
			for(j=0;j<i;j++) {
				if (aux1==options->BRDCSelOrder[QZSS][QZSUserDefined][j]) {
					sprintf(messagestr,"Navigation message type selection '%s' for QZSS is repeated. Each type should be provided only once",p2);
					printError(messagestr,options);
				}
			}
			options->BRDCSelOrder[QZSS][QZSUserDefined][i]=aux1;
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[QZSS][QZSUserDefined][MAX_BRDC_TYPES]=aux2;
	}

	//Save order of navigation messages for GEO (if provided)
	if (sopt->BRDCTypesList[GEO][0]!='\0') {
		options->BrdcTypeSel[GEO]=GEOUserDefined;
		aux2=0;
		p=strchr(sopt->BRDCTypesList[GEO],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[GEO];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"CNAV")==0) {
				aux1=GEOCNAV;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for GEO is not valid for user defined order. Valid value is 'CNAV'",p2);
				printError(messagestr,options);
			}
			//Check if message type is already provided
			for(j=0;j<i;j++) {
				if (aux1==options->BRDCSelOrder[GEO][GEOUserDefined][j]) {
					sprintf(messagestr,"Navigation message type selection '%s' for GEO is repeated. Each type should be provided only once",p2);
					printError(messagestr,options);
				}
			}
			options->BRDCSelOrder[GEO][GEOUserDefined][i]=aux1;
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[GEO][GEOUserDefined][MAX_BRDC_TYPES]=aux2;
	}

	//Save order of navigation messages for IRNSS (if provided)
	if (sopt->BRDCTypesList[IRNSS][0]!='\0') {
		options->BrdcTypeSel[IRNSS]=IRNUserDefined;
		aux2=0;
		p=strchr(sopt->BRDCTypesList[IRNSS],',');
		while(p!=NULL) {
			aux2++;
			p++;
			p=strchr(p,',');
		}
		aux2++;
		p2=sopt->BRDCTypesList[IRNSS];
		p=strchr(p2,',');
		if(p!=NULL) *p='\0';
		for(i=0;i<aux2;i++) {
			if (strcasecmp(p2,"CNAV")==0) {
				aux1=IRNCNAV;
			} else {
				sprintf(messagestr,"Navigation message type selection '%s' for IRNSS is not valid for user defined order. Valid value are 'CNAV'",p2);
				printError(messagestr,options);
			}
			//Check if message type is already provided
			for(j=0;j<i;j++) {
				if (aux1==options->BRDCSelOrder[IRNSS][IRNUserDefined][j]) {
					sprintf(messagestr,"Navigation message type selection '%s' for IRNSS is repeated. Each type should be provided only once",p2);
					printError(messagestr,options);
				}
			}
			options->BRDCSelOrder[IRNSS][IRNUserDefined][i]=aux1;
			if (i<(aux2-1)) {
				*p=',';
				p2=p+1;
				p=strchr(p2,',');
				if (p!=NULL) *p='\0';
			}
		}
		options->BRDCSelOrder[IRNSS][IRNUserDefined][MAX_BRDC_TYPES]=aux2;
	}


	//Print messages for deprecated options
	if ( options->deprecatedMode == 1 && options->printInfo ==1 ) {
		fprintf(options->outFileStream,"%s",sopt->deprecatedMessages);
	}

	//If summary is enabled, compute and show summary message at the end of file
	if ( sopt->obsFile[0] != '\0' && options->printSummary == 1 ) {
		options->useDatasummary=1;
		if(options->percentile<=0. || options->percentile>100. ) {
			printError("Percentile for summary must be greater than 0 and smaller or equal than 100",options);
		}
		if (options->SBAScorrections>=SBAS1Fused ) {
			//Check that Alarm limits given are valid
			if(options->HorAlarmLimit<=0.) {
				printError("Horizontal Alarm Limit for SBAS summary must be greater than 0",options);
			}
			if(options->VerAlarmLimit<=0.) {
				printError("Vertical Alarm Limit for SBAS summary must be greater than 0",options);
			}
			if(options->ContRiskWindowSize<=0 ) {
				printError("Continuity Risk Sliding Window epoch size for SBAS summary must be greater than 0",options);
			}
			if(options->ContRiskWindowSizeMar<=0 ) {
				printError("Continuity Risk Sliding Window (maritime mode) epoch size for SBAS summary must be greater than 0",options);
			}
		}
	} else if ( options->stanfordesa==1 && options->printSummary == 0 ) {
		//This is for the case that summary is not computed, but we want Stanford-ESA to be computed
		options->useDatasummary=2; 
	} else {
		options->useDatasummary=0;
	}


	// Check if gLAB has to convert SBAS data files and if doesn't have to do any computations
	if ( options->SBAScorrections>=SBAS1Fused ) {

		if ( sopt->sbas1FfileProvided==1 && sopt->sbasDFMCfileProvided==1 ) {
			printError("SBAS 1F and SBAS DFMC navigation modes cannot be both selected. Remove parameter '-input:sbas1f' or '-input:sbasdfmc'",options);
		}

		if ( sopt->navFile[0][0]=='\0' && options->onlyconvertSBAS == 0 ) {
			printError("SBAS navigation mode selected, but no navigation file available",options);
		}


		if ( options->onlyconvertSBAS == 1 ) {
			if (options->writeRinexBfile==0 && options->writeEMSfile==0 && options->writePegasusfile==0) {
				printError("SBAS file conversion only selected, but no file format given. Use '-output:rinexb' or '-output:ems' or '-output:pegasus' to select file formats",options);
			}
			return 1;
		}

		if ( options->filterIterations == 2 ) {
			printError("SBAS mode activated, which is incompatible with backward processing. Disable backward processing for SBAS mode",options);
		}

		//Check that parameter '-filter:combtype' has not been provided
		if ( options->CombTypeAutoSelection != CombTypeAutoSelectionAutomatic ) {
			printError("Parameter '-filter:combtype' cannot be provided in SBAS 1F or SBAS DFMC modes. Remove this parameter",options);
		}

		if ( options->GEOPRN >= MINGEOPRN && options->GEOPRNunsel[options->GEOPRN] == 1 ) {
			sprintf(messagestr,"Selected GEO %d for SBAS processing, but this GEO has also been set as unselected",options->GEOPRN);
			printError(messagestr,options);
		}

		//If switch mode is enabled or initial mode is NPA or receiver position is set, then we don't need to use Klobuchar in PA in the first epochs
		if ( options->switchmode==1 || options->precisionapproach==NPAMODE || options->receiverPositionSource < rpCALCULATE ) {
			options->initcoordNPA=0;
		}

		//Set default broadcast type order if non set
		if (options->BrdcTypeSel[GPS]==UnknownGPSBRDCPref) {
			options->BrdcTypeSel[GPS]=GPSLNAVOnly;
		}
		if (options->BrdcTypeSel[Galileo]==UnknownGalBRDCPref) {
			options->BrdcTypeSel[Galileo]=GalFNAVOnly;
		}
		//Check broadcast type order so LNAV is used for GPS
		if ( options->BrdcTypeSel[GPS] == GPSCNAVOnly || options->BrdcTypeSel[GPS] == GPSCNAV2Only || options->BrdcTypeSel[GPS] == GPSAnyCNAVOnly || 
			 options->BrdcTypeSel[GPS] == PreferGPSCNAV || options->BrdcTypeSel[GPS] == PreferGPSCNAV2 ) {
			printError("GPS broadcast selection modes 'PreferCNAV', 'PreferCNAV2', 'CNAV' or 'CNAV2' or 'AnyCNAV' are not valid for SBAS mode, as SBAS uses LNAV messages only",options);
		} else if (options->BrdcTypeSel[GPS]==GPSUserDefined) {
			for(i=0;i<options->BRDCSelOrder[GPS][GPSUserDefined][MAX_BRDC_TYPES];i++) {
				if (options->BRDCSelOrder[GPS][GPSUserDefined][i]!=GPSLNAV) {
					printError("GPS broadcast selection modes 'CNAV' or 'CNAV2' are not valid for SBAS mode, as SBAS uses LNAV messages only",options);
				}
			}
		}

		//Check broadcast type order so FNAV is used for Galileo
		if ( options->BrdcTypeSel[Galileo] == GalINAVOnly || options->BrdcTypeSel[Galileo] == GalINAVE1Only || options->BrdcTypeSel[Galileo] == GalINAVE5bOnly ||options->BrdcTypeSel[Galileo] == GalINAVE1E5bOnly ||
		    options->BrdcTypeSel[Galileo] == GalCNAVOnly || options->BrdcTypeSel[Galileo] == GalGNAVOnly || options->BrdcTypeSel[Galileo] == PreferGalINAV || options->BrdcTypeSel[Galileo] == PreferGalCNAV || 
			options->BrdcTypeSel[Galileo] == PreferGalGNAV ) {
			printError("Galileo broadcast selection modes 'PreferINAV', 'PreferCNAV', 'PreferGNAV', 'INAV', 'INAVE1', 'INAVE5b', 'INAVE1E5b', 'CNAV' or 'GNAV' are not valid for SBAS mode, as SBAS DFMC uses FNAV messages only",options);
		} else if (options->BrdcTypeSel[Galileo]==GalUserDefined) {
			for(i=0;i<options->BRDCSelOrder[Galileo][GalUserDefined][MAX_BRDC_TYPES];i++) {
				if (options->BRDCSelOrder[Galileo][GalUserDefined][i]!=GalFNAV) {
					printError("Galileo broadcast selection modes 'INAV', 'INAVE1', 'INAVE5b', 'INAVE1E5b', 'CNAV' or 'GNAV' are not valid for SBAS mode, as SBAS DFMC uses FNAV messages only",options);
				}
			}
		}

		//Check broadcast type order so LNAV is used for QZSS
		if ( options->BrdcTypeSel[QZSS] == QZSCNAVOnly || options->BrdcTypeSel[QZSS] == QZSCNAV2Only || options->BrdcTypeSel[QZSS] == QZSAnyCNAVOnly || 
			 options->BrdcTypeSel[QZSS] == PreferQZSCNAV || options->BrdcTypeSel[QZSS] == PreferQZSCNAV2 ) {
			printError("QZSS broadcast selection modes 'PreferCNAV', 'PreferCNAV2', 'CNAV' or 'CNAV2' or 'AnyCNAV' are not valid for SBAS mode, as SBAS uses LNAV messages only",options);
		} else if (options->BrdcTypeSel[QZSS]==QZSUserDefined) {
			for(i=0;i<options->BRDCSelOrder[QZSS][QZSUserDefined][MAX_BRDC_TYPES];i++) {
				if (options->BRDCSelOrder[QZSS][QZSUserDefined][i]!=QZSLNAV) {
					printError("QZSS broadcast selection modes 'CNAV' or 'CNAV2' are not valid for SBAS mode, as SBAS uses LNAV messages only",options);
				}
			}
		}

		// Check navigation health options
		if ( sopt->satelliteHealth == -1 && sopt->allowMarginal == -1 ) {
			options->satHealthMode = BRDCUseAnyHealth; //Default use any health type, as SBAS will define either to use or not
		} else if ( sopt->satelliteHealth == 1 && sopt->allowMarginal == -1 ) {
			options->satHealthMode = BRDCUseHealthyOnly;
		} else if ( sopt->satelliteHealth == -1 && sopt->allowMarginal == 1 ) {
			options->satHealthMode = BRDCUseAnyHealth; 
		} else if ( sopt->satelliteHealth == 1 && sopt->allowMarginal == 1 ) {
			options->satHealthMode = BRDCUseHealthyMarginal;
		} else if ( sopt->satelliteHealth == -1 && sopt->allowMarginal == 0	) {
			options->satHealthMode = BRDCUseHealthyOnly;
		} else if ( sopt->satelliteHealth == 1 && sopt->allowMarginal == 0	) {
			options->satHealthMode = BRDCUseHealthyOnly;
		} else { //Any case with sopt->satelliteHealth == 0
			options->satHealthMode = BRDCUseAnyHealth;
		}

		// Set default SBAS smoothing if non set
		if ( options->smoothEpochs == -1 ) options->smoothEpochs = 100;
		// Set kinematic navigation if non set
		if ( sopt->navKinematics == NKND ) sopt->navKinematics = NKkinematic;
		// Set 1 second decimation if non set
		if ( options->decimate == -1. ) options->decimate = 1.;
		// Set to do not indentify P1 as C1 if non set
		if ( sopt->GPSp1c1DCBModel == GPSp1c1UNKNOWN ) {
			options->GPSp1c1DCBModel = GPSp1c1NONE;
		}
		// Disable ISC l1ca correction (l1 is the only frequency used)
		if ( sopt->GPSISCl1caDCBModel == DCBUNKNOWN ) {
			options->GPSISCl1caDCBModel = DCBNONE;
		}

		// Unset GDOP threshold if non set
		if (options->GDOPthreshold == -1) options->GDOPthreshold = 0;
		// Set default SBAS smoothing convergence time if non set
		if ( options->excludeSmoothingConvergence == -1 ) options->excludeSmoothingConvergence = 360;
		//Enable minimum SNR filter
		if ( options->SNRminfilter == -1 ) {
			options->SNRminfilter = 1;
		}
		//Disable maximum SNR filter if not set
		if ( options->SNRmaxfilter == -1 ) {
			options->SNRmaxfilter = 0;
		}
		//Disable Ncon for SBAS if not set
		if ( options->csNcon == -1 ) {
			options->csNcon = 0;
		}
		//Set default Data Gap to 10 seconds if not set
		if ( options->csDataGap == -1 ) {
			options->csDataGap = 10;
		}

		//Enable ARP correction if not set
		if (options->ARPData==arpUNKNOWN) {
			options->ARPData = arpRINEX;
		}
		//Disable check of transmission time in broadcast messages if user has not set anything
		if ( options->brdcBlockTransTime == -1 ) options->brdcBlockTransTime = 0;

		if (options->SBAScorrections==SBAS1Fused) {
			// Set SF cycle-slip detector if not set
			if ( sopt->csSF == -1 ) sopt->csSF = 1;
			// Unset all dual frequency cycle-slip detectors if not set
			if ( sopt->csMW == -1 ) sopt->csMW = 0;
			if ( sopt->csLI == -1 ) sopt->csLI = 0;

			// Activate step detector if user has not enabled or disabled it
			// For now we will leave it by default disabled, as it has no real practical use
			// if(options->stepdetector==-1) options->stepdetector=1;

			//Check if RRC corrections are enabled but fast corrections are disabled
			if(options->NoRRCCorrection==0 && options->NoFastCorrection==1) {
				printError("SBAS 1F Fast corrections must be enabled if RRC corrections are going to be used",options);
			}

			//Check if RRC degradation terms are enabled but fast corrections are disabled
			if(options->NoRRCSigma==0 && options->NoFastSigma==1) {
				printError("SBAS 1F Fast corrections sigmas must be enabled if RRC degradation term is going to be used",options);
			}
		} else  {
			// Unset SF cycle-slip detector if not set
			if ( sopt->csSF == -1 ) sopt->csSF = 0;
			// Set dual frequency cycle-slip detectors if not set
			if ( sopt->csMW == -1 ) sopt->csMW = 1;
			if ( sopt->csLI == -1 ) sopt->csLI = 1;
		}

		//Set Galileo DCB model to off (in SBAS 1F Galileo is not used and in SBAS DFMC no DCB has to be applied to Galileo according to MOPS)
		options->GALe1e5aDCBModel = DCBNONE;
		options->GALe1e5bDCBModel = DCBNONE;

		//Disable ISC from GPS L1C/L2C/L5Q/L5I that are not used (mainly to show as disabled in INFO so not to confuse the user)
		options->GPSISCl1cpDCBModel = DCBNONE;
		options->GPSISCl2cDCBModel = DCBNONE;
		options->GPSISCl5i5DCBModel = DCBNONE;
		options->GPSISCl5q5DCBModel = DCBNONE;

		//Disable TGD from BeiDou (mainly to show as disabled in INFO so not to confuse the user)
		options->BDSISCb1cdDCBModel = DCBNONE;
		options->BDSISCb2adDCBModel = DCBNONE;
		options->BDSb1b6DCBModel = DCBNONE;
		options->BDSb2b6DCBModel = DCBNONE;
		options->BDSb5b6DCBModel = DCBNONE;
		options->BDSb7b6DCBModel = DCBNONE;
		
		//Disable TGD from QZSS (mainly to show as disabled in INFO so not to confuse the user)
		options->QZSc1cDCBModel = DCBNONE;
		options->QZSISCl1cpDCBModel = DCBNONE;
		options->QZSISCl2cDCBModel = DCBNONE;
		options->QZSISCl5i5DCBModel = DCBNONE;
		options->QZSISCl5q5DCBModel = DCBNONE;

		//Disable TGD from IRNSS (mainly to show as disabled in INFO so not to confuse the user)
		options->IRNc9c5DCBModel = DCBNONE;

		if (options->SBAScorrections==SBASDFMCused) {
			//Disable P1-P2 correction, as it is a iono-free combination, the TGD is removed in this combination
			options->GPSp1p2DCBModel = DCBNONE;	

			//Enable GPS dual-frequency DCB. SBAS DFMC has the special case to only apply LNAV TGD and not the ISC
			if (sopt->DualFreqDCBModel[GPS]==DCBUNKNOWN) {
				options->DualFreqDCBModel[GPS]=DCBRINEX;
			}
		}

		//Check if both fixed sigma multipath value and user defined sigma multipath model are given
		if(options->airborneReceiverType==0 && options->usersigmamultipath==1 && options->sigma2multipath[0]!=-99999.) {
			printError("SBAS Sigma multipath has been defined with a fixed value and a user defined model, but only one definition type can be selected at once",options);
		}

		//If select best GEO option is enabled, check that minimum switch time is 0
		if (options->selectBestGEO==1) {
			if (options->minimumswitchtime!=-1 && options->minimumswitchtime!=0) {
				printError("Minimum time between switches (option '-model:switchtime') must be 0 if option '-model:selectbestgeo' is enabled",options);
			} else {
				options->minimumswitchtime=0;
			}
			if (options->mixedGEOdata==1) {
				printError("Mixed GEO cannot be enabled if option '-model:selectbestgeo' is enabled",options);
			}
		} else if (options->minimumswitchtime==-1) {
			options->minimumswitchtime=0;
		}

		//Set the value of noMixedGEOdata (complentary of noMixedGEOdata)
		if ( options->mixedGEOdata==1 ) {
			options->noMixedGEOdata=0;
		} else {
			options->noMixedGEOdata=1;
		}

		// Set default prints
		if ( options->printInput == -1 )          options->printInput = 0;
		if ( options->printModel == -1 )          options->printModel = 0;
		if ( options->printPrefit == -1 )         options->printPrefit = 0;
		if ( options->printPostfit == -1 )        options->printPostfit = 0;
		if ( options->printFilterSolution == -1 ) options->printFilterSolution = 0;
		if ( options->printSatellites == -1 )     options->printSatellites = 0;
		if ( options->printSatSel == -1 )         options->printSatSel = 0;

	}
	//Options for Stanford-ESA computation (it can be computed outside of SBAS mode)
	if ( options->stanfordesa == 1 ) {
		//Check that Worst Integrity threshold for printing Stanford-ESA iteration given is valid
		if(options->WIRHorThreshold<0.) {
			printError("Horizontal Worst Integrity Ratio threshold for printing solution in Stanford-ESA computation must be greater or equal than 0",options);
		}
		if(options->WIRVerThreshold<0.) {
			printError("Vertical Worst Integrity Ratio threshold for printing solution in Stanford-ESA computation must be greater or equal than 0",options);
		}

		// Check if a filename is given for stanford-ESA plot. If non given, use the observation filename with "_stdESA.txt" appended at the end
		if ( sopt->stanfordESAFile[0] == '\0' && sopt->obsFile[0] != '\0') {
			#if defined (__WIN32__)
				filepointer = strrchr(sopt->obsFile,'\\');
			#elif defined (__CYGWIN__)
				filepointer = strrchr(sopt->obsFile,'/');
				// In cygwin, we may have linux or windows pathes
				if ( filepointer == NULL ) {
					filepointer = strrchr(sopt->obsFile,'\\');
				}
			#else
				filepointer = strrchr(sopt->obsFile,'/');
			#endif
				if ( filepointer == NULL ) {
					// There is no directory path in the file
					sprintf(sopt->stanfordESAFile,"%s_stdESA.txt",sopt->obsFile);
				} else {
					// There is directory path in the file. Only use the filename so the file is created in the current directory
					sprintf(sopt->stanfordESAFile,"%s_stdESA.txt",(char *)(filepointer+sizeof(char)));
				}
		}

		// Check if a filename is given for stanford-ESA LOI data. If non given, use the observation filename with "_stdESA_LOI.txt" appended at the end
		if ( sopt->stanfordESALOIFile[0] == '\0' && sopt->obsFile[0] != '\0') {
			#if defined (__WIN32__)
				filepointer = strrchr(sopt->obsFile,'\\');
			#elif defined (__CYGWIN__)
				filepointer = strrchr(sopt->obsFile,'/');
				// In cygwin, we may have linux or windows pathes
				if ( filepointer == NULL ) {
					filepointer = strrchr(sopt->obsFile,'\\');
				}
			#else
				filepointer = strrchr(sopt->obsFile,'/');
			#endif
				if ( filepointer == NULL ) {
					// There is no directory path in the file
					sprintf(sopt->stanfordESALOIFile,"%s_stdESA_LOI.txt",sopt->obsFile);
				} else {
					// There is directory path in the file. Only use the filename so the file is created in the current directory
					sprintf(sopt->stanfordESALOIFile,"%s_stdESA_LOI.txt",(char *)(filepointer+sizeof(char)));
				}
		}
	}

	// Defaults for DGNSS
	if ( options->DGNSS == 1 ) {
	
		//Check that parameter '-filter:combtype' has not been provided
		if ( options->CombTypeAutoSelection != CombTypeAutoSelectionAutomatic ) {
			printError("Parameter '-filter:combtype' cannot be provided in DGNSS mode. Remove this parameter",options);
		}

		// Set L1-C1 cycle-slip detector if not set
		if ( sopt->csSF == -1 ) sopt->csSF = 1;
		// Set default DGNSS smoothing if non set
		if ( options->smoothEpochs == -1 ) options->smoothEpochs = 100;
		// If decimation not set and DGNSS mode, set it to 0 (no decimation)
		if ( options->decimate == -1. ) options->decimate = 0.;
		// Set GDOP threshold if non set
		if (options->GDOPthreshold == -1) options->GDOPthreshold = 1;
		//Enable minimum SNR filter
		if ( options->SNRminfilter == -1 ) {
			options->SNRminfilter = 1;
		}
		//Disable maximum SNR filter if not set
		if ( options->SNRmaxfilter == -1 ) {
			options->SNRmaxfilter = 0;
		}
		//Disable Ncon for DGNSS if not set
		if ( options->csNcon == -1 ) {
			options->csNcon = 0;
		}
		//Set default Data Gap to 10 seconds if not set
		if ( options->csDataGap == -1 ) {
			options->csDataGap = 10;
		}

		//Enable ARP correction if not set
		if (options->ARPData==arpUNKNOWN) {
			options->ARPData = arpRINEX;
		}

		// Use the RTCM file path to output the converted RINEX
		if ( sopt->rtcmFile[0] != '\0' || sopt->rtcm2File[0] != '\0' || sopt->rtcm3File[0] != '\0' ) {
			if ( sopt->rtcmFile[0] != '\0' ) removeExtension(sopt->rtcmFile, auxpathRTCMpointer);
			else if ( sopt->rtcm2File[0] != '\0' ) removeExtension(sopt->rtcm2File, auxpathRTCMpointer);
			else removeExtension(sopt->rtcm3File, auxpathRTCMpointer);

			getRTCMpath(auxpathRTCMpointer, pathRTCMpointer);
		}


		if ( options->filterIterations == 2 ) {
			printError("DGNSS mode activated, which is incompatible with backward processing. Disable backward processing for DGNSS mode",options);
		}

		//Disable check of transmission time in broadcast messages if user has not set anything
		if ( options->brdcBlockTransTime == -1 ) options->brdcBlockTransTime = 0;

		//Set default broadcast type order if non set
		if (options->BrdcTypeSel[GPS]==UnknownGPSBRDCPref) {
			options->BrdcTypeSel[GPS]=GPSLNAVOnly;
		}
		if (options->BrdcTypeSel[Galileo]==UnknownGalBRDCPref) {
			options->BrdcTypeSel[Galileo]=PreferGalINAV;
		}

		//Check broadcast type order so LNAV is used for GPS
		if ( options->BrdcTypeSel[GPS] == GPSCNAVOnly || options->BrdcTypeSel[GPS] == GPSCNAV2Only || options->BrdcTypeSel[GPS] == GPSAnyCNAVOnly || 
			 options->BrdcTypeSel[GPS] == PreferGPSCNAV || options->BrdcTypeSel[GPS] == PreferGPSCNAV2 ) {
			printError("GPS broadcast selection modes 'PreferCNAV', 'PreferCNAV2', 'CNAV' or 'CNAV2' or 'AnyCNAV' are not valid for DGNSS mode, as DGNSS uses LNAV messages only",options);
		} else if (options->BrdcTypeSel[GPS]==GPSUserDefined) {
			for(i=0;i<options->BRDCSelOrder[GPS][GPSUserDefined][MAX_BRDC_TYPES];i++) {
				if (options->BRDCSelOrder[GPS][GPSUserDefined][i]!=GPSLNAV) {
					printError("GPS broadcast selection modes 'CNAV' or 'CNAV2' are not valid for DGNSS mode, as DGNSS uses LNAV messages only",options);
				}
			}
		}

	}

	//Check option for selecting best GEO. If it not SBAS mode or user did not set it, disable it
	if ( options->SBAScorrections<=SBASionoOnly ) {
		options->selectBestGEO=0;
	} else if (options->selectBestGEO==-1 || options->switchGEO) {
		options->selectBestGEO=0;
	}

	// If decimation not set, set it to 0
	if ( options->decimate == -1. ) options->decimate = 0.;

	// If smoothing not set, disable it if user has not set any smoothing measurement
	if ( options->smoothEpochs == -1 ) {
		if (sopt->numSmoothMeasFilterText[ROVERPOS]==0) {
			options->smoothEpochs = 0;
		} else {
			options->smoothEpochs = 100;
		}
	} else if (options->smoothEpochs==0) {
	   if (sopt->numSmoothMeasFilterText[ROVERPOS]>0) {
		   printError("Smoothing disabled by user (parameter '-pre:smooth 0'), but measurements for rover smoothing have been provided (parameter '-pre:smoothmeas'",options);
	   } else if (options->DGNSS==1 && sopt->numSmoothMeasFilterText[REFSTAPOS]>0) {
		   printError("Smoothing disabled by user (parameter '-pre:smooth 0'), but measurements for reference station smoothing have been provided (parameter '-pre:smoothmeasdgnss'",options);
	   }
	}

	//Check broadcast type order
	if (options->BrdcTypeSel[GPS]==UnknownGPSBRDCPref) {
		options->BrdcTypeSel[GPS]=PreferGPSCNAV;
	}
	if (options->BrdcTypeSel[Galileo]==UnknownGalBRDCPref) {
		options->BrdcTypeSel[Galileo]=PreferGalINAV;
	}
	if (options->BrdcTypeSel[GLONASS]==UnknownGLOBRDCPref) {
		options->BrdcTypeSel[GLONASS]=GLOFDMAOnly; //CDMA navigation messages not supported
	}
	if (options->BrdcTypeSel[BDS]==UnknownBDSBRDCPref) {
		options->BrdcTypeSel[BDS]=BDSD1Only; //CNAV1 and CNAV2 messages not supported
	}
	if (options->BrdcTypeSel[QZSS]==UnknownQZSSBRDCPref) {
		options->BrdcTypeSel[QZSS]=QZSLNAVOnly; //CNAV message format still not clear
	}
	if (options->BrdcTypeSel[GEO]==UnknownGEOBRDCPref) {
		options->BrdcTypeSel[GEO]=GEOCNAVOnly; //Only one type available
	}
	if (options->BrdcTypeSel[IRNSS]==UnknownIRNSSBRDCPref) {
		options->BrdcTypeSel[IRNSS]=IRNCNAVOnly; //Only one type available
	}


	// Disable smoothing convergence time if non set
	if ( options->excludeSmoothingConvergence == -1 ) options->excludeSmoothingConvergence = 0;

	// If step detector not set, disable it
	if ( options->stepdetector == -1 ) options->stepdetector=0;

	//Disable SNR minimum filtering for SPP and PPP if not set
	if ( options->SNRminfilter == -1 ) {
		options->SNRminfilter = 0;
	}
	//Disable SNR maximum filtering for SPP and PPP if not set
	if ( options->SNRmaxfilter == -1 ) {
		options->SNRmaxfilter = 0;
	}
	//Set SNR filtering if set
	if ( options->SNRminfilter == 1 || options->SNRmaxfilter == 1 ) {
		options->SNRfilter = 1;
	} else {
		options->SNRfilter = 0;
	}

	if ( options->SNRminfilter == 1 && options->SNRmaxfilter == 1) {
		options->SNRchecktype=SNRCheckMinMax;
	} else if ( options->SNRminfilter == 1 && options->SNRmaxfilter == 0 ) {
		options->SNRchecktype=SNRCheckMin;
	} else if ( options->SNRminfilter == 0 && options->SNRmaxfilter == 1 ) {
		options->SNRchecktype=SNRCheckMax;
	} else {
		options->SNRchecktype=NoSNRCheck;
	}

	//Set default values to SNR thresholds for values not set for the user
	if (options->SNRfilter == 1) {
		for (i=0;i<MAX_GNSS;i++) {
			for (j=0;j<MAX_SATELLITES_PER_GNSS;j++) {
				for (k=0;k<MAX_MEASUREMENTS_NO_COMBINATIONS;k++) {
					if (options->SNRminfilter==0) {
						options->SNRminvalues[i][j][k]=-9999.;
					} else if (options->SNRminvalues[i][j][k]==-9999.) {
						options->SNRminvalues[i][j][k]=33.;//Default min SNR threshold
					}
					if (options->SNRmaxfilter==0) {
						options->SNRmaxvalues[i][j][k]=9999.;
					} else if (options->SNRmaxvalues[i][j][k]==9999.) {
						options->SNRmaxvalues[i][j][k]=54.; //Default max SNR threshold
					}
				}
			}
		}
	}

	//Enable Ncon for SPP and PPP if not set
	if ( options->csNcon == -1 ) {
		options->csNcon = 1;
	}

	//Set default Data Gap to 40 seconds if not set
	if ( options->csDataGap == -1 ) {
		options->csDataGap = 40;
	}

	// Set default prints
	if ( options->printInput == -1 )          options->printInput = 0;
	if ( options->printModel == -1 )          options->printModel = 0;
	if ( options->printPrefit == -1 )         options->printPrefit = 0;
	if ( options->printPostfit == -1 )        options->printPostfit = 0;
	if ( options->printFilterSolution == -1 ) options->printFilterSolution = 0;
	if ( options->printSatellites == -1 )     options->printSatellites = 0;
	if ( options->printSatSel == -1 )         options->printSatSel = 0;

	//Check HDOP or PDOP thresholds are enabled and if both are not enabled, disable check PDOP or HDOP
	if (options->HDOPthreshold==0 || options->PDOPthreshold==0) {
		options->HDOPorPDOP=0;
	}

	// Products availability check
	if ( sopt->SP3File[0][0] == '\0' && (sopt->orbFile[0][0] == '\0' || sopt->clkFile[0][0] == '\0') ) {
		preciseProductsAvailable = 0;
	} else {
		preciseProductsAvailable = 1;
	}
	
	if ( sopt->navFile[0][0] == '\0' ) {
		broadcastProductsAvailable = 0;
	} else {
		broadcastProductsAvailable = 1;
	}

	//Check that station network name has no spaces
	if (strchr(options->StationNetworkName,' ')!=NULL) {
		printError("Station network name cannot have space characters (' ')",options);
	}

	// Sanity check
	if ( sopt->obsFile[0] != '\0' ) {
		options->workMode = wmDOPROCESSING;
		if ( broadcastProductsAvailable && sopt->navMode == NMND ) sopt->navMode = NMstandalone;
		if ( preciseProductsAvailable && sopt->navMode == NMND ) sopt->navMode = NMppp;
		if ( broadcastProductsAvailable && preciseProductsAvailable ) {
			printError("Cannot determine if processing Standalone or PPP. Please use only one source of GNSS products",options);
		} else if (sopt->navMode==NMppp && broadcastProductsAvailable) {
			printError("PPP and input:nav were set",options);
		} else if (sopt->navMode==NMstandalone && preciseProductsAvailable) {
			printError("Standalone and input:sp3/input:orb/input:clk were set",options);
		} else if (sopt->SP3File[0][0]!='\0' && sopt->orbFile[0][0]!='\0' && sopt->clkFile[0][0]!='\0') {
			printError("input:sp3, input:orb and input:clk cannot be all set",options);
		} else if (sopt->SP3File[0][0]!='\0' && sopt->orbFile[0][0]!='\0') {
			printError("input:sp3 and input:orb cannot be both set. Use '-input:sp3' to read orbit and clock products from a SP3 file, or use '-input:orb' to read only orbits from SP3 and '-input:clk' to read clocks from a CLK file",options);
		} else if (sopt->SP3File[0][0]!='\0' && sopt->clkFile[0][0]!='\0') {
			printError("input:sp3 and input:clk cannot be both set. Use '-input:sp3' to read orbit and clock products from a SP3 file, or use '-input:orb' to read only orbits from SP3 file and '-input:clk' to read clocks from a CLK file",options);
		} else if ((sopt->numOrb>0 || sopt->numClk>0) && sopt->numOrb!=sopt->numClk) {
			sprintf(messagestr, "Inconsistent number of orb and clk input files (%d vs %d)", sopt->numOrb, sopt->numClk);
			printError(messagestr,options);
		} else if (!broadcastProductsAvailable && !preciseProductsAvailable) {
			if (sopt->addederrorFile[0]!='\0' && options->DGNSS==0 && options->SBAScorrections==NoSBASdata ) {
				options->workMode = wmUSERERROR2RINEX;
				if (sopt->rnxFile[0]=='\0') {
					//If no output file is given, observation rinex filename will be used with suffix "_usererror"
					sprintf(sopt->rnxFile,"%s_usererror",sopt->obsFile);
				}
				//In this mode it will enter
				return 1;
			} else {
				printInfo("Disconnecting modelling and filtering (no GNSS products available)",options);
				options->workMode = wmSHOWINPUT;
				if ( options->printMeas == -1 ) options->printMeas = 1;
			}
		}
		if ( options->printMeas == -1 ) options->printMeas = 0;
		if ( options->receiverPositionSource == rpSINEX && sopt->snxFile[0] == '\0' ) {
			printError("Receiver position source set to SINEX, but no SINEX file has been included. Include one with the '-input:snx' option",options);
		}
		if ( options->receiverPositionSource >= rpRTCMbaseline && sopt->dgnssFile[0] == '\0' && sopt->rtcmFile[0] == '\0' && sopt->rtcm2File[0] == '\0' && sopt->rtcm3File[0] == '\0' ) {
			printError("Receiver position source set to RTCM, but no RTCM file has been included. Include one with the '-input:rtcm' option", options);
		}
		if( options->DGNSS ==1 ) {
			if ( sopt->navFile[0][0]=='\0' ) {
				printError("DGNSS mode activated, but no navigation file available",options);
			}
		}
		if ( options->BrdcTypeSel[GPS] >= GPSLNAVvsCNAV ) {
			printError("GPS broadcast selection modes 'LNAVvsCNAV', 'CNAVvsLNAV', 'LNAVvsCNAV2', 'CNAV2vsLNAV', 'CNAVvsCNAV2' and 'CNAV2vsCNAV' are only for orbit comparison mode",options);
		}
		if ( options->BrdcTypeSel[Galileo] >= GalINAVvsFNAV ) {
			printError("Galileo broadcast selection modes 'INAVvsFNAV', 'FNAVvsINAV', 'INAVvsCNAV', 'CNAVvsINAV', 'INAVvsGNAV', 'GNAVvsINAV', 'FNAVvsCNAV', 'CNAVvsFNAV', 'FNAVvsGNAV', 'GNAVvsFNAV', 'CNAVvsGNAV' and 'GNAVvsCNAV' are only for orbit comparison mode",options);
		}
		if ( options->BrdcTypeSel[GLONASS] >= GLOFDMAvsCDMA ) {
			printError("Glonass broadcast selection modes 'FDMAvsCDMA' and 'CDMAvsFDMA' are only for orbit comparison mode",options);
		}
		if ( options->BrdcTypeSel[BDS] >= BDSD1vsD2 ) {
			printError("BeiDou broadcast selection modes 'D1vsD2', 'D2vsD1', 'D1vsCNAV1', 'CNAV1vsD1', 'D1vsCNAV2', 'CNAV2vsD1', 'D2vsCNAV1', 'CNAV1vsD2', 'D2vsCNAV2', 'CNAV2vsD2', 'CNAV1vsCNAV2' and 'CNAV2vsCNAV1' are only for orbit comparison mode",options);
		}
		if ( options->BrdcTypeSel[QZSS] >= QZSLNAVvsCNAV ) {
			printError("QZSS broadcast selection modes 'LNAVvsCNAV', 'CNAVvsLNAV', 'LNAVvsCNAV2', 'CNAV2vsLNAV', 'CNAVvsCNAV2' and 'CNAV2vsCNAV' are only for orbit comparison mode",options);
		}
		if ( options->printMeas == -1 ) options->printMeas = 0;
	} else { // No observation file found
		if ( nProd == 1 && sopt->sbasFile[0] != '\0' ) {
			options->workMode = wmSBASPLOTS;
			if ( options->printMeas == -1 ) options->printMeas = 0;
			//Enable SBAS corrections
			if (options->SBASFreqPosToProcess==SBAS1FFREQPOS) {
				options->SBAScorrections=SBASMaps1freqUsed;
				if (sopt->NoIonoPlot!=-1) {
					options->NoIonoPlot=sopt->NoIonoPlot;
				}
			} else {
				options->SBAScorrections=SBASMapsDFMCused;
				options->NoIonoPlot=1; 
			}

			// SBAS plots and SBAS convert only cannot be both set
			if ( options->onlyconvertSBAS == 1 && options->SBAScorrections>=SBASMaps1freqUsed ) {
				printError("SBAS file conversion only and SBAS plot computation cannot be both set",options);
			}

			if ( options->SBAScorrections==SBASMaps1freqUsed) {
				if ( options->NoAvailabilityPlot==1 && options->NoIonoPlot==1) {
					printError("SBAS 1F plots mode selected, but both Availability and Iono maps are disabled. Disable just one of the plots",options);
				}
				if( options->NoAvailabilityPlot==1 && options->ComputeRiskPlots == 1 ) {
					printError("SBAS 1F Continuity Risk plot cannot be computed without SBAS Availability plot. Availablity plot has to be activated in order to compute Continuity Risk plot",options);
				}
			} else {
				if ( options->NoAvailabilityPlot==1) {
					printError("SBAS DFMC plots mode selected, but Availability maps cannot be disabled",options);
				}
				if( options->NoAvailabilityPlot==1 && options->ComputeRiskPlots == 1 ) {
					printError("SBAS DFMC Continuity Risk plot cannot be computed without SBAS DFMC Availability plot. Availablity plot has to be activated in order to compute Continuity Risk plot",options);
				}
			}
			if ((options->HDOPPlot==1||options->PDOPPlot==1) && options->NoAvailabilityPlot==1) {
				printError("SBAS HDOP or PDOP plots cannot be computed without SBAS Availability plot. Availablity plot has to be activated in order to compute HDOP or PDOP plots",options);
			}
			if( options->GEOPRN==2 ) {
				printError("Selection of SBAS GEO with highest elevation is not available in SBAS plots mode. Use automatic GEO selection, or select GEO from first line data read ('-pre:geosel 1') or manually set a GEO ('-pre:geosel GEOPRN')",options);
			} else if ( options->GEOPRN==-1 ) {
				//No GEO satellite selection. Set first GEO read
				options->GEOPRN=options->GEOPRNSelected=1;
			} 
			//Check that we have valid limits and steps for the plots
			if(options->minLatplots<-90. || options->maxLatplots>90.) {
				printError("SBAS plots latitude range must be between -90 and 90 degrees",options);
			}
			if(options->minLatplots>options->maxLatplots) {
				sprintf(messagestr,"SBAS plots latitude range is not valid. Maximum selected (%.2f) has to be greater or equal than the minimum latitude (%.2f)",options->maxLatplots,options->minLatplots);
				printError(messagestr,options);
			}
			if(options->minLonplots<-180. || options->maxLonplots>180.) {
				printError("SBAS plots longitude range must be between -180 and 180 degrees",options);
			}
			if(options->minLonplots>options->maxLonplots) {
				sprintf(messagestr,"SBAS plots longitude range is not valid. Maximum longitude (%.2f) has to be greater or equal than the minimum longitude (%.2f)",options->maxLonplots,options->minLonplots);
				printError(messagestr,options);
			}
			if(options->HorAlarmLimit<=0.) {
				printError("SBAS plots Horizontal Alarm Limit must be greater than 0",options);
			}
			if(options->VerAlarmLimit<=0.) {
				printError("SBAS plots Vertical Alarm Limit must be greater than 0",options);
			}
			if(options->AvailabilityPlotStep<0.01) {
				printError("SBAS plots Availability Step must be greater than 0 with a minimum resolution of 0.01 degrees",options);
			}
			if(options->AvailPlotTimeStep<=0) {
				printError("SBAS plots Availability Time Step must be greater than 0",options);

			} else if (options->SBASHourlyMaps==1) {
				//If hourly maps enabled, the time step must be a multiple of 3600, so hourly files are closed when a new hour starts
				if (options->AvailPlotTimeStep>3600) {
					if (options->AvailPlotTimeStep%3600!=0) {
						sprintf(messagestr,"SBAS plots Availability Time Step set to %d, but this time step is not divisible by 3600 (needed only when hourly plots are enabled)",options->AvailPlotTimeStep);
						printError(messagestr,options);
					}
				} else if (options->AvailPlotTimeStep<3600) {
					if (3600%options->AvailPlotTimeStep!=0) {
						sprintf(messagestr,"SBAS plots Availability Time Step set to %d, but this time step is not a multiple of 3600 (needed only when hourly plots are enabled)",options->AvailPlotTimeStep);
						printError(messagestr,options);
					}
				}
			}
			if ( options->SBAScorrections==SBASMaps1freqUsed) {
				if(options->IonoPlotStep<0.01) {
					printError("SBAS plots Iono Step must be greater than 0 with a minimum resolution of 0.01 degrees",options);
				}
				if(options->IonoPlotTimeStep<=0) {
					printError("SBAS plots Iono Time Step must be greater than 0",options);

				} else if (options->SBASHourlyMaps==1) {
					//If hourly maps enabled, the time step must be a multiple of 3600, so hourly files are closed when a new hour starts
					if (options->IonoPlotTimeStep>3600) {
						if (options->IonoPlotTimeStep%3600!=0) {
							sprintf(messagestr,"SBAS plots Iono Time Step set to %d, but this time step is not divisible by 3600 (needed only when hourly plots are enabled)",options->IonoPlotTimeStep);
							printError(messagestr,options);
						}
					} else if (options->IonoPlotTimeStep<3600) {
						if (3600%options->IonoPlotTimeStep!=0) {
							sprintf(messagestr,"SBAS plots Iono Time Step set to %d, but this time step is not a multiple of 3600 (needed only when hourly plots are enabled)",options->IonoPlotTimeStep);
							printError(messagestr,options);
						}
					}
				}
			}
			if(options->ContRiskWindowSize<=0 ) {
				printError("Continuity Risk Sliding Window epoch size for SBAS plots must be greater than 0",options);
			}
			if(options->ContRiskWindowSizeMar<=0 ) {
				printError("Continuity Risk Sliding Window (maritime mode) epoch size for SBAS plots must be greater than 0",options);
			}
			if ( options->BrdcTypeSel[GPS] >= GPSLNAVvsCNAV ) {
				printError("GPS broadcast selection modes 'LNAVvsCNAV', 'CNAVvsLNAV', 'LNAVvsCNAV2', 'CNAV2vsLNAV', 'CNAVvsCNAV2' and 'CNAV2vsCNAV' are only for orbit comparison mode",options);
			} else if (options->BrdcTypeSel[GPS] != GPSLNAVOnly ) {
				printError("GPS broadcast selection mode can only be 'GPSLNAVOnly' in SBAS plots mode",options);
			}
			if ( options->BrdcTypeSel[Galileo] >= GalINAVvsFNAV ) {
				printError("Galileo broadcast selection modes 'INAVvsFNAV', 'FNAVvsINAV', 'INAVvsCNAV', 'CNAVvsINAV', 'INAVvsGNAV', 'GNAVvsINAV', 'FNAVvsCNAV', 'CNAVvsFNAV', 'FNAVvsGNAV', 'GNAVvsFNAV', 'CNAVvsGNAV' and 'GNAVvsCNAV' are only for orbit comparison mode",options);
			} else if (options->BrdcTypeSel[Galileo] != GalFNAVOnly ) {
				printError("Galileo broadcast selection mode can only be 'GalFNAVOnly' in SBAS plots mode",options);
			}
			if ( options->BrdcTypeSel[GLONASS] >= GLOFDMAvsCDMA ) {
				printError("Glonass broadcast selection modes 'FDMAvsCDMA' and 'CDMAvsFDMA' are only for orbit comparison mode",options);
			}
			if ( options->BrdcTypeSel[BDS] >= BDSD1vsD2 ) {
				printError("BeiDou broadcast selection modes 'D1vsD2', 'D2vsD1', 'D1vsCNAV1', 'CNAV1vsD1', 'D1vsCNAV2', 'CNAV2vsD1', 'D2vsCNAV1', 'CNAV1vsD2', 'D2vsCNAV2', 'CNAV2vsD2', 'CNAV1vsCNAV2' and 'CNAV2vsCNAV1'  are only for orbit comparison mode",options);
			}
			if ( options->BrdcTypeSel[QZSS] >= QZSLNAVvsCNAV ) {
				printError("QZSS broadcast selection modes 'LNAVvsCNAV', 'CNAVvsLNAV', 'LNAVvsCNAV2', 'CNAV2vsLNAV', 'CNAVvsCNAV2' and 'CNAV2vsCNAV' are only for orbit comparison mode",options);
			}
			if(options->percentile<=0. || options->percentile>100. ) {
				printError("Percentile for SBAS DOP maps must be greater than 0 and smaller or equal than 100",options);
			}

			//Check exclusion areas
			if (options->NumSBASPlotsExclusionArea>0) {
				for(i=0;i<options->NumSBASPlotsExclusionArea;i++) {
					//Check minimum longitude is between -180 and 180
					if (options->SBASPlotsExclusionAreaDelimeters[i][0]<-180 || options->SBASPlotsExclusionAreaDelimeters[i][0]>180) {
						sprintf(messagestr,"Minimum longitude must be between -180 and 180 degrees in this exclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsExclusionAreaDelimeters[i][1]<-180 || options->SBASPlotsExclusionAreaDelimeters[i][1]>180) {
						sprintf(messagestr,"Maximum longitude must be between -180 and 180 degrees in this exclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsExclusionAreaDelimeters[i][0]>options->SBASPlotsExclusionAreaDelimeters[i][1]) {
						sprintf(messagestr,"Maximum longitude must be greater than the minimum longitude in this exclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsExclusionAreaDelimeters[i][2]<-90 || options->SBASPlotsExclusionAreaDelimeters[i][2]>90) {
						sprintf(messagestr,"Minimum latitude must be between -90 and 90 degrees in this exclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsExclusionAreaDelimeters[i][3]<-90 || options->SBASPlotsExclusionAreaDelimeters[i][3]>90) {
						sprintf(messagestr,"Maximum latitude must be between -90 and 90 degrees in this exclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsExclusionAreaDelimeters[i][2]>options->SBASPlotsExclusionAreaDelimeters[i][3]) {
						sprintf(messagestr,"Maximum latitude must be greater than the minimum latitude  in this exclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					}
				}
			}

			//Check inclusion areas
			if (options->NumSBASPlotsInclusionArea>0) {
				for(i=0;i<options->NumSBASPlotsInclusionArea;i++) {
					//Check minimum longitude is between -180 and 180
					if (options->SBASPlotsInclusionAreaDelimeters[i][0]<-180 || options->SBASPlotsInclusionAreaDelimeters[i][0]>180) {
						sprintf(messagestr,"Minimum longitude must be between -180 and 180 degrees in this inclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsInclusionAreaDelimeters[i][1]<-180 || options->SBASPlotsInclusionAreaDelimeters[i][1]>180) {
						sprintf(messagestr,"Maximum longitude must be between -180 and 180 degrees in this inclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsInclusionAreaDelimeters[i][0]>options->SBASPlotsInclusionAreaDelimeters[i][1]) {
						sprintf(messagestr,"Maximum longitude must be greater than the minimum longitude in this inclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsInclusionAreaDelimeters[i][2]<-90 || options->SBASPlotsInclusionAreaDelimeters[i][2]>90) {
						sprintf(messagestr,"Minimum latitude must be between -90 and 90 degrees in this inclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsInclusionAreaDelimeters[i][3]<-90 || options->SBASPlotsInclusionAreaDelimeters[i][3]>90) {
						sprintf(messagestr,"Maximum latitude must be between -90 and 90 degrees in this inclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					} else if (options->SBASPlotsInclusionAreaDelimeters[i][2]>options->SBASPlotsInclusionAreaDelimeters[i][3]) {
						sprintf(messagestr,"Maximum latitude must be greater than the minimum latitude  in this inclusion area: %.2f, %.2f, %.2f, %.2f",options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
						printError(messagestr,options);
					}
				}
			}

			//Disable check of broadcast transmission time check if non set
			if ( options->brdcBlockTransTime == -1 ) options->brdcBlockTransTime = 0;
			// Disable excluding during smoothing convergence
			options->excludeSmoothingConvergence=0;
			//Stanford-ESA plots are disabled in this mode
			options->stanfordesa=0;
			//Disable transmission time of signal
			options->timeTrans=0;
			//Disable inital NPA mode for converging solution, so Klobuchar is not used for ionosphere
			options->initcoordNPA=0;
			//Disable mode switching
			options->switchmode = 0;
			//Set SBAS ionosphere if non set
			if (options->SBAScorrections==SBASMapsDFMCused) {
				//No Iono in SBAS DFMC
				options->ionoModel = NoIonoModel;
			} else {
				if(sopt->ionoModel==UNKNOWN_IM || sopt->ionoModel==SBASIonoModel ) {
					options->ionoModel = SBASIonoModel; 
				} else if (sopt->ionoModel==KlobucharIonoModel) {
					options->ionoModel = KlobucharIonoModel;
				} else if (sopt->ionoModel==NoIonoModel) {
					options->ionoModel = NoIonoModel;
				} else {
					printError("In SBAS 1F plots mode, only 'SBAS', 'Klobuchar' or 'no' are valid options for '-model:iono' parameter",options);
				}
			}

			//Check if HDOP or PDOP are enabled
			if (options->CombinedDOPPlot==1) {
				options->SBASplotsDOP=SBASplotsHDOPPDOPGDOP;
			} else if( (options->HDOPPlot==1 && options->PDOPPlot==1 && options->GDOPPlot==1) || (options->HDOPthreshold==1 && options->PDOPthreshold==1 && options->GDOPthreshold==1)) {
				options->SBASplotsDOP=SBASplotsHDOPPDOPGDOP;
			} else if( (options->HDOPPlot==1 && options->PDOPPlot==1) || (options->HDOPthreshold==1 && options->PDOPthreshold==1)) {
				options->SBASplotsDOP=SBASplotsHDOPandPDOP;
			} else if( (options->HDOPPlot==1 && options->GDOPPlot==1) || (options->HDOPthreshold==1 && options->GDOPthreshold==1)) {
				options->SBASplotsDOP=SBASplotsHDOPandGDOP;
			} else if( (options->PDOPPlot==1 && options->GDOPPlot==1) || (options->PDOPthreshold==1 && options->GDOPthreshold==1)) {
				options->SBASplotsDOP=SBASplotsPDOPandGDOP;
			} else if (options->HDOPPlot==1 || options->HDOPthreshold==1) {
				options->SBASplotsDOP=SBASplotsHDOPOnly;
			} else if (options->PDOPPlot==1 || options->PDOPthreshold==1) {
				options->SBASplotsDOP=SBASplotsPDOPOnly;
			} else if (options->GDOPPlot==1 || options->GDOPthreshold==1) {
				options->SBASplotsDOP=SBASplotsGDOPOnly;
			}

			//Set the output filename for availability file if non set
			if(sopt->sbasAvailplotsFile[0]=='\0' && options->NoAvailabilityPlot==0) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasAvailplotsFile,"SBASAvailPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasAvailplotsFileNoExtension,"SBASAvailPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasAvailplotsFile,"SBASAvailPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasAvailplotsFileNoExtension,"SBASAvailPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if (sopt->sbasAvailplotsFile[0]!='\0' && options->NoAvailabilityPlot==0) {
				removeExtension(sopt->sbasAvailplotsFile,sopt->sbasAvailplotsFileNoExtension);
			}


			//Set the output filename for continuity risk file if non set
			if(sopt->sbasRiskplotsFile[0]=='\0' && options->NoContRiskPlot==0) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasRiskplotsFile,"SBASRiskPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasRiskplotsFileNoExtension,"SBASRiskPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasRiskplotsFile,"SBASRiskPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasRiskplotsFileNoExtension,"SBASRiskPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if (sopt->sbasRiskplotsFile[0]!='\0' && options->NoContRiskPlot==0) {
				removeExtension(sopt->sbasRiskplotsFile,sopt->sbasRiskplotsFileNoExtension);
			}

			//Set the output filename for continuity risk for maritime file if non set
			if(sopt->sbasRiskMarplotsFile[0]=='\0' && options->NoContRiskMarPlot==0) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasRiskMarplotsFile,"SBASRiskMarPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasRiskMarplotsFileNoExtension,"SBASRiskMarPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasRiskMarplotsFile,"SBASRiskMarPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasRiskMarplotsFileNoExtension,"SBASRiskMarPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if (sopt->sbasRiskMarplotsFile[0]!='\0' && options->NoContRiskMarPlot==0) {
				removeExtension(sopt->sbasRiskMarplotsFile,sopt->sbasRiskMarplotsFileNoExtension);
			}

			//Set the output filename for discontinuity file if non set
			if(sopt->sbasDiscontinuityFile[0]=='\0' && options->ComputeRiskPlots==1 ) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasDiscontinuityFile,"SBASRiskDisc_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasDiscontinuityFileNoExtension,"SBASRiskDisc_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasDiscontinuityFile,"SBASRiskDisc_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasDiscontinuityFileNoExtension,"SBASRiskDisc_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if (sopt->sbasDiscontinuityFile[0]!='\0' && options->ComputeRiskPlots==1 ) {
				removeExtension(sopt->sbasDiscontinuityFile,sopt->sbasDiscontinuityFileNoExtension);
			}



			//Set the output filename for ionosphere availability if non set
			if (options->SBAScorrections==SBASMaps1freqUsed) {
				if(sopt->sbasIonoplotsFile[0]=='\0' && options->NoIonoPlot==0) {
					//Extract the name of the file without the extension and the path
					#if defined (__WIN32__)
						filepointer=strrchr(sopt->sbasFile,'\\');
					#elif defined (__CYGWIN__)
						filepointer=strrchr(sopt->sbasFile,'/');
					   //In cygwin, we may have linux or windows pathes
						if(filepointer==NULL) {
							filepointer=strrchr(sopt->sbasFile,'\\');
						}
					#else
						filepointer=strrchr(sopt->sbasFile,'/');
					#endif

					if (filepointer==NULL) {
						//There is no directory path in the file
						sprintf(sopt->sbasIonoplotsFile,"SBASIonoPlots_%s.txt",sopt->sbasFile);
						sprintf(sopt->sbasIonoplotsFileNoExtension,"SBASIonoPlots_%s",sopt->sbasFile);
					} else {
						//There are directories in the path
						sprintf(sopt->sbasIonoplotsFile,"SBASIonoPlots_%s.txt",(char *)(filepointer+sizeof(char)));
						sprintf(sopt->sbasIonoplotsFileNoExtension,"SBASIonoPlots_%s",(char *)(filepointer+sizeof(char)));
					}
				} else if(sopt->sbasIonoplotsFile[0]!='\0' && options->NoIonoPlot==0) {
					removeExtension(sopt->sbasIonoplotsFile,sopt->sbasIonoplotsFileNoExtension);
				}
			}

			//Set the output filename for HDOP map if non set
			if(sopt->sbasHDOPplotsFile[0]=='\0' && options->HDOPPlot==1) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasHDOPplotsFile,"SBASHDOPPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasHDOPplotsFileNoExtension,"SBASHDOPPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasHDOPplotsFile,"SBASHDOPPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasHDOPplotsFileNoExtension,"SBASHDOPPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if(sopt->sbasHDOPplotsFile[0]!='\0' && options->HDOPPlot==1) {
				removeExtension(sopt->sbasHDOPplotsFile,sopt->sbasHDOPplotsFileNoExtension);
			}

			//Set the output filename for PDOP map if non set
			if(sopt->sbasPDOPplotsFile[0]=='\0' && options->PDOPPlot==1) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasPDOPplotsFile,"SBASPDOPPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasPDOPplotsFileNoExtension,"SBASPDOPPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasPDOPplotsFile,"SBASPDOPPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasPDOPplotsFileNoExtension,"SBASPDOPPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if(sopt->sbasPDOPplotsFile[0]!='\0' && options->PDOPPlot==1) {
				removeExtension(sopt->sbasPDOPplotsFile,sopt->sbasPDOPplotsFileNoExtension);
			}

			//Set the output filename for GDOP map if non set
			if(sopt->sbasGDOPplotsFile[0]=='\0' && options->GDOPPlot==1) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasGDOPplotsFile,"SBASGDOPPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasGDOPplotsFileNoExtension,"SBASGDOPPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasGDOPplotsFile,"SBASGDOPPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasGDOPplotsFileNoExtension,"SBASGDOPPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if(sopt->sbasGDOPplotsFile[0]!='\0' && options->GDOPPlot==1) {
				removeExtension(sopt->sbasGDOPplotsFile,sopt->sbasGDOPplotsFileNoExtension);
			}

			//Set the output filename for Combined HDOP,PDOP and GDOP file if non set
			if(sopt->sbasCombDOPplotsFile[0]=='\0' && options->CombinedDOPPlot==1) {
				//Extract the name of the file without the extension and the path
				#if defined (__WIN32__)
					filepointer=strrchr(sopt->sbasFile,'\\');
				#elif defined (__CYGWIN__)
					filepointer=strrchr(sopt->sbasFile,'/');
				   //In cygwin, we may have linux or windows pathes
					if(filepointer==NULL) {
						filepointer=strrchr(sopt->sbasFile,'\\');
					}
				#else
					filepointer=strrchr(sopt->sbasFile,'/');
				#endif

				if (filepointer==NULL) {
					//There is no directory path in the file
					sprintf(sopt->sbasCombDOPplotsFile,"SBASCombDOPPlots_%s.txt",sopt->sbasFile);
					sprintf(sopt->sbasCombDOPplotsFileNoExtension,"SBASCombDOPPlots_%s",sopt->sbasFile);
				} else {
					//There are directories in the path
					sprintf(sopt->sbasCombDOPplotsFile,"SBASCombDOPPlots_%s.txt",(char *)(filepointer+sizeof(char)));
					sprintf(sopt->sbasCombDOPplotsFileNoExtension,"SBASCombDOPPlots_%s",(char *)(filepointer+sizeof(char)));
				}
			} else if(sopt->sbasCombDOPplotsFile[0]!='\0' && options->CombinedDOPPlot==1) {
				removeExtension(sopt->sbasCombDOPplotsFile,sopt->sbasCombDOPplotsFileNoExtension);
			}

			//Print INFO Messages
			sprintf(messagestr,"RINEX navigation message input file: %s",sopt->navFile[0]);
			printInfo(messagestr,options);
			sprintf(messagestr,"SBAS message data input file: %s",sopt->sbasFile);
			printInfo(messagestr,options);

			if (options->SBAScorrections==SBASMaps1freqUsed) {
				if (options->NoAvailabilityPlot==1) {
					printInfo("Compute Iono Corrections Availability plot for a Fault-Free Receiver",options);
				} else if (options->NoIonoPlot==1 && options->ComputeRiskPlots==1) {
					if (options->NoContRiskPlot==1) {
						sprintf(messagestr,"Compute SBAS 1F %sPA Availability and Maritime Continuity Risk plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					} else if (options->NoContRiskMarPlot==1) {
						sprintf(messagestr,"Compute SBAS 1F %sPA Availability and Aviation Continuity Risk plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					} else {
						sprintf(messagestr,"Compute SBAS 1F %sPA Availability, Aviation and Maritime Continuity Risk for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					}
					printInfo(messagestr,options);
				} else if (options->NoIonoPlot==1 && options->ComputeRiskPlots==0) {
					sprintf(messagestr,"Compute SBAS 1F %sPA Availability plot for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					printInfo(messagestr,options);
				} else {
					if (options->NoContRiskPlot==1) {
						sprintf(messagestr,"Compute SBAS 1F %sPA Availability, Maritime Continuity Risk and Iono Corrections Availability plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					} else if (options->NoContRiskMarPlot==1) {
						sprintf(messagestr,"Compute SBAS 1F %sPA Availability, Aviation Continuity Risk and Iono Corrections Availability plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					} else {
						sprintf(messagestr,"Compute SBAS 1F %sPA Availability, Aviation and Maritime Continuity Risk and Iono Corrections Availability plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					}
					printInfo(messagestr,options);
				}
			} else {
				if (options->ComputeRiskPlots==1) {
					if (options->NoContRiskPlot==1) {
						sprintf(messagestr,"Compute SBAS DFMC %sPA Availability and Maritime Continuity Risk plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					} else if (options->NoContRiskMarPlot==1) {
						sprintf(messagestr,"Compute SBAS DFMC %sPA Availability and Aviation Continuity Risk plots for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					} else {
						sprintf(messagestr,"Compute SBAS DFMC %sPA Availability, Aviation and Maritime Continuity Risk for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					}
					printInfo(messagestr,options);
				} else if (options->ComputeRiskPlots==0) {
					sprintf(messagestr,"Compute SBAS DFMC %sPA Availability plot for a Fault-Free Receiver",options->precisionapproach==PAMODE?"":"N");
					printInfo(messagestr,options);
				}
			}
			if((options->HDOPPlot==1 && options->PDOPPlot==1 && options->GDOPPlot==1) || options->CombinedDOPPlot==1) {
				printInfo("Compute SBAS HDOP, PDOP and GDOP plots for a Fault-Free Receiver",options);
			} else if (options->HDOPPlot==1 && options->PDOPPlot==1) {
				printInfo("Compute SBAS HDOP and PDOP plots for a Fault-Free Receiver",options);
			} else if (options->HDOPPlot==1 && options->GDOPPlot==1) {
				printInfo("Compute SBAS HDOP and GDOP plots for a Fault-Free Receiver",options);
			} else if (options->PDOPPlot==1 && options->GDOPPlot==1) {
				printInfo("Compute SBAS PDOP and GDOP plots for a Fault-Free Receiver",options);
			} else if (options->HDOPPlot==1) {
				printInfo("Compute SBAS HDOP plot for a Fault-Free Receiver",options);
			} else if (options->PDOPPlot==1) {
				printInfo("Compute SBAS PDOP plot for a Fault-Free Receiver",options);
			} else if (options->GDOPPlot==1) {
				printInfo("Compute SBAS GDOP plot for a Fault-Free Receiver",options);
			}

			if (options->DOPPercentile==1) {
				if(options->HDOPPlot==0 && options->PDOPPlot==0 && options->GDOPPlot==0 && options->CombinedDOPPlot==0) {
					printError("Percentiles for DOP maps is enabled (option '-sbasplots:doppercentile'), but no DOP map enabled. Enable any of the HDOP, PDOP, GDOP or Combined DOP maps by using the options '-sbasplots:hdopplot', '-sbasplots:pdopplot', '-sbasplots:gdopplot' or '-sbasplots:combdopplot' respectively.",options);
				} else {
					printInfo("Percentiles for DOP maps is enabled",options);
				}
			}
			if(options->SBASHourlyMaps==1) {
				printInfo("Hourly plots option is enabled. Each hour will be written in a separate file",options);
			} else {
				printInfo("Hourly plots option is disabled",options);
			}

			sprintf(messagestr,"Elevation mask: %.2f degrees",options->elevationMask/d2r);
			printInfo(messagestr,options);
			if (options->SBASPlotsMinGEOElev == -99.99f) {
				sprintf(messagestr,"SBAS GEO Elevation mask: Disabled");
			} else {
				sprintf(messagestr,"SBAS GEO Elevation mask: %.2f degrees",(double)(options->SBASPlotsMinGEOElev)*r2d);
			}
			printInfo(messagestr,options);

			sprintf(messagestr,"Minimum latitude  for plots: %7.2f degrees",options->minLatplots);
			printInfo(messagestr,options);
			sprintf(messagestr,"Maximum latitude  for plots: %7.2f degrees",options->maxLatplots);
			printInfo(messagestr,options);
			sprintf(messagestr,"Minimum longitude for plots: %7.2f degrees",options->minLonplots);
			printInfo(messagestr,options);
			sprintf(messagestr,"Maximum longitude for plots: %7.2f degrees",options->maxLonplots);
			printInfo(messagestr,options);
			for(i=0;i<options->NumSBASPlotsInclusionArea;i++) {
				sprintf(messagestr,"Inclusion area #%d (MinLon, MaxLon, MinLat, MaxLat): %7.2f %7.2f %6.2f %6.2f (degrees)",i+1,options->SBASPlotsInclusionAreaDelimeters[i][0],options->SBASPlotsInclusionAreaDelimeters[i][1],options->SBASPlotsInclusionAreaDelimeters[i][2],options->SBASPlotsInclusionAreaDelimeters[i][3]);
				printInfo(messagestr,options);
			}
			for(i=0;i<options->NumSBASPlotsExclusionArea;i++) {
				sprintf(messagestr,"Exclusion area #%d (MinLon, MaxLon, MinLat, MaxLat): %7.2f %7.2f %6.2f %6.2f (degrees)",i+1,options->SBASPlotsExclusionAreaDelimeters[i][0],options->SBASPlotsExclusionAreaDelimeters[i][1],options->SBASPlotsExclusionAreaDelimeters[i][2],options->SBASPlotsExclusionAreaDelimeters[i][3]);
				printInfo(messagestr,options);
			}
			if(options->SBASPlotsRecHeight==0.) {
				sprintf(messagestr,"Receiver height for plots: %.2f metres (over the WGS84 geoid)",options->SBASPlotsRecHeight);
			} else {
				sprintf(messagestr,"Receiver height for plots: %.2f metres",options->SBASPlotsRecHeight);
			}
			printInfo(messagestr,options);
			if (options->NoAvailabilityPlot==0) {
				sprintf(messagestr,"Horizontal Alarm Limit: %3.2f metres",options->HorAlarmLimit);
				printInfo(messagestr,options);
				sprintf(messagestr,"Vertical   Alarm Limit: %3.2f metres",options->VerAlarmLimit);
				printInfo(messagestr,options);
			}
			if (options->HDOPPlot==1 || options->PDOPPlot==1 ||options->GDOPPlot==1) {
				if (options->ComputeRiskPlots==1) {
					sprintf(messagestr,"Step for SBAS Availability, Continuity Risk and DOP: %2.2f degree%s",options->AvailabilityPlotStep,options->AvailabilityPlotStep!=1.?"s":"");
					printInfo(messagestr,options);
				} else {
					sprintf(messagestr,"Step for SBAS Availability and DOP:                  %2.2f degree%s",options->AvailabilityPlotStep,options->AvailabilityPlotStep!=1.?"s":"");
					printInfo(messagestr,options);
				}
			} else if (options->NoAvailabilityPlot==0 && options->ComputeRiskPlots==1) {
				sprintf(messagestr,"Step for SBAS Availability and Continuity Risk:      %2.2f degree%s",options->AvailabilityPlotStep,options->AvailabilityPlotStep!=1.?"s":"");
				printInfo(messagestr,options);
			} else if (options->NoAvailabilityPlot==0 && options->ComputeRiskPlots==0) {
				sprintf(messagestr,"Step for SBAS Availability:                          %2.2f degree%s",options->AvailabilityPlotStep,options->AvailabilityPlotStep!=1.?"s":"");
				printInfo(messagestr,options);
			}
			if (options->SBAScorrections==SBASMaps1freqUsed) {
				if (options->NoIonoPlot==0) {
					sprintf(messagestr,"Step for SBAS Ionosphere Corrections Availability:   %2.2f degree%s",options->IonoPlotStep,options->IonoPlotStep!=1.?"s":"");
					printInfo(messagestr,options);
				}

				if (options->ionoModel == NoIonoModel) {
					if (options->HDOPPlot==1 || options->PDOPPlot==1 ||options->GDOPPlot==1) {
						if (options->ComputeRiskPlots==1) {
							printInfo("SBAS ionosphere is disabled in SBAS 1F Availability, Continuity Risk and DOP plots",options);
						} else {
							printInfo("SBAS ionosphere is disabled in SBAS 1F Availability and DOP plots",options);
						}
					} else if (options->NoAvailabilityPlot==0 && options->ComputeRiskPlots==1) {
						printInfo("SBAS ionosphere is disabled in SBAS 1F Availability and Continuity Risk plots",options);
					} else if (options->ComputeRiskPlots==1) {
						printInfo("SBAS ionosphere is disabled in SBAS 1F Availability plot",options);
					}
				}
			}
			if (options->HDOPPlot==1 || options->PDOPPlot==1 ||options->GDOPPlot==1) {
				if (options->ComputeRiskPlots==1) {
					sprintf(messagestr,"Time step for SBAS Availability, Continuity Risk and DOP: %d second%s",options->AvailPlotTimeStep,options->AvailPlotTimeStep>1?"s":"");
					printInfo(messagestr,options);
				} else {
					sprintf(messagestr,"Time step for SBAS Availability and DOP:                  %d second%s",options->AvailPlotTimeStep,options->AvailPlotTimeStep>1?"s":"");
					printInfo(messagestr,options);
				}
			} else if (options->NoAvailabilityPlot==0 && options->ComputeRiskPlots==1) {
				sprintf(messagestr,"Time step for SBAS Availability and Continuity Risk:      %d second%s",options->AvailPlotTimeStep,options->AvailPlotTimeStep>1?"s":"");
				printInfo(messagestr,options);
			} else if (options->NoAvailabilityPlot==0 && options->ComputeRiskPlots==0) {
				sprintf(messagestr,"Time step for SBAS Availability:                          %d second%s",options->AvailPlotTimeStep,options->AvailPlotTimeStep>1?"s":"");
				printInfo(messagestr,options);
			}

			if (options->SBAScorrections==SBASMaps1freqUsed) {
				if (options->NoIonoPlot==0) {
					sprintf(messagestr,"Time step for SBAS Ionosphere Corrections Availability:   %d second%s",options->IonoPlotTimeStep,options->IonoPlotTimeStep>1?"s":"");
					printInfo(messagestr,options);
				}
			}

			if (options->NoContRiskPlot==0) {
				sprintf(messagestr,"Sliding Window Size for Aviation Continuity Risk: %3d seconds",options->ContRiskWindowSize);
				printInfo(messagestr,options);
			}
			if (options->NoContRiskPlot==0) {
				sprintf(messagestr,"Fixed   Window Size for Maritime Continuity Risk: %3d seconds",options->ContRiskWindowSizeMar);
				printInfo(messagestr,options);
			}

			sprintf(messagestr,"SBAS Signal flight time: %.6g seconds",options->SBASmsgFlightTime);
			printInfo(messagestr,options);

			sprintf(messagestr,"Ignore SBAS MT 0: %3s",options->usetype0messages==1?"OFF":"ON");
			printInfo(messagestr,options);

			if (options->SBAScorrections==SBASMaps1freqUsed) {
				sprintf(messagestr,"Read SBAS 1F MT 0 as MT 2: %3s",options->useAlarmmessageForCorrections==1?"ON":"OFF");
				printInfo(messagestr,options);

				if (options->ionoModel == KlobucharIonoModel) {
					sprintf(messagestr,"Klobuchar ionosphere model used for SBAS 1F Availability plots");
					printInfo(messagestr,options);
				} else if (options->ionoModel == NoIonoModel) {
					sprintf(messagestr,"Ionosphere model disabled for SBAS 1F Availability plots");
					printInfo(messagestr,options);
				}
			} else {
				sprintf(messagestr,"SBAS DFMC Read MT 0 as MT 34/35/36: %3s",options->useAlarmmessageForCorrections==1?"ON":"OFF");
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS DFMC Read MT37    using ED-259 version <=0.4: %3s",options->SBASDFMCMT37version!=MT37V1?"ON":"OFF");
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS DFMC Read MT39/40 using ED-259 version <=0.4: %3s",options->SBASDFMCMT3940version!=MT3940V1?"ON":"OFF");
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS DFMC Read MT42    using ED-259 version <=0.7: %3s",options->SBASDFMCMT42version!=MT42V1?"ON":"OFF");
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS DFMC Read MT47    using ED-259 version <=0.4: %3s",options->SBASDFMCMT47version!=MT47V1?"ON":"OFF");
				printInfo(messagestr,options);
			}

			if(options->HDOPthreshold == 1) {
				sprintf(messagestr,"HDOP Threshold for skipping epoch%s: %.2f",options->switchGEO==1?" or switching GEO":"",options->maxHDOP);
				printInfo(messagestr,options);
			} else {
				sprintf(messagestr,"HDOP Filter: OFF");
				printInfo(messagestr,options);
			}
			if(options->PDOPthreshold == 1) {
				sprintf(messagestr,"PDOP Threshold for skipping epoch%s: %.2f",options->switchGEO==1?" or switching GEO":"",options->maxPDOP);
				printInfo(messagestr,options);
			} else {
				sprintf(messagestr,"PDOP Filter: OFF");
				printInfo(messagestr,options);
			}
			if (options->GDOPthreshold == 1) {
				sprintf(messagestr,"GDOP Threshold for skipping epoch%s: %.2f",options->switchGEO==1?" or switching GEO":"",options->maxGDOP);
				printInfo(messagestr,options);
			} else {
				sprintf(messagestr,"GDOP Filter: OFF");
				printInfo(messagestr,options);
			}
			if(options->HDOPorPDOP == 1) {
				 printInfo("HDOP and PDOP filters are ORed (i.e. only one of the conditions have to be met)",options);
			}

			if (options->SBAScorrections==SBASMaps1freqUsed) {
				if (options->precisionapproach==PAMODE) {
					//PA mode only
					sprintf(messagestr,"SBAS MT  0 (Do not Use for Safety Applications) timeout PA: %7d (seconds)",options->usertmout[1][0]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  1 (PRN Mask)                           timeout PA: %7d (seconds)",options->usertmout[1][1]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  6 (Integrity Info)                     timeout PA: %7d (seconds)",options->usertmout[1][6]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  7 (Fast Correction Degradation Factor) timeout PA: %7d (seconds)",options->usertmout[1][7]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  9 (GEO Navigation Message)             timeout PA: %7d (seconds)",options->usertmout[1][9]);
					printInfo(messagestr,options);
					if (options->NoMT10==1) {
						sprintf(messagestr,"SBAS MT 10 (Degradation Parameters)             Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 10 (Degradation Parameters)             timeout PA: %7d (seconds)",options->usertmout[1][10]);
						printInfo(messagestr,options);
					}
					sprintf(messagestr,"SBAS MT 12 (Network Time Parameters)            timeout PA: %7d (seconds)",options->usertmout[1][12]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 17 (GEO satellite Almanacs)             timeout PA: %7d (seconds)",options->usertmout[1][17]);
					printInfo(messagestr,options);
					if (options->ionoModel!=SBASIonoModel && options->NoIonoPlot == 1) {
						sprintf(messagestr,"SBAS MT 18 (Ionospheric Grid Points Mask)       Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 18 (Ionospheric Grid Points Mask)       timeout PA: %7d (seconds)",options->usertmout[1][18]);
						printInfo(messagestr,options);
					}
					sprintf(messagestr,"SBAS MT 25 (Long Term Satellite Corrections)    timeout PA: %7d (seconds)",options->usertmout[1][25]);
					printInfo(messagestr,options);
					if (options->ionoModel!=SBASIonoModel && options->NoIonoPlot == 1) {
						sprintf(messagestr,"SBAS MT 26 (Ionospheric Delay Corrections)      Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 26 (Ionospheric Delay Corrections)      timeout PA: %7d (seconds)",options->usertmout[1][26]);
						printInfo(messagestr,options);
					}
					if (options->NoDeltaUDRE==1) {
						sprintf(messagestr,"SBAS MT 27 (Service Message)                    Message disabled");
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 28 (Clock Ephemeris Covariance Matrix)  Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 27 (Service Message)                    timeout PA: %7d (seconds)",options->usertmout[1][27]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 28 (Clock Ephemeris Covariance Matrix)  timeout PA: %7d (seconds)",options->usertmout[1][28]);
						printInfo(messagestr,options);
					}
				} else {
					//NPA mode only
					sprintf(messagestr,"SBAS MT  0 (Do not Use for Safety Applications) timeout NPA: %7d (seconds)",options->usertmout[0][0]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  1 (PRN Mask)                           timeout NPA: %7d (seconds)",options->usertmout[0][1]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  6 (Integrity Info)                     timeout NPA: %7d (seconds)",options->usertmout[0][6]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  7 (Fast Correction Degradation Factor) timeout NPA: %7d (seconds)",options->usertmout[0][7]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT  9 (GEO Navigation Message)             timeout NPA: %7d (seconds)",options->usertmout[0][9]);
					printInfo(messagestr,options);
					if (options->NoMT10==1) {
						sprintf(messagestr,"SBAS MT 10 (Degradation Parameters)             Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 10 (Degradation Parameters)             timeout NPA: %7d (seconds)",options->usertmout[0][10]);
						printInfo(messagestr,options);
					}
					sprintf(messagestr,"SBAS MT 12 (Network Time Parameters)            timeout NPA: %7d (seconds)",options->usertmout[0][12]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 17 (GEO satellite Almanacs)             timeout NPA: %7d (seconds)",options->usertmout[0][17]);
					printInfo(messagestr,options);
					if (options->ionoModel!=SBASIonoModel && options->NoIonoPlot == 1) {
						sprintf(messagestr,"SBAS MT 18 (Ionospheric Grid Points Mask)       Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 18 (Ionospheric Grid Points Mask)       timeout NPA: %7d (seconds)",options->usertmout[0][18]);
						printInfo(messagestr,options);
					}
					sprintf(messagestr,"SBAS MT 25 (Long Term Satellite Corrections)    timeout NPA: %7d (seconds)",options->usertmout[0][25]);
					printInfo(messagestr,options);
					if (options->ionoModel!=SBASIonoModel && options->NoIonoPlot == 1) {
						sprintf(messagestr,"SBAS MT 26 (Ionospheric Delay Corrections)      Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 26 (Ionospheric Delay Corrections)      timeout NPA: %7d (seconds)",options->usertmout[0][26]);
						printInfo(messagestr,options);
					}
					if (options->NoDeltaUDRE==1) {
						sprintf(messagestr,"SBAS MT 27 (Service Message)                    Message disabled");
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 28 (Clock Ephemeris Covariance Matrix)  Message disabled");
						printInfo(messagestr,options);
					} else {
						sprintf(messagestr,"SBAS MT 27 (Service Message)                    timeout NPA: %7d (seconds)",options->usertmout[0][27]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 28 (Clock Ephemeris Covariance Matrix)  timeout NPA: %7d (seconds)",options->usertmout[0][28]);
						printInfo(messagestr,options);
					}
				}
				if(options->FCtmout[1]!=-1 && options->FCtmout[0]==-1) {
					sprintf(messagestr,"SBAS Fast corrections timeout PA: %3d (seconds)",options->FCtmout[1]);
					printInfo(messagestr,options);
				} else if (options->FCtmout[1]==-1 && options->FCtmout[0]!=-1) {
					sprintf(messagestr,"SBAS Fast corrections timeout NPA: %3d (seconds)",options->FCtmout[0]);
					printInfo(messagestr,options);
				} else if (options->FCtmout[1]!=-1 && options->FCtmout[0]!=-1) {
					sprintf(messagestr,"SBAS Fast corrections timeout PA: %3d NPA: %3d (seconds)",options->FCtmout[1],options->FCtmout[0]);
					printInfo(messagestr,options);
				}
				if(options->RRCtmout[1]!=-1 && options->RRCtmout[0]==-1) {
					sprintf(messagestr,"SBAS RRC  corrections timeout PA: %3d (seconds)",options->RRCtmout[1]);
					printInfo(messagestr,options);
				} else if (options->RRCtmout[1]==-1 && options->RRCtmout[0]!=-1) {
					sprintf(messagestr,"SBAS RRC  corrections timeout NPA: %3d (seconds)",options->RRCtmout[0]);
					printInfo(messagestr,options);
				} else if (options->RRCtmout[1]!=-1 && options->RRCtmout[0]!=-1) {
					sprintf(messagestr,"SBAS RRC  corrections timeout PA: %3d NPA: %3d (seconds)",options->RRCtmout[1],options->RRCtmout[0]);
					printInfo(messagestr,options);
				}

				if(options->NoFastCorrection == 1) {
					sprintf(messagestr,"SBAS Fast and RRC corrections set to 0");
					printInfo(messagestr,options);
				} else if (options->NoRRCCorrection==1) {
					sprintf(messagestr,"SBAS RRC corrections set to 0");
					printInfo(messagestr,options);
				}
				if(options->NoSlowCorrection==1) {
					sprintf(messagestr,"SBAS slow corrections set to 0");
					printInfo(messagestr,options);
				}
				if (options->NoIonoCorrection==1) {
					sprintf(messagestr,"SBAS ionosphere corrections set to 0");
					printInfo(messagestr,options);
				}
				if (options->NoFastDeg==1 && options->NoFastSigma==0) {
					sprintf(messagestr,"SBAS Fast degradation term set to 0");
					printInfo(messagestr,options);
				}
				if (options->NoFastSigma==1) {
					sprintf(messagestr,"SBAS Sigma UDRE, Fast and RRC degradation terms set to 0");
					printInfo(messagestr,options);
				} else if (options->NoRRCSigma==1) {
					sprintf(messagestr,"SBAS RRC degradation term set to 0");
					printInfo(messagestr,options);
				}
				if (options->NoSlowSigma==1) {
					sprintf(messagestr,"SBAS slow degradation term set to 0");
					printInfo(messagestr,options);
				}
				if (options->NoEnRouteSigma==1) {
					sprintf(messagestr,"SBAS En Route degradation term set to 0");
					printInfo(messagestr,options);
				}
				if (options->NoDeltaUDRE==1) {
					sprintf(messagestr,"SBAS Delta UDRE set to 1");
					printInfo(messagestr,options);
				}
				if (options->NoIonoSigma==1) {
					sprintf(messagestr,"SBAS ionosphere sigma set to 0");
					printInfo(messagestr,options);
				}
				if(options->NoTropoSigma==1) {
					sprintf(messagestr,"SBAS troposphere sigma set to 0");
					printInfo(messagestr,options);
				}
			} else {
				//SBAS DFMC
				if (options->switchmode==1) {
					//Switch mode enabled. Show both timeouts
					sprintf(messagestr,"SBAS MT  0 (Do not Use for Safety Applications)                 timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][0],options->usertmout[0][0]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 31 (Satellite Mask)                                     timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][31],options->usertmout[0][31]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 34/35/36 (Integrity Messages)                           timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][34],options->usertmout[0][34]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 37 (OBAD parameters and DFREI scale table)              timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][37],options->usertmout[0][37]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 42 (GNSS Time Offsets)                                  timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][42],options->usertmout[0][42]);
					printInfo(messagestr,options);
					sprintf(messagestr,"SBAS MT 47 (SBAS satellites almanacs)                           timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][47],options->usertmout[0][47]);
					printInfo(messagestr,options);
				} else {
					if (options->precisionapproach==PAMODE) {
						//PA mode only
						sprintf(messagestr,"SBAS MT  0 (Do not Use for Safety Applications)                 timeout PA: %7d (seconds)",options->usertmout[1][0]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 31 (Satellite Mask)                                     timeout PA: %7d (seconds)",options->usertmout[1][31]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 34/35/36 (Integrity Messages)                           timeout PA: %7d (seconds)",options->usertmout[1][34]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 37 (OBAD parameters and DFREI scale table)              timeout PA: %7d (seconds)",options->usertmout[1][37]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 42 (GNSS Time Offsets)                                  timeout PA: %7d (seconds)",options->usertmout[1][42]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 47 (SBAS satellites almanacs)                           timeout PA: %7d (seconds)",options->usertmout[1][47]);
						printInfo(messagestr,options);
					} else {
						//NPA mode only
						sprintf(messagestr,"SBAS MT  0 (Do not Use for Safety Applications)                 timeout NPA: %7d (seconds)",options->usertmout[0][0]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 31 (Satellite Mask)                                     timeout NPA: %7d (seconds)",options->usertmout[0][31]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 34/35/36 (Integrity Messages)                           timeout NPA: %7d (seconds)",options->usertmout[0][34]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 37 (OBAD parameters and DFREI scale table)              timeout NPA: %7d (seconds)",options->usertmout[0][37]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 42 (GNSS Time Offsets)                                  timeout NPA: %7d (seconds)",options->usertmout[0][42]);
						printInfo(messagestr,options);
						sprintf(messagestr,"SBAS MT 47 (SBAS satellites almanacs)                           timeout NPA: %7d (seconds)",options->usertmout[0][47]);
						printInfo(messagestr,options);
					}
				}
				if (options->usertmout[1][32]!=-1 && options->usertmout[0][32]==-1) {
					sprintf(messagestr,"SBAS MT 32 (Clock-Ephemeris corrections and covariance matrix)  timeout PA: %7d (seconds)",options->usertmout[1][32]);
					printInfo(messagestr,options);
				} else if (options->usertmout[1][32]==-1 && options->usertmout[0][32]!=-1) {
					sprintf(messagestr,"SBAS MT 32 (Clock-Ephemeris corrections and covariance matrix)  timeout NPA: %7d (seconds)",options->usertmout[0][32]);
					printInfo(messagestr,options);
				} else if (options->usertmout[1][32]!=-1 && options->usertmout[0][32]!=-1) {
					sprintf(messagestr,"SBAS MT 32 (Clock-Ephemeris corrections and covariance matrix)  timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][32],options->usertmout[0][32]);
					printInfo(messagestr,options);
				}

				if (options->usertmout[1][39]!=-1 && options->usertmout[0][39]==-1) {
					sprintf(messagestr,"SBAS MT 39/40 (SBAS satellites ephemeris and covariance matrix) timeout PA: %7d (seconds)",options->usertmout[1][39]);
					printInfo(messagestr,options);
				} else if (options->usertmout[1][39]==-1 && options->usertmout[0][39]!=-1) {
					sprintf(messagestr,"SBAS MT 39/40 (SBAS satellites ephemeris and covariance matrix) timeout NPA: %7d (seconds)",options->usertmout[0][39]);
					printInfo(messagestr,options);
				} else if (options->usertmout[1][39]!=-1 && options->usertmout[0][39]!=-1) {
					sprintf(messagestr,"SBAS MT 39/40 (SBAS satellites ephemeris and covariance matrix) timeout PA: %7d NPA: %7d (seconds)",options->usertmout[1][39],options->usertmout[0][39]);
					printInfo(messagestr,options);
				}
				if (options->SBASDFMCcer!=-1.) {
					sprintf(messagestr,"SBAS DFMC MT 37 Cer: %.6g (metres)",options->SBASDFMCcer);
					printInfo(messagestr,options);
				}
				if (options->SBASDFMCccovariance!=-1.) {
					sprintf(messagestr,"SBAS DFMC MT 37 Ccovariance: %.6g",options->SBASDFMCccovariance);
					printInfo(messagestr,options);
				}
				j=0;
				for(i=0;i<MAX_GNSS;i++) {
					if (options->SBASDFMCicorr[i]!=-1.) {
						if(j==0) {
							j=sprintf(messagestr,"SBAS DFMC MT 37 Icorr (seconds):      ");
						}
						j+=sprintf(&messagestr[j]," %s: %.6g",gnsstype2gnssstr(i),options->SBASDFMCicorr[i]);
					}
				}
				if(j>0) {
					printInfo(messagestr,options);
				}
				j=0;
				for(i=0;i<MAX_GNSS;i++) {
					if (options->SBASDFMCccorr[i]!=-1.) {
						if(j==0) {
							j=sprintf(messagestr,"SBAS DFMC MT 37 Ccorr (metres):       ");
						}
						j+=sprintf(&messagestr[j]," %s: %.6g",gnsstype2gnssstr(i),options->SBASDFMCccorr[i]);
					}
				}
				if(j>0) {
					printInfo(messagestr,options);
				}
				j=0;
				for(i=0;i<MAX_GNSS;i++) {
					if (options->SBASDFMCrcorr[i]!=-1.) {
						if(j==0) {
							j=sprintf(messagestr,"SBAS DFMC MT 37 Rcorr (metres/second):");
						}
						j+=sprintf(&messagestr[j]," %s: %.6g",gnsstype2gnssstr(i),options->SBASDFMCrcorr[i]);
					}
				}
				if(j>0) {
					printInfo(messagestr,options);
				}
				if (options->SBASDFMCdeltaRcorr!=-1.) {
					sprintf(messagestr,"SBAS DFMC MT 32 or MT39/40 DeltaRcorr: %.6g",options->SBASDFMCdeltaRcorr);
					printInfo(messagestr,options);
				}
				j=0;
				for(i=0;i<15;i++) {
					if (options->SBASDFMCdfreiTable[i]!=-1.) {
						if (j==0) {
							j=sprintf(messagestr,"SBAS DFMC User defined DFREIs:");
						}
						j+=sprintf(&messagestr[j]," %d: %.6g",i,options->SBASDFMCdfreiTable[i]);
					}
				}
				if(j>0) {
					printInfo(messagestr,options);
				}
				if (options->SBASDFMCdeltaDFRE!=-1.) {
					sprintf(messagestr,"SBAS DFMC DeltaDFRE: %.6g",options->SBASDFMCdeltaDFRE);
					printInfo(messagestr,options);
				}
				if (options->SBASDFMCsigmauire !=-1.) {
					sprintf(messagestr,"SBAS DFMC Sigma UIRE: %.6g (metres)",options->SBASDFMCsigmauire);
					printInfo(messagestr,options);
				}
				if (options->SBASDFMCsigmatropo !=-1.) {
					sprintf(messagestr,"SBAS DFMC Sigma troposphere: %.6g (metres)",options->SBASDFMCsigmatropo);
					printInfo(messagestr,options);
				}
			}
			if (options->switchmode==1) {
				sprintf(messagestr,"SBAS Kh factor PA: %.6g NPA: %.6g",options->kfactor[PAMODE][KHORPOS],options->kfactor[NPAMODE][KHORPOS]);
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS Kv factor PA: %.6g NPA: %.6g",options->kfactor[PAMODE][KVERPOS],options->kfactor[NPAMODE][KVERPOS]);
				printInfo(messagestr,options);
			} else {
			   if (options->precisionapproach==PAMODE) {
				   sprintf(messagestr,"SBAS Kh factor PA: %.6g",options->kfactor[PAMODE][KHORPOS]);
				   printInfo(messagestr,options);
				   sprintf(messagestr,"SBAS Kv factor PA: %.6g",options->kfactor[PAMODE][KVERPOS]);
				   printInfo(messagestr,options);
				} else {
				   sprintf(messagestr,"SBAS Kh factor NPA: %.6g",options->kfactor[NPAMODE][KHORPOS]);
				   printInfo(messagestr,options);
				   sprintf(messagestr,"SBAS Kv factor NPA: %.6g",options->kfactor[NPAMODE][KVERPOS]);
				   printInfo(messagestr,options);
			   }	   
			}
			if (options->airborneReceiverType==0) {
				sprintf(messagestr,"SBAS Receiver type: user defined");
				printInfo(messagestr,options);
			} else {
				sprintf(messagestr,"SBAS Receiver type: %d",options->airborneReceiverType);
				printInfo(messagestr,options);
			}
			if (options->usersigmamultipath==1) {
				sprintf(messagestr,"SBAS Receiver sigma multipath read from file");
				printInfo(messagestr,options);
			} else {
				sprintf(messagestr,"SBAS Receiver sigma noise:      %.6g (metres)",options->sigma2noise==-1?0.36:sqrt(options->sigma2noise));
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS Receiver sigma divergence: %.6g (metres)",options->sigma2divergence==-1?0:sqrt(options->sigma2divergence));
				printInfo(messagestr,options);
				sprintf(messagestr,"SBAS Receiver sigma multipath:  %.6g + %.6g*e^(-elev/%.6g) (metres)",options->sigma2multipath[0]==-99999.?0.13:options->sigma2multipath[0],options->sigma2multipath[1]==-99999.?0.53:options->sigma2multipath[1],1./options->sigma2multipath[2]);
				printInfo(messagestr,options);
				if (options->SBAScorrections==SBASMapsDFMCused) {
					sprintf(messagestr,"SBAS Receiver sigma multipath factor: %.6g",options->SBASDFMCsigmaMultipathFactor==-1.?2.59:options->SBASDFMCsigmaMultipathFactor);
					printInfo(messagestr,options);
				}
			}
			if (options->NoAvailabilityPlot==0) {
				sprintf(messagestr,"Output file for SBAS Availability plots:             %s",sopt->sbasAvailplotsFile);
				printInfo(messagestr,options);
			}
			
			if (options->ComputeRiskPlots==1) {
				if (options->NoContRiskPlot==0) {
					sprintf(messagestr,"Output file for SBAS Aviation Continuity Risk plots: %s",sopt->sbasRiskplotsFile);
					printInfo(messagestr,options);
				}
				if (options->NoContRiskMarPlot==0) {
					sprintf(messagestr,"Output file for SBAS Maritime Continuity Risk plots: %s",sopt->sbasRiskMarplotsFile);
					printInfo(messagestr,options);
				}
				sprintf(messagestr,"Output file for SBAS discontinuities:                %s",sopt->sbasDiscontinuityFile);
				printInfo(messagestr,options);
			}
			if (options->SBAScorrections==SBASMaps1freqUsed) {
				if (options->NoIonoPlot==0) {
					sprintf(messagestr,"Output file for SBAS Ionosphere Availability plots:  %s",sopt->sbasIonoplotsFile);
					printInfo(messagestr,options);
				}
			}
			if (options->HDOPPlot==1) {
				sprintf(messagestr,"Output file for SBAS HDOP plots:                     %s",sopt->sbasHDOPplotsFile);
				printInfo(messagestr,options);
			}
			if (options->PDOPPlot==1) {
				sprintf(messagestr,"Output file for SBAS PDOP plots:                     %s",sopt->sbasPDOPplotsFile);
				printInfo(messagestr,options);
			}
			if (options->GDOPPlot==1) {
				sprintf(messagestr,"Output file for SBAS GDOP plots:                     %s",sopt->sbasGDOPplotsFile);
				printInfo(messagestr,options);
			}
			if (options->CombinedDOPPlot==1) {
				sprintf(messagestr,"Output file for SBAS combined DOP plots:             %s",sopt->sbasCombDOPplotsFile);
				printInfo(messagestr,options);
			}
			return 1;
		} else if ( nProd == 1 ) {
			options->workMode = wmSHOWPRODUCT;
			if ( options->BrdcTypeSel[GPS] >= GPSLNAVvsCNAV ) {
				printError("GPS broadcast selection modes 'LNAVvsCNAV', 'CNAVvsLNAV', 'LNAVvsCNAV2', 'CNAV2vsLNAV', 'CNAVvsCNAV2' and 'CNAV2vsCNAV' are only for orbit comparison mode",options);
			}
			if ( options->BrdcTypeSel[Galileo] >= GalINAVvsFNAV ) {
				printError("Galileo broadcast selection modes 'INAVvsFNAV', 'FNAVvsINAV', 'INAVvsCNAV', 'CNAVvsINAV', 'INAVvsGNAV', 'GNAVvsINAV', 'FNAVvsCNAV', 'CNAVvsFNAV', 'FNAVvsGNAV', 'GNAVvsFNAV', 'CNAVvsGNAV' and 'GNAVvsCNAV' are only for orbit comparison mode",options);
			}
			if ( options->BrdcTypeSel[GLONASS] >= GLOFDMAvsCDMA ) {
				printError("Glonass broadcast selection modes 'FDMAvsCDMA' and 'CDMAvsFDMA' are only for orbit comparison mode",options);
			}
			if ( options->BrdcTypeSel[BDS] >= BDSD1vsD2 ) {
				printError("BeiDou broadcast selection modes 'D1vsD2', 'D2vsD1', 'D1vsCNAV1', 'CNAV1vsD1', 'D1vsCNAV2', 'CNAV2vsD1', 'D2vsCNAV1', 'CNAV1vsD2', 'D2vsCNAV2', 'CNAV2vsD2', 'CNAV1vsCNAV2' and 'CNAV2vsCNAV1' are only for orbit comparison mode",options);
			}
			if ( options->BrdcTypeSel[QZSS] >= QZSLNAVvsCNAV ) {
				printError("QZSS broadcast selection modes 'LNAVvsCNAV', 'CNAVvsLNAV', 'LNAVvsCNAV2', 'CNAV2vsLNAV', 'CNAVvsCNAV2' and 'CNAV2vsCNAV' are only for orbit comparison mode",options);
			}
			if ( options->printMeas == -1 ) options->printMeas = 0;
			printInfo("Show satellite information mode", options);
		} else if ( nProd == 2 ) {
			options->workMode = wmCOMPAREORBITS;
			if ( options->printMeas == -1 ) options->printMeas = 0;
			printInfo("Compare orbits & clocks mode", options);
			if (sopt->numOrb!=sopt->numClk) {
				sprintf(messagestr, "Inconsistent number of orb and clk input files (%d vs %d)", sopt->numOrb, sopt->numClk);
				printError(messagestr,options);
			}
		} else {
			if (printProgress==1) {
				printProgressConvert=1;	
			}
			// RTCM unknown version
			RTCMversion = 0;
			if ( options->printMeas == -1 ) options->printMeas = 0;
			if ( sopt->rtcmFile[0] != '\0' ) {
				options->RTCMmode = RTCMCheckVersion; // Check what version of RTCM is the binary file
				if ( !(fdRTCM = fopen(sopt->rtcmFile, "rb")) ) {
					sprintf(messagestr, "Problem reading the RTCM binary file [%s]", sopt->rtcmFile);
					printError(messagestr, options);
				}
				rtcm2 = malloc(sizeof(TRTCM2));
				initRTCM2(rtcm2);
				rtcm3 = malloc(sizeof(TRTCM3));
				initRTCM3(rtcm3);
				RTCMversion = converterRTCM2(fdRTCM, rtcm2, NULL, NULL, NULL, options);
				if ( RTCMversion == 2 ) {
					strcpy(sopt->rtcm2File, sopt->rtcmFile);
					sprintf(messagestr, "Processing the RTCM v2.x binary file [%s] ...", sopt->rtcm2File);
					printInfo(messagestr, options);
				} else {
					RTCMversion = converterRTCM3(fdRTCM, rtcm3, NULL, NULL, epoch, options);
					strcpy(sopt->rtcm3File, sopt->rtcmFile);
					if ( RTCMversion == 3 ) {
						sprintf(messagestr, "Processing the RTCM v3.x binary file [%s] ...", sopt->rtcm3File);
						printInfo(messagestr, options);
					} else {
						fclose(fdRTCM);
						free(rtcm2);
						free(rtcm3);
						sprintf(messagestr, "File [%s] format unknown.", sopt->rtcm3File);
						printError(messagestr, options);
					}
				}
				fclose(fdRTCM);
				free(rtcm2);
				free(rtcm3);
				rtcm2 = NULL;
				rtcm3 = NULL;
			}
			// RTCM v2.x conversion 
			if ( sopt->rtcm2File[0] != '\0' || RTCMversion == 2 ) {
				if ( !(fdRTCM2 = fopen(sopt->rtcm2File, "rb")) ) {
					sprintf(messagestr,"Problem reading the RTCM binary file [%s]", sopt->rtcm2File);
					printError(messagestr, options);
				} else if ( options->rtcmYear == 0 || options->rtcmMonth == 0 || options->rtcmDay == 0 ) {
					sprintf(messagestr, "Option \"-input:rtcm:initdate\" must be set");
					printError(messagestr, options);
				} else if ( options->rtcmHour == -1 ) {
					sprintf(messagestr, "Option \"-input:rtcm:inithour\" must be set");
					printError(messagestr, options);
				} else {
					// Initialise
					rtcm2 = malloc(sizeof(TRTCM2));
					initRTCM2(rtcm2);

					// Check to ensure the format
					options->RTCMmode = RTCMCheckVersion;
					RTCMversion = converterRTCM2(fdRTCM2, rtcm2, NULL, NULL, NULL, options);
					if ( RTCMversion != 2 ) {
						fclose(fdRTCM2);
						free(rtcm2);
						sprintf(messagestr, "File [%s] does not have RTCM v2.x format.", sopt->rtcm2File);
						printError(messagestr, options);
					}

					options->RTCMmode = ConvertRTCM2;
					fileASCIIcorrections = malloc(sizeof(char) * 2 * MAX_INPUT_LINE); 	//Double size to avoid -Wformat-overflow warning
					fileASCIIantenna = malloc(sizeof(char) * 2 * MAX_INPUT_LINE);		//Double size to avoid -Wformat-overflow warning
					doy = date2doy(options->rtcmYear, options->rtcmMonth, options->rtcmDay);

					if ( sopt->dataASCIIFile[0] == '\0' ) {
						// Build the full path and filename for output ASCII data file
						sprintf(fileASCIIcorrections,"%s%03d_corrections.asc", pathRTCMpointer, doy);
					} else strcpy(fileASCIIcorrections,sopt->dataASCIIFile);
					if ( sopt->antennaASCIIFile[0] == '\0' ) {
						// Build the full path and filename for output ASCII data file
						sprintf(fileASCIIantenna,"%s%03d_antenna.asc", pathRTCMpointer, doy);
					} else strcpy(fileASCIIantenna,sopt->antennaASCIIFile);

					// Check if file already exsits
					/*if ( access(fileASCIIcorrections,F_OK) != -1 ) {
						// File exists
						sprintf(messagestr, "The file [%s] already exist. Conversion stopped", fileASCIIcorrections);
						printError(messagestr, options);
					}*/

					// Check if file already exsits
					/*if ( access(fileASCIIantenna, F_OK) != -1 ) {
						// File exists
						sprintf(messagestr, "The file [%s] already exist. Conversion stopped", fileASCIIantenna);
						printError(messagestr, options);
					}*/

					//Create directory recursively if needed
					ret=mkdir_recursive(fileASCIIcorrections);
					if(ret!=0) {
						//Error when creating the directory, and it is not due to that the directory already exists
						sprintf(messagestr,"When creating [%s] folder for writing corrections",fileASCIIcorrections);
						printError(messagestr,options);
					}

					//Create directory recursively if needed
					ret=mkdir_recursive(fileASCIIantenna);
					if(ret!=0) {
						//Error when creating the directory, and it is not due to that the directory already exists
						sprintf(messagestr,"When creating [%s] folder for writing antenna data",fileASCIIantenna);
						printError(messagestr,options);
					}

					// Convert the binary file RTCM v2.x
					ret = converterRTCM2(fdRTCM2, rtcm2, fileASCIIcorrections, fileASCIIantenna, NULL, options);

					// Output message
					if ( ret == 1 ) {
						sprintf(messagestr, "RTCM binary file [%s] has been converted to files [%s] (antenna information) and [%s] (corrections)", sopt->rtcm2File, fileASCIIantenna, fileASCIIcorrections);
						printInfo(messagestr, options);
					}
					fclose(fdRTCM2);
					free(rtcm2);
					free(fileASCIIcorrections);
					free(fileASCIIantenna);
					if (printProgressConvert==1) {
						fprintf(options->terminalStream,"Percentage converted: %3d%%%10s%c",100,"",options->ProgressEndCharac);
						#if !defined(__WIN32__)
							//This is to clear terminal for characters after finishing (in Windows is not necessary as it adds a newline when the process finishes)
							if (options->ProgressEndCharac=='\r') {
								fprintf(options->terminalStream,"%60s%c","",options->ProgressEndCharac);
							}
							//Enable cursor again
							if (sopt->disableCursor==1) {
								fprintf(options->terminalStream,"%s",enableCursor);
							}
						#endif
						fflush_function(options->terminalStream);
					}
					return 2;
				}
			}
			// RTCM v3.x conversion 
			if ( sopt->rtcm3File[0] != '\0' || RTCMversion == 3 ) {
				fdRTCM3 = fopen(sopt->rtcm3File, "rb");
				if ( fdRTCM3 == NULL ) {
					sprintf(messagestr, "Problem reading the RTCM binary file [%s]", sopt->rtcm3File);
					printError(messagestr, options);
				} else if ( options->rtcmYear == 0 || options->rtcmMonth == 0 || options->rtcmDay == 0 ) {
					sprintf(messagestr, "Option \"-input:rtcm:initdate\" must be set");
					printError(messagestr,options);
				} else {
					// Initialise
					rtcm3 = malloc(sizeof(TRTCM3));
					initRTCM3(rtcm3);

					// Check to ensure the format
					options->RTCMmode = RTCMCheckVersion;
					RTCMversion = converterRTCM3(fdRTCM3, rtcm3, NULL, NULL, epoch, options);
					if ( RTCMversion != 3 ) {
						fclose(fdRTCM3);
						free(rtcm3);
						sprintf(messagestr, "File [%s] does not have RTCM v3.x format.", sopt->rtcm3File);
						printError(messagestr, options);
					}

					// Continue with the normal procedure
					options->RTCMmode = ConvertRTCM3;

					// Get DoY from date for RINEX filename purposes
					doy = date2doy(options->rtcmYear,options->rtcmMonth,options->rtcmDay);
					options->rtcmDoy = doy;
					if ( doy == -1 ) {
						sprintf(messagestr,"Problem with the day of the year");
						printError(messagestr,options);
					} else {
						sprintf(strDoy,"%03d",doy);
					}

					if ( sopt->rnxFile[0] == '\0' ) {
						// Build the full path and filename for output RINEX file
						strcpy(fileRINEXpointer,pathRTCMpointer);
						strcat(fileRINEXpointer,strDoy);
						strcat(fileRINEXpointer,"0.");
						sprintf(strYear,"%02d",options->rtcmYearShort);
						strcat(fileRINEXpointer,strYear);
						strcat(fileRINEXpointer,"o");
					} else strcpy(fileRINEXpointer,sopt->rnxFile);

					// Check if file already exsits
					/*if ( access(fileRINEXpointer,F_OK) != -1 ) {
						// File exists
						sprintf(messagestr,"The file [%s] already exist. Conversion stopped",fileRINEXpointer);
						printError(messagestr,options);
					}*/

					//Create directory recursively if needed
					ret=mkdir_recursive(fileRINEXpointer);
					if(ret!=0) {
					   //Error when creating the directory, and it is not due to that the directory already exists
					   sprintf(messagestr,"When creating [%s] folder for writing corrections",fileRINEXpointer);
					   printError(messagestr,options);
					}

					// Convert the binary file RTCM v3.x
					ret = converterRTCM3(fdRTCM3,rtcm3,fileRINEXpointer,NULL,epoch,options);
					if ( ret == -1 ) {
						sprintf(messagestr,"Problem reading the RTCM binary file [%s]",sopt->rtcm3File);
						printError(messagestr,options);
					}

					// Output message
					if ( ret ==1 || ret == 2 ) {
						if ( options->rinexVersion == 2 ) sprintf(messagestr,"RTCM binary file [%s] has been converted to file [%s], which is a RINEX version 2.11",sopt->rtcm3File,fileRINEXpointer);
						if ( options->rinexVersion == 3 ) sprintf(messagestr,"RTCM binary file [%s] has been converted to file [%s], which is a RINEX version 3.00",sopt->rtcm3File,fileRINEXpointer);
						printInfo(messagestr, options);
					}
					free(rtcm3);
				}
				fclose(fdRTCM3);
				if (printProgressConvert==1) {
					fprintf(options->terminalStream,"Percentage converted: %3d%%%10s%c",100,"",options->ProgressEndCharac);
					#if !defined(__WIN32__)
						if (options->ProgressEndCharac=='\r') {
						//This is to clear terminal for characters after finishing (in Windows is not necessary as it adds a newline when the process finishes)
							fprintf(options->terminalStream,"%60s%c","",options->ProgressEndCharac);
						}
						//Enable cursor again
						if (sopt->disableCursor==1) {
							fprintf(options->terminalStream,"%s",enableCursor);
						}
					#endif
					fflush_function(options->terminalStream);
				}
				return 2;
			}
			if ( options->SBAScorrections>=SBAS1Fused ) {
				sprintf(messagestr,"SBAS input selected, but no GNSS sources given. For just converting SBAS files, use the '-onlyconvert' option");
			} else {
				sprintf(messagestr,"No observation file found, but there are %d different GNSS sources. To compare products, provide 2 different sources. To parse a products file, provide 1 single source",nProd);
			}
			printError(messagestr,options);
		} 
	}
	if ( sopt->antFile[0] != '\0' && sopt->conFile[0] != '\0' ) {
		printError("'-input:ant' and '-input:con' cannot be both set",options);
	} else if ( sopt->antrecFile[0][0] != '\0' && sopt->conFile[0] != '\0' ) {
		printError("'-input:antrec' and '-input:con' cannot be both set",options);
	} else if ( sopt->antFile[0] == '\0' && sopt->antrecFile[0][0] != '\0' ) {
		printError("If '-input:antrec' is set, option '-input:ant' must also be set",options);
	}
	if ( preciseProductsAvailable ) {
		if ( options->workMode == wmDOPROCESSING ) {
			if (sopt->antFile[0]=='\0' && sopt->conFile[0]=='\0' && options->satellitePhaseCenter) {
				printError("When positioning with precise products, an ANTEX or Constellation file is required (-input:ant or -input:con)",options);
			}	
		} else if (options->workMode==wmCOMPAREORBITS || options->workMode==wmSHOWPRODUCT) {
			if (sopt->antFile[0]=='\0' && sopt->conFile[0]=='\0' && options->satellitePhaseCenter) {
				printError("Precise orbits and 'Satellite Phase Centre' corrections are specified, but no ANTEX or Constellation file is found",options);
			}
		}
	}

	//Only set automatic smoothing flag if user did not set any measurement to smooth with (for both rover and reference station)
	if (sopt->smoothAuto==1) {
		if (sopt->numSmoothMeasFilterText[ROVERPOS]==0) { 
			//User did not enter any measurement to smooth with
			options->smoothAuto=1;
			if (options->SBAScorrections>=SBAS1Fused) {
				printInfo("WARNING Option '-pre:smoothauto' is unnecessary in SBAS 1F/DFMC modes, as smoothing is applied by default",options);
			}
			if (options->smoothEpochs==0) {
				options->smoothEpochs=100;
			}
		} else {
			printError("Automatic smoothing (option '-pre:smoothauto'),  and user measurement to smooth with (options '-pre:smoothmeas' or '-pre:smoothmeasdgnss') cannot be both provided",options);
		}
	}

	// Check navigation health options if not set
	if ( options->satHealthMode == BRDCUseUndefined) {
		if ( sopt->satelliteHealth == -1 && sopt->allowMarginal == -1 ) {
			if (sopt->navMode==NMppp) {
				if (sopt->numNavHealth > 0) {
					options->satHealthMode = BRDCUseHealthyOnly; //Navigation file for health check provided in PPP, so default to use healthy only
				} else {
					options->satHealthMode = BRDCUseAnyHealth; //Default in PPP is not to check for health (as there is no health data)
				}
			} else {
				options->satHealthMode = BRDCUseHealthyOnly; //Default in SPP/DGNSS use healthy satellites only (in SBAS mode is set above in the code)
			}
		} else if ( sopt->satelliteHealth == 1 && sopt->allowMarginal == -1 ) {
			options->satHealthMode = BRDCUseHealthyOnly;
		} else if ( sopt->satelliteHealth == -1 && sopt->allowMarginal == 1 ) {
			options->satHealthMode = BRDCUseHealthyMarginal;
		} else if ( sopt->satelliteHealth == 1 && sopt->allowMarginal == 1 ) {
			options->satHealthMode = BRDCUseHealthyMarginal;
		} else if ( sopt->satelliteHealth == -1 && sopt->allowMarginal == 0	) {
			options->satHealthMode = BRDCUseHealthyOnly;
		} else if ( sopt->satelliteHealth == 1 && sopt->allowMarginal == 0	) {
			options->satHealthMode = BRDCUseHealthyOnly;
		} else { //Any case with sopt->satelliteHealth == 0
			options->satHealthMode = BRDCUseAnyHealth;
		}
	}

	//Check DCB file types
	for (i=0;i<sopt->numTGD;i++) {
		auxft1 = whatFileTypeIs(sopt->tgdFile[i]);
		if (auxft1 == ftP1C1DCB) {
			sopt->numP1C1DCB++;
			//Set DCB P1-C1 to strict, as if a file is provided, is to be used
			options->GPSp1c1DCBModel = GPSp1c1STRICT;
		} else if (auxft1 == ftP1P2DCB) sopt->numP1P2DCB++;
		else if (auxft1 == ftSINEXBIASOSB) sopt->numSINEXBIASOSB++;
		else if (auxft1 == ftSINEXBIASDSB) sopt->numSINEXBIASDSB++;
		else if (auxft1 == ftRINEXbroadcast) sopt->numP1P2RINEX++;
		else if (auxft1 == ftIONEX) sopt->numP1P2IONEX++;
		else if (auxft1 == ftFPPP) sopt->numP1P2FPPP++;
	}
		
	if (options->workMode == wmDOPROCESSING) {
		// Navigation mode and observables
		if (sopt->navMode==NMppp) {
			options->discardEclipsedSatellites = 1;
			options->csMW = 1;
			options->csLI = 1;
			options->csSF = 0;
			options->csLLI = 1;
			options->ionoModel = NoIonoModel;
			options->GPSp1p2DCBModel = DCBNONE; 
			options->GPSISCl1caDCBModel = DCBNONE;
			options->GPSISCl1cpDCBModel = DCBNONE;
			options->GPSISCl1cdDCBModel = DCBNONE;
			options->GPSISCl2cDCBModel = DCBNONE;
			options->GPSISCl5i5DCBModel = DCBNONE;
			options->GPSISCl5q5DCBModel = DCBNONE;
			options->GALe1e5aDCBModel = DCBNONE;
			options->GALe1e5bDCBModel = DCBNONE;
			options->GLOp1p2DCBModel = DCBNONE;
			options->BDSb1b6DCBModel = DCBNONE;
			options->BDSb2b6DCBModel = DCBNONE;
			options->BDSb5b6DCBModel = DCBNONE;
			options->BDSb7b6DCBModel = DCBNONE;
			options->BDSISCb1cdDCBModel = DCBNONE;
			options->BDSISCb2adDCBModel = DCBNONE;
			options->QZSc1cDCBModel = DCBNONE;
			options->QZSISCl1cpDCBModel = DCBNONE;
			options->QZSISCl1cdDCBModel = DCBNONE;
			options->QZSISCl2cDCBModel = DCBNONE;
			options->QZSISCl5i5DCBModel = DCBNONE;
			options->QZSISCl5q5DCBModel = DCBNONE;
			options->IRNc9c5DCBModel = DCBNONE;
			//Disable dual frequency DCBs if DCB files are not RINEX navigation files and are not SINEX BIAS files
			if (sopt->numTGD==0 || sopt->numTGD==(sopt->numP1C1DCB+sopt->numP1P2DCB+sopt->numP1P2IONEX+sopt->numP1P2FPPP)) {
				for(i=0;i<MAX_GNSS;i++) {
					options->DualFreqDCBModel[i] = DCBNONE;
				}
			}
			options->troposphericCorrection = 1;
			options->tropNominal = SimpleNominal; 
			options->tropMapping = NiellMapping;
			if (options->satellitePhaseCenter!=0) options->satellitePhaseCenter = 1;
			options->antennaData = adANTEX;
			if (options->ARPData==arpUNKNOWN) options->ARPData = arpRINEX;
			options->solidTidesCorrection = 1;
			options->gravitationalCorrection = 1;
			options->receiverPhaseVar=1;
			options->satellitePhaseVar=1;
			options->solutionMode = PPPMode;
			// Carrier phase + pseudorange by default
			if (sopt->navObservables==NTND) sopt->navObservables = NTcarrierphase;
			// Static by default
			if (sopt->navKinematics==NKND) sopt->navKinematics = NKstatic;
			// Disable check of transmission time in broadcast messages if user has not set anything and we are in PPP
			if ( options->brdcBlockTransTime == -1 ) options->brdcBlockTransTime = 0;
			// Set GDOP threshold if non set
			if (options->GDOPthreshold == -1) options->GDOPthreshold = 1;
			//Inter system clock bias in PPP is estimated as a constant value
			options->filterParams[PHI_PAR][DT_IS_UNK] = 1;	
			options->filterParams[Q_PAR][DT_IS_UNK] = 0;	
			if (options->printSummary==1) {
				options->computeConvergenceTime=1;
				options->computeConvTimeFormalErrHor = 1;
				options->computeConvTimeFormalErrVer = 1;
				options->computeConvTimeFormalErr3D = 1;
				options->computeConvTimePosErrHor = 1;
				options->computeConvTimePosErrVer = 1;
				options->computeConvTimePosErr3D = 1;
				options->computeConvTimePeriodFormalErrHor = 1;
				options->computeConvTimePeriodFormalErrVer = 1;
				options->computeConvTimePeriodFormalErr3D = 1;
				options->computeConvTimePeriodPosErrHor = 1;
				options->computeConvTimePeriodPosErrVer = 1;
				options->computeConvTimePeriodPosErr3D = 1;
			}
			if (options->FastPPP==0) {
				printInfo("Processing with precise products",options);
			} else {
				printInfo("Processing with precise products in Fast-PPP mode",options);
				//In Fast-PPP there are no dual frequency DCBs, disable them
				for(i=0;i<MAX_GNSS;i++) {
					options->DualFreqDCBModel[i] = DCBNONE;
				}
			}
		} else if (sopt->navMode==NMstandalone) {
			options->discardEclipsedSatellites = 0;
			options->csMW = 0;
			options->csLI = 0;
			options->csSF = 0;
			options->csLLI = 0;
			options->ionoModel = KlobucharIonoModel;
			options->BDSSP3DCBModel = DCBNONE;
			options->troposphericCorrection = 1;
			options->tropNominal = UNB3Nominal; 
			options->tropMapping = SimpleMapping;
			options->satellitePhaseCenter = 0;
			options->antennaData = adNONE;
			if (options->ARPData==arpUNKNOWN) options->ARPData = arpNONE;
			options->solidTidesCorrection = 0;
			options->gravitationalCorrection = 0;
			options->receiverPhaseVar=0;
			options->satellitePhaseVar=0;
			options->estimateIono = 0;
			options->estimateSatDCB = 0;
			options->estimateRecDCB = 0;
			options->solutionMode = SPPMode;
			// Pseudorange only
			if (sopt->navObservables==NTND) sopt->navObservables = NTpseudorange;
			// Dynamic by default
			if (sopt->navKinematics==NKND) sopt->navKinematics = NKkinematic;
			// Enable check of transmission time in broadcast messages if user has not set anything and we are not in SBAS
			if ( options->brdcBlockTransTime == -1 ) options->brdcBlockTransTime = 1;
			// Set GDOP threshold if non set
			if (options->GDOPthreshold == -1) options->GDOPthreshold = 0;
			printInfo("Processing with broadcast products",options);
		}
		if (sopt->navMode==NMppp && sopt->navObservables==NTpseudorange) {
			options->estimateTroposphere = 0;
			options->usePhase = 0;
			options->windUpCorrection = 0;
		} else if (sopt->navMode==NMppp && sopt->navObservables==NTcarrierphase) {
			if (options->smoothAuto==1) {
				options->estimateTroposphere = 1;
				options->usePhase = 0;
				options->windUpCorrection = 0;
			} else {
				options->estimateTroposphere = 1;
				options->usePhase = 1;
				options->windUpCorrection = 1;
			}
		} else if (sopt->navMode==NMstandalone && sopt->navObservables==NTpseudorange) {
			options->estimateTroposphere = 0;
			options->usePhase = 0;
			options->windUpCorrection = 0;
			if (options->smoothAuto==1) options->csSF = 1;
		} else if (sopt->navMode==NMstandalone && sopt->navObservables==NTcarrierphase) {
			if (options->smoothAuto==1) {
				options->estimateTroposphere = 0;
				options->usePhase = 0;
				options->windUpCorrection = 0;
			} else {
				options->estimateTroposphere = 0;
				options->usePhase = 1;
				options->windUpCorrection = 1;
			}	
			options->csSF = 1;
		}

		if (options->SBAScorrections>=SBAS1Fused) {
			//In SBAS mode, force C1C measurement for navigation
			options->estimateTroposphere = 0;
			options->usePhase = 0;
			if (sopt->numMeasFilterText[ROVERPOS]>0) {
				sprintf(messagestr,"In SBAS mode, user cannot select measurements to use in the filter. Remove parameters '-filter:select' and '-filter:selectlist'");
				printError(messagestr,options);
			}
			if (sopt->numSmoothMeasFilterText[ROVERPOS]>0) {
				sprintf(messagestr,"In SBAS mode, user cannot select smoothing measurements. Remove parameter '-pre:smoothmeas'");
				printError(messagestr,options);
			}
			for(i=1;i<=listMaxSatGNSS[GPS];i++) {
				if (options->usableFreq[GPS][i][1]==1) break;
			}
			if (i>listMaxSatGNSS[GPS]) {
				printError("In SBAS mode, GPS frequency 1 must be used, but user disabled it",options);
			}

			options->windUpCorrection = 0;
			// Set SBAS processing mode for OUTPUT message and default measurements
			if (options->SBAScorrections==SBAS1Fused) {
				options->solutionMode = SBAS1FMode;
			} else {
				options->solutionMode = SBASDFMCMode;
			}
		} else if (options->DGNSS==1) {
			//In DGNSS mode, set C1C measurement as default for navigation
			options->estimateTroposphere = 0;
			options->windUpCorrection = 0;
			// Set DGNSS processing mode for OUTPUT message
			options->solutionMode = DGNSSMode;
			for(i=1;i<=listMaxSatGNSS[GPS];i++) {
				if (options->usableFreq[GPS][i][1]==1) break;
			}
			if (i>listMaxSatGNSS[GPS]) {
				printError("In DGNSS mode, GPS frequency 1 must be used, but user disabled it",options);
			}
			if (sopt->numMeasFilterText[ROVERPOS]>0) {
				sprintf(messagestr,"In DGNSS mode, user cannot select measurements to use in the filter. Remove parameters '-filter:select' and '-filter:selectlist'");
				printError(messagestr,options);
			}
			if (sopt->numMeasFilterText[REFSTAPOS]>0) {
				sprintf(messagestr,"In DGNSS mode, user cannot select measurements to use for modelling in the reference station. Remove parameters '-model:dgnss:measprc' and '-model:dgnss:measprclist'");
				printError(messagestr,options);
			}
		}
	}

	//Set the default receiver phase centre option to all frequencies (will depend of the processing mode)
	for(i=0;i<MAX_GNSS;i++) {
		for (j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
			options->antennaDataGNSS[i][j] = options->antennaData;
			options->antennaDataGNSSsource[i][j] = options->antennaData;
		}
	}

	//Process receiver phase centre options
	l=0;
	if (sopt->numRecPhaseCenterParam>0) {
		if (strcasecmp(sopt->recPhaseCenterParam[0],"no")==0) {
			//No antenna phase centre corrections for any constellation and frequency
			l++;
			options->antennaData = adNONE;
			for(i=0;i<MAX_GNSS;i++) {
				for (j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
					options->antennaDataGNSS[i][j] = adNONE;
					options->antennaDataGNSSsource[i][j] = adNONE;
				}
			}
		} 
		if (strcasecmp(sopt->recPhaseCenterParam[l],"ANTEX")==0) {
			//Antenna phase centre corrections from ANTEX for any constellation and frequency
			l++;
			options->antennaData = adANTEX;
			for(i=0;i<MAX_GNSS;i++) {
				for (j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
					options->antennaDataGNSS[i][j] = adANTEX;
					options->antennaDataGNSSsource[i][j] = adANTEX;
				}
			}
		} 
		if (l<=sopt->numRecPhaseCenterParam) {
			if (sopt->numRecPhaseCenterParam<(2-l)) {
				sprintf(messagestr,"Parameter '-model:recphasecenter' requires at least two arguments when user manually sets receiver phase center values, but only %d arguments provided",sopt->numRecPhaseCenterParam);
				printError(messagestr,options);
			}
			//If user set a value manually, all the non set frequencies by the user will default to read from ANTEX
			//Antenna phase centre corrections from ANTEX for any constellation and frequency
			options->antennaData = adANTEX;
			for(i=0;i<MAX_GNSS;i++) {
				for (j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
					options->antennaDataGNSS[i][j] = adANTEX;
					options->antennaDataGNSSsource[i][j] = adANTEX;
				}
			}
			while(l<sopt->numRecPhaseCenterParam) {
				if ((sopt->numRecPhaseCenterParam-l)<2) {
					sprintf(messagestr,"Parameter '-model:recphasecenter' requires at least two arguments per each set of user manually sets receiver phase center values, but last set only has one argument left");
					printError(messagestr,options);
				}
				for(i=0;i<MAX_GNSS;i++) {
					GNSSused[i]=0;
				}
				for(i=0;i<MAX_FREQUENCIES_PER_GNSS;i++) {
					freqUsed[i]=0;
				}
				if (strcasecmp(sopt->recPhaseCenterParam[l],"0")==0) {
					//Select all constellations and frequencies
					for(i=0;i<MAX_GNSS;i++) {
						GNSSused[i]=1;
					}
					for(i=0;i<MAX_FREQUENCIES_PER_GNSS;i++) {
						freqUsed[i]=1;
					}
				} else {	
					aux1=0;
					aux2=(int)strlen(sopt->recPhaseCenterParam[l]);
					while(checkConstellationChar(sopt->recPhaseCenterParam[l][aux1])==1) {
						i=gnsschar2gnsstype(sopt->recPhaseCenterParam[l][aux1]);
						GNSSused[i]=1;
						aux1++;
					}
					if(aux1==0) {
						//If no constellation provided, default for GPS as in previous versions
						GNSSused[GPS]=1;
					}
					if(aux2<=aux1) {
						//Missing frequencies
						sprintf(messagestr,"Missing frequencies in argument '%s' for parameter '-model:recphasecenter'",sopt->recPhaseCenterParam[l]);
						printError(messagestr,options);
					}
					auxstr[1]='\0';
					for(i=aux1;i<aux2;i++) {
						if (sopt->recPhaseCenterParam[l][i]<48 || sopt->recPhaseCenterParam[l][i]>57) { //48 is ASCII 0 and 57 is ASCII 9
							sprintf(messagestr,"Frequency '%c' in argument '%s' for parameter '-model:recphasecenter' is not a valid frequency",sopt->recPhaseCenterParam[l][i],sopt->recPhaseCenterParam[l]);
							printError(messagestr,options);
						}
						auxstr[0]=sopt->recPhaseCenterParam[l][i];
						aux3 = atoi(auxstr);
						freqUsed[aux3]=1;
					}
				} 
				if (strcasecmp(sopt->recPhaseCenterParam[l+1],"ANTEX")==0) {
					//Current combination of constellations and frequencies to be read from ANTEX
					for(i=0;i<MAX_GNSS;i++) {
						if(GNSSused[i]==0) continue;
						for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
							if(freqUsed[j]==0) continue;
							options->antennaDataGNSS[i][j] = adANTEX;
							options->antennaDataGNSSsource[i][j] = adANTEX;
						}
					}
					l+=2;		
				} else if (checkConstellationChar(sopt->recPhaseCenterParam[l+1][0])==1) {
					//Current combination of constellations and frequencies to be gathered from the given constellation. 
					//If no frequency is provided, it will match the each source frequency with the destination frequency (e.g. QZS F1 and F2 will be matched to GPS F1 and F2)
					//To save the destination frequency and pointer, the value used will be the constellation
					aux1=gnsschar2gnsstype(sopt->recPhaseCenterParam[l+1][0]);
					aux2=(int)strlen(sopt->recPhaseCenterParam[l+1]);
					if (aux2==1) {
						//No frequencies provided
						for(i=0;i<MAX_GNSS;i++) {
							if(GNSSused[i]==0) continue;
							for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
								if(freqUsed[j]==0) continue;
								//Check that the destination constellation and frequency does not point to the source constellation and frequency (to avoid a loop of each one correcting to each other)

								if (options->antennaDataGNSSsource[aux1][j]==(i*100+j+100)) {
									sprintf(messagestr,"Argument '%s' for parameter '-model:recphasecenter' is pointing to a destination constellation whose correction is pointing to the source constellation in argument '%s'",sopt->recPhaseCenterParam[l+1],sopt->recPhaseCenterParam[l]);
									printError(messagestr,options);
								}
								options->antennaDataGNSSsource[i][j] = aux1*100+j+100;
							}
						}
					} else {
						//Frequency provided
						if (aux2>2) {
							sprintf(messagestr,"Argument '%s' for parameter '-model:recphasecenter' can not contain more than one frequency or constellation when specifying the source",sopt->recPhaseCenterParam[l+1]);
							printError(messagestr,options);
						}
						if (checkConstellationChar(sopt->recPhaseCenterParam[l+1][1])==1) {
							sprintf(messagestr,"Argument '%s' for parameter '-model:recphasecenter' can not contain more than one constellation when specifying the constellation to use as a source",sopt->recPhaseCenterParam[l+1]);
							printError(messagestr,options);
						}
						if (sopt->recPhaseCenterParam[l+1][1]<48 || sopt->recPhaseCenterParam[l+1][1]>57) { //48 is ASCII 0 and 57 is ASCII 9
							sprintf(messagestr,"Frequency '%c' in argument '%s' for parameter '-model:recphasecenter' is not a valid frequency",sopt->recPhaseCenterParam[l+1][1],sopt->recPhaseCenterParam[l+1]);
							printError(messagestr,options);
						}
						auxstr[1]='\0';
						auxstr[0]=sopt->recPhaseCenterParam[l+1][1];
						aux3=atoi(auxstr);
						for(i=0;i<MAX_GNSS;i++) {
							if(GNSSused[i]==0) continue;
							for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
								if(freqUsed[j]==0) continue;
								//Check that the destination constellation and frequency does not point to the source constellation and frequency (to avoid a loop of each one correcting to each other)

								if (options->antennaDataGNSSsource[aux1][aux3]==(i*100+j+100)) {
									sprintf(messagestr,"Argument '%s' for parameter '-model:recphasecenter' is pointing to a destination constellation whose correction is pointing to the source constellation in argument '%s'",sopt->recPhaseCenterParam[l+1],sopt->recPhaseCenterParam[l]);
									printError(messagestr,options);
								}
								options->antennaDataGNSSsource[i][j] = aux1*100+aux3+100; //The +100 is because for GPS, const value is 0, and the minimum value for copying value shall be 100
							}
						}
					}
					l+=2;
				} else {
					//User provides dN, dE and dUp
					if ((sopt->numRecPhaseCenterParam-l)<4) {
						sprintf(messagestr,"Parameter '-model:recphasecenter' requires at three arguments per each set of user manually sets of North, East and Up receiver phase center values, but last set only has %d argument%s left",(sopt->numRecPhaseCenterParam-l),(sopt->numRecPhaseCenterParam-l)==1?"":"s");
						printError(messagestr,options);
					}
					for(i=0;i<MAX_GNSS;i++) {
						if(GNSSused[i]==0) continue;
						for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
							if(freqUsed[j]==0) continue;
							//Check that the destination constellation and frequency does not point to the source constellation and frequency (to avoid a loop of each one correcting to each other)
							options->antennaDataGNSS[i][j] = adSET;
							options->antennaDataGNSSsource[i][j] = adSET;
							for (k=1;k<4;k++) {
								auxd = atof(sopt->recPhaseCenterParam[l+k]);
								options->receiverPCO[i][j][k-1] = auxd;
							}
						}
					}
					l+=4;
				}
			} //End while(l<sopt->numRecPhaseCenterParam)
			//Check if any frequency is to be read by ANTEX. If none, set the generic value to adSET
			//Also set the value for antennaDataGNSS for the values copied, to indicate if the values copied are from ANTEX or set by the user
			aux1=adNONE;
			for(i=0;i<MAX_GNSS;i++) {
				for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
					if (availGNSSFreq[i][j]==0) continue; //Skip non-existent frequencies
					if (options->antennaDataGNSSsource[i][j]==adANTEX) {
						aux1=adANTEX;
					} else if (options->antennaDataGNSSsource[i][j]>=100) {
						k=(int)((options->antennaDataGNSSsource[i][j]-100)/100); //Get the constellation
						l=options->antennaDataGNSSsource[i][j]%100; //Get the frequency
						options->antennaDataGNSS[i][j] = options->antennaDataGNSS[k][l];
					}
				}
			}
			if (aux1==adNONE) {
				//No frequencies to be read from ANTEX
				options->antennaData=adSET;
			}
		} //End else recphasecenter equal to "no" or "ANTEX"
		//A further check of used frequencies for the receiver APC will be done in "setDefaultMeasurements" function later on
	}

	if ( preciseProductsAvailable ) {
		if ( options->workMode == wmDOPROCESSING ) {
			if (sopt->antFile[0]=='\0' && sopt->conFile[0]=='\0' && options->antennaData == adANTEX && options->satellitePhaseCenter) {
				printError("When positioning with precise products, an ANTEX or Constellation file is required (-input:ant or -input:con)",options);
			}	
		}
	}


	//Read measurement list for MEAS message
	if (sopt->numprintMeastext>0) {
		parseMeasurements(parsePrintMeasList,ROVERPOS,0,sopt,options);
	}

	for(i=0;i<NUM_OBSRINEX;i++) {		
		//Read table of measurement order (if user has set them)
		if (sopt->numMeasTableText[i]>0) {
			parseMeasurements(parseMeasTableList,i,0,sopt,options);
		}
		
		//Read measurements for SF (if user has set them)
		if (sopt->numcsSFtext[i]>0) {
			parseMeasurements(parsecsSFmeas,i,0,sopt,options);
		}

		//Read measurements for MW (if user has set them)
		if (sopt->numcsMWtext[i]>0) {
			parseMeasurements(parsecsMWmeas,i,0,sopt,options);
		}

		//Read measurements for LI (if user has set them)
		if (sopt->numcsLItext[i]>0) {
			parseMeasurements(parsecsLImeas,i,0,sopt,options);
		}

		//Read measurements for IGF (if user has set them)
		if (sopt->numcsIGFtext[i]>0) {
			parseMeasurements(parsecsIGFmeas,i,0,sopt,options);
		}

		//Read frequencies for SF (if user has set them)
		if (sopt->numcsSFfreqtext[i]>0) {
			parseMeasurements(parsecsSFfreq,i,0,sopt,options);
		}

		//Read frequencies for MW (if user has set them)
		if (sopt->numcsMWfreqtext[i]>0) {
			parseMeasurements(parsecsMWfreq,i,0,sopt,options);
		}

		//Read frequencies for LI (if user has set them)
		if (sopt->numcsLIfreqtext[i]>0) {
			parseMeasurements(parsecsLIfreq,i,0,sopt,options);
		}

		//Read frequencies for IGF (if user has set them)
		if (sopt->numcsIGFfreqtext[i]>0) {
			parseMeasurements(parsecsIGFfreq,i,0,sopt,options);
		}

		//Read measurements for the filter (if user has set them)
		if (sopt->numMeasFilterText[i]>0) {
			parseMeasurements(parseFiltermeas,i,0,sopt,options);
		}

		//Read Doppler measurements (if user has set them)
		if (sopt->numMeasDopplerText[i]>0) {
			parseMeasurements(parseDopplermeas,i,0,sopt,options);
		}

		if(i==0) { //Weights are only applied in the rover
			//Read measurements for the weights in the filter 
			if (sopt->numweightText>0) {
				parseMeasurements(parseWeightFiltermeas,i,0,sopt,options);
			}

			//Read measurements for the weights combining mode in the filter 
			if (sopt->numweightTextComb>0) {
				parseMeasurements(parseWeightCombFiltermeas,i,0,sopt,options);
			}

			//Read measurements for the weights mode in the filter 
			if (sopt->numweightTextMode>0) {
				parseMeasurements(parseWeightModeFiltermeas,i,0,sopt,options);
			}
		}
		//Read measurements to be smoothed in the filter (if user has set them)
		//Note that smoothing has to be the last, as it changes the filterMeasKind value
		if (sopt->numSmoothMeasFilterText[i]>0) {
			parseMeasurements(parseSmoothFiltermeas,i,0,sopt,options);
		}
	}

	for(i=0;i<NUM_OBSRINEX;i++) {
		if (i>0 && options->DGNSS==0) continue;
		//Check if user set frequencies for SF cycle-slip detector
		if (sopt->csSF==1 || (options->csSF==1 && sopt->csSF==-1)) {
			if (sopt->numcsSFfreqtext[i]>0) {
				for(j=0;j<MAX_GNSS;j++) {
					for(k=1;k<=listMaxSatGNSS[j];k++) {
						if (options->includeSatellite[j][k]==0) continue;
						for(l=0;l<options->numcsSFfreq[i][j][k];l++) {
							if (options->numcsSFMeasList[i][j][k]==MAX_CS_LIST) {
								sprintf(messagestr,"Maximum number of single frequency cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
								printError(messagestr,options);
							}
							options->csSFMeasList[i][j][k][options->numcsSFMeasList[i][j][k]][0]=NA;
							options->csSFMeasList[i][j][k][options->numcsSFMeasList[i][j][k]][1]=NA;
							options->csSFMeasFreq[i][j][k][options->numcsSFMeasList[i][j][k]][0]=options->csSFfreq[i][j][k][l];
							options->csSFMeasFreq[i][j][k][options->numcsSFMeasList[i][j][k]][1]=options->csSFfreq[i][j][k][l];
							options->csSFWithMeas[i][j][k][options->numcsSFMeasList[i][j][k]]=0;
							options->csSFMeasSelected[i][j][k][options->numcsSFMeasList[i][j][k]]=0;
							options->numcsSFMeasList[i][j][k]++;
						}
					}
				}
			}
		}

		//Check if user set frequencies for MW cycle-slip detector
		if (sopt->csMW==1 || (options->csMW==1 && sopt->csMW==-1)) {
			if (sopt->numcsMWfreqtext[i]>0) {
				auxstr[0]='M';
				auxstr[1]='W';
				auxstr[4]='\0';
				auxstr2[0]='P';
				auxstr2[1]='N';
				auxstr2[4]='\0';
				auxstr3[0]='L';
				auxstr3[1]='W';
				auxstr3[4]='\0';
				for(j=0;j<MAX_GNSS;j++) {
					for(k=1;k<=listMaxSatGNSS[j];k++) {
						if (options->includeSatellite[j][k]==0) continue;
						for(l=0;l<options->numcsMWfreq[i][j][k];l++) {
							if (options->numcsMWMeasList[i][j][k]==MAX_CS_LIST) {
								sprintf(messagestr,"Maximum number of Melbourne-Wubbena cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
								printError(messagestr,options);
							}
							auxstr[2]='0'+options->csMWfreq[i][j][k][l][0];
							auxstr[3]='0'+options->csMWfreq[i][j][k][l][1];
							meas=measstr2meastype(auxstr);
							auxstr2[2]='0'+options->csMWfreq[i][j][k][l][0];
							auxstr2[3]='0'+options->csMWfreq[i][j][k][l][1];
							meas2=measstr2meastype(auxstr2);
							auxstr3[2]='0'+options->csMWfreq[i][j][k][l][0];
							auxstr3[3]='0'+options->csMWfreq[i][j][k][l][1];
							meas3=measstr2meastype(auxstr3);
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][0]=meas;
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][1]=meas2;
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][2]=NA;
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][3]=NA;
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][4]=meas3;
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][5]=NA;
							options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][6]=NA;
							options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][0]=options->csMWfreq[i][j][k][l][0];
							options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][1]=options->csMWfreq[i][j][k][l][1];
							options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][2]=options->csMWfreq[i][j][k][l][0];
							options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][3]=options->csMWfreq[i][j][k][l][1];
							options->csMWWithMeas[i][j][k][options->numcsMWMeasList[i][j][k]]=0;
							options->csMWMeasSelected[i][j][k][options->numcsMWMeasList[i][j][k]]=0;
							options->numcsMWMeasList[i][j][k]++;
						}
					}
				}
			} 
		}

		//Check if user set frequencies for LI cycle-slip detector
		if (sopt->csLI==1 || (options->csLI==1 && sopt->csLI==-1)) {
			if (sopt->numcsLIfreqtext[i]>0) {
				auxstr[0]='L';
				auxstr[1]='I';
				auxstr[4]='\0';
				for(j=0;j<MAX_GNSS;j++) {
					for(k=1;k<=listMaxSatGNSS[j];k++) {
						if (options->includeSatellite[j][k]==0) continue;
						for(l=0;l<options->numcsLIfreq[i][j][k];l++) {
							if (options->numcsLIMeasList[i][j][k]==MAX_CS_LIST) {
								sprintf(messagestr,"Maximum number of LI cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
								printError(messagestr,options);
							}
							auxstr[2]='0'+options->csLIfreq[i][j][k][l][0];
							auxstr[3]='0'+options->csLIfreq[i][j][k][l][1];
							meas=measstr2meastype(auxstr);
							options->csLIMeasList[i][j][k][options->numcsLIMeasList[i][j][k]][0]=meas;
							options->csLIMeasList[i][j][k][options->numcsLIMeasList[i][j][k]][1]=NA;
							options->csLIMeasList[i][j][k][options->numcsLIMeasList[i][j][k]][2]=NA;
							options->csLIMeasFreq[i][j][k][options->numcsLIMeasList[i][j][k]][0]=options->csLIfreq[i][j][k][l][0];
							options->csLIMeasFreq[i][j][k][options->numcsLIMeasList[i][j][k]][1]=options->csLIfreq[i][j][k][l][1];
							options->csLIWithMeas[i][j][k][options->numcsLIMeasList[i][j][k]]=0;
							options->csLIMeasSelected[i][j][k][options->numcsLIMeasList[i][j][k]]=0;
							options->numcsLIMeasList[i][j][k]++;
						}
					}
				}
			} 
		}

		//Check IGF cycle-slip detector
		if (options->csIGF==1) {
			if (sopt->numcsIGFfreqtext[i]>0) {
				auxstr[0]='I';
				auxstr[1]='G';
				auxstr[2]='F';
				auxstr[7]='\0';
				auxstr2[0]='L';
				auxstr2[1]='C';
				auxstr2[4]='\0';
				auxstr3[0]='L';
				auxstr3[1]='C';
				auxstr3[4]='\0';
				for(j=0;j<MAX_GNSS;j++) {
					for(k=1;k<=listMaxSatGNSS[j];k++) {
						if (options->includeSatellite[j][k]==0) continue;
						for(l=0;l<options->numcsIGFfreq[i][j][k];l++) {
							if (options->numcsIGFMeasList[i][j][k]==MAX_CS_LIST) {
								sprintf(messagestr,"Maximum number of IGF cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
								printError(messagestr,options);
							}
							auxstr[3]='0'+options->csIGFfreq[i][j][k][l][0];
							auxstr[4]='0'+options->csIGFfreq[i][j][k][l][1];
							auxstr[5]='0'+options->csIGFfreq[i][j][k][l][2];
							auxstr[6]='0'+options->csIGFfreq[i][j][k][l][3];
							meas=measstr2meastype(auxstr);
							auxstr2[2]='0'+options->csIGFfreq[i][j][k][l][0];
							auxstr2[3]='0'+options->csIGFfreq[i][j][k][l][1];
							meas2=measstr2meastype(auxstr2);
							auxstr3[2]='0'+options->csIGFfreq[i][j][k][l][2];
							auxstr3[3]='0'+options->csIGFfreq[i][j][k][l][3];
							meas3=measstr2meastype(auxstr3);
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][0]=meas;
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][1]=meas2;
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][2]=NA;
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][3]=NA;
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][4]=meas3;
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][5]=NA;
							options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][6]=NA;
							options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][0]=options->csIGFfreq[i][j][k][l][0];
							options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][1]=options->csIGFfreq[i][j][k][l][1];
							options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][2]=options->csIGFfreq[i][j][k][l][2];
							options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][3]=options->csIGFfreq[i][j][k][l][3];
							options->csIGFWithMeas[i][j][k][options->numcsIGFMeasList[i][j][k]]=0;
							options->csIGFMeasSelected[i][j][k][options->numcsIGFMeasList[i][j][k]]=0;
							options->numcsIGFMeasList[i][j][k]++;
						}
					}
				}
			} 
		}
	}	

	// Navigation kinematics
	if (sopt->navKinematics==NKstatic) {
		options->filterParams[PHI_PAR][DR_UNK] = 1;
		options->filterParams[Q_PAR][DR_UNK] = 0;
	} else if (sopt->navKinematics==NKkinematic) {
		options->filterParams[PHI_PAR][DR_UNK] = 0;
		options->filterParams[Q_PAR][DR_UNK] = SIGMA_INF_DR*SIGMA_INF_DR;
	} else if (sopt->navKinematics==NKrandomWalk) {
		options->CoordRandWalk=1;	
		options->filterParams[PHI_PAR][DR_UNK] = 1;
		options->filterParams[Q_PAR][DR_UNK] = SIGMA_RANDOMWALK_DR*SIGMA_RANDOMWALK_DR;
	}


	// Filter parameters change
	for (i=0;i<3;i++) {
		for (j=0;j<MAX_PAR;j++) {
			if (sopt->filterParams[i][j]!=-1) {
				options->filterParams[i][j] = sopt->filterParams[i][j];
			}
		}
	}

	if (sopt->filterParams[Q_PAR][DT_UNK]!=-1 && options->ClkRandWalk==1) {
		options->filterParams[Q_PAR][DT_UNK]/=86400.; //Convert from m^2/d to m^2/s
	}
	if (sopt->filterParams[Q_PAR][DT_IS_UNK]!=-1 && options->ISCBRandWalk==1) {
		options->filterParams[Q_PAR][DT_IS_UNK]/=86400.; //Convert from m^2/d to m^2/s
	}
	

	//If random walk is set for coordinates, clock or inter-system clock bias, check that Phi value is 1 if user didn't set any value
	//Also, for random walk, set an appropiate default Q value
	if (options->CoordRandWalk==1) {
		if (sopt->filterParams[PHI_PAR][DR_UNK]==-1) {
			options->filterParams[PHI_PAR][DR_UNK]=1;
		}
		if (sopt->filterParams[Q_PAR][DR_UNK]==-1) {
			options->filterParams[Q_PAR][DR_UNK]=SIGMA_RANDOMWALK_DR*SIGMA_RANDOMWALK_DR;
		}
	}
	if (options->ClkRandWalk==1) {
		if (sopt->filterParams[PHI_PAR][DT_UNK]==-1) {
			options->filterParams[PHI_PAR][DT_UNK]=1;
		}
		if (sopt->filterParams[Q_PAR][DT_UNK]==-1) {
			options->filterParams[Q_PAR][DT_UNK]=SIGMA_RANDOMWALK_DT*SIGMA_RANDOMWALK_DT/86400.;
		}
	}
	if (options->ISCBRandWalk==1) {
		if (sopt->filterParams[PHI_PAR][DT_IS_UNK]==-1) {
			options->filterParams[PHI_PAR][DT_IS_UNK]=1;
		}
		if (sopt->filterParams[Q_PAR][DT_IS_UNK]==-1) {
			options->filterParams[Q_PAR][DT_IS_UNK]=SIGMA_RANDOMWALK_DT*SIGMA_RANDOMWALK_DT/86400.;
		}
	}	

	//Check SNR thresholds
	if (options->SNRminfilter==1 && options->SNRmaxfilter==1) {
		for (meas=2;meas<I1;meas+=4) { //Loop through all carrier phase measurements (as the other types will have the same SNR threshold)
			for(i=0;i<MAX_GNSS;i++) {
				//Check if current measurement (or its code or Doppler type) is in the observation file
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->SNRminvalues[i][j][meas]>options->SNRmaxvalues[i][j][meas]) {
						sprintf(messagestr,"Satellite %s %d has a minimum SNR threshold (%.6g) higher than the maximum SNR allowed (%.6g)",gnsstype2gnssstr(i),j,options->SNRminvalues[i][j][meas],options->SNRmaxvalues[i][j][meas]);
						printError(messagestr,options);
					}
				}
			}
		}
	}
		
	// Ionospheric model 
	if (options->SBAScorrections==SBASDFMCused) {
		//No iono model for SBAS DFMC, as iono-free combination is used
		//Iono model will be disabled even if user sets one, as in the model process for SBAS DFMC iono will never be applied even if it is enabled
		options->ionoModel = NoIonoModel;
		if (sopt->ionoModel!=UNKNOWN_IM && sopt->ionoModel!=NoIonoModel) {
			printInfo("Disabling ionospheric model for SBAS DFMC processing, as ionosphere model cannot be applied in this mode",options);
		}
	} else if (sopt->ionoModel!=UNKNOWN_IM) {
		options->ionoModel = sopt->ionoModel; 
		if (options->ionoModel!=NoIonoModel) {
			printInfo("Enabling ionospheric model for this processing",options);
		}
	} else if (sopt->ionoModel==UNKNOWN_IM && options->SBAScorrections==SBAS1Fused) {
		//If we have activated SBAS 1 frequency mode, but we have not set any ionosphere model, use SBAS iono. Else use the model given by parameters
		options->ionoModel = SBASIonoModel; 
		printInfo("Enabling SBAS 1F ionospheric model for this processing",options);
	}

	switch (options->ionoModel) {
		case IONEXIonoModel:
			if (sopt->inxFile[0]=='\0') {  // No IONEX source
				printError("Unable to get ionospheric model from IONEX input file. Please use '-input:inx'",options);
				return 0;
			}
			break;
		case FPPPIonoModel:
			if (sopt->fppFile[0]=='\0') {  // No FPPP source
				printError("Unable to get ionospheric model from FPPP input file. Please use '-input:fppp'",options);
				return 0;
			}
			if (options->ionoRMS <=0) {
				sprintf(messagestr,"Max RMS value is %2.2f, but it must be greater than zero",options->ionoRMS);
				printError(messagestr,options);
				return 0;
			}	
			break;
		case KlobucharIonoModel:
			if (sopt->numNav==0 && sopt->klbFile[0]=='\0') { // No Klobuchar source
				printError("Unable to get ionospheric Klobuchar model from input data. Please use '-input:nav' or '-input:klb'",options);
				return 0;
			}
			break;
		case BeiDouIonoModel:
			if (sopt->numNav==0 && sopt->beiFile[0]=='\0') { // No Beidou source
				printError("Unable to get ionospheric BeiDou model from input data. Please use '-input:nav' or '-input:bds'",options);
				return 0;
			}
			break;
		case neQuickIonoModel:
			if (sopt->numNav==0 && sopt->neqFile[0]=='\0') { // No NeQuick source
				printError("Unable to get ionospheric NeQuick model from input data. Please use '-input:nav' or '-input:neq'",options);
				return 0;
			}
			break;
		case SBASIonoModel:
			if(options->SBAScorrections<=SBASionoOnly && sopt->SBASIONOFile[0]=='\0') { // No SBAS source
				printError("Unable to get ionospheric SBAS model from input data. Please use '-input:sbasiono'",options);
				return 0;
			} else if (options->onlyconvertSBAS==1) {
				printError("SBAS file conversion only selected, which is not possible when processing standalone GPS with SBAS iono",options);
			} else {
				if(options->SBAScorrections<=SBASionoOnly) {
					strcpy(sopt->sbasFile,sopt->SBASIONOFile);
					if( options->GEOPRN==2 ) {
						printError("Selection of SBAS GEO with highest elevation is not available when using only SBAS ionosphere. Use automatic GEO selection, or select GEO from first line data read ('-pre:geosel 1') or manually set a GEO ('-pre:geosel GEOPRN')",options);
					}
					if ( options->filterIterations == 2 ) {
						printError("SBAS ionosphere selected, which is incompatible with backward processing. Disable backward processing for SBAS ionosphere model",options);
					}
					options->SBAScorrections=SBASionoOnly;
				}
			}
			break;
		default:
			break;
	}

	// Tropospheric model: specific configuration check
	if (sopt->troposphericCorrection!=-1) options->troposphericCorrection = sopt->troposphericCorrection;

	// Tropospheric model: Nominal
	if (sopt->tropNominal!=UNKNOWN_TMNominal) {
		options->tropNominal = sopt->tropNominal;
		if (options->troposphericCorrection == 0) {
			printInfo("Warning: Tropospheric modelling is disabled although nominal values are given",options);
			if (options->estimateTroposphere) {
				printInfo("Disconnecting tropospheric estimation (no tropospheric nominal value computed)",options);
				options->estimateTroposphere = 0;
			}
		}
	}

	// Tropospheric model: Mapping
	if (sopt->tropMapping!=UNKNOWN_TMMapping) {
		options->tropMapping = sopt->tropMapping;
		if (options->troposphericCorrection == 0) {
			printInfo("Warning: Tropospheric modelling is disabled although a troposphere mapping is given",options);
		}
		else if (options->tropNominal==TropoGalileo && options->tropMapping!=NiellMapping) {
			printError("Galileo tropospheric modelling only accepts Niell mapping, but Simple mapping is selected",options);
		}
	} else {
		if (options->tropNominal==TropoGalileo) {
			options->tropMapping = NiellMapping;
			printInfo("Warning: Galileo tropospheric modelling selected, but no mapping is given. Niell mapping will be used",options);
		}
	}

	// Tropospheric estimation
	if (options->troposphericCorrection==0) {
		//As troposphere model is disabled, we will also disable tropo estimation
		//as the filter needs the tropo mappings provided by the tropo model
		options->estimateTroposphere = 0;
		printInfo("Forcing disabled tropospheric estimation due to troposphere model correction is disabled",options);
	} else if (sopt->estimateTroposphere==1) {
		options->estimateTroposphere = 1;
		printInfo("Forcing enabled tropospheric estimation for this processing",options);
	} else if (sopt->estimateTroposphere==0) {
		options->estimateTroposphere = 0;
		printInfo("Forcing disabled tropospheric estimation for this processing",options);
	}


	
	//// TGD Source
	//GPS P1-C1
	if (sopt->GPSp1c1DCBModel!=GPSp1c1UNKNOWN) {
		options->GPSp1c1DCBModel = sopt->GPSp1c1DCBModel;
	}
	//GPS P1-P2
	if (sopt->GPSp1p2DCBModel!=DCBUNKNOWN) {
		options->GPSp1p2DCBModel = sopt->GPSp1p2DCBModel;
	} else if (options->workMode == wmSHOWINPUT) {
		options->GPSp1p2DCBModel = DCBNONE;
	}
	//GPS ISC L1C/A
	if (sopt->GPSISCl1caDCBModel!=DCBUNKNOWN) {
		options->GPSISCl1caDCBModel = sopt->GPSISCl1caDCBModel;
	}
	//GPS ISC L1Cp
	if (sopt->GPSISCl1cpDCBModel!=DCBUNKNOWN) {
		options->GPSISCl1cpDCBModel = sopt->GPSISCl1cpDCBModel;
	}
	//GPS ISC L1Cd
	if (sopt->GPSISCl1cdDCBModel!=DCBUNKNOWN) {
		options->GPSISCl1cdDCBModel = sopt->GPSISCl1cdDCBModel;
	}
	//GPS ISC L2C
	if (sopt->GPSISCl2cDCBModel!=DCBUNKNOWN) {
		options->GPSISCl2cDCBModel = sopt->GPSISCl2cDCBModel;
	}
	//GPS L5I5
	if (sopt->GPSISCl5i5DCBModel!=DCBUNKNOWN) {
		options->GPSISCl5i5DCBModel = sopt->GPSISCl5i5DCBModel;
	}
	//GPS L5Q5
	if (sopt->GPSISCl5q5DCBModel!=DCBUNKNOWN) {
		options->GPSISCl5q5DCBModel = sopt->GPSISCl5q5DCBModel;
	}
	//GAL E1E5a
	if (sopt->GALe1e5aDCBModel!=DCBUNKNOWN) {
		options->GALe1e5aDCBModel = sopt->GALe1e5aDCBModel;
	}
	//Galileo E1E5b
	if (sopt->GALe1e5bDCBModel!=DCBUNKNOWN) {
		options->GALe1e5bDCBModel = sopt->GALe1e5bDCBModel;
	}
	//GLONASS P1P2
	if (sopt->GLOp1p2DCBModel!=DCBUNKNOWN) {
		options->GLOp1p2DCBModel = sopt->GLOp1p2DCBModel;
	}
	//BeiDou B1B6
	if (sopt->BDSb1b6DCBModel!=DCBUNKNOWN) {
		options->BDSb1b6DCBModel = sopt->BDSb1b6DCBModel;
	}
	//BeiDou B2B6
	if (sopt->BDSb2b6DCBModel!=DCBUNKNOWN) {
		options->BDSb2b6DCBModel = sopt->BDSb2b6DCBModel;
	}
	//BeiDou B5B6
	if (sopt->BDSb5b6DCBModel!=DCBUNKNOWN) {
		options->BDSb5b6DCBModel = sopt->BDSb5b6DCBModel;
	}
	//BeiDou B7B6
	if (sopt->BDSb7b6DCBModel!=DCBUNKNOWN) {
		options->BDSb7b6DCBModel = sopt->BDSb7b6DCBModel;
	}
	//BeiDou SP3 DCB Single Freq
	if (sopt->BDSSP3DCBModel!=DCBUNKNOWN) {
		if (sopt->BDSSP3DCBModel!=DCBNONE) {
			if (sopt->navMode==NMstandalone) {
				printInfo("Forcing disable of BeiDou precise orbit DCB, as it not necessary for broadcast products",options);
			} else {
				options->BDSSP3DCBModel = sopt->BDSSP3DCBModel;
			}
		} else {
			options->BDSSP3DCBModel = sopt->BDSSP3DCBModel;
		}
	}
	//BeiDou ISC B1Cd
	if (sopt->BDSISCb1cdDCBModel!=DCBUNKNOWN) {
		options->BDSISCb1cdDCBModel = sopt->BDSISCb1cdDCBModel;
	}
	//BeiDou ISC B2Ad
	if (sopt->BDSISCb2adDCBModel!=DCBUNKNOWN) {
		options->BDSISCb2adDCBModel = sopt->BDSISCb2adDCBModel;
	}
	//QZSS C1C
	if (sopt->QZSc1cDCBModel!=DCBUNKNOWN) {
		options->QZSc1cDCBModel = sopt->QZSc1cDCBModel;
	}
	//QZSS ISC L1Cp
	if (sopt->QZSISCl1cpDCBModel!=DCBUNKNOWN) {
		options->QZSISCl1cpDCBModel = sopt->QZSISCl1cpDCBModel;
	}
	//QZSS L1Cd
	if (sopt->QZSISCl1cdDCBModel!=DCBUNKNOWN) {
		options->QZSISCl1cdDCBModel = sopt->QZSISCl1cdDCBModel;
	}
	//QZSS ISC L2C
	if (sopt->QZSISCl2cDCBModel!=DCBUNKNOWN) {
		options->QZSISCl2cDCBModel = sopt->QZSISCl2cDCBModel;
	}
	//QZSS ISC L5I5
	if (sopt->QZSISCl5i5DCBModel!=DCBUNKNOWN) {
		options->QZSISCl5i5DCBModel = sopt->QZSISCl5i5DCBModel;
	}
	//QZSS ISC L5Q5
	if (sopt->QZSISCl5q5DCBModel!=DCBUNKNOWN) {
		options->QZSISCl5q5DCBModel = sopt->QZSISCl5q5DCBModel;
	}
	//IRNSS C9C5
	if (sopt->IRNc9c5DCBModel!=DCBUNKNOWN) {
		options->IRNc9c5DCBModel = sopt->IRNc9c5DCBModel;
	}
	//OSB DCB Model
	if (sopt->OSBdcbModel!=OSBUNKNOWN) {
		options->OSBdcbModel = sopt->OSBdcbModel;
	}
	//DSB DCB Model
	if (sopt->DSBdcbModel!=DSBUNKNOWN) {
		options->DSBdcbModel = sopt->DSBdcbModel;
	}
	//Save options for all dual frequency DCBs
	for(i=0;i<MAX_GNSS;i++) {
		if (sopt->DualFreqDCBModel[i]!=DCBUNKNOWN) {
			options->DualFreqDCBModel[i] = sopt->DualFreqDCBModel[i];
		}
	}

	if (options->GPSp1c1DCBModel == GPSp1c1STRICT && sopt->numP1C1DCB>0 && sopt->recFile[0] != '\0') {
		if(options->printInput == 1 && options->printMeas == 1) {
			printInfo("INPUT and MEAS messages have the GPS DCB P1-C1 correction applied on GPS measurements",options);
		} else if (options->printInput == 1) {
			printInfo("INPUT message has the GPS DCB P1-C1 correction applied on GPS measurements",options);
		} else if (options->printMeas == 1) {
			printInfo("MEAS message has the GPS DCB P1-C1 correction applied on GPS measurements",options);
		}
	}
	
	// Orbit and clock interpolation degree
	if (options->orbitInterpolationDegree>MAX_INTERPOLATION_DEGREE) {
		sprintf(messagestr,"Max interpolation degree for orbits is %d (selected %d)",MAX_INTERPOLATION_DEGREE,options->orbitInterpolationDegree);
		printError(messagestr,options);
	}
	if (options->clockInterpolationDegree>MAX_INTERPOLATION_DEGREE) {
		sprintf(messagestr,"Max interpolation degree for clocks is %d (selected %d)",MAX_INTERPOLATION_DEGREE,options->clockInterpolationDegree);
		printError(messagestr,options);
	}
	
	// Enable check of transmission time in broadcast messages if user has not set anything and we are not in SBAS
	if ( options->brdcBlockTransTime == -1 ) options->brdcBlockTransTime = 1;
		
	// Check forcing a specific configuration for cycle-slips
	if ( sopt->csAllPosOn > sopt->csAllPosOff ) {
		//All CS on was provided the last in respect to All CS off
		options->csSF   = 1; 
		options->csMW   = 1; 
		options->csLI   = 1; 
		options->csLLI  = 1; 
		options->csIGF  = 1; 
		if ( sopt->csSFPosOff > sopt->csAllPosOn )   options->csSF   = 0;
		if ( sopt->csMWPosOff > sopt->csAllPosOn )   options->csMW   = 0;
		if ( sopt->csLIPosOff > sopt->csAllPosOn )   options->csLI   = 0;
		if ( sopt->csLLIPosOff > sopt->csAllPosOn )  options->csLLI  = 0;
		if ( sopt->csIGFPosOff > sopt->csAllPosOn )  options->csIGF  = 0;
	} else if ( sopt->csAllPosOff > sopt->csAllPosOn ) {
		//All CS off was provided the last in respect to All CS on
		options->csSF   = 0; 
		options->csMW   = 0; 
		options->csLI   = 0; 
		options->csLLI  = 0; 
		options->csIGF  = 0; 
		if ( sopt->csSFPosOn > sopt->csAllPosOff )   options->csSF   = 1;
		if ( sopt->csMWPosOn > sopt->csAllPosOff )   options->csMW   = 1;
		if ( sopt->csLIPosOn > sopt->csAllPosOff )   options->csLI   = 1;
		if ( sopt->csLLIPosOn > sopt->csAllPosOff )  options->csLLI  = 1;
		if ( sopt->csIGFPosOn > sopt->csAllPosOff )  options->csIGF  = 1;
	} else {
		//No all CS on or off was provided
		if ( sopt->csSF != -1 )   options->csSF   = sopt->csSF;
		if ( sopt->csMW != -1 )   options->csMW   = sopt->csMW;
		if ( sopt->csLI != -1 )   options->csLI   = sopt->csLI;
		if ( sopt->csLLI != -1 )  options->csLLI  = sopt->csLLI;
		if ( sopt->csIGF != -1 )  options->csIGF  = sopt->csIGF;
	}

	if ( options->csSF == 0 && options->csMW == 0 && options->csLI == 0 && options->csIGF == 0 && options->csLLI == 0 ) {
		options->allCSDetectorsOff = 1;
	}

	if ( options->csIGFmax == -1. ) {
		//No IGF max set by user
		if ( options->csIGFminNoise == 1 ) {
			//If IGF with minimum noise is enabled, set the same default value as LI detector
			options->csIGFmax = 0.08;
		} else {
			//If IGF is built with two LC, set double the threshold for LI. Even though the noise
			//is amplified by a factor sqrt(2)*3, setting the threshold 3 times larger is too big
			//It is better to detect false cycle-slip than not detecting real cycle-slips
			options->csIGFmax = 0.08*2;
		}
	}

	//If any cycle-slip is forced to be disabled, set the number of measurements in each one disabled to 0
	//This is for the case the user sets measurements but in the end sets the detector to disabled
	for(i=0;i<NUM_OBSRINEX;i++) {		
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				if (options->csSF==0) options->numcsSFMeasList[i][j][k]=0;
				if (options->csMW==0) options->numcsMWMeasList[i][j][k]=0;
				if (options->csLI==0) options->numcsLIMeasList[i][j][k]=0;
				if (options->csIGF==0) options->numcsIGFMeasList[i][j][k]=0;
			}
		}
	}

	if (options->csSF==1) {
		if (options->csSFsamples<2) {
			sprintf(messagestr,"Single Frequency cycle-slip detector mininum number of samples must be 2, but user set %d",options->csSFsamples);
			printError(messagestr,options);
		}
	}
	if (options->csMW==1) {
		if (options->csMWsamples<2) {
			sprintf(messagestr,"Melbourne-Wubbena cycle-slip detector mininum number of samples must be 2, but user set %d",options->csMWsamples);
			printError(messagestr,options);
		}
	}
	if (options->csLI==1) {
		options->csLIThreshold = options->csLImax / (1.0 + exp(-options->csDataGap/options->csLIt));
		if (options->csLIsamples<2) {
			sprintf(messagestr,"LI cycle-slip detector mininum number of samples must be 2, but user set %d",options->csLIsamples);
			printError(messagestr,options);
		}
	}
	if (options->csIGF==1) {
		options->csIGFThreshold = options->csIGFmax / (1.0 + exp(-options->csDataGap/options->csIGFt));
		if (options->csIGFsamples<2) {
			sprintf(messagestr,"IGF cycle-slip detector mininum number of samples must be 2, but user set %d",options->csIGFsamples);
			printError(messagestr,options);
		}
	}

	// Warning gLAB is going to use carrier phase without any cycle-slip detector activated
	if ( options->allCSDetectorsOff == 1 && options->usePhase == 1 && options->estimateAmbiguities == 1 ) {
		printInfo("WARNING Carrier phase is used but no cycle-slip detector is activated",options);
	}

	// Discard eclipse satellites
	if (sopt->discardEclipsedSatellites!=-1) {
		options->discardEclipsedSatellites = sopt->discardEclipsedSatellites;
	}


	// Printing
	if ( options->printInfo ) {
		if ( options->workMode == wmDOPROCESSING ) {
			sprintf(messagestr,"RINEX observation input file: %s",sopt->obsFile);
			printInfo(messagestr,options);
			if ( sopt->dgnssFile[0] != '\0' ) {
				sprintf(messagestr,"RINEX observation input file for reference station: %s",sopt->dgnssFile);
				printInfo(messagestr,options);
			}
			if ( sopt->rtcm3File[0] != '\0' ) {
				sprintf(messagestr,"RTCM v3.x binary input file for reference station: %s",sopt->rtcm3File);
				printInfo(messagestr,options);
			}
			if ( sopt->rtcm2File[0] != '\0' ) {
				sprintf(messagestr,"RTCM v2.x binary input file for reference station: %s",sopt->rtcm2File);
				printInfo(messagestr,options);
			}
			if (sopt->navMode==NMstandalone) {
				len=sprintf(messagestr,"RINEX navigation message input file%s:",sopt->numNav==1?"":"s");
				for(i=0;i<sopt->numNav;i++) {
					len+=sprintf(&messagestr[len]," %s",sopt->navFile[i]);
				}
				printInfo(messagestr,options);
			} else if (sopt->navMode==NMppp) {
				if (sopt->SP3File[0][0]!='\0') {
					sprintf(messagestr,"SP3 products file: %s",sopt->SP3File[0]);
					printInfo(messagestr,options);
				} else {
					sprintf(messagestr,"SP3 orbits file: %s",sopt->orbFile[0]);
					printInfo(messagestr,options);
					sprintf(messagestr,"Clocks file:     %s",sopt->clkFile[0]);
					printInfo(messagestr,options);
				}
			}
			if (sopt->glonavFile[0]!='\0') {
				sprintf(messagestr,"RINEX navigation file for GLONASS frequencies: %s",sopt->glonavFile);
				printInfo(messagestr,options);
			}
			if (sopt->numNavHealth>0 && sopt->navMode==NMppp) {
				len=sprintf(messagestr,"RINEX navigation file%s for satellite health:",sopt->numNavHealth==1?"":"s");
				for(i=0;i<sopt->numNavHealth;i++) {
					len+=sprintf(&messagestr[len]," %s",sopt->navHealthFile[i]);
				}
				printInfo(messagestr,options);
			}

			if ( options->SBAScorrections>=SBAS1Fused) {
				sprintf(messagestr,"SBAS message data input file: %s",sopt->sbasFile);
				printInfo(messagestr,options);
			}
			if ( options->useraddednoise == 1 && sopt->addederrorFile[0] != '\0' ) {
				sprintf(messagestr,"User defined error input file: %s",sopt->addederrorFile);
				printInfo(messagestr,options);
				if (options->useraddednoisepreprocess==1) {
					printInfo("Adding user defined error after preprocessing",options);
				} else {
					printInfo("Adding user defined error before preprocessing",options);
				}
			}
			if (options->usersigmamultipath == 1 && sopt->sigmamultipathFile[0] != '\0') {
				sprintf(messagestr,"User defined sigma multipath file: %s",sopt->sigmamultipathFile);
				printInfo(messagestr,options);
			}

			switch (options->ionoModel) {
				case IONEXIonoModel:
					if (sopt->inxFile[0]!='\0') {
						sprintf(messagestr,"IONEX file for ionospheric corrections: %s",sopt->inxFile);
						printInfo(messagestr,options);
					}
					break;
				case FPPPIonoModel:
					if (sopt->fppFile[0]!='\0') {
						sprintf(messagestr,"FPPP ionospheric file for ionospheric corrections: %s",sopt->fppFile);
						printInfo(messagestr,options);
					}
					break;
				case KlobucharIonoModel:
					if (sopt->klbFile[0]!='\0') {
						sprintf(messagestr,"RINEX navigation file for Klobuchar corrections: %s",sopt->klbFile);
						printInfo(messagestr,options);
					} else {
						printInfo("File for Klobuchar corrections same as for navigation",options); 
					}
					break;
				case BeiDouIonoModel:
					if (sopt->beiFile[0]!='\0') {
						sprintf(messagestr,"RINEX navigation file for BeiDou corrections: %s",sopt->beiFile);
						printInfo(messagestr,options);
					} else {
						printInfo("File for BeiDou corrections same as for navigation",options); 
					}
					break;
				case neQuickIonoModel:
					if (sopt->neqFile[0]!='\0') {
						sprintf(messagestr,"RINEX navigation file for NeQuick corrections: %s",sopt->neqFile);
						printInfo(messagestr,options);
					} else {
						printInfo("File for NeQuick corrections same as for navigation",options); 
					}
					break;
				case SBASIonoModel:
					if (options->SBAScorrections<=SBASionoOnly && sopt->SBASIONOFile[0]!='\0') {
						//Print this message only if we are using SBAS iono but no other SBAS corrections
						sprintf(messagestr,"SBAS data file for SBAS iono corrections: %s",sopt->SBASIONOFile);
						printInfo(messagestr,options);
					}
					break;
				default:
					break;
			}

			if (sopt->numP1P2RINEX==0 && broadcastProductsAvailable) {
				printInfo("File for differential DCB corrections same as for navigation",options);
			} else if (sopt->numP1P2RINEX==0 && options->GPSp1p2DCBModel==DCBRINEX && broadcastProductsAvailable) {
				printInfo("File for GPS differential DCB corrections same as for navigation",options);
			}

			for (i=0;i<sopt->numTGD;i++) {
				sprintf(messagestr,"File for DCB corrections: %s",sopt->tgdFile[i]);
				printInfo(messagestr,options);
			}
			if (sopt->recFile[0]!='\0') {
				sprintf(messagestr,"GPS receiver types file: %s",sopt->recFile);
				printInfo(messagestr,options);
			}
			if (sopt->snxFile[0]!='\0') {
				sprintf(messagestr,"SINEX input file: %s",sopt->snxFile);
				printInfo(messagestr,options);
			}
		} else if (options->workMode==wmCOMPAREORBITS || options->workMode==wmSHOWPRODUCT) {
			sources = 0;
			for (i=0;i<sopt->numNav;i++) {
				sources++;
				sprintf(messagestr,"OC Product %d: RINEX navigation message input file: %s",sources,sopt->navFile[i]);
				printInfo(messagestr,options);
			}
			for (i=0;i<sopt->numSP3;i++) {
				sources++;
				sprintf(messagestr,"OC Product %d: SP3 products file: %s",sources,sopt->SP3File[i]);
				printInfo(messagestr,options);
			}
			for (i=0;i<sopt->numOrb;i++) {
				sources++;
				sprintf(messagestr,"OC Product %d: SP3 orbit file: %s",sources,sopt->orbFile[i]);
				printInfo(messagestr,options);
				sprintf(messagestr,"OC Product %d: clock file:     %s",sources,sopt->clkFile[i]);
				printInfo(messagestr,options);
			}
		} else if (options->workMode==wmSBASPLOTS ) {
			sprintf(messagestr,"RINEX navigation message input file: %s",sopt->navFile[0]);
			printInfo(messagestr,options);
			sprintf(messagestr,"SBAS message data input file: %s",sopt->sbasFile);
			printInfo(messagestr,options);
		} else if (options->workMode==wmSHOWINPUT) {
			sprintf(messagestr,"RINEX observation input file: %s",sopt->obsFile);
			printInfo(messagestr,options);
			if (sopt->glonavFile[0]!='\0') {
				sprintf(messagestr,"Input RINEX navigation file for GLONASS frequencies: %s",sopt->glonavFile);
				printInfo(messagestr,options);
			}
		}

		if (options->workMode==wmDOPROCESSING || options->workMode==wmCOMPAREORBITS || options->workMode==wmSHOWPRODUCT) {
			if (preciseProductsAvailable) {
				if (sopt->conFile[0]!='\0') {
					sprintf(messagestr,"Constellation status file: %s",sopt->conFile);
					printInfo(messagestr,options);
				}
				if (sopt->antFile[0]!='\0') {
					sprintf(messagestr,"ANTEX %s antenna input file: %s",sopt->numAntRec==0?"satellite and receiver":"satellite",sopt->antFile);
					printInfo(messagestr,options);
				}
				if (sopt->numAntRec>0) {
					strpos=sprintf(messagestr,"ANTEX receiver antenna input file%s:",sopt->numAntRec==1?"":"s");
					for(i=0;i<sopt->numAntRec;i++) {
						strpos+=sprintf(&messagestr[strpos]," %s",sopt->antrecFile[i]);
					}
					printInfo(messagestr,options);
				}
			}
		}

		if (options->workMode==wmDOPROCESSING || options->workMode==wmSHOWPRODUCT || options->workMode==wmSHOWINPUT ) {
			if (sopt->antsatblockFile[0]!='\0') {
				sprintf(messagestr,"ANTEX input file for satellite block type: %s",sopt->antsatblockFile);
				printInfo(messagestr,options);
			}
		}
		if (sopt->posReferenceFile[0]!='\0') {
			if ( options->receiverPositionSource == rpSETREF ) {
				sprintf(messagestr,"Reference position file for modelling and differential fields: %s",sopt->posReferenceFile);
				printInfo(messagestr,options);
				sprintf(messagestr,"Interpolation degree for reference position: %d",options->RefDegInterp);
				printInfo(messagestr,options);
			} else if ( options->receiverPositionSource == rpCALCULATEREF || options->receiverPositionSource == rpCALCULATERINEXREF
				   || options->receiverPositionSource == rpCALCULATEUSERREF ||  options->receiverPositionSource == rpRTCMRoverUSERREF 
					||  options->receiverPositionSource == rpRTCMRefUSERRoverREF) {
				sprintf(messagestr,"Reference position file for differential fields: %s",sopt->posReferenceFile);
				printInfo(messagestr,options);
				sprintf(messagestr,"Interpolation degree for reference position: %d",options->RefDegInterp);
				printInfo(messagestr,options);
			}
		}
	}

	if (options->workMode!=wmDOPROCESSING) {
		//If mode is not data processing, disable the summary
		options->printSummary=0;
		options->useDatasummary=0;
	} 
	if (options->workMode==wmSHOWINPUT) {
		//Disable all DCBs (except GPS P1-C1)
		options->GPSp1p2DCBModel = DCBNONE;
		options->GPSISCl1caDCBModel = DCBNONE;
		options->GPSISCl1cpDCBModel = DCBNONE;
		options->GPSISCl1cdDCBModel = DCBNONE;
		options->GPSISCl2cDCBModel = DCBNONE;
		options->GPSISCl5i5DCBModel = DCBNONE;
		options->GPSISCl5q5DCBModel = DCBNONE;
		options->GALe1e5aDCBModel = DCBNONE;
		options->GALe1e5bDCBModel = DCBNONE;
		options->GLOp1p2DCBModel = DCBNONE;
		options->BDSb1b6DCBModel = DCBNONE;
		options->BDSb2b6DCBModel = DCBNONE;
		options->BDSb5b6DCBModel = DCBNONE;
		options->BDSb7b6DCBModel = DCBNONE;
		options->BDSSP3DCBModel = DCBNONE;
		options->BDSISCb1cdDCBModel = DCBNONE;
		options->BDSISCb2adDCBModel = DCBNONE;
		options->QZSc1cDCBModel = DCBNONE;
		options->QZSISCl1cpDCBModel = DCBNONE;
		options->QZSISCl1cdDCBModel = DCBNONE;
		options->QZSISCl2cDCBModel = DCBNONE;
		options->QZSISCl5i5DCBModel = DCBNONE;
		options->QZSISCl5q5DCBModel = DCBNONE;
		options->IRNc9c5DCBModel = DCBNONE;
		options->OSBdcbModel = OSBNONE;
		options->DSBdcbModel = DSBNONE;
		for(i=0;i<MAX_GNSS;i++) {
			options->DualFreqDCBModel[i] = DCBNONE;
		}
	}
	
	if (options->workMode==wmDOPROCESSING && options->estimateAmbiguities==0) {
		//In processing mode, if ambiguity computation is disabled by user, 
		//then force the disable of cycle-slip detection, code phase jumps detection 
		//and carrier phase aligment
		if (options->checkPhaseCodeJumps==1) {
			options->checkPhaseCodeJumps=0;
			printInfo("Forcing disable of code jumps detection as carrier phases are used as absolute measurements",options);
		}
		if (options->prealignCP==1) {
			options->prealignCP=0;
			printInfo("Forcing disable of carrier phase alignment as carrier phases are used as absolute measurements",options);
		}
	}

	if (options->usePhase==0) options->estimateAmbiguities=0;

	return 1;
}


/*****************************************************************************
 * Name        : setAutomaticSmoothing
 * Description : Check all code measurements selected and apply to them
 *                smoothing. The rationale is to use the same measurement or
 *                combination with the same frequncy(ies) but with carrier
 *                phase measurements to smooth with
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TOptions  *options              IO N/A  TOptions structure
 *****************************************************************************/
void setAutomaticSmoothing (TOptions *options) {

	int 	i,j,k,l,m;

	if (options->smoothAuto==0 && options->numAutoMeasSmoothSatByUser==0) return;


	for(i=0;i<NUM_OBSRINEX;i++) {
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				if (options->includeSatellite[j][k]==0) continue;
				if (options->smoothAuto==0 && options->autoMeasSmoothSatByUser[j][k]<=0) continue;
				for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
					switch(options->filterMeasTypeList[i][j][k][l]) {
						case SinglePseudorange:
							options->filterMeasTypeList[i][j][k][l]=SinglePseudorangeSmoothed;
							if (options->filterListWithMeas[i][j][k][l]==0) {
								options->filterSmoothMeasList[i][j][k][l][0]=NA;
								options->filterSmoothListWithMeas[i][j][k][l]=0;
								options->filterSmoothListMeasSelected[i][j][k][l]=0;
							} else {
								for(m=0;m<=options->numCombfilterSmoothMeas[i][j][k][l];m++) {
									options->filterSmoothMeasList[i][j][k][l][m]=options->filterMeasList[i][j][k][l][m]+1;
								}
								options->filterSmoothListWithMeas[i][j][k][l]=1;
								options->filterSmoothListMeasSelected[i][j][k][l]=1;
							}
							options->filterMeasSmoothed[i][j][k][l]=1;
							options->numCombfilterSmoothMeas[i][j][k][l]=options->numCombfilterMeas[i][j][k][l];
							options->filterSmoothMeasfreq[i][j][k][l][0]=options->filterMeasfreq[i][j][k][l][0];
							break;
						case IonoFreeCombCode:
							options->filterMeasTypeList[i][j][k][l]=IonoFreeCombCodeSmoothed;
							if (options->filterMeasList[i][j][k][l][0]>=IF12 && options->filterMeasList[i][j][k][l][0]<=IF90) {
								//IF combination, no need to convert
								options->filterSmoothMeasList[i][j][k][l][0]=options->filterMeasList[i][j][k][l][0];
							} else {
								//Convert PCXX to LCXX
								options->filterSmoothMeasList[i][j][k][l][0]=options->filterMeasList[i][j][k][l][0]+135;
							}
							if (options->filterListWithMeas[i][j][k][l]==0) {
								options->filterSmoothListWithMeas[i][j][k][l]=0;
								options->filterSmoothListMeasSelected[i][j][k][l]=0;
							} else {
								for(m=1;m<=options->numCombfilterMeas[i][j][k][l];m++) {
									options->filterSmoothMeasList[i][j][k][l][m]=options->filterMeasList[i][j][k][l][m]+1;
								}
								options->filterSmoothListWithMeas[i][j][k][l]=1;
								options->filterSmoothListMeasSelected[i][j][k][l]=1;
							}
							for(m=0;m<options->numCombfilterMeas[i][j][k][l];m++) {
								options->filterSmoothMeasfreq[i][j][k][l][m]=options->filterMeasfreq[i][j][k][l][m];
							}
							options->filterMeasSmoothed[i][j][k][l]=1;
							options->numCombfilterSmoothMeas[i][j][k][l]=options->numCombfilterMeas[i][j][k][l];
							break;
						case DivergenceFreeCode:
							options->filterMeasTypeList[i][j][k][l]=DivergenceFreeCodeSmoothed;
							options->filterSmoothMeasList[i][j][k][l][0]=options->filterMeasList[i][j][k][l][0];
							if (options->filterListWithMeas[i][j][k][l]==0) {
								options->filterSmoothListWithMeas[i][j][k][l]=0;
								options->filterSmoothListMeasSelected[i][j][k][l]=0;
							} else {
								for(m=1;m<=options->numCombfilterMeas[i][j][k][l];m++) {
									options->filterSmoothMeasList[i][j][k][l][m]=options->filterMeasList[i][j][k][l][m]+1;
								}
								options->filterSmoothListWithMeas[i][j][k][l]=1;
								options->filterSmoothListMeasSelected[i][j][k][l]=1;
							}
							for(m=0;m<options->numCombfilterMeas[i][j][k][l];m++) {
								options->filterSmoothMeasfreq[i][j][k][l][m]=options->filterMeasfreq[i][j][k][l][m];
							}
							options->filterMeasSmoothed[i][j][k][l]=1;
							options->numCombfilterSmoothMeas[i][j][k][l]=options->numCombfilterMeas[i][j][k][l];
							break;							
						case SecondIonoFreeCode:
							options->filterMeasTypeList[i][j][k][l]=SecondIonoFreeCodeSmoothed;
							options->filterSmoothMeasList[i][j][k][l][0]=options->filterMeasList[i][j][k][l][0];
							if (options->filterListWithMeas[i][j][k][l]==0) {
								options->filterSmoothListWithMeas[i][j][k][l]=0;
								options->filterSmoothListMeasSelected[i][j][k][l]=0;
							} else {
								for(m=1;m<=options->numCombfilterMeas[i][j][k][l];m++) {
									options->filterSmoothMeasList[i][j][k][l][m]=options->filterMeasList[i][j][k][l][m]+1;
								}
								options->filterSmoothListWithMeas[i][j][k][l]=1;
								options->filterSmoothListMeasSelected[i][j][k][l]=1;
							}
							for(m=0;m<options->numCombfilterMeas[i][j][k][l];m++) {
								options->filterSmoothMeasfreq[i][j][k][l][m]=options->filterMeasfreq[i][j][k][l][m];
							}
							options->filterMeasSmoothed[i][j][k][l]=1;
							options->numCombfilterSmoothMeas[i][j][k][l]=options->numCombfilterMeas[i][j][k][l];
							break;
						default:
							//Measurements is a carrier phase, or it is already smoothed or it is not a measurment that can be smoothed
							continue;
							break;
					}
				}
			}
		}
	}	
}

/*****************************************************************************
 * Name        : setDefaultMeasurements
 * Description : Set the default measurements (if user did not set all the
 *                options). It has to be done after the RINEX observation header
 *                has been read, so the available frequencies are known.
 *               Also, fill the table of measurements to be modelled and to
 *                 be checked by SNR if user has manually defined measurements
 *                 to use.
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TEpoch *epoch                   I  N/A  TEpoch structure
 * TEpoch *epochDGNSS              I  N/A  TEpoch structure for DGNSS
 * TConstellation  *constellation  I  N/A  TConstellation structure where satellite data
 *                                          is stored and it will be used for unselecting
 *                                          frequencies not available in current satellite block
 * TSupportOptions  *sopt          I  N/A  TSupportOptions structure
 * TOptions  *options              IO N/A  TOptions structure
 *****************************************************************************/
void setDefaultMeasurements (TEpoch *epoch, TEpoch *epochDGNSS, TConstellation *constellation, TSupportOptions *sopt, TOptions *options) {
	int 						i,j,k,l,m,n,o,x,y,z;
	int 						AnyMeasSmoothed;
	int							aux1;
	int							freq[4],freqNotChecked[MAX_FREQUENCIES_PER_GNSS];
	int							freqUsed[MAX_GNSS][MAX_FREQUENCIES_PER_GNSS];
	int							numCombMeas,numFreqNotUsed,numFreqSelected,quadmeas;
	int							computedIGFcombFactor[NUM_OBSRINEX][MAX_GNSS][MAX_TRIPLE_FREQUENCIES_COMBINATIONS];
	int							computedIGFcombFactorGLONASS[NUM_OBSRINEX][MAX_SATELLITES_PER_GNSS][MAX_TRIPLE_FREQUENCIES_COMBINATIONS];
	int							GPSLNAVAvail[2]={0,0},GPSCNAVAvail[2]={0,0},GPSCNAV2Avail[2]={0,0},QZSLNAVAvail[2]={0,0},QZSCNAVAvail[2]={0,0};
	int							QZSCNAV2Avail[2]={0,0},GalFNAVAvail[2]={0,0},GalINAVAvail[2]={0,0},GLOFDMAAvail[2]={0,0},GLOCDMAAvail[2]={0,0};
	int							BDSD1Avail[2]={0,0},BDSD2Avail[2]={0,0},BDSCNAV1Avail[2]={0,0},BDSCNAV2Avail[2]={0,0},GEOCNAVAvail[2]={0,0},IRNCNAVAvail[2]={0,0};
	int							BDSPreciseOrbitsDCBSingleFreqOff=0,BDSPreciseOrbitsDCBDualFreqOff=0;
	double						freq1,freq2;
	char						auxstr[1000],auxstr2[1000],auxstr3[1000],charaux;
	enum WeightMode		 		defaultWeightModeToSet=defaultWeightMode; 
	enum MeasurementType		meas,meas2,meas3,combIGF;
	enum SatelliteBlock			satBlock;
	TEpoch 						*epochPointer;
		
	for(i=0;i<MAX_GNSS;i++) {
		options->ConstellationUsed[i]=0;
	}



	//Get satellite block type if ANTEX is available. 
	//If not enabled or satellite block not found, default value is UNKNOWN_BLOCK, which has no missing frequencies
	if (options->SatBlockMeasDiscard==1) {
		//Get satellite block
		for(i=0;i<MAX_GNSS;i++) {
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				constellation->satLastUsed[i][j] = getConstellationElement(i,j,&epoch->t,constellation);
				if (constellation->satLastUsed[i][j]!=NULL) {
					satBlock=constellation->satLastUsed[i][j]->block;
					memcpy(options->availFreq[i][j],options->FreqAvailSatBlock[satBlock],sizeof(int)*MAX_FREQUENCIES_PER_GNSS);
				} else {
					satBlock=UNKNOWN_BLOCK;
				}
			}
		}
	}

	if (options->FastPPP==1 || options->UncombinedPPP==1) {
		//Two codes and two phases without combining (F-PPP or uncombined PPP)
		//Disable dual-frequency DCBs
		for(i=0;i<MAX_GNSS;i++) {
			options->DualFreqDCBModel[i]=DCBNONE;
		}
		if (sopt->userFilterMeas[ROVERPOS]==0 || options->numAutoMeasSatByUser>0) {
			//Only set measurements if user did not provide any
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (sopt->userFilterMeas[ROVERPOS]==1 && options->autoMeasSatByUser[i][j]<=0) {
						if (options->autoMeasSatByUser[i][j]==0) {
							options->ConstellationUsed[i]=1;
						}
						continue;
					}
					//Select iono free combination with available frequencies (per satellite basis)
					numFreqSelected=0;
					for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
						freq[numFreqSelected]=options->defaultFreq[i][j][k];
						if (freq[numFreqSelected]==-1) break; //No more available frequencies
						if (options->usableFreq[i][j][freq[numFreqSelected]]==1 && availGNSSFreq[i][freq[numFreqSelected]]==1
								&& epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
							numFreqSelected++;
						} else if (i==GLONASS && options->GLOsatFDMAdisabled[GLONASS][j][freq[numFreqSelected]]==1) {
							if (availGNSSFreq[i][freq[numFreqSelected]]==1 && epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
								numFreqSelected++;
							}
						}
						if (numFreqSelected==2) {
							break;
						}
					}
					//Sort frequencies
					if (freq[0]!=0 && freq[1]!=0 && freq[0]>freq[1]) {
						aux1=freq[0];
						freq[0]=freq[1];
						freq[1]=aux1;
					} else if (freq[0]==0) {
						aux1=freq[0];
						freq[0]=freq[1];
						freq[1]=aux1;
					}

					if (numFreqSelected==2) {
						options->filterMeasList[ROVERPOS][i][j][0][0]=NA;
						options->filterMeasList[ROVERPOS][i][j][1][0]=NA;
						options->filterMeasList[ROVERPOS][i][j][2][0]=NA;
						options->filterMeasList[ROVERPOS][i][j][3][0]=NA;
						options->filterMeasTypeList[ROVERPOS][i][j][0]=SinglePseudorange;
						options->filterMeasTypeList[ROVERPOS][i][j][1]=SinglePseudorange;
						options->filterMeasTypeList[ROVERPOS][i][j][2]=SingleCarrierPhase;
						options->filterMeasTypeList[ROVERPOS][i][j][3]=SingleCarrierPhase;
						options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
						options->filterMeasKind[ROVERPOS][i][j][1]=Pseudorange;
						options->filterMeasKind[ROVERPOS][i][j][2]=CarrierPhase;
						options->filterMeasKind[ROVERPOS][i][j][3]=CarrierPhase;
						options->filterMeasfreq[ROVERPOS][i][j][0][0]=freq[0];
						options->filterMeasfreq[ROVERPOS][i][j][1][0]=freq[1];
						options->filterMeasfreq[ROVERPOS][i][j][2][0]=freq[0];
						options->filterMeasfreq[ROVERPOS][i][j][3][0]=freq[1];
						options->filterListWithMeas[ROVERPOS][i][j][0]=0; //Measurement to use will be selected later
						options->filterListWithMeas[ROVERPOS][i][j][1]=0; //Measurement to use will be selected later
						options->filterListWithMeas[ROVERPOS][i][j][2]=0; //Measurement to use will be selected later
						options->filterListWithMeas[ROVERPOS][i][j][3]=0; //Measurement to use will be selected later
						options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
						options->filterListMeasSelected[ROVERPOS][i][j][1]=MEASUNSELECTED;
						options->filterListMeasSelected[ROVERPOS][i][j][2]=MEASUNSELECTED;
						options->filterListMeasSelected[ROVERPOS][i][j][3]=MEASUNSELECTED;
						options->numCombfilterMeas[ROVERPOS][i][j][0]=1;
						options->numCombfilterMeas[ROVERPOS][i][j][1]=1;
						options->numCombfilterMeas[ROVERPOS][i][j][2]=1;
						options->numCombfilterMeas[ROVERPOS][i][j][3]=1;
						options->numfilterMeasList[ROVERPOS][i][j]=4;
						options->ConstellationUsed[i]=1;
					} else {
						options->numfilterMeasList[ROVERPOS][i][j]=0;
					}
				}
			}
		} else {
			//Check if a constellation has measurements to use (selected by user)
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (options->numfilterMeasList[ROVERPOS][i][j]>0) {
						options->ConstellationUsed[i]=1;
						break;
					}
					if (options->ConstellationUsed[i]==1) break;
				}
			}
		}
	} else if (options->CombTypeAutoSelection==CombTypeAutoSelectionGraphic) {
		//Graphic combination
		auxstr[0]='G';
		auxstr[2]='\0';
		if (sopt->userFilterMeas[ROVERPOS]==0 || options->numAutoMeasSatByUser>0) {
			//Only set measurements if user did not provide any
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (sopt->userFilterMeas[ROVERPOS]==1 && options->autoMeasSatByUser[i][j]<=0) {
						if (options->autoMeasSatByUser[i][j]==0) {
							options->ConstellationUsed[i]=1;
						}
						continue;
					}
					//Select iono free combination with available frequencies (per satellite basis)
					numFreqSelected=0;
					for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
						freq[numFreqSelected]=options->defaultFreq[i][j][k];
						if (freq[numFreqSelected]==-1) break; //No more available frequencies
						if (options->usableFreq[i][j][freq[numFreqSelected]]==1 && availGNSSFreq[i][freq[numFreqSelected]]==1
								&& epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
							numFreqSelected++;
						} else if (i==GLONASS && options->GLOsatFDMAdisabled[GLONASS][j][freq[numFreqSelected]]==1) {
							if (availGNSSFreq[i][freq[numFreqSelected]]==1 && epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
								numFreqSelected++;
							}
						}
						if (numFreqSelected==1) {
							break;
						}
					}
					auxstr[1]='0'+freq[0];
					meas=measstr2meastype(auxstr);
					if (numFreqSelected==1) {
						options->filterMeasList[ROVERPOS][i][j][0][0]=meas;
						options->filterMeasTypeList[ROVERPOS][i][j][0]=GraphicComb;
						options->filterMeasKind[ROVERPOS][i][j][0]=CarrierPhase;
						options->filterListWithMeas[ROVERPOS][i][j][0]=0; //Measurement to use will be selected later
						options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
						options->numCombfilterMeas[ROVERPOS][i][j][0]=2;
						options->filterMeasfreq[ROVERPOS][i][j][0][0]=freq[0];
						options->filterMeasfreq[ROVERPOS][i][j][0][1]=freq[0];
						options->numfilterMeasList[ROVERPOS][i][j]=1;
					} else {
						options->numfilterMeasList[ROVERPOS][i][j]=0;
					}
				}
			}
		} else {
			//Check if a constellation has measurements to use (selected by user)
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (options->numfilterMeasList[ROVERPOS][i][j]>0) {
						options->ConstellationUsed[i]=1;
						break;
					}
					if (options->ConstellationUsed[i]==1) break;
				}
			}
		}
	} else if (( (sopt->navMode==NMppp && options->CombTypeAutoSelection!=CombTypeAutoSelectionSingleFreq) || 
				options->CombTypeAutoSelection==CombTypeAutoSelectionDualFreq) && sopt->navObservables==NTpseudorange) {
		//Dual frequency with code only
		auxstr[0]='I';
		auxstr[1]='F';
		auxstr[4]='\0';
		if (sopt->userFilterMeas[ROVERPOS]==0 || options->numAutoMeasSatByUser>0) {
			//Only set measurements if user did not provide any
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (sopt->userFilterMeas[ROVERPOS]==1 && options->autoMeasSatByUser[i][j]<=0) {
						if (options->autoMeasSatByUser[i][j]==0) {
							options->ConstellationUsed[i]=1;
						}
						continue;
					}
					//Select iono free combination with available frequencies (per satellite basis)
					numFreqSelected=0;
					for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
						freq[numFreqSelected]=options->defaultFreq[i][j][k];
						if (freq[numFreqSelected]==-1) break; //No more available frequencies
						if (options->usableFreq[i][j][freq[numFreqSelected]]==1 && availGNSSFreq[i][freq[numFreqSelected]]==1
								&& epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
							auxstr[2+numFreqSelected]='0'+freq[numFreqSelected];
							numFreqSelected++;
						} else if (i==GLONASS && options->GLOsatFDMAdisabled[GLONASS][j][freq[numFreqSelected]]==1) {
							if (availGNSSFreq[i][freq[numFreqSelected]]==1 && epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
								auxstr[2+numFreqSelected]='0'+freq[numFreqSelected];
								numFreqSelected++;
							}
						}
						if (numFreqSelected==2) {
							meas=measstr2meastype(auxstr);
							break;
						}
					}
					//Sort frequencies
					if (auxstr[2]!='0' && auxstr[3]!='0' && auxstr[2]>auxstr[3]) {
						charaux=auxstr[2];
						auxstr[2]=auxstr[3];
						auxstr[3]=charaux;
						aux1=freq[0];
						freq[0]=freq[1];
						freq[1]=aux1;
						meas=measstr2meastype(auxstr);
					} else if (auxstr[2]=='0') {
						charaux=auxstr[2];
						auxstr[2]=auxstr[3];
						auxstr[3]=charaux;
						aux1=freq[0];
						freq[0]=freq[1];
						freq[1]=aux1;
						meas=measstr2meastype(auxstr);
					}

					if (numFreqSelected==2) {
						options->filterMeasList[ROVERPOS][i][j][0][0]=meas;
						options->filterMeasTypeList[ROVERPOS][i][j][0]=IonoFreeCombCode;
						options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
						options->filterListWithMeas[ROVERPOS][i][j][0]=0; //Measurement to use will be selected later
						options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
						options->numCombfilterMeas[ROVERPOS][i][j][0]=2;
						options->filterMeasfreq[ROVERPOS][i][j][0][0]=freq[0];
						options->filterMeasfreq[ROVERPOS][i][j][0][1]=freq[1];
						options->numfilterMeasList[ROVERPOS][i][j]=1;
						options->ConstellationUsed[i]=1;
					} else {
						options->numfilterMeasList[ROVERPOS][i][j]=0;
					}
				}
			}
		} else {
			//Check if a constellation has measurements to use (selected by user)
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (options->numfilterMeasList[ROVERPOS][i][j]>0) {
						options->ConstellationUsed[i]=1;
						break;
					}
					if (options->ConstellationUsed[i]==1) break;
				}
			}
		}
		//Set automatic smoothing (if enabled)
		setAutomaticSmoothing(options);

	} else if (( ( (sopt->navMode==NMppp && options->CombTypeAutoSelection!=CombTypeAutoSelectionSingleFreq) 
					|| options->CombTypeAutoSelection==CombTypeAutoSelectionDualFreq) && sopt->navObservables==NTcarrierphase) || options->workMode==wmSHOWINPUT) {
		//Dual frequency with code and phase (also showINPUT default combination)
		auxstr[0]='I';
		auxstr[1]='F';
		auxstr[4]='\0';
		auxstr2[0]='I';
		auxstr2[1]='F';
		auxstr2[4]='\0';
		if (sopt->userFilterMeas[ROVERPOS]==0 || options->numAutoMeasSatByUser>0) {
			if (MAX_FILTER_MEASUREMENTS_SAT<2) {
				sprintf(messagestr,"Maximum number of measurements per satellite are %d, but PPP needs at least 2",MAX_FILTER_MEASUREMENTS_SAT);
				printError(messagestr,options);
			}
			//Only set measurements if user did not provide any
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (sopt->userFilterMeas[ROVERPOS]==1 && options->autoMeasSatByUser[i][j]<=0) {
						if (options->autoMeasSatByUser[i][j]==0) {
							options->ConstellationUsed[i]=1;
						}
						continue;
					}
					//Select iono free combination with available frequencies (per satellite basis)
					numFreqSelected=0;
					for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
						freq[numFreqSelected]=options->defaultFreq[i][j][k];
						if (freq[numFreqSelected]==-1) break; //No more available frequencies
						if (options->usableFreq[i][j][freq[numFreqSelected]]==1 && availGNSSFreq[i][freq[numFreqSelected]]==1
							&& epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1 ) {
							auxstr[2+numFreqSelected]='0'+freq[numFreqSelected];
							auxstr2[2+numFreqSelected]='0'+freq[numFreqSelected];
							numFreqSelected++;
						} else if (i==GLONASS && options->GLOsatFDMAdisabled[GLONASS][j][freq[numFreqSelected]]==1) {
							if (availGNSSFreq[i][freq[numFreqSelected]]==1 && epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
								auxstr[2+numFreqSelected]='0'+freq[numFreqSelected];
								auxstr2[2+numFreqSelected]='0'+freq[numFreqSelected];
								numFreqSelected++;
							}
						}
						if (numFreqSelected==2) {
							meas=measstr2meastype(auxstr);
							meas2=measstr2meastype(auxstr2);
							break;
						}
					}
					//Sort frequencies
					if (auxstr[2]!='0' && auxstr[3]!='0' && auxstr[2]>auxstr[3]) {
						charaux=auxstr[2];
						auxstr[2]=auxstr[3];
						auxstr[3]=charaux;
						charaux=auxstr2[2];
						auxstr2[2]=auxstr2[3];
						auxstr2[3]=charaux;
						aux1=freq[0];
						freq[0]=freq[1];
						freq[1]=aux1;
						meas=measstr2meastype(auxstr);
						meas2=measstr2meastype(auxstr2);
					} else if (auxstr[2]=='0') {
						charaux=auxstr[2];
						auxstr[2]=auxstr[3];
						auxstr[3]=charaux;
						charaux=auxstr2[2];
						auxstr2[2]=auxstr2[3];
						auxstr2[3]=charaux;
						aux1=freq[0];
						freq[0]=freq[1];
						freq[1]=aux1;
						meas=measstr2meastype(auxstr);
						meas2=measstr2meastype(auxstr2);
					}

					if (numFreqSelected==2) {
						options->filterMeasList[ROVERPOS][i][j][0][0]=meas;
						options->filterMeasTypeList[ROVERPOS][i][j][0]=IonoFreeCombCode;
						options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
						options->filterListWithMeas[ROVERPOS][i][j][0]=0; //Measurement to use will be selected later
						options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
						options->numCombfilterMeas[ROVERPOS][i][j][0]=2;
						options->filterMeasfreq[ROVERPOS][i][j][0][0]=freq[0];
						options->filterMeasfreq[ROVERPOS][i][j][0][1]=freq[1];
						options->filterMeasList[ROVERPOS][i][j][1][0]=meas2;
						options->filterMeasfreq[ROVERPOS][i][j][1][0]=freq[0];
						if (options->smoothAuto==0) {
							//Only set iono free phase combination if automatic smoothing is disabled
							options->filterMeasTypeList[ROVERPOS][i][j][1]=IonoFreeCombPhase;
							options->filterMeasKind[ROVERPOS][i][j][1]=CarrierPhase;
							options->filterListWithMeas[ROVERPOS][i][j][1]=0; //Measurement to use will be selected later
							options->filterListMeasSelected[ROVERPOS][i][j][1]=MEASUNSELECTED;
							options->numCombfilterMeas[ROVERPOS][i][j][1]=2;
							options->filterMeasfreq[ROVERPOS][i][j][1][1]=freq[1];
							options->numfilterMeasList[ROVERPOS][i][j]=2;
						} else {
							options->numfilterMeasList[ROVERPOS][i][j]=1;
						}
						options->ConstellationUsed[i]=1;
					} else {
						options->numfilterMeasList[ROVERPOS][i][j]=0;
					}
				}
			}
		} else {
			//Check if a constellation has measurements to use (selected by user)
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (options->numfilterMeasList[ROVERPOS][i][j]>0) {
						options->ConstellationUsed[i]=1;
						break;
					}
					if (options->ConstellationUsed[i]==1) break;
				}
			}
		}
		//Set automatic smoothing (if enabled)
		setAutomaticSmoothing(options);
	} else if ( (sopt->navMode==NMstandalone || options->CombTypeAutoSelection==CombTypeAutoSelectionSingleFreq) && sopt->navObservables==NTpseudorange) {
		//Single frequency with code only
		if (sopt->userFilterMeas[ROVERPOS]==0 || options->numAutoMeasSatByUser>0) {
			//Only set measurements if user did not provide any
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (sopt->userFilterMeas[ROVERPOS]==1 && options->autoMeasSatByUser[i][j]<=0) {
						if (options->autoMeasSatByUser[i][j]==0) {
							options->ConstellationUsed[i]=1;
						}
						continue;
					}
					//Select iono free combination with available frequencies (per satellite basis)
					numFreqSelected=0;
					for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
						freq[numFreqSelected]=options->defaultFreq[i][j][k];
						if (freq[numFreqSelected]==-1) break; //No more available frequencies
						if (options->usableFreq[i][j][freq[numFreqSelected]]==1 && availGNSSFreq[i][freq[numFreqSelected]]==1
								&& epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
							numFreqSelected++;
						} else if (i==GLONASS && options->GLOsatFDMAdisabled[GLONASS][j][freq[numFreqSelected]]==1) {
							if (availGNSSFreq[i][freq[numFreqSelected]]==1 && epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
								numFreqSelected++;
							}
						}
						if (numFreqSelected==1) {
							break;
						}
					}
					if (numFreqSelected==1) {
						options->filterMeasList[ROVERPOS][i][j][0][0]=NA;
						options->filterMeasTypeList[ROVERPOS][i][j][0]=SinglePseudorange;
						options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
						options->filterMeasfreq[ROVERPOS][i][j][0][0]=freq[0];
						options->filterListWithMeas[ROVERPOS][i][j][0]=0; //Measurement to use will be selected later
						options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
						options->numCombfilterMeas[ROVERPOS][i][j][0]=1;
						options->numfilterMeasList[ROVERPOS][i][j]=1;
						options->ConstellationUsed[i]=1;
					} else {
						options->numfilterMeasList[ROVERPOS][i][j]=0;
					}
				}
			}
		} else {
			//Check if a constellation has measurements to use (selected by user)
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (options->numfilterMeasList[ROVERPOS][i][j]>0) {
						options->ConstellationUsed[i]=1;
						break;
					}
					if (options->ConstellationUsed[i]==1) break;
				}
			}
		}
		//Set automatic smoothing (if enabled)
		setAutomaticSmoothing(options);
	} else if ( (sopt->navMode==NMstandalone || options->CombTypeAutoSelection==CombTypeAutoSelectionSingleFreq) && sopt->navObservables==NTcarrierphase) {
		//Single frequency with code and phase
		if (sopt->userFilterMeas[ROVERPOS]==0 || options->numAutoMeasSatByUser>0) {
			if (MAX_FILTER_MEASUREMENTS_SAT<2) {
				sprintf(messagestr,"Maximum number of measurements per satellite are %d, but SPP with carrier phase needs at least 2",MAX_FILTER_MEASUREMENTS_SAT);
				printError(messagestr,options);
			}
			//Only set measurements if user did not provide any
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (sopt->userFilterMeas[ROVERPOS]==1 && options->autoMeasSatByUser[i][j]<=0) {
						if (options->autoMeasSatByUser[i][j]==0) {
							options->ConstellationUsed[i]=1;
						}
						continue;
					}
					//Select iono free combination with available frequencies (per satellite basis)
					numFreqSelected=0;
					for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
						freq[numFreqSelected]=options->defaultFreq[i][j][k];
						if (freq[numFreqSelected]==-1) break; //No more available frequencies
						if (options->usableFreq[i][j][freq[numFreqSelected]]==1 && availGNSSFreq[i][freq[numFreqSelected]]==1
								&& epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
							numFreqSelected++;
						} else if (i==GLONASS && options->GLOsatFDMAdisabled[GLONASS][j][freq[numFreqSelected]]==1) {
							if (availGNSSFreq[i][freq[numFreqSelected]]==1 && epoch->measOrder[i].availFreq[freq[numFreqSelected]] && options->availFreq[i][j][freq[numFreqSelected]]==1) {
								numFreqSelected++;
							}
						}
						if (numFreqSelected==1) {
							break;
						}
					}
					if (numFreqSelected==1) {
						options->filterMeasList[ROVERPOS][i][j][0][0]=NA;
						options->filterMeasTypeList[ROVERPOS][i][j][0]=SinglePseudorange;
						options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
						options->filterListWithMeas[ROVERPOS][i][j][0]=0; //Measurement to use will be selected later
						options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
						options->numCombfilterMeas[ROVERPOS][i][j][0]=1;
						options->filterMeasfreq[ROVERPOS][i][j][0][0]=freq[0];
						if (options->smoothAuto==0) {
							options->filterMeasList[ROVERPOS][i][j][1][0]=NA;
							options->filterMeasTypeList[ROVERPOS][i][j][1]=SingleCarrierPhase;
							options->filterMeasKind[ROVERPOS][i][j][1]=CarrierPhase;
							options->filterListWithMeas[ROVERPOS][i][j][1]=0; //Measurement to use will be selected later
							options->numCombfilterMeas[ROVERPOS][i][j][1]=1;
							options->filterMeasfreq[ROVERPOS][i][j][1][0]=freq[0];
							options->filterListMeasSelected[ROVERPOS][i][j][1]=MEASUNSELECTED;
							options->numfilterMeasList[ROVERPOS][i][j]=2;
						} else {
							options->numfilterMeasList[ROVERPOS][i][j]=1;
						}
						options->ConstellationUsed[i]=1;
					} else {
						options->numfilterMeasList[ROVERPOS][i][j]=0;
					}
				}
			}
		} else {
			//Check if a constellation has measurements to use (selected by user)
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->includeSatellite[i][j]==0) continue;
					if (options->numfilterMeasList[ROVERPOS][i][j]>0) {
						options->ConstellationUsed[i]=1;
						break;
					}
					if (options->ConstellationUsed[i]==1) break;
				}
			}
		}
		//Set automatic smoothing (if enabled)
		setAutomaticSmoothing(options);
	}

	if (options->SBAScorrections==SBAS1Fused) {
		//In SBAS one frequency mode, force C1C measurement for navigation
		//Set default weight mode to SBAS
		defaultWeightModeToSet=SBASOnlyWeight;
		
		options->usePhase = 0;
		options->estimateAmbiguities=0;

		//Disable dual frequency DCB corrections
		for(i=0;i<MAX_GNSS;i++) {
			options->DualFreqDCBModel[i]=DCBNONE;
		}

		if (sopt->userMeasOrderList[ROVERPOS]==0) {
			for(j=1;j<=listMaxSatGNSS[GPS];j++) {
				//Set measurement priority list for frequency 1
				options->MeasOrder[ROVERPOS][GPS][j][1][CODEMEAS][0]=C1C;
				options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][0]=L1C;
				options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][1]=L1P;
				options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][2]=L1W;
				options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][0]=D1C;
				options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][1]=D1P;
				options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][2]=D1W;
				options->numMeasOrder[ROVERPOS][GPS][j][1][CODEMEAS]=1;
				options->numMeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS]=3;
				options->numMeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS]=3;
			}
			for(j=1;j<=listMaxSatGNSS[GLONASS];j++) {
				//Set measurement priority list for frequency 1
				options->MeasOrder[ROVERPOS][GLONASS][j][1][CODEMEAS][0]=C1C;
				options->MeasOrder[ROVERPOS][GLONASS][j][1][PHASEMEAS][0]=L1C;
				options->MeasOrder[ROVERPOS][GLONASS][j][1][PHASEMEAS][1]=L1P;
				options->MeasOrder[ROVERPOS][GLONASS][j][1][DOPPLERMEAS][0]=D1C;
				options->MeasOrder[ROVERPOS][GLONASS][j][1][DOPPLERMEAS][1]=D1P;
				options->numMeasOrder[ROVERPOS][GLONASS][j][1][CODEMEAS]=1;
				options->numMeasOrder[ROVERPOS][GLONASS][j][1][PHASEMEAS]=2;
				options->numMeasOrder[ROVERPOS][GLONASS][j][1][DOPPLERMEAS]=2;
			}
			for(j=1;j<=listMaxSatGNSS[GEO];j++) {
				//Set measurement priority list for frequency 1
				options->MeasOrder[ROVERPOS][GEO][j][1][CODEMEAS][0]=C1C;
				options->MeasOrder[ROVERPOS][GEO][j][1][PHASEMEAS][0]=L1C;
				options->MeasOrder[ROVERPOS][GEO][j][1][PHASEMEAS][1]=L1P;
				options->MeasOrder[ROVERPOS][GEO][j][1][DOPPLERMEAS][0]=D1C;
				options->MeasOrder[ROVERPOS][GEO][j][1][DOPPLERMEAS][1]=D1P;
				options->numMeasOrder[ROVERPOS][GEO][j][1][CODEMEAS]=1;
				options->numMeasOrder[ROVERPOS][GEO][j][1][PHASEMEAS]=2;
				options->numMeasOrder[ROVERPOS][GEO][j][1][DOPPLERMEAS]=2;
			}
		}

		for(i=0;i<MAX_GNSS;i++) {
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				if (i==GPS||i==GEO||i==GLONASS) {
					if (options->includeSatellite[i][j]==0) continue;
					options->filterMeasList[ROVERPOS][i][j][0][0]=C1C;
					options->filterMeasList[ROVERPOS][i][j][0][1]=C1C;
					if (options->smoothEpochs>0) {
						options->filterMeasTypeList[ROVERPOS][i][j][0]=SinglePseudorangeSmoothed;
					} else {
						options->filterMeasTypeList[ROVERPOS][i][j][0]=SinglePseudorange;
					}
					options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
					options->filterListWithMeas[ROVERPOS][i][j][0]=1; 
					options->filterMeasfreq[ROVERPOS][i][j][0][0]=1;
					options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
					options->numCombfilterMeas[ROVERPOS][i][j][0]=1;
					options->numfilterMeasList[ROVERPOS][i][j]=1;
					options->ConstellationUsed[i]=1;

					//Set smoothing measurement if smoothing is enabled
					if (options->smoothEpochs>0) {
						options->filterSmoothMeasList[ROVERPOS][i][j][0][0]=NA; //To be defined later between L1C, L1P or L1W
						options->filterMeasSmoothed[ROVERPOS][i][j][0]=1;
						options->filterSmoothListWithMeas[ROVERPOS][i][j][0]=0;
						options->numCombfilterSmoothMeas[ROVERPOS][i][j][0]=1;
						options->filterSmoothMeasfreq[ROVERPOS][i][j][0][0]=1;
						options->filterSmoothListMeasSelected[ROVERPOS][i][j][0]=0;
					}
				} else {
					//Unselect non GPS/GEO/GLONASS satellites
					options->numfilterMeasList[ROVERPOS][i][j]=0;
					options->includeSatellite[i][j]=0;
					options->ConstellationUsed[i]=0;
				}
			}
		}
			
		// Set SBAS processing mode for OUTPUT message
		options->solutionMode = SBAS1FMode;
	} else if (options->SBAScorrections==SBASDFMCused) {
		//In SBAS one frequency mode, force C1C measurement for navigation
		//Set default weight mode to SBAS
		defaultWeightModeToSet=SBASOnlyWeight;
		
		options->usePhase = 0;
		options->estimateAmbiguities=0;

		//Disable dual frequency DCB corrections.
		//For GPS only TGD from LNAV is used, the ISC is included in the SBAS DFMC clock correction, so it is already enabled by default
		//Galileo uses the combined frequencies 15 (same as reference clock). No need for dual frequency DCB
		for(i=1;i<MAX_GNSS;i++) {
			options->DualFreqDCBModel[i]=DCBNONE;
		}
		if (MAX_FILTER_MEASUREMENTS_SAT<2) {
			sprintf(messagestr,"Maximum number of measurements per satellite are %d, but SBAS DFMC needs at least 2",MAX_FILTER_MEASUREMENTS_SAT);
			printError(messagestr,options);
		}

		if (sopt->userMeasOrderList[ROVERPOS]==0) {
			if (options->useAnyMeasSBASDFMC==0) {
				//Set default values for Galileo, GLONASS, GEO and QZSS
				for(i=0;i<MAX_GNSS;i++) {
					if (i!=Galileo && i!=GEO && i!=QZSS && i!=GLONASS) continue;
					for(j=1;j<=listMaxSatGNSS[i];j++) {
						//Set measurement priority list for frequency 1
						options->MeasOrder[ROVERPOS][i][j][1][CODEMEAS][0]=C1C;
						options->MeasOrder[ROVERPOS][i][j][1][PHASEMEAS][0]=L1C;
						options->MeasOrder[ROVERPOS][i][j][1][DOPPLERMEAS][0]=D1C;
						options->numMeasOrder[ROVERPOS][i][j][1][CODEMEAS]=1;
						options->numMeasOrder[ROVERPOS][i][j][1][PHASEMEAS]=1;
						options->numMeasOrder[ROVERPOS][i][j][1][DOPPLERMEAS]=1;
						//Set measurement priority list for frequency 5
						options->MeasOrder[ROVERPOS][i][j][5][CODEMEAS][0]=C5Q;
						options->MeasOrder[ROVERPOS][i][j][5][PHASEMEAS][0]=L5Q;
						options->MeasOrder[ROVERPOS][i][j][5][DOPPLERMEAS][0]=D5Q;
						options->numMeasOrder[ROVERPOS][i][j][5][CODEMEAS]=1;
						options->numMeasOrder[ROVERPOS][i][j][5][PHASEMEAS]=1;
						options->numMeasOrder[ROVERPOS][i][j][5][DOPPLERMEAS]=1;
					}
				}
				for(j=1;j<=listMaxSatGNSS[GPS];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][GPS][j][1][CODEMEAS][0]=C1C;
					options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][0]=L1C;
					options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][0]=D1C;
					options->numMeasOrder[ROVERPOS][GPS][j][1][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS]=1;
					//Set measurement priority list for frequency 2 (for tests with GPS L1 and L2)
					options->MeasOrder[ROVERPOS][GPS][j][2][CODEMEAS][0]=C2P;
					options->MeasOrder[ROVERPOS][GPS][j][2][CODEMEAS][1]=C2W;
					options->MeasOrder[ROVERPOS][GPS][j][2][PHASEMEAS][0]=L2P;
					options->MeasOrder[ROVERPOS][GPS][j][2][PHASEMEAS][1]=L2W;
					options->MeasOrder[ROVERPOS][GPS][j][2][DOPPLERMEAS][0]=D2P;
					options->MeasOrder[ROVERPOS][GPS][j][2][DOPPLERMEAS][1]=D2W;
					options->numMeasOrder[ROVERPOS][GPS][j][2][CODEMEAS]=2;
					options->numMeasOrder[ROVERPOS][GPS][j][2][PHASEMEAS]=2;
					options->numMeasOrder[ROVERPOS][GPS][j][2][DOPPLERMEAS]=2;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][GPS][j][5][CODEMEAS][0]=C5Q;
					options->MeasOrder[ROVERPOS][GPS][j][5][PHASEMEAS][0]=L5Q;
					options->MeasOrder[ROVERPOS][GPS][j][5][DOPPLERMEAS][0]=D5Q;
					options->numMeasOrder[ROVERPOS][GPS][j][5][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GPS][j][5][PHASEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GPS][j][5][DOPPLERMEAS]=1;
				}
				for(j=1;j<=listMaxSatGNSS[BDS];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][BDS][j][1][CODEMEAS][0]=C1P;  //P attribute is pilot channel in BDS
					options->MeasOrder[ROVERPOS][BDS][j][1][PHASEMEAS][0]=L1P;
					options->MeasOrder[ROVERPOS][BDS][j][1][DOPPLERMEAS][0]=D1P;
					options->numMeasOrder[ROVERPOS][BDS][j][1][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][BDS][j][1][PHASEMEAS]=1;
					options->numMeasOrder[ROVERPOS][BDS][j][1][DOPPLERMEAS]=1;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][BDS][j][5][CODEMEAS][0]=C5P; //P attribute is pilot channel in BDS
					options->MeasOrder[ROVERPOS][BDS][j][5][PHASEMEAS][0]=L5P;
					options->MeasOrder[ROVERPOS][BDS][j][5][DOPPLERMEAS][0]=D5P;
					options->numMeasOrder[ROVERPOS][BDS][j][5][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][BDS][j][5][PHASEMEAS]=1;
				}
			} else {
				for(j=1;j<=listMaxSatGNSS[GPS];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][GPS][j][1][CODEMEAS][0]=C1C;
					options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][0]=L1C;
					options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][1]=L1P;
					options->MeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS][2]=L1W;
					options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][0]=D1C;
					options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][1]=D1P;
					options->MeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS][2]=D1W;
					options->numMeasOrder[ROVERPOS][GPS][j][1][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GPS][j][1][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GPS][j][1][DOPPLERMEAS]=3;
					//Set measurement priority list for frequency 2 (for tests with GPS L1 and L2)
					options->MeasOrder[ROVERPOS][GPS][j][2][CODEMEAS][0]=C2P;
					options->MeasOrder[ROVERPOS][GPS][j][2][CODEMEAS][1]=C2W;
					options->MeasOrder[ROVERPOS][GPS][j][2][PHASEMEAS][0]=L2P;
					options->MeasOrder[ROVERPOS][GPS][j][2][PHASEMEAS][1]=L2W;
					options->MeasOrder[ROVERPOS][GPS][j][2][DOPPLERMEAS][0]=D2P;
					options->MeasOrder[ROVERPOS][GPS][j][2][DOPPLERMEAS][1]=D2W;
					options->numMeasOrder[ROVERPOS][GPS][j][2][CODEMEAS]=2;
					options->numMeasOrder[ROVERPOS][GPS][j][2][PHASEMEAS]=2;
					options->numMeasOrder[ROVERPOS][GPS][j][2][DOPPLERMEAS]=2;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][GPS][j][5][CODEMEAS][0]=C5Q;
					options->MeasOrder[ROVERPOS][GPS][j][5][CODEMEAS][1]=C5I;
					options->MeasOrder[ROVERPOS][GPS][j][5][CODEMEAS][2]=C5X;
					options->MeasOrder[ROVERPOS][GPS][j][5][PHASEMEAS][0]=L5Q;
					options->MeasOrder[ROVERPOS][GPS][j][5][PHASEMEAS][1]=L5I;
					options->MeasOrder[ROVERPOS][GPS][j][5][PHASEMEAS][2]=L5X;
					options->MeasOrder[ROVERPOS][GPS][j][5][DOPPLERMEAS][0]=D5Q;
					options->MeasOrder[ROVERPOS][GPS][j][5][DOPPLERMEAS][1]=D5I;
					options->MeasOrder[ROVERPOS][GPS][j][5][DOPPLERMEAS][2]=D5X;
					options->numMeasOrder[ROVERPOS][GPS][j][5][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GPS][j][5][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GPS][j][5][DOPPLERMEAS]=3;
				}
				for(j=1;j<=listMaxSatGNSS[Galileo];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][Galileo][j][1][CODEMEAS][0]=C1C;
					options->MeasOrder[ROVERPOS][Galileo][j][1][CODEMEAS][1]=C1B;
					options->MeasOrder[ROVERPOS][Galileo][j][1][CODEMEAS][2]=C1X;
					options->MeasOrder[ROVERPOS][Galileo][j][1][PHASEMEAS][0]=L1C;
					options->MeasOrder[ROVERPOS][Galileo][j][1][PHASEMEAS][1]=L1B;
					options->MeasOrder[ROVERPOS][Galileo][j][1][PHASEMEAS][2]=L1X;
					options->MeasOrder[ROVERPOS][Galileo][j][1][DOPPLERMEAS][0]=D1C;
					options->MeasOrder[ROVERPOS][Galileo][j][1][DOPPLERMEAS][1]=D1B;
					options->MeasOrder[ROVERPOS][Galileo][j][1][DOPPLERMEAS][2]=D1X;
					options->numMeasOrder[ROVERPOS][Galileo][j][1][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][Galileo][j][1][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][Galileo][j][1][DOPPLERMEAS]=3;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][Galileo][j][5][CODEMEAS][0]=C5Q;
					options->MeasOrder[ROVERPOS][Galileo][j][5][CODEMEAS][1]=C5I;
					options->MeasOrder[ROVERPOS][Galileo][j][5][CODEMEAS][2]=C5X;
					options->MeasOrder[ROVERPOS][Galileo][j][5][PHASEMEAS][0]=L5Q;
					options->MeasOrder[ROVERPOS][Galileo][j][5][PHASEMEAS][1]=L5I;
					options->MeasOrder[ROVERPOS][Galileo][j][5][PHASEMEAS][2]=L5X;
					options->MeasOrder[ROVERPOS][Galileo][j][5][DOPPLERMEAS][0]=D5Q;
					options->MeasOrder[ROVERPOS][Galileo][j][5][DOPPLERMEAS][1]=D5I;
					options->MeasOrder[ROVERPOS][Galileo][j][5][DOPPLERMEAS][2]=D5X;
					options->numMeasOrder[ROVERPOS][Galileo][j][5][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][Galileo][j][5][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][Galileo][j][5][DOPPLERMEAS]=3;
				}
				for(j=1;j<=listMaxSatGNSS[GLONASS];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][GLONASS][j][1][CODEMEAS][0]=C1C;
					options->MeasOrder[ROVERPOS][GLONASS][j][1][PHASEMEAS][0]=L1C;
					options->MeasOrder[ROVERPOS][GLONASS][j][1][PHASEMEAS][1]=L1P;
					options->MeasOrder[ROVERPOS][GLONASS][j][1][DOPPLERMEAS][0]=D1C;
					options->MeasOrder[ROVERPOS][GLONASS][j][1][DOPPLERMEAS][1]=D1P;
					options->numMeasOrder[ROVERPOS][GLONASS][j][1][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GLONASS][j][1][PHASEMEAS]=2;
					options->numMeasOrder[ROVERPOS][GLONASS][j][1][DOPPLERMEAS]=2;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][GLONASS][j][5][CODEMEAS][0]=C5Q;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][CODEMEAS][1]=C5I;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][CODEMEAS][2]=C5X;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][PHASEMEAS][0]=L5Q;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][PHASEMEAS][1]=L5I;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][PHASEMEAS][2]=L5X;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][DOPPLERMEAS][0]=D5Q;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][DOPPLERMEAS][1]=D5I;
					options->MeasOrder[ROVERPOS][GLONASS][j][5][DOPPLERMEAS][2]=D5X;
					options->numMeasOrder[ROVERPOS][GLONASS][j][5][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GLONASS][j][5][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GLONASS][j][5][DOPPLERMEAS]=3;
				}
				for(j=1;j<=listMaxSatGNSS[GEO];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][GEO][j][1][CODEMEAS][0]=C1C;
					options->MeasOrder[ROVERPOS][GEO][j][1][PHASEMEAS][0]=L1C;
					options->MeasOrder[ROVERPOS][GEO][j][1][PHASEMEAS][1]=L1P;
					options->MeasOrder[ROVERPOS][GEO][j][1][DOPPLERMEAS][0]=D1C;
					options->MeasOrder[ROVERPOS][GEO][j][1][DOPPLERMEAS][1]=D1P;
					options->numMeasOrder[ROVERPOS][GEO][j][1][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][GEO][j][1][PHASEMEAS]=2;
					options->numMeasOrder[ROVERPOS][GEO][j][1][DOPPLERMEAS]=2;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][GEO][j][5][CODEMEAS][0]=C5Q;
					options->MeasOrder[ROVERPOS][GEO][j][5][CODEMEAS][1]=C5I;
					options->MeasOrder[ROVERPOS][GEO][j][5][CODEMEAS][2]=C5X;
					options->MeasOrder[ROVERPOS][GEO][j][5][PHASEMEAS][0]=L5Q;
					options->MeasOrder[ROVERPOS][GEO][j][5][PHASEMEAS][1]=L5I;
					options->MeasOrder[ROVERPOS][GEO][j][5][PHASEMEAS][2]=L5X;
					options->MeasOrder[ROVERPOS][GEO][j][5][DOPPLERMEAS][0]=D5Q;
					options->MeasOrder[ROVERPOS][GEO][j][5][DOPPLERMEAS][1]=D5I;
					options->MeasOrder[ROVERPOS][GEO][j][5][DOPPLERMEAS][2]=D5X;
					options->numMeasOrder[ROVERPOS][GEO][j][5][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GEO][j][5][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][GEO][j][5][DOPPLERMEAS]=3;
				}
				for(j=1;j<=listMaxSatGNSS[BDS];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][BDS][j][1][CODEMEAS][0]=C1P;
					options->MeasOrder[ROVERPOS][BDS][j][1][CODEMEAS][1]=C1D;
					options->MeasOrder[ROVERPOS][BDS][j][1][CODEMEAS][2]=C1X;
					options->MeasOrder[ROVERPOS][BDS][j][1][PHASEMEAS][0]=L1P;
					options->MeasOrder[ROVERPOS][BDS][j][1][PHASEMEAS][1]=L1D;
					options->MeasOrder[ROVERPOS][BDS][j][1][PHASEMEAS][2]=L1X;
					options->MeasOrder[ROVERPOS][BDS][j][1][DOPPLERMEAS][0]=D1P;
					options->MeasOrder[ROVERPOS][BDS][j][1][DOPPLERMEAS][1]=D1D;
					options->MeasOrder[ROVERPOS][BDS][j][1][DOPPLERMEAS][1]=D1X;
					options->numMeasOrder[ROVERPOS][BDS][j][1][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][BDS][j][1][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][BDS][j][1][DOPPLERMEAS]=3;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][BDS][j][5][CODEMEAS][0]=C5P;
					options->MeasOrder[ROVERPOS][BDS][j][5][CODEMEAS][1]=C5D;
					options->MeasOrder[ROVERPOS][BDS][j][5][CODEMEAS][2]=C5X;
					options->MeasOrder[ROVERPOS][BDS][j][5][PHASEMEAS][0]=L5P;
					options->MeasOrder[ROVERPOS][BDS][j][5][PHASEMEAS][1]=L5D;
					options->MeasOrder[ROVERPOS][BDS][j][5][PHASEMEAS][2]=L5X;
					options->MeasOrder[ROVERPOS][BDS][j][5][DOPPLERMEAS][0]=D5P;
					options->MeasOrder[ROVERPOS][BDS][j][5][DOPPLERMEAS][1]=D5D;
					options->MeasOrder[ROVERPOS][BDS][j][5][DOPPLERMEAS][2]=D5X;
					options->numMeasOrder[ROVERPOS][BDS][j][5][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][BDS][j][5][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][BDS][j][5][DOPPLERMEAS]=3;
				}
				for(j=1;j<=listMaxSatGNSS[QZSS];j++) {
					//Set measurement priority list for frequency 1
					options->MeasOrder[ROVERPOS][QZSS][j][1][CODEMEAS][0]=C1C;
					options->MeasOrder[ROVERPOS][QZSS][j][1][PHASEMEAS][0]=L1C;
					options->MeasOrder[ROVERPOS][QZSS][j][1][PHASEMEAS][1]=L1P;
					options->MeasOrder[ROVERPOS][QZSS][j][1][DOPPLERMEAS][0]=D1C;
					options->MeasOrder[ROVERPOS][QZSS][j][1][DOPPLERMEAS][1]=D1P;
					options->numMeasOrder[ROVERPOS][QZSS][j][1][CODEMEAS]=1;
					options->numMeasOrder[ROVERPOS][QZSS][j][1][PHASEMEAS]=2;
					options->numMeasOrder[ROVERPOS][QZSS][j][1][DOPPLERMEAS]=2;
					//Set measurement priority list for frequency 5
					options->MeasOrder[ROVERPOS][QZSS][j][5][CODEMEAS][0]=C5Q;
					options->MeasOrder[ROVERPOS][QZSS][j][5][CODEMEAS][1]=C5I;
					options->MeasOrder[ROVERPOS][QZSS][j][5][CODEMEAS][2]=C5X;
					options->MeasOrder[ROVERPOS][QZSS][j][5][PHASEMEAS][0]=L5Q;
					options->MeasOrder[ROVERPOS][QZSS][j][5][PHASEMEAS][1]=L5I;
					options->MeasOrder[ROVERPOS][QZSS][j][5][PHASEMEAS][2]=L5X;
					options->MeasOrder[ROVERPOS][QZSS][j][5][DOPPLERMEAS][0]=D5Q;
					options->MeasOrder[ROVERPOS][QZSS][j][5][DOPPLERMEAS][1]=D5I;
					options->MeasOrder[ROVERPOS][QZSS][j][5][DOPPLERMEAS][2]=D5X;
					options->numMeasOrder[ROVERPOS][QZSS][j][5][CODEMEAS]=3;
					options->numMeasOrder[ROVERPOS][QZSS][j][5][PHASEMEAS]=3;
					options->numMeasOrder[ROVERPOS][QZSS][j][5][DOPPLERMEAS]=3;
				}
			}
		}
		for(i=0;i<MAX_GNSS;i++) {
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				if (i==GPS) {
					if (options->includeSatellite[i][j]==0) continue;

					//Set GPS default frequency filling order to 1,5,2
					options->defaultFreq[i][j][1]=5;
					options->defaultFreq[i][j][2]=2;

					options->filterMeasList[ROVERPOS][i][j][0][0]=IF15;
					if (options->smoothEpochs>0) {
						options->filterMeasTypeList[ROVERPOS][i][j][0]=IonoFreeCombCodeSmoothed;
					} else {
						options->filterMeasTypeList[ROVERPOS][i][j][0]=IonoFreeCombCode;
					}
					options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
					options->filterListWithMeas[ROVERPOS][i][j][0]=0;
					options->filterMeasfreq[ROVERPOS][i][j][0][0]=1;
					options->filterMeasfreq[ROVERPOS][i][j][0][1]=5;
					options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
					options->numCombfilterMeas[ROVERPOS][i][j][0]=2;
					options->numfilterMeasList[ROVERPOS][i][j]=1;
					options->ConstellationUsed[i]=1;

					//Set smoothing measurement if smoothing is enabled
					if (options->smoothEpochs>0) {
						options->filterSmoothMeasList[ROVERPOS][i][j][0][0]=IF15; 
						options->filterMeasSmoothed[ROVERPOS][i][j][0]=1;
						options->filterSmoothListWithMeas[ROVERPOS][i][j][0]=0;
						options->numCombfilterSmoothMeas[ROVERPOS][i][j][0]=2;
						options->filterSmoothMeasfreq[ROVERPOS][i][j][0][0]=1;
						options->filterSmoothMeasfreq[ROVERPOS][i][j][0][1]=5;
						options->filterSmoothListMeasSelected[ROVERPOS][i][j][0]=0;
					}
				} else if (i==Galileo||i==QZSS||i==GEO||i==BDS) {
					if (options->includeSatellite[i][j]==0) continue;
					options->filterMeasList[ROVERPOS][i][j][0][0]=IF15;
					if (options->smoothEpochs>0) {
						options->filterMeasTypeList[ROVERPOS][i][j][0]=IonoFreeCombCodeSmoothed;
					} else {
						options->filterMeasTypeList[ROVERPOS][i][j][0]=IonoFreeCombCode;
					}
					options->filterMeasKind[ROVERPOS][i][j][0]=Pseudorange;
					options->filterListWithMeas[ROVERPOS][i][j][0]=0;
					options->filterMeasfreq[ROVERPOS][i][j][0][0]=1;
					options->filterMeasfreq[ROVERPOS][i][j][0][1]=5;
					options->filterListMeasSelected[ROVERPOS][i][j][0]=MEASUNSELECTED;
					options->numCombfilterMeas[ROVERPOS][i][j][0]=2;
					options->numfilterMeasList[ROVERPOS][i][j]=1;
					options->ConstellationUsed[i]=1;

					//Set smoothing measurement if smoothing is enabled
					if (options->smoothEpochs>0) {
						options->filterSmoothMeasList[ROVERPOS][i][j][0][0]=IF15; 
						options->filterMeasSmoothed[ROVERPOS][i][j][0]=1;
						options->filterSmoothListWithMeas[ROVERPOS][i][j][0]=0;
						options->numCombfilterSmoothMeas[ROVERPOS][i][j][0]=2;
						options->filterSmoothMeasfreq[ROVERPOS][i][j][0][0]=1;
						options->filterSmoothMeasfreq[ROVERPOS][i][j][0][1]=5;
						options->filterSmoothListMeasSelected[ROVERPOS][i][j][0]=0;
					}
				} else {
					//Unselect non GPS or Galileo or GEO or BDS or QZSS satellites
					options->numfilterMeasList[ROVERPOS][i][j]=0;
					options->includeSatellite[i][j]=0;
					options->ConstellationUsed[i]=0;
				}
			}
		}
			
		// Set SBAS processing mode for OUTPUT message
		options->solutionMode = SBASDFMCMode;
	} else if (options->DGNSS==1) {

		options->usePhase = 0;
		options->estimateAmbiguities=0;

		//Unselect non GPS constellations. To be removed when DGNSS is updated to multi-constellation
		for(i=0;i<MAX_GNSS;i++) { 
			if(i==GPS) continue;
			options->ConstellationUsed[i]=0;
		} 

		//Set default weight mode to DGNSS
		defaultWeightModeToSet=DGNSSOnlyWeight;

		//Disable dual frequency DCB corrections
		for(i=0;i<MAX_GNSS;i++) {
			options->DualFreqDCBModel[i]=DCBNONE;
			//Unselect all non GPS satellites
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				if (i!=GPS) {
					options->includeSatellite[i][j]=0;
				}
			}
		}

		for(i=0;i<NUM_OBSRINEX;i++) {
			//Set default measurements
			if (i==REFSTAPOS && sopt->userFilterMeas[ROVERPOS]>0 && sopt->userFilterMeas[REFSTAPOS]==0) {
					//If measurements for the rover are set but not for the reference station,
					//reference station measurements will be set according to rover
					//Smoothing will also be set later as measurements and smoothing must be
					//aligned in both rover and reference station
					//Check if a constellation has measurements to use (selected by user)
					for(j=0;j<MAX_GNSS;j++) {
						for(k=1;k<=listMaxSatGNSS[j];k++) {
							if (options->includeSatellite[j][k]==0) continue;
							if (options->numfilterMeasList[ROVERPOS][j][k]>0) {
								options->ConstellationUsed[j]=1;
								break;
							}
							if (options->ConstellationUsed[j]==1) break;
						}
					}
			} else {
				if (sopt->userFilterMeas[i]==0) {
					//In DGNSS mode, set C1C measurement as default for navigation
					for(j=0;j<MAX_GNSS;j++) {
						for(k=1;k<=listMaxSatGNSS[j];k++) {
							if (options->includeSatellite[j][k]==0) continue;
							if (j==GPS) {
								options->filterMeasList[i][j][k][0][0]=C1C;
								options->filterMeasList[i][j][k][0][1]=C1C;
								if (options->smoothEpochs>0) {
									options->filterMeasTypeList[i][j][k][0]=SinglePseudorangeSmoothed;
								} else {
									options->filterMeasTypeList[i][j][k][0]=SinglePseudorange;
								}
								options->filterMeasKind[i][j][k][0]=Pseudorange;
								options->filterListWithMeas[i][j][k][0]=1;
								options->filterListMeasSelected[i][j][k][0]=MEASUNSELECTED;
								options->filterMeasfreq[i][j][k][0][0]=1;
								options->numfilterMeasList[i][j][k]=1;
								options->numCombfilterMeas[i][j][k][0]=1;
								options->ConstellationUsed[j]=1;

							} else {
								//Unselect non GPS satellites
								options->numfilterMeasList[i][j][k]=0;
							}
						}
					}
				} else {
					//Check if a constellation has measurements to use (selected by user)
					for(j=0;j<MAX_GNSS;j++) {
						for(k=1;k<=listMaxSatGNSS[j];k++) {
							if (options->includeSatellite[j][k]==0) continue;
							if (options->numfilterMeasList[ROVERPOS][j][k]>0) {
								options->ConstellationUsed[j]=1;
								break;
							}
							if (options->ConstellationUsed[j]==1) break;
						}
					}
				}
				//Set smoothing measurement if smoothing is enabled
				//For reference station, only set smoothing if rover has no measurements set
				if (sopt->userFilterSmoothMeas[i]==0 && options->smoothEpochs>0) {
					if ((i==ROVERPOS && sopt->numMeasFilterText[ROVERPOS]==0) ||(i==REFSTAPOS && sopt->numMeasFilterText[REFSTAPOS]==0)) {
						for(j=0;j<MAX_GNSS;j++) {
							for(k=1;k<=listMaxSatGNSS[j];k++) {
								if (options->includeSatellite[j][k]==0) continue;
								if (j==GPS) {
									options->filterSmoothMeasList[i][j][k][0][0]=NA; //To be defined later between L1C, L1P or L1W
									options->filterMeasSmoothed[i][j][k][0]=1;
									options->filterSmoothListWithMeas[i][j][k][0]=0;
									options->numCombfilterSmoothMeas[i][j][k][0]=1;
									options->filterSmoothMeasfreq[i][j][k][0][0]=1;
									options->filterSmoothListMeasSelected[i][j][k][0]=0;
								}
							}
						}
					}
				}
			}
			//Set measurement priority list
			if (sopt->userMeasOrderList[i]==0) {
				for(j=0;j<MAX_GNSS;j++) {
					if(j!=GPS) continue;
					for(k=1;k<=listMaxSatGNSS[j];k++) {
						//Set measurement priority list fro frequency 1
						options->MeasOrder[i][j][k][1][CODEMEAS][0]=C1C;
						options->MeasOrder[i][j][k][1][PHASEMEAS][0]=L1C;
						options->MeasOrder[i][j][k][1][PHASEMEAS][1]=L1P;
						options->MeasOrder[i][j][k][1][PHASEMEAS][2]=L1W;
						options->MeasOrder[i][j][k][1][DOPPLERMEAS][0]=D1C;
						options->MeasOrder[i][j][k][1][DOPPLERMEAS][1]=D1P;
						options->MeasOrder[i][j][k][1][DOPPLERMEAS][2]=D1W;
						options->numMeasOrder[i][j][k][1][CODEMEAS]=1;
						options->numMeasOrder[i][j][k][1][PHASEMEAS]=3;
						options->numMeasOrder[i][j][k][1][DOPPLERMEAS]=3;
						options->MeasOrder[i][j][k][2][CODEMEAS][0]=C2P;
						options->MeasOrder[i][j][k][2][CODEMEAS][1]=C2W;
						options->MeasOrder[i][j][k][2][PHASEMEAS][0]=L2P;
						options->MeasOrder[i][j][k][2][PHASEMEAS][1]=L2W;
						options->MeasOrder[i][j][k][2][DOPPLERMEAS][0]=D2P;
						options->MeasOrder[i][j][k][2][DOPPLERMEAS][1]=D2W;
						options->numMeasOrder[i][j][k][2][CODEMEAS]=2;
						options->numMeasOrder[i][j][k][2][PHASEMEAS]=2;
						options->numMeasOrder[i][j][k][2][DOPPLERMEAS]=2;
					}
				}
			}
		}
	}

	//Remove constellations from reference clock constellation list if constellation is not used
	if (options->workMode == wmDOPROCESSING) {
		for(i=0;i<options->numClkRefPriorityList;i++) {
			if (options->ConstellationUsed[options->ClkRefPriorityList[i]]==0) {
				for(j=i;j<(options->numClkRefPriorityList-1);j++) {
					options->ClkRefPriorityList[j]=options->ClkRefPriorityList[j+1];
				}
				options->numClkRefPriorityList--;
				i--;
			}
		}
	}

	//Unset receiver APC correction for the frequencies not set by user and not used in the filter
	//This is for the case that the user provides the APC for the frequencies used and the receiver type is not found in the ANTEX. In this cases, as all corrections
	//have been provided, the APC data from the ANTEX is not needed (otherwise gLAB will exit with an error)

	//First check which frequencies are set in the filter. Set a variable to all frequencies to 0
	memset(freqUsed,0,sizeof(int)*MAX_GNSS*MAX_FREQUENCIES_PER_GNSS);
	//Loop through all measurements in the filter and mark all frequencies used
	for(i=0;i<NUM_OBSRINEX;i++) {
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				if (options->includeSatellite[j][k]==0) continue;
				for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
					for(m=0;m<options->numCombfilterMeas[i][j][k][l];m++) {
						freqUsed[j][options->filterMeasfreq[i][j][k][l][m]]=1;
					}
					if (options->filterMeasSmoothed[i][j][k][l]==1) {
						for(m=0;m<options->numCombfilterSmoothMeas[i][j][k][l];m++) {
							freqUsed[j][options->filterSmoothMeasfreq[i][j][k][l][m]]=1;
						}
					}
				}
			}
		}
	}
	//Set all frequencies not used and not set to adNONE (no receiver APC correction)
	for(i=0;i<MAX_GNSS;i++) {
		for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
			if (freqUsed[i][j]==0 && options->antennaDataGNSSsource[i][j]<=0) {
				options->antennaDataGNSS[i][j]=adNONE;
				options->antennaDataGNSSsource[i][j]=adNONE;
			}
		}
	}
	//Check if any frequency is to be read by ANTEX. If none, set the generic value to adSET
	k=adNONE;
	l=adNONE;
	for(i=0;i<MAX_GNSS;i++) {
		for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
			if (options->antennaDataGNSSsource[i][j]==adANTEX) {
				k=adANTEX;
			} else if (options->antennaDataGNSSsource[i][j]==adSET) {
				l=adSET;
			}
		}
	}
	if (k==adNONE) {
		//No frequencies to be read from ANTEX
		if (l==adSET) {
			options->antennaData=adSET;
		} else {
			options->antennaData=adNONE;
		}
	}


	//Check that there are constellations available for the reference clock (constellations used in the filter and not removed from the list of constellations to be used as reference clock)
	if (options->numClkRefPriorityList==0) {
		printError("There are no constellations available to be use as reference clock and available for navigation. Either add more constellations to be used as reference clock with parameter '-filter:refclkonlyorder' or select more constellations and satellites to be used for navigation with parameter '-pre:sat'",options);
	}

	for(i=0;i<MAX_GNSS;i++) {
		if (options->ConstellationUsed[i]==0) {
			//If no measurements for a whole constellation are selected, unselect all its DCBs
			switch(i) {
				case GPS:
					options->GPSp1c1DCBModel=GPSp1c1NONE;
					options->GPSp1p2DCBModel = DCBNONE;
					options->GPSISCl1caDCBModel=DCBNONE;
					options->GPSISCl1cpDCBModel=DCBNONE;
					options->GPSISCl1cdDCBModel=DCBNONE;
					options->GPSISCl2cDCBModel=DCBNONE;
					options->GPSISCl5i5DCBModel=DCBNONE;
					options->GPSISCl5q5DCBModel=DCBNONE;
					options->DualFreqDCBModel[GPS]=DCBNONE;
					break;
				case Galileo:
					options->GALe1e5aDCBModel= DCBNONE;
					options->GALe1e5bDCBModel= DCBNONE;
					options->DualFreqDCBModel[Galileo]=DCBNONE;
					break;
				case GLONASS:
					options->GLOp1p2DCBModel = DCBNONE;
					options->DualFreqDCBModel[GLONASS]=DCBNONE;
					break;
				case GEO:
					options->DualFreqDCBModel[GEO]=DCBNONE;
					break;
				case BDS:
					options->BDSb2b6DCBModel= DCBNONE;
					options->BDSb7b6DCBModel= DCBNONE;
					options->BDSSP3DCBModel= DCBNONE;
					options->BDSb1b6DCBModel= DCBNONE;
					options->BDSb5b6DCBModel= DCBNONE;
					options->BDSISCb1cdDCBModel= DCBNONE;
					options->BDSISCb2adDCBModel= DCBNONE;
					options->BDSSP3DCBModel=DCBNONE;
					options->DualFreqDCBModel[BDS]=DCBNONE;
					break;
				case QZSS:
					options->QZSc1cDCBModel= DCBNONE;
					options->QZSISCl1cpDCBModel= DCBNONE;
					options->QZSISCl1cdDCBModel= DCBNONE;
					options->QZSISCl2cDCBModel= DCBNONE;
					options->QZSISCl5i5DCBModel= DCBNONE;
					options->QZSISCl5q5DCBModel= DCBNONE;
					options->DualFreqDCBModel[QZSS]=DCBNONE;
					break;
				case IRNSS:
					options->IRNc9c5DCBModel=DCBNONE;
					options->DualFreqDCBModel[IRNSS]=DCBNONE;
					break;
				default:
					break;
			}
		}
	}

	//Add measurements to SNR, LLI and model lists if user has set them
	for(i=0;i<NUM_OBSRINEX;i++) {
		if (i==ROVERPOS) epochPointer=epoch;
		else epochPointer=epochDGNSS;
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				if (options->includeSatellite[j][k]==0) continue;
				//Also add measurements to be modelled in the to be modelled list
				for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
					//Check it is not a SIF measurement (not implemented yet, this check to be removed when implemented)
					if ((options->filterMeasList[i][j][k][l][0]>=SIF1012 && options->filterMeasList[i][j][k][l][0]<=SIF8990) ||
						(options->filterMeasList[i][j][k][l][0]>=SIF1234 && options->filterMeasList[i][j][k][l][0]<=SIF9078)) {
						sprintf(messagestr,"Satellite %s %d has a second iono free combination (%s) selected, but this combination is not implemented yet",gnsstype2gnssstr(j),k,meastype2measstr(options->filterMeasList[i][j][k][l][0]));
						printError(messagestr,options);
					}
					if (options->filterListWithMeas[i][j][k][l]==1) {
						numCombMeas=options->numCombfilterMeas[i][j][k][l];
						for(m=0;m<numCombMeas;m++) {
							//If measurement is not in RINEX observation file or frequency is unselected, do not add it
							if (epochPointer->measOrder[j].meas2Ind[options->filterMeasList[i][j][k][l][m+1]]==-1
									|| options->usableFreq[j][k][options->filterMeasfreq[i][j][k][l][m]]==0) {
								options->filterListMeasSelected[i][j][k][l]=MEASNOTAVAIL;
								options->filterListAllMeasSelected[i][j][k][l]=MEASNOTAVAIL;
								break;
								//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
								//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
							}
						} 
						if (m==numCombMeas) {
							for(m=0;m<numCombMeas;m++) {
								freq[0]=options->filterMeasfreq[i][j][k][l][m];
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->filterMeasList[i][j][k][l][m+1];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->filterMeasList[i][j][k][l][m+1]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter == 1 ) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->filterMeasList[i][j][k][l][m+1]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list
										epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->filterMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
									}
								}
								//Check if only measurements to model are the ones to be used in the filter
								if (options->ModelAllMeas==0) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToBeModelled[k];n++) {
										if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToBeModelled[k][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToBeModelled[k]) {
										//Meas not found in list
										epochPointer->measOrder[j].measListToBeModelled[k][n]=options->filterMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numMeasListToBeModelled[k]++;
									}
								}
								//Add phase measurements to LLI list
								if (options->csLLI==1) {
									if (whatIs(options->filterMeasList[i][j][k][l][m+1])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckLLI[k];n++) {
											if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckLLI[k][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numMeasListToCheckLLI[k]) {
											//Meas not found in list.
											epochPointer->measOrder[j].measListToCheckLLI[k][n]=options->filterMeasList[i][j][k][l][m+1];
											epochPointer->measOrder[j].measIndListToCheckLLI[k][n]=epochPointer->measOrder[j].meas2Ind[options->filterMeasList[i][j][k][l][m+1]];
											epochPointer->measOrder[j].numMeasListToCheckLLI[k]++;
										}
									}
								}
								//Add phase measurements to CS SF check list
								if (options->csSF ==1 && options->autoFillcsSF==1) {
									if (whatIs(options->filterMeasList[i][j][k][l][m+1])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]];n++) {
											if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]]) {
											//Meas not found in list
											epochPointer->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][n]=options->filterMeasList[i][j][k][l][m+1];
											epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]]++;
										}
									}
								}
								//Add phase measurements to CS MW check list
								if (options->csMW ==1 && options->autoFillcsMW==1) {
									if (whatIs(options->filterMeasList[i][j][k][l][m+1])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]];n++) {
											if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]]) {
											//Meas not found in list
											epochPointer->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][n]=options->filterMeasList[i][j][k][l][m+1];
											epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]]++;
										}
									}
								}
								//Add phase measurements to CS LI check list
								if (options->csLI ==1 && options->autoFillcsLI==1) {
									if (whatIs(options->filterMeasList[i][j][k][l][m+1])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]];n++) {
											if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]]) {
											//Meas not found in list
											epochPointer->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][n]=options->filterMeasList[i][j][k][l][m+1];
											epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]]++;
										}
									}
								}
								//Add phase measurements to CS IGF check list
								if (options->csIGF ==1 && options->autoFillcsIGF==1) {
									if (whatIs(options->filterMeasList[i][j][k][l][m+1])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]];n++) {
											if (options->filterMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]]) {
											//Meas not found in list
											epochPointer->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][n]=options->filterMeasList[i][j][k][l][m+1];
											epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]]++;
										}
									}
								}
							}
						}
					}
					//Include also measurements used for smoothing
					if (options->filterMeasSmoothed[i][j][k][l]==1) {
						if (options->filterSmoothListWithMeas[i][j][k][l]==1) {
							numCombMeas=options->numCombfilterSmoothMeas[i][j][k][l];
							for(m=0;m<numCombMeas;m++) {
								//If measurement is not in RINEX observation file or frequency is unselected, do not add it
								if (epochPointer->measOrder[j].meas2Ind[options->filterSmoothMeasList[i][j][k][l][m+1]]==-1
									|| options->usableFreq[j][k][options->filterSmoothMeasfreq[i][j][k][l][m]]==0) {
									options->filterSmoothListMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									options->filterListAllMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									break;
									//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
									//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
								}
							} 
							if (m<numCombMeas) continue;
							for(m=0;m<numCombMeas;m++) {
								freq[0]=options->filterSmoothMeasfreq[i][j][k][l][m];
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->filterSmoothMeasList[i][j][k][l][m+1]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter==1) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->filterSmoothMeasList[i][j][k][l][m+1]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list
										if (epochPointer->measOrder[j].meas2Ind[options->filterSmoothMeasList[i][j][k][l][m+1]]!=-1) {
											epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
											epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
										}
									}
								}
								//Add phase measurements to LLI list
								if (options->csLLI==1) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckLLI[k];n++) {
										if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckLLI[k][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckLLI[k]) {
										//Meas not found in list
										epochPointer->measOrder[j].measListToCheckLLI[k][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].measIndListToCheckLLI[k][n]=epochPointer->measOrder[j].meas2Ind[options->filterSmoothMeasList[i][j][k][l][m+1]];
										epochPointer->measOrder[j].numMeasListToCheckLLI[k]++;
									}
								}
								//Add phase measurements to CS SF check list
								if (options->csSF ==1 && options->autoFillcsSF==1) {
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]];n++) {
										if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]]) {
										//Meas not found in list
										epochPointer->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]]++;
									}
								}
								//Add phase measurements to CS MW check list
								if (options->csMW ==1 && options->autoFillcsMW==1) {
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]];n++) {
										if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]]) {
										//Meas not found in list
										epochPointer->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]]++;
									}
								}
								//Add phase measurements to CS LI check list
								if (options->csLI ==1 && options->autoFillcsLI==1) {
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]];n++) {
										if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]]) {
										//Meas not found in list
										epochPointer->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]]++;
									}
								}
								//Add phase measurements to CS IGF check list
								if (options->csIGF ==1 && options->autoFillcsIGF==1) {
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]];n++) {
										if (options->filterSmoothMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]]) {
										//Meas not found in list
										epochPointer->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][n]=options->filterSmoothMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]]++;
									}
								}
							}
						}
					}
				}
			}
		}
	}

	for(i=0;i<NUM_OBSRINEX;i++) {
		//Check that there are not any combination which appears twice, but one being given with measurement
		//and the other without measurement (and both have to be smoothed or not smoothed). This case
		//is not allowed, as it may occur that when the combination without measurement gets filled with
		//measurements, these may be the same as the ones in the other combination, therefore having twice
		//the same combination in the filter.
		//As checking for this case every time a combination has its measurement set can be computationally
		//expensive (on the one hand, the measurement fulfilling is checked every epoch, and the function
		//executed every epoch while a measurement is still to be set, and on the other hand, checking
		//that the new set measurements are not repeated requires to loop through all measurements, and
		//if repeated, set them again)
		//If user wants one combination several times with different measurements, it will have to manually
		//set each combination with its measurements
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
					for(m=0;m<options->numfilterMeasList[i][j][k];m++) {
						if (m==l) continue;
						if (options->numCombfilterMeas[i][j][k][m]==1) {
							//Single measurements. Check same frequency, both smoothed or not and one has
							//manual measurements and another automatic measurements
							if (options->filterMeasfreq[i][j][k][m][0]==options->filterMeasfreq[i][j][k][l][0] &&
									options->filterMeasTypeList[i][j][k][m]==options->filterMeasTypeList[i][j][k][l] &&
									options->filterMeasSmoothed[i][j][k][m]==options->filterMeasSmoothed[i][j][k][l] &&
									options->filterListWithMeas[i][j][k][m]!=options->filterListWithMeas[i][j][k][l]) {
								sprintf(messagestr,"Satellite %3s %2d has two single measurements (for the %s) from frequency %d (one is '%s' and the other is to be automatically set). Two single measurements from the same frequency with automatic measurement selection is not allowed, as it may occur that a measurement could be used twice",gnsstype2gnssstr(j),k,i==ROVERPOS?"rover":"reference station",options->filterMeasfreq[i][j][k][m][0],options->filterMeasList[i][j][k][m][0]!=NA?meastype2measstr(options->filterMeasList[i][j][k][m][0]):meastype2measstr(options->filterMeasList[i][j][k][l][0]));
								printError(messagestr,options);
							}

						} else {
							//Combinations. Check same combination, both smoothed or not and one has
							//manual measurements and another automatic measurements
							if (options->filterMeasList[i][j][k][m][0]==options->filterMeasList[i][j][k][l][0] &&
									options->filterMeasTypeList[i][j][k][m]==options->filterMeasTypeList[i][j][k][l] &&
									options->filterMeasSmoothed[i][j][k][m]==options->filterMeasSmoothed[i][j][k][l] &&
									options->filterListWithMeas[i][j][k][m]!=options->filterListWithMeas[i][j][k][l]) {
								sprintf(messagestr,"Satellite %3s %2d has two equal combinations (for the %s) with the same frequencies ('%s'). Two equal combinations with the same frequencies with automatic measurement selection is not allowed, as it may occur that a combination could be used twice",gnsstype2gnssstr(j),k,i==ROVERPOS?"rover":"reference station",meastype2measstr(options->filterMeasList[i][j][k][l][0]));
								printError(messagestr,options);
							}
						}
					}
				}
			}
		}

		if (options->DGNSS==0) break; //If DGNSS is disabled, no need to read data for reference station
		else if (i==REFSTAPOS) {
			if (sopt->userFilterMeas[REFSTAPOS]==0) {
				//Reference measurements not set, but set for the rover. Set the same values
				memcpy(&options->filterMeasList[REFSTAPOS],&options->filterMeasList[ROVERPOS],sizeof(enum MeasurementType)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT*5);
				memcpy(&options->filterMeasfreq[REFSTAPOS],&options->filterMeasfreq[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT*4);
				memcpy(&options->numfilterMeasList[REFSTAPOS],&options->numfilterMeasList[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS);
				memcpy(&options->numCombfilterMeas[REFSTAPOS],&options->numCombfilterMeas[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterListWithMeas[REFSTAPOS],&options->filterListWithMeas[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterListMeasSelected[REFSTAPOS],&options->filterListMeasSelected[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterMeasKind[REFSTAPOS],&options->filterMeasKind[ROVERPOS],sizeof(enum MeasurementKind)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterMeasTypeList[REFSTAPOS],&options->filterMeasTypeList[ROVERPOS],sizeof(enum MeasurementType)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->MeasSelected[REFSTAPOS],&options->MeasSelected[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS);
				
				//Also set the smoothing as the rover if reference station measurements were not set
				memcpy(&options->filterSmoothMeasList[REFSTAPOS],&options->filterSmoothMeasList[ROVERPOS],sizeof(enum MeasurementType)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT*5);
				memcpy(&options->filterSmoothMeasfreq[REFSTAPOS],&options->filterSmoothMeasfreq[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT*4);
				memcpy(&options->numCombfilterSmoothMeas[REFSTAPOS],&options->numCombfilterSmoothMeas[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterSmoothListWithMeas[REFSTAPOS],&options->filterSmoothListWithMeas[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterSmoothListMeasSelected[REFSTAPOS],&options->filterSmoothListMeasSelected[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
				memcpy(&options->filterMeasSmoothed[REFSTAPOS],&options->filterMeasSmoothed[ROVERPOS],sizeof(int)*MAX_GNSS*MAX_SATELLITES_PER_GNSS*MAX_FILTER_MEASUREMENTS_SAT);
			}
		}
	}

	//In DGNSS, we need to check that the number of measurements given for the rover match with the number
	//of measurements of the reference station. Furthermore, the given measurement type of the reference
	//station must match with the rover
	if (options->DGNSS==1) {
		for(i=0;i<MAX_GNSS;i++) {
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				if (options->numfilterMeasList[ROVERPOS][i][j]!=options->numfilterMeasList[REFSTAPOS][i][j]) {
					sprintf(messagestr,"Satellite %3s %2d does not have the same number of measurements in the rover (%d set) and in the reference station (%d set)",gnsstype2gnssstr(i),j,options->numfilterMeasList[ROVERPOS][i][j],options->numfilterMeasList[REFSTAPOS][i][j]);
					printError(messagestr,options);
				}
				for(k=0;k<options->numfilterMeasList[ROVERPOS][i][j];k++) {
					if (options->filterMeasKind[ROVERPOS][i][j][k]!=options->filterMeasKind[REFSTAPOS][i][j][k] ||
							options->filterMeasTypeList[ROVERPOS][i][j][k]!=options->filterMeasTypeList[REFSTAPOS][i][j][k]) {
						//Different type (code or phase) or different combination type
						strcpy(auxstr,meastype2measstr(options->filterMeasList[ROVERPOS][i][j][k][0]));
						if(strcmp(auxstr,"NAN")==0) {
							strcpy(auxstr,"single measurement");
						}
						strcpy(auxstr2,meastype2measstr(options->filterMeasList[REFSTAPOS][i][j][k][0]));
						if(strcmp(auxstr2,"NAN")==0) {
							strcpy(auxstr2,"single measurement");
						}
						sprintf(messagestr,"Satellite %3s %2d has different measurement types (rover has %s %s and reference station has %s %s) in the rover and reference station. If measurements are set for both, they must be the same type and in the same order",gnsstype2gnssstr(i),j,auxstr,options->filterMeasSmoothed[ROVERPOS][i][j][k]==1?"smoothed":"not smoothed",auxstr2,options->filterMeasSmoothed[REFSTAPOS][i][j][k]==1?"smoothed":"not smoothed");
						printError(messagestr,options);
					} else if (options->filterListWithMeas[ROVERPOS][i][j][k]!=options->filterListWithMeas[REFSTAPOS][i][j][k]) {
						//One has automatic selection and the other has no automatic selection
						strcpy(auxstr,meastype2measstr(options->filterMeasList[ROVERPOS][i][j][k][0]));
						if(strcmp(auxstr,"NAN")==0) {
							strcpy(auxstr,"single measurement");
						}
						strcpy(auxstr2,meastype2measstr(options->filterMeasList[REFSTAPOS][i][j][k][0]));
						if(strcmp(auxstr2,"NAN")==0) {
							strcpy(auxstr2,"single measurement");
						}
						sprintf(messagestr,"Satellite %3s %2d has in the rover %s %s and the reference station has %s %s. If measurements are set for both, they must be the both manual or automatic and in the same order",gnsstype2gnssstr(i),j,auxstr,options->filterListWithMeas[ROVERPOS][i][j][k]==1?"with user measurements":"with automatic measurements",auxstr2,options->filterListWithMeas[REFSTAPOS][i][j][k]==1?"with user measurements":"with automatic measurements");
						printError(messagestr,options);
					}
					for(l=0;l<options->numCombfilterMeas[ROVERPOS][i][j][k];l++) {
						if (options->filterMeasfreq[ROVERPOS][i][j][k][l]!=options->filterMeasfreq[REFSTAPOS][i][j][k][l]) {
							break;
						}
					}
					if (l<options->numCombfilterMeas[ROVERPOS][i][j][k]) {
						//Frequencies do not match
						strcpy(auxstr,meastype2measstr(options->filterMeasList[ROVERPOS][i][j][k][0]));
						if(strcmp(auxstr,"NAN")==0) {
							strcpy(auxstr,"single measurement");
						}
						strcpy(auxstr2,meastype2measstr(options->filterMeasList[REFSTAPOS][i][j][k][0]));
						if(strcmp(auxstr2,"NAN")==0) {
							strcpy(auxstr2,"single measurement");
						}
						if (options->numCombfilterMeas[ROVERPOS][i][j][k]==1) {
							sprintf(messagestr,"Satellite %3s %2d has in the rover %s with frequency %d and the reference station has %s with frequency %d. If measurements are set for both, they must be the same type and same frequency and in the same order",gnsstype2gnssstr(i),j,auxstr,options->filterMeasfreq[ROVERPOS][i][j][k][0],auxstr2,options->filterMeasfreq[REFSTAPOS][i][j][k][0]);
						} else if (options->numCombfilterMeas[ROVERPOS][i][j][k]==2) {
							sprintf(messagestr,"Satellite %3s %2d has in the rover %s with frequencies %d and %d and the reference station has %s with frequencies %d and %d. If measurements are set for both, they must be the same type and same frequencies and in the same order",gnsstype2gnssstr(i),j,auxstr,options->filterMeasfreq[ROVERPOS][i][j][k][0],options->filterMeasfreq[ROVERPOS][i][j][k][1],auxstr2,options->filterMeasfreq[REFSTAPOS][i][j][k][0],options->filterMeasfreq[REFSTAPOS][i][j][k][1]);
						} else {
							sprintf(messagestr,"Satellite %3s %2d has in the rover %s with frequencies %d %d %d and %d and the reference station has %s with frequencies %d %d %d and %d. If measurements are set for both, they must be the same type and same frequencies and in the same order",gnsstype2gnssstr(i),j,auxstr,options->filterMeasfreq[ROVERPOS][i][j][k][0],options->filterMeasfreq[ROVERPOS][i][j][k][1],options->filterMeasfreq[ROVERPOS][i][j][k][2],options->filterMeasfreq[ROVERPOS][i][j][k][3],auxstr2,options->filterMeasfreq[REFSTAPOS][i][j][k][0],options->filterMeasfreq[REFSTAPOS][i][j][k][1],options->filterMeasfreq[REFSTAPOS][i][j][k][2],options->filterMeasfreq[REFSTAPOS][i][j][k][3]);
						}
						printError(messagestr,options);
					}
				}
			}
		}
	}

	//Filter weights. Search for measurements without weight applied and set the default one
	//Also search for measurements with "DGNSSOnlyWeight" but no weight value applied
	//Also set totalFilterMeasurements to the maximum number of measurements per satellite in the filter
	options->totalFilterMeasurements=0;
	for(i=0;i<MAX_GNSS;i++) {
		for(j=1;j<=listMaxSatGNSS[i];j++) {
			if (options->numfilterMeasList[ROVERPOS][i][j]>options->totalFilterMeasurements) {
				options->totalFilterMeasurements=options->numfilterMeasList[ROVERPOS][i][j];
			}
			for(k=0;k<options->numfilterMeasList[ROVERPOS][i][j];k++) {
				if (options->weightMode[i][j][k]==UnknownWeight|| 
						(options->weightMode[i][j][k]==DGNSSOnlyWeight && options->WeightConstantsValues[i][j][k][0]==-999.)) {
					options->weightMode[i][j][k]=defaultWeightModeToSet;
					switch(options->filterMeasTypeList[ROVERPOS][i][j][k]) {
						case SinglePseudorange:
							options->WeightConstantsValues[i][j][k][0]=1.;
							break;
						case SinglePseudorangeSmoothed:
							options->WeightConstantsValues[i][j][k][0]=1.;
							break;
						case IonoFreeCombCode:
							options->WeightConstantsValues[i][j][k][0]=3.;
							break;
						case IonoFreeCombCodeSmoothed:
							options->WeightConstantsValues[i][j][k][0]=3.;
							break;
						case SecondIonoFreeCode:
							options->WeightConstantsValues[i][j][k][0]=3.;
							break;
						case SecondIonoFreeCodeSmoothed:
							options->WeightConstantsValues[i][j][k][0]=3.;
							break;
						case DivergenceFreeCode:
							options->WeightConstantsValues[i][j][k][0]=1.3;
							break;
						case DivergenceFreeCodeSmoothed:
							options->WeightConstantsValues[i][j][k][0]=1.3;
							break;
						case SingleCarrierPhase:
							options->WeightConstantsValues[i][j][k][0]=.01;
							break;
						case GraphicComb:
							options->WeightConstantsValues[i][j][k][0]=.5;
							break;
						case IonoFreeCombPhase:
							options->WeightConstantsValues[i][j][k][0]=.03;
							break;
						case DivergenceFreePhase:
							options->WeightConstantsValues[i][j][k][0]=.02;
							break;
						default: //SecondIonoFreePhase
							options->WeightConstantsValues[i][j][k][0]=.03;
							break;
					}
				}					
				if (options->SNRweightComb[i][j][k]==SNRWeightUnknown) {
					options->SNRweightComb[i][j][k]=SNRWeightCombMean;
					switch(options->filterMeasTypeList[ROVERPOS][i][j][k]) {
						case IonoFreeCombCode: case IonoFreeCombCodeSmoothed: case IonoFreeCombPhase:
							options->SNRweightCombVal[i][j][k][0]=0.5;
							options->SNRweightCombVal[i][j][k][1]=0.5;
							options->SNRweightCombVal[i][j][k][2]=0.;
							options->SNRweightCombVal[i][j][k][3]=0.;
							break;
						case SecondIonoFreeCode: case SecondIonoFreeCodeSmoothed: case SecondIonoFreePhase:
							options->SNRweightCombVal[i][j][k][0]=0.25;
							options->SNRweightCombVal[i][j][k][1]=0.25;
							options->SNRweightCombVal[i][j][k][2]=0.25;
							options->SNRweightCombVal[i][j][k][3]=0.25;
							break;
						default:
							//Not a combination or graphic combination, where only an SNR is used
							//No need to set any value
							break;
					}
				} else if (options->SNRweightComb[i][j][k]==SNRWeightCombk) {
					switch(options->filterMeasTypeList[ROVERPOS][i][j][k]) {
						case IonoFreeCombCode: case IonoFreeCombCodeSmoothed: case IonoFreeCombPhase:
						case DivergenceFreeCode: case DivergenceFreeCodeSmoothed: case DivergenceFreePhase:
							sprintf(messagestr,"User selected 'SNRk' SNR weight combination for %s combination, but 'SNRk' is only for triple or quadruple frequency combination",meastype2measstr(options->filterMeasList[ROVERPOS][i][j][k][0]));
							printError(messagestr,options);
							break;
						default:
							break;
					}
				} else if (options->SNRweightComb[i][j][k]==SNRWeightCombl) {
					switch(options->filterMeasTypeList[ROVERPOS][i][j][k]) {
						case IonoFreeCombCode: case IonoFreeCombCodeSmoothed: case IonoFreeCombPhase:
						case DivergenceFreeCode: case DivergenceFreeCodeSmoothed: case DivergenceFreePhase:
							sprintf(messagestr,"User selected 'SNRl' SNR weight combination for %s combination, but 'SNRl' is only for triple or quadruple frequency combination",meastype2measstr(options->filterMeasList[ROVERPOS][i][j][k][0]));
							printError(messagestr,options);
							break;
						default:
							break;
					}
				}
			}
		}
	}

	//Set cycle-slip defaults if needed
	for(i=0;i<NUM_OBSRINEX;i++) {
		if (i==ROVERPOS) epochPointer=epoch;
		else epochPointer=epochDGNSS;
		if (i>0 && options->DGNSS==0) continue;
		//Check SF cycle-slip detector
		if (options->csSF==1) {
			//Check measurements in the filter and check measurements for each frequency used
			for(j=0;j<MAX_GNSS;j++) {
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					if (options->includeSatellite[j][k]==0) continue;
					//Add measurements to SF list if set by the user
					for(l=0;l<options->numcsSFMeasList[i][j][k];l++) {
						if (options->csSFWithMeas[i][j][k][l]==1) {
							//If measurement is not in RINEX observation file or frequency is unselected, do not add it
							for(m=0;m<NUMMEASCSSF;m++) {
								if (epochPointer->measOrder[j].meas2Ind[options->csSFMeasList[i][j][k][l][m]]==-1
									|| options->usableFreq[j][k][options->csSFMeasFreq[i][j][k][l][m]]==0) {
									options->csSFMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									break;
									//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
									//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
								}
							}
							if (m<NUMMEASCSSF) continue;
							for(m=0;m<NUMMEASCSSF;m++) {
								freq[0]=options->csSFMeasFreq[i][j][k][l][m];
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->csSFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->csSFMeasList[i][j][k][l][m];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->csSFMeasList[i][j][k][l][m]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter == 1 ) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->csSFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->csSFMeasList[i][j][k][l][m]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->csSFMeasList[i][j][k][l][m];
										epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
									}
								}
								//Add phase measurements to LLI list
								if (options->csLLI==1) {
									if (whatIs(options->csSFMeasList[i][j][k][l][m])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckLLI[k];n++) {
											if (options->csSFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListToCheckLLI[k][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numMeasListToCheckLLI[k]) {
											//Meas not found in list. Add it
											epochPointer->measOrder[j].measListToCheckLLI[k][n]=options->csSFMeasList[i][j][k][l][m];
											epochPointer->measOrder[j].measIndListToCheckLLI[k][n]=epochPointer->measOrder[j].meas2Ind[options->csSFMeasList[i][j][k][l][m]];
											epochPointer->measOrder[j].numMeasListToCheckLLI[k]++;
										}
									}
								}
								//If phase measurements from CS SF are set in CS SF by user, remove them from the list
								if (options->autoFillcsSF==1 && m==1) { //Second measurement is the carrier phase
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]];n++) {
										if (options->csSFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][n]) {
											//Phase measurement in the filter set by user in CS SF. Remove it from list
											for(o=n;o<(epoch->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]]-1);o++) {
												epoch->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][o]=epoch->measOrder[j].PhaseMeasFilterToCSSF[k][freq[0]][o+1];
											}
											n--; //The next measurement will be in the current position, as the current position has been overwritten
											epoch->measOrder[j].numPhaseMeasFilterToCSSF[k][freq[0]]--;
										}
									}
								}
							}
						}
					}
					//For each measurement in the filter, check its frequencies and add them to the SF detector
					for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
						if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
							numCombMeas=options->numCombfilterMeas[i][j][k][l];
						} else if (options->filterMeasSmoothed[i][j][k][l]==1) {
							numCombMeas=options->numCombfilterSmoothMeas[i][j][k][l];
						} else {
							continue;
						}
						for(m=0;m<numCombMeas;m++) {
							if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
								freq[0]=options->filterMeasfreq[i][j][k][l][m];
							} else {
								freq[0]=options->filterSmoothMeasfreq[i][j][k][l][m];
							}
							options->csSFfreqAutoChecked[i][j][k][freq[0]][UNCHECKFREQ]=1;
							for(n=0;n<options->numcsSFMeasList[i][j][k];n++) {
								options->csSFfreqAutoChecked[i][j][k][options->csSFMeasFreq[i][j][k][n][0]][UNCHECKFREQ]=0;
								if (freq[0]==options->csSFMeasFreq[i][j][k][n][0]) {
									//Frequency already parsed
									break;
								}
							}
							if (n==options->numcsSFMeasList[i][j][k] && options->autoFillcsSF==1) {
								if (options->numcsSFMeasList[i][j][k]==MAX_CS_LIST) {
									sprintf(messagestr,"Maximum number of single frequency cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
									printError(messagestr,options);
								}
								options->csSFMeasList[i][j][k][options->numcsSFMeasList[i][j][k]][0]=NA;
								options->csSFMeasList[i][j][k][options->numcsSFMeasList[i][j][k]][1]=NA;
								options->csSFMeasFreq[i][j][k][options->numcsSFMeasList[i][j][k]][0]=freq[0];
								options->csSFMeasFreq[i][j][k][options->numcsSFMeasList[i][j][k]][1]=freq[0];
								options->csSFWithMeas[i][j][k][options->numcsSFMeasList[i][j][k]]=0;
								options->csSFMeasSelected[i][j][k][options->numcsSFMeasList[i][j][k]]=0;
								options->csSFfreqAutoChecked[i][j][k][freq[0]][ADDEDFREQ]=1;
								options->numcsSFMeasList[i][j][k]++;
							}
						}
					}
				}
			}
		}
		//Check MW cycle-slip detector
		if (options->csMW==1) {
			//Check measurements in the filter and check measurements for each frequency used
			auxstr[0]='M';
			auxstr[1]='W';
			auxstr[4]='\0';
			auxstr2[0]='P';
			auxstr2[1]='N';
			auxstr2[4]='\0';
			auxstr3[0]='L';
			auxstr3[1]='W';
			auxstr3[4]='\0';
			for(j=0;j<MAX_GNSS;j++) {
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					if (options->includeSatellite[j][k]==0) continue;
					//Add measurements to SNR list if set by the user
					for(l=0;l<options->numcsMWMeasList[i][j][k];l++) {
						if (options->csMWWithMeas[i][j][k][l]==1) {
							for(m=2;m<=NUMMEASCSMW+2;m++) {
								if (m==4) continue;
								//If measurement is not in RINEX observation file or frequency is unselected, do not add it
								if (m<4) {
									n=m-2;
								} else {
									n=m-3;
								}
								if (epochPointer->measOrder[j].meas2Ind[options->csMWMeasList[i][j][k][l][m]]==-1
									|| options->usableFreq[j][k][options->csMWMeasFreq[i][j][k][l][n]]==0) {
									options->csMWMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									break;
									//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
									//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
								}
							}
							if (m<=NUMMEASCSMW+2) continue;
							for(m=2;m<=NUMMEASCSMW+2;m++) {
								if (m==4) continue;
								if (m<4) {
									freq[0]=options->csMWMeasFreq[i][j][k][l][m-2];
								} else {
									freq[0]=options->csMWMeasFreq[i][j][k][l][m-3];
								}
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->csMWMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->csMWMeasList[i][j][k][l][m];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->csMWMeasList[i][j][k][l][m]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter == 1 ) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->csMWMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->csMWMeasList[i][j][k][l][m]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->csMWMeasList[i][j][k][l][m];
										epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
									}
								}
								//Add phase measurements to LLI list
								if (options->csLLI==1) {
									if (whatIs(options->csMWMeasList[i][j][k][l][m])==CarrierPhase) {
										for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckLLI[k];n++) {
											if (options->csMWMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListToCheckLLI[k][n]) {
												//Measurement already in the list
												break;
											}
										}
										if (n==epochPointer->measOrder[j].numMeasListToCheckLLI[k]) {
											//Meas not found in list. Add it
											epochPointer->measOrder[j].measListToCheckLLI[k][n]=options->csMWMeasList[i][j][k][l][m];
											epochPointer->measOrder[j].measIndListToCheckLLI[k][n]=epochPointer->measOrder[j].meas2Ind[options->csMWMeasList[i][j][k][l][m]];
											epochPointer->measOrder[j].numMeasListToCheckLLI[k]++;
										}
									}
								}
								//If phase measurements from CS MW are set in CS MW by user, remove them from the list
								if (options->autoFillcsMW==1 && m>1) { //Third and fourth measurements are the carrier phases
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]];n++) {
										if (options->csMWMeasList[i][j][k][l][m]==epochPointer->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][n]) {
											//Phase measurement in the filter set by user in CS MW. Remove it from list
											for(o=n;o<(epoch->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]]-1);o++) {
												epoch->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][o]=epoch->measOrder[j].PhaseMeasFilterToCSMW[k][freq[0]][o+1];
											}
											n--; //The next measurement will be in the current position, as the current position has been overwritten
											epoch->measOrder[j].numPhaseMeasFilterToCSMW[k][freq[0]]--;
										}
									}
								}
							}
						}
					}
					//For each measurement in the filter, check its frequencies and add them to the MW detector
					for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
						if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
							numCombMeas=options->numCombfilterMeas[i][j][k][l];
						} else if (options->filterMeasSmoothed[i][j][k][l]==1) {
							numCombMeas=options->numCombfilterSmoothMeas[i][j][k][l];
						} else {
							continue;
						}
						numFreqNotUsed=0;
						for(m=0;m<numCombMeas;m++) {
							if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
								freq[0]=options->filterMeasfreq[i][j][k][l][m];
							} else {
								freq[0]=options->filterSmoothMeasfreq[i][j][k][l][m];
							}
							//Check that frequency is not repeated
							for(n=0;n<numFreqNotUsed;n++) {
								if (freqNotChecked[n]==freq[0]) {
									break;
								}
							}
							if (n==numFreqNotUsed) {
								if (options->autoFillcsMW==0) {
									options->csMWfreqAutoChecked[i][j][k][freq[0]][UNCHECKFREQ]=1;
								}
								freqNotChecked[numFreqNotUsed]=freq[0];
								numFreqNotUsed++;
							}
						}
						if (numFreqNotUsed%2!=0) {
							//Number of frequencies to parse is odd. Add a default one to make it even.
							for(n=0;n<MAX_FREQUENCIES_PER_GNSS;n++) {
								freq[0]=options->defaultFreq[j][k][n];
								if (freq[0]==-1) break;
								if (options->usableFreq[j][k][freq[0]]==1 && availGNSSFreq[j][freq[0]]==1 &&
										epoch->measOrder[j].availFreq[freq[0]] && options->availFreq[j][k][freq[0]]==1 && freqNotChecked[numFreqNotUsed-1]!=freq[0]) {
									freqNotChecked[numFreqNotUsed]=freq[0];
									numFreqNotUsed++;
									break;
								}
							}
							if (freq[0]==-1||n==MAX_FREQUENCIES_PER_GNSS) {
								//Could not add an additional frequency. Mark it as unchecked
								if (options->autoFillcsMW==1) {
									options->csMWfreqAutoChecked[i][j][k][freqNotChecked[numFreqNotUsed-1]][UNCHECKFREQ]=1;
								}
								continue;
							}
						}
						for(n=0;n<numFreqNotUsed;n+=2) {
							if (freqNotChecked[n]==0 || (freqNotChecked[n]>0 && freqNotChecked[n]>freqNotChecked[n+1])) {
								//Order frequencies
								freq[0]=freqNotChecked[n];
								freqNotChecked[n]=freqNotChecked[n+1];
								freqNotChecked[n+1]=freq[0];
							}
							//Check if combination is already saved
							for(o=0;o<options->numcsMWMeasList[i][j][k];o++) {
								options->csMWfreqAutoChecked[i][j][k][options->csMWMeasFreq[i][j][k][o][0]][UNCHECKFREQ]=0;
								options->csMWfreqAutoChecked[i][j][k][options->csMWMeasFreq[i][j][k][o][1]][UNCHECKFREQ]=0;
								if (options->csMWMeasFreq[i][j][k][o][0]==freqNotChecked[n] && 
										options->csMWMeasFreq[i][j][k][o][1]==freqNotChecked[n+1]) {
									break;
								}
							}
							if (o==options->numcsMWMeasList[i][j][k] && options->autoFillcsMW==1) {
								if (options->numcsMWMeasList[i][j][k]==MAX_CS_LIST) {
									sprintf(messagestr,"Maximum number of Melbourne-Wubbena cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
									printError(messagestr,options);
								}
								auxstr[2]='0'+freqNotChecked[n];
								auxstr[3]='0'+freqNotChecked[n+1];
								meas=measstr2meastype(auxstr);
								auxstr2[2]='0'+freqNotChecked[n];
								auxstr2[3]='0'+freqNotChecked[n+1];
								meas2=measstr2meastype(auxstr2);
								auxstr3[2]='0'+freqNotChecked[n];
								auxstr3[3]='0'+freqNotChecked[n+1];
								meas3=measstr2meastype(auxstr3);
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][0]=meas;
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][1]=meas2;
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][2]=NA;
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][3]=NA;
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][4]=meas3;
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][5]=NA;
								options->csMWMeasList[i][j][k][options->numcsMWMeasList[i][j][k]][6]=NA;
								options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][0]=freqNotChecked[n];
								options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][1]=freqNotChecked[n+1];
								options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][2]=freqNotChecked[n];
								options->csMWMeasFreq[i][j][k][options->numcsMWMeasList[i][j][k]][3]=freqNotChecked[n+1];
								options->csMWWithMeas[i][j][k][options->numcsMWMeasList[i][j][k]]=0;
								options->csMWMeasSelected[i][j][k][options->numcsMWMeasList[i][j][k]]=0;
								options->csMWfreqAutoChecked[i][j][k][freqNotChecked[n]][ADDEDFREQ]=1;
								options->csMWfreqAutoChecked[i][j][k][freqNotChecked[n+1]][ADDEDFREQ]=1;
								options->numcsMWMeasList[i][j][k]++;
							}
						}
					}
				}
			}
		}
		//Check LI cycle-slip detector
		if (options->csLI==1) {
			//Check measurements in the filter and check measurements for each frequency used
			auxstr[0]='L';
			auxstr[1]='I';
			auxstr[4]='\0';
			for(j=0;j<MAX_GNSS;j++) {
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					if (options->includeSatellite[j][k]==0) continue;
					for(l=0;l<options->numcsLIMeasList[i][j][k];l++) {
						if (options->csLIWithMeas[i][j][k][l]==1) {
							for(m=0;m<NUMMEASCSLI;m++) {
								//If measurement is not in RINEX observation file or frequency is unselected, do not add it
								if (epochPointer->measOrder[j].meas2Ind[options->csLIMeasList[i][j][k][l][m+1]]==-1
									|| options->usableFreq[j][k][options->csLIMeasFreq[i][j][k][l][m]]==0) {
									options->csLIMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									break;
									//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
									//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
								}
							}
							if (m<NUMMEASCSLI) continue;
							for(m=0;m<NUMMEASCSLI;m++) {
								freq[0]=options->csLIMeasFreq[i][j][k][l][m];
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->csLIMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->csLIMeasList[i][j][k][l][m+1];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->csLIMeasList[i][j][k][l][m+1]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter == 1 ) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->csLIMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->csLIMeasList[i][j][k][l][m+1]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->csLIMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
									}
								}
								//Add phase measurements to LLI list
								if (options->csLLI==1) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckLLI[k];n++) {
										if (options->csLIMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckLLI[k][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckLLI[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckLLI[k][n]=options->csLIMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].measIndListToCheckLLI[k][n]=epochPointer->measOrder[j].meas2Ind[options->csLIMeasList[i][j][k][l][m+1]];
										epochPointer->measOrder[j].numMeasListToCheckLLI[k]++;
									}
								}
								//If phase measurements from CS LI are set in CS LI by user, remove them from the list
								if (options->autoFillcsLI==1) { 
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]];n++) {
										if (options->csLIMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][n]) {
											//Phase measurement in the filter set by user in CS LI. Remove it from list
											for(o=n;o<(epoch->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]]-1);o++) {
												epoch->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][o]=epoch->measOrder[j].PhaseMeasFilterToCSLI[k][freq[0]][o+1];
											}
											n--; //The next measurement will be in the current position, as the current position has been overwritten
											epoch->measOrder[j].numPhaseMeasFilterToCSLI[k][freq[0]]--;
										}
									}
								}
							}
						}
					}
					//For each measurement in the filter, check its frequencies and add them to the LI detector
					for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
						if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
							numCombMeas=options->numCombfilterMeas[i][j][k][l];
						} else if (options->filterMeasSmoothed[i][j][k][l]==1) {
							numCombMeas=options->numCombfilterSmoothMeas[i][j][k][l];
						} else {
							continue;
						}
						numFreqNotUsed=0;
						for(m=0;m<numCombMeas;m++) {
							if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
								freq[0]=options->filterMeasfreq[i][j][k][l][m];
							} else {
								freq[0]=options->filterSmoothMeasfreq[i][j][k][l][m];
							}
							//Check that frequency is not repeated
							for(n=0;n<numFreqNotUsed;n++) {
								if (freqNotChecked[n]==freq[0]) {
									break;
								}
							}
							if (n==numFreqNotUsed) {
								if (options->autoFillcsLI==0) {
									options->csLIfreqAutoChecked[i][j][k][freq[0]][UNCHECKFREQ]=1;
								}
								freqNotChecked[numFreqNotUsed]=freq[0];
								numFreqNotUsed++;
							}
						}
						if (numFreqNotUsed%2!=0) {
							//Number of frequencies to parse is odd. Add a default one to make it even.
							for(n=0;n<MAX_FREQUENCIES_PER_GNSS;n++) {
								freq[0]=options->defaultFreq[j][k][n];
								if (freq[0]==-1) break;
								if (options->usableFreq[j][k][freq[0]]==1 && availGNSSFreq[j][freq[0]]==1 &&
										epoch->measOrder[j].availFreq[freq[0]] && options->availFreq[j][k][freq[0]]==1 && freqNotChecked[numFreqNotUsed-1]!=freq[0]) {
									freqNotChecked[numFreqNotUsed]=freq[0];
									numFreqNotUsed++;
									break;
								}
							}
							if (freq[0]==-1||n==MAX_FREQUENCIES_PER_GNSS) {
								//Could not add an additional frequency. Mark it as unchecked
								if (options->autoFillcsLI==1) {
									options->csLIfreqAutoChecked[i][j][k][freqNotChecked[numFreqNotUsed-1]][UNCHECKFREQ]=1;
								}
								continue;
							}
						}
						for(n=0;n<numFreqNotUsed;n+=2) {
							if (freqNotChecked[n]==0 || (freqNotChecked[n]>0 && freqNotChecked[n]>freqNotChecked[n+1])) {
								//Order frequencies
								freq[0]=freqNotChecked[n];
								freqNotChecked[n]=freqNotChecked[n+1];
								freqNotChecked[n+1]=freq[0];
							}
							//Check if combination is already saved
							for(o=0;o<options->numcsLIMeasList[i][j][k];o++) {
								options->csLIfreqAutoChecked[i][j][k][options->csLIMeasFreq[i][j][k][o][0]][UNCHECKFREQ]=0;
								options->csLIfreqAutoChecked[i][j][k][options->csLIMeasFreq[i][j][k][o][1]][UNCHECKFREQ]=0;
								if (options->csLIMeasFreq[i][j][k][o][0]==freqNotChecked[n] && 
										options->csLIMeasFreq[i][j][k][o][1]==freqNotChecked[n+1]) {
									break;
								}
							}
							if (o==options->numcsLIMeasList[i][j][k] && options->autoFillcsLI==1) {
								if (options->numcsLIMeasList[i][j][k]==MAX_CS_LIST) {
									sprintf(messagestr,"Maximum number of LI cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
									printError(messagestr,options);
								}
								auxstr[2]='0'+freqNotChecked[n];
								auxstr[3]='0'+freqNotChecked[n+1];
								meas=measstr2meastype(auxstr);
								options->csLIMeasList[i][j][k][options->numcsLIMeasList[i][j][k]][0]=meas;
								options->csLIMeasList[i][j][k][options->numcsLIMeasList[i][j][k]][1]=NA;
								options->csLIMeasList[i][j][k][options->numcsLIMeasList[i][j][k]][2]=NA;
								options->csLIMeasFreq[i][j][k][options->numcsLIMeasList[i][j][k]][0]=freqNotChecked[n];
								options->csLIMeasFreq[i][j][k][options->numcsLIMeasList[i][j][k]][1]=freqNotChecked[n+1];
								options->csLIWithMeas[i][j][k][options->numcsLIMeasList[i][j][k]]=0;
								options->csLIMeasSelected[i][j][k][options->numcsLIMeasList[i][j][k]]=0;
								options->csLIfreqAutoChecked[i][j][k][freqNotChecked[n]][ADDEDFREQ]=1;
								options->csLIfreqAutoChecked[i][j][k][freqNotChecked[n+1]][ADDEDFREQ]=1;
								options->numcsLIMeasList[i][j][k]++;
							}
						}
					}
				}
			}
		}
		//Check IGF cycle-slip detector
		if (options->csIGF==1) {
			//Check if user set frequencies for IGF cycle-slip detector
			//User did not set any frequencies or measurements for IGF cycle-slip detector, but it is enabled
			//Check measurements in the filter and check measurements for each frequency used
			auxstr[0]='I';
			auxstr[1]='G';
			auxstr[2]='F';
			auxstr[7]='\0';
			auxstr2[0]='L';
			auxstr2[1]='C';
			auxstr2[4]='\0';
			auxstr3[0]='L';
			auxstr3[1]='C';
			auxstr3[4]='\0';
			for(j=0;j<MAX_GNSS;j++) {
				if (GNSS3Freq[j]==0) continue; //Constellation that has less than 3 frequencies
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					if (options->includeSatellite[j][k]==0) continue;
					for(l=0;l<options->numcsIGFMeasList[i][j][k];l++) {
						if (options->csIGFWithMeas[i][j][k][l]==1) {
							for(m=2;m<=NUMMEASCSIGF+2;m++) {
								if(m==4) continue;
								//If measurement is not in RINEX observation file or frequency is unselected, do not add it
								if (m<4) {
									n=m-2;
								} else {
									n=m-3;
								}
								//If measurement is not in RINEX observation file, do not add it
								if (epochPointer->measOrder[j].meas2Ind[options->csIGFMeasList[i][j][k][l][m]]==-1
									|| options->usableFreq[j][k][options->csIGFMeasFreq[i][j][k][l][n]]==0) {
									options->csIGFMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									break;
									//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
									//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
								}
							}
							if (m<=NUMMEASCSIGF+2) continue;
							for(m=2;m<=NUMMEASCSIGF+2;m++) {
								if(m==4) continue;
								if(m<4) {
									freq[0]=options->csIGFMeasFreq[i][j][k][l][m-2];
								} else {
									freq[0]=options->csIGFMeasFreq[i][j][k][l][m-3];
								}
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->csIGFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->csIGFMeasList[i][j][k][l][m];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->csIGFMeasList[i][j][k][l][m]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter == 1 ) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->csIGFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->csIGFMeasList[i][j][k][l][m]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->csIGFMeasList[i][j][k][l][m];
										epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
									}
								}
								//Add phase measurements to LLI list
								if (options->csLLI==1) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckLLI[k];n++) {
										if (options->csIGFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].measListToCheckLLI[k][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckLLI[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckLLI[k][n]=options->csIGFMeasList[i][j][k][l][m];
										epochPointer->measOrder[j].measIndListToCheckLLI[k][n]=epochPointer->measOrder[j].meas2Ind[options->csIGFMeasList[i][j][k][l][m]];
										epochPointer->measOrder[j].numMeasListToCheckLLI[k]++;
									}
								}
								//If phase measurements from CS IGF are set in CS IGF by user, remove them from the list
								if (options->autoFillcsIGF==1) { 
									for(n=0;n<epochPointer->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]];n++) {
										if (options->csIGFMeasList[i][j][k][l][m]==epochPointer->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][n]) {
											//Phase measurement in the filter set by user in CS IGF. Remove it from list
											for(o=n;o<(epoch->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]]-1);o++) {
												epoch->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][o]=epoch->measOrder[j].PhaseMeasFilterToCSIGF[k][freq[0]][o+1];
											}
											n--; //The next measurement will be in the current position, as the current position has been overwritten
											epoch->measOrder[j].numPhaseMeasFilterToCSIGF[k][freq[0]]--;
										}
									}
								}
							}
						}
					}
					//For each measurement in the filter, check its frequencies and add them to the IGF detector
					for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
						if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
							numCombMeas=options->numCombfilterMeas[i][j][k][l];
						} else if (options->filterMeasSmoothed[i][j][k][l]==1) {
							numCombMeas=options->numCombfilterSmoothMeas[i][j][k][l];
						} else {
							continue;
						}
						numFreqNotUsed=0;
						for(m=0;m<numCombMeas;m++) {
							if (options->filterMeasKind[i][j][k][l]==CarrierPhase) {
								freq[0]=options->filterMeasfreq[i][j][k][l][m];
							} else {
								freq[0]=options->filterSmoothMeasfreq[i][j][k][l][m];
							}
							//Check that frequency is not repeated
							for(n=0;n<numFreqNotUsed;n++) {
								if (freqNotChecked[n]==freq[0]) {
									break;
								}
							}
							if (n==numFreqNotUsed) {
								if (options->autoFillcsIGF==0) {
									options->csIGFfreqAutoChecked[i][j][k][freq[0]][UNCHECKFREQ]=1;
								}
								freqNotChecked[numFreqNotUsed]=freq[0];
								numFreqNotUsed++;
							}
						}
						if (numFreqNotUsed%4==0 && options->csIGFminNoise==1) {
							//If minimum noise combination is set and four frequencies are to be added,
							//we will build two IGF combinations with three different frequencies by repeating
							//the first two frequencies
							freq[0]=freqNotChecked[numFreqNotUsed-1];
							freqNotChecked[numFreqNotUsed-1]=freqNotChecked[0];
							freqNotChecked[numFreqNotUsed]=freq[0];
							numFreqNotUsed++;
							freqNotChecked[numFreqNotUsed]=freqNotChecked[0];
							numFreqNotUsed++;
							freqNotChecked[numFreqNotUsed]=freq[0];
							numFreqNotUsed++;
							freqNotChecked[numFreqNotUsed]=freqNotChecked[1];
							numFreqNotUsed++;
						}
						if (numFreqNotUsed%3==0) {
							//Repeat the first frequency so there are four in the list
							freqNotChecked[numFreqNotUsed]=freqNotChecked[numFreqNotUsed-3];
							numFreqNotUsed++;
						} else if (numFreqNotUsed%3!=0 && numFreqNotUsed%4!=0) {
							//Number of frequencies is not a multiple of 3 and 4
							if (numFreqNotUsed%3==1) {
								//Add two frequencies to make it multiple of 3 (repeting the provided one to get 4 frequencies)
								x=0;
								for(n=0;n<MAX_FREQUENCIES_PER_GNSS;n++) {
									freq[0]=options->defaultFreq[j][k][n];
									if (freq[0]==-1) break;
									if (options->usableFreq[j][k][freq[0]]==1 && availGNSSFreq[j][freq[0]]==1 &&
											epoch->measOrder[j].availFreq[freq[0]] && options->availFreq[j][k][freq[0]]==1 && freqNotChecked[numFreqNotUsed-1]!=freq[0]){
										freqNotChecked[numFreqNotUsed]=freq[0];
										numFreqNotUsed++;
										x++;
										if(x==2) break;
										else {
											//Repeat the not used frequency in the list
											freqNotChecked[numFreqNotUsed]=freqNotChecked[numFreqNotUsed-2];
											numFreqNotUsed++;
										}
									}
								}
								if (freq[0]==-1||n==MAX_FREQUENCIES_PER_GNSS) {
									//Could not add two additional frequencies. Mark them as unchecked
									if (options->autoFillcsIGF==1) {
										options->csIGFfreqAutoChecked[i][j][k][freqNotChecked[numFreqNotUsed-1]][UNCHECKFREQ]=1;
									}
									continue;
								}
							} else { //numFreqNotUsed%3==2
								//Add one frequency to make it multiple of 3 (repeting one provided one to get 4 frequencies)
								//Repeat the first not used frequency in the list
								freqNotChecked[numFreqNotUsed]=freqNotChecked[numFreqNotUsed-2];
								numFreqNotUsed++;
								for(n=0;n<MAX_FREQUENCIES_PER_GNSS;n++) {
									freq[0]=options->defaultFreq[j][k][n];
									if (freq[0]==-1) break;
									if (options->usableFreq[j][k][freq[0]]==1 && availGNSSFreq[j][freq[0]]==1 &&
											epoch->measOrder[j].availFreq[freq[0]] && options->availFreq[j][k][freq[0]]==1 && freqNotChecked[numFreqNotUsed-1]!=freq[0]
											&& freqNotChecked[numFreqNotUsed-2]!=freq[0]) {
										freqNotChecked[numFreqNotUsed]=freq[0];
										numFreqNotUsed++;
										break;
									}
								}
								if (freq[0]==-1||n==MAX_FREQUENCIES_PER_GNSS) {
									//Could not add two additional frequencies. Mark them as unchecked
									if (options->autoFillcsIGF==1) {
										options->csIGFfreqAutoChecked[i][j][k][freqNotChecked[numFreqNotUsed-1]][UNCHECKFREQ]=1;
										options->csIGFfreqAutoChecked[i][j][k][freqNotChecked[numFreqNotUsed-2]][UNCHECKFREQ]=1;
									}
									continue;
								}
							}
						}
						for(n=0;n<numFreqNotUsed;n+=4) {
							//Save frequencies in a measurement string for ordering
							for(o=0;o<4;o++) {
								auxstr[o+3]='0' + (unsigned int)freqNotChecked[n+o];
								freq[o]=freqNotChecked[n+o];
							}
							//Order frequencies
							if (freqNotChecked[n]!=freqNotChecked[n+1] && freqNotChecked[n]!=freqNotChecked[n+2] && freqNotChecked[n]!=freqNotChecked[n+3]) {
								//4 frequencies
								quadmeas=1;
							} else {
								//3 frequencies
								quadmeas=0;
							}
							meas = measstr2meastype(auxstr);
							if(meas==NA) {
								for(x=0;x<2;x++) {
									if(x==1 && quadmeas==1) break;
									for(y=0;y<2;y++) {
										if(y==1) {
											//In second loop, swap order of the combinations
											aux1=freq[0];
											freq[0]=freq[2];
											freq[2]=aux1;
											aux1=freq[1];
											freq[1]=freq[3];
											freq[3]=aux1;
											aux1=(int)auxstr[3];
											auxstr[3]=auxstr[5];
											auxstr[5]=(char)aux1;
											aux1=(int)auxstr[4];
											auxstr[4]=auxstr[6];
											auxstr[6]=(char)aux1;
											meas = measstr2meastype(auxstr);
											if (meas!=NA) break;
										}
										for(z=0;z<3;z++) {
											if(z==0) {
												//Swap first 2 frequency numbers
												aux1=freq[1];
												freq[1]=freq[0];
												freq[0]=aux1;
												aux1=(int)auxstr[4];
												auxstr[4]=auxstr[3];
												auxstr[3]=(char)aux1;
											} else if (z==1) {
												//Swap last 2 frequency numbers (leaving the first 2 numbers swapped)
												aux1=freq[3];
												freq[3]=freq[2];
												freq[2]=aux1;
												aux1=(int)auxstr[6];
												auxstr[6]=auxstr[5];
												auxstr[5]=(char)aux1;
											} else {
												//Swap first 2 frequency numbers (so they are as in original position) and leave last 2 numbers swapped
												aux1=freq[1];
												freq[1]=freq[0];
												freq[0]=aux1;
												aux1=(int)auxstr[4];
												auxstr[4]=auxstr[3];
												auxstr[3]=(char)aux1;
											}
											meas = measstr2meastype(auxstr);
											if (meas!=NA) break;
										}
										if (meas!=NA) break;
									}
									if (meas!=NA) break;
									else if (quadmeas==0) {
										//In the case of three frequencies, the repeated frequency may be set
										//toguether at the beginning or at the end (example 1123 or 2311)
										//Swap second and third frequency number so there are two pairo od
										//frequencies with the different frequencies
										aux1=freq[1];
										freq[1]=freq[2];
										freq[2]=aux1;
										aux1=(int)auxstr[4];
										auxstr[4]=auxstr[5];
										auxstr[5]=(char)aux1;
									}
								}
								if(meas==NA) {
									sprintf(messagestr,"Invalid frequencies in '%s' for IGF cycle-slip detector for satellite %s %2d",&auxstr[3],gnsstype2gnssstr(j),k);
									printError(messagestr,options);
								}
							}
							//Check if combination is already saved
							for(o=0;o<options->numcsIGFMeasList[i][j][k];o++) {
								options->csIGFfreqAutoChecked[i][j][k][options->csIGFMeasFreq[i][j][k][o][0]][UNCHECKFREQ]=0;
								options->csIGFfreqAutoChecked[i][j][k][options->csIGFMeasFreq[i][j][k][o][1]][UNCHECKFREQ]=0;
								options->csIGFfreqAutoChecked[i][j][k][options->csIGFMeasFreq[i][j][k][o][2]][UNCHECKFREQ]=0;
								options->csIGFfreqAutoChecked[i][j][k][options->csIGFMeasFreq[i][j][k][o][3]][UNCHECKFREQ]=0;
								if (options->csIGFMeasFreq[i][j][k][o][0]==freq[0] && 
										options->csIGFMeasFreq[i][j][k][o][1]==freq[1] &&
										options->csIGFMeasFreq[i][j][k][o][2]==freq[2] &&
										options->csIGFMeasFreq[i][j][k][o][3]==freq[3]) {
									break;
								}
							}
							if (o==options->numcsIGFMeasList[i][j][k] && options->autoFillcsIGF==1) {
								if (options->numcsIGFMeasList[i][j][k]==MAX_CS_LIST) {
									sprintf(messagestr,"Maximum number of IGF cycle-slip combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_CS_LIST,gnsstype2gnssstr(j),k,MAX_CS_LIST+1);
									printError(messagestr,options);
								}
								auxstr2[2]='0'+freq[0];
								auxstr2[3]='0'+freq[1];
								meas2=measstr2meastype(auxstr2);
								auxstr3[2]='0'+freq[2];
								auxstr3[3]='0'+freq[3];
								meas3=measstr2meastype(auxstr3);
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][0]=meas;
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][1]=meas2;
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][2]=NA;
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][3]=NA;
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][4]=meas3;
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][5]=NA;
								options->csIGFMeasList[i][j][k][options->numcsIGFMeasList[i][j][k]][6]=NA;
								options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][0]=freq[0];
								options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][1]=freq[1];
								options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][2]=freq[2];
								options->csIGFMeasFreq[i][j][k][options->numcsIGFMeasList[i][j][k]][3]=freq[3];
								options->csIGFWithMeas[i][j][k][options->numcsIGFMeasList[i][j][k]]=0;
								options->csIGFfreqAutoChecked[i][j][k][freq[0]][ADDEDFREQ]=1;
								options->csIGFfreqAutoChecked[i][j][k][freq[1]][ADDEDFREQ]=1;
								options->csIGFfreqAutoChecked[i][j][k][freq[2]][ADDEDFREQ]=1;
								options->csIGFfreqAutoChecked[i][j][k][freq[3]][ADDEDFREQ]=1;
								options->csIGFMeasSelected[i][j][k][options->numcsIGFMeasList[i][j][k]]=0;
								options->numcsIGFMeasList[i][j][k]++;
							}
						}
					}
				}
			}

			//Compute factors for minimum noise IGF combinations
			if (options->csIGFminNoise==1) {
				for(j=0;j<MAX_GNSS;j++) {
					if (GNSS3Freq[j]==0) continue; //Constellation that has less than 3 frequencies
					//Initialize computedIGFminNoiseFactor values
					if (j==GLONASS) {
						for(k=1;k<=listMaxSatGNSS[j];k++) {
							for(l=0;l<MAX_TRIPLE_FREQUENCIES_COMBINATIONS;l++) {
								computedIGFcombFactorGLONASS[i][k][l]=0;
							}
						}
					} else {
						for(k=0;k<MAX_TRIPLE_FREQUENCIES_COMBINATIONS;k++) {
							computedIGFcombFactor[i][j][k]=0;
						}
					}
					for(k=1;k<=listMaxSatGNSS[j];k++) {
						if (options->includeSatellite[j][k]==0) continue;
						for(l=0;l<options->numcsIGFMeasList[i][j][k];l++) {
							//If the combination has a frequency that doesn't exist, it will use
							//lambda=1. for the unexsitent frequencies. It is not a problem as this
							//frequencies will be unselected later
							combIGF=options->csIGFMeasList[i][j][k][l][0]-IGF1012;
							if (j==GLONASS) {
								if (computedIGFcombFactorGLONASS[i][k][combIGF]==1) continue;
							} else {
								if (computedIGFcombFactor[i][j][combIGF]==1) continue;
							}
							computeIGFfactors(epochPointer,j,k,combIGF,options->csIGFMeasFreq[i][j][k][l]);
							//For constellation different than GLONASS, all PRN have the same factors. Copy them to all PRNs
							if (j!=GLONASS) {
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									if(m==k) continue;
									epochPointer->measOrder[j].IGFcombFactors[m][combIGF][0]=epochPointer->measOrder[j].IGFcombFactors[k][combIGF][0];
									epochPointer->measOrder[j].IGFcombFactors[m][combIGF][1]=epochPointer->measOrder[j].IGFcombFactors[k][combIGF][1];
									epochPointer->measOrder[j].IGFcombFactors[m][combIGF][2]=epochPointer->measOrder[j].IGFcombFactors[k][combIGF][2];
								}
							}							
						}
					}
				}
			}
		}
	}

	//Set doppler defaults if needed
	if (options->computeVelocity == 1 ) {
		for(i=0;i<NUM_OBSRINEX;i++) {
			if (i==REFSTAPOS) continue; //Skip reference station
			epochPointer=epoch;
			for(j=0;j<MAX_GNSS;j++) {
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					if (options->includeSatellite[j][k]==0) continue;
					//Add measurements to SNR list if set by the user
					for(l=0;l<options->numDopplerMeasList[i][j][k];l++) {
						if (options->DopplerListWithMeas[i][j][k][l]==1) {
							numCombMeas=options->numCombDopplerMeas[i][j][k][l];
							for(m=0;m<numCombMeas;m++) {
								//If measurement is not in RINEX observation file or frequency is unselected, do not add it
								if (epochPointer->measOrder[j].meas2Ind[options->DopplerMeasList[i][j][k][l][m+1]]==-1
									|| options->usableFreq[j][k][options->DopplerMeasfreq[i][j][k][l][m]]==0) {
									options->DopplerListMeasSelected[i][j][k][l]=MEASNOTAVAIL;
									break;
									//No setting to MEASSELECTED, as satellite may be unselected later (e.g. if no broadcast orbits are selected)
									//Change to MEASSELECTED will be done in posRINEXHeaderDataUpdate function
								}
							}
							if (m<numCombMeas) continue;
							for(m=0;m<numCombMeas;m++) {
								//Add measurements to Data Gap list
								for(n=0;n<epochPointer->measOrder[j].numMeasListDataGap[k];n++) {
									if (options->DopplerMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListDataGap[k][n]) {
										//Measurement already in the list
										break;
									}
								}
								if (n==epochPointer->measOrder[j].numMeasListDataGap[k]) {
									//Meas not found in list
									epochPointer->measOrder[j].measListDataGap[k][n]=options->DopplerMeasList[i][j][k][l][m+1];
									epochPointer->measOrder[j].measIndListDataGap[k][n]=epochPointer->measOrder[j].meas2Ind[options->DopplerMeasList[i][j][k][l][m+1]];
									epochPointer->measOrder[j].numMeasListDataGap[k]++;
								}
								//Add measurements to SNR list
								if (options->SNRfilter == 1 ) {
									for(n=0;n<epochPointer->measOrder[j].numMeasListToCheckSNR[k];n++) {
										if (options->DopplerMeasList[i][j][k][l][m+1]==epochPointer->measOrder[j].measListToCheckSNR[k][n] ||
											epochPointer->measOrder[j].meas2SNRInd[options->DopplerMeasList[i][j][k][l][m+1]]==epochPointer->measOrder[j].meas2SNRInd[epochPointer->measOrder[j].measListToCheckSNR[k][n]]) {
											//Measurement already in the list or another one in the list points to the same SNR measurement
											//This avoids checking the same SNR more than once (smaller list is less computation time checking SNR)
											break;
										}
									}
									if (n==epochPointer->measOrder[j].numMeasListToCheckSNR[k]) {
										//Meas not found in list. Add it
										epochPointer->measOrder[j].measListToCheckSNR[k][n]=options->DopplerMeasList[i][j][k][l][m+1];
										epochPointer->measOrder[j].numMeasListToCheckSNR[k]++;
									}
								}
								//Check if only measurements to model are the ones to be used in the filter
								//The code is commented in case in the the future Doppler needs to be modelled
								/*if (options->ModelAllMeas==0) {
									for(n=0;n<epoch->measOrder[j].numMeasListToBeModelled[i];n++) {
										if (options->DopplerMeasList[i][j][k][l][m+1]==epoch->measOrder[j].measListToBeModelled[k][n]) {
											//Measurement already in the list
											break;
										}
									}
									if (n==epoch->measOrder[j].numMeasListToBeModelled[k]) {
										//Meas not found in list. Add it
										epoch->measOrder[j].measListToBeModelled[k][n]=options->DopplerMeasList[i][j][k][l][m+1];
										epoch->measOrder[j].numMeasListToBeModelled[k]++;
									}
								}*/
							}
						}
					}
					//Check if user set measurements for Doppler
					if (sopt->userDopplerMeas[i]>0) continue;
					for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
						for(m=0;m<2;m++) { //For reading measurements and smoothed measurements
							if (m==0) {
								numCombMeas=options->numCombfilterMeas[i][j][k][l];
							} else {
								numCombMeas=options->numCombfilterSmoothMeas[i][j][k][l];
							}
							for(n=0;n<numCombMeas;n++) {
								if (m==0) {
									freq[0]=options->filterMeasfreq[i][j][k][l][n];
								} else {
									freq[0]=options->filterSmoothMeasfreq[i][j][k][l][n];
								}
								for(x=0;x<options->numDopplerMeasList[i][j][k];x++) {
									if (freq[0]==options->DopplerMeasfreq[i][j][k][x][0]) {
										//Frequency already parsed
										break;
									}
								}
								if (x==options->numDopplerMeasList[i][j][k]) {
									if (options->numDopplerMeasList[i][j][k]==MAX_FILTER_MEASUREMENTS_SAT) {
										sprintf(messagestr,"Maximum number of Doppler combinations per satellite and detection type (for the %s) are %d, but satellite %s %2d has %d combinations",i==ROVERPOS?"rover":"reference station",MAX_FILTER_MEASUREMENTS_SAT,gnsstype2gnssstr(j),k,MAX_FILTER_MEASUREMENTS_SAT+1);
										printError(messagestr,options);
									}
									options->DopplerMeasList[i][j][k][options->numDopplerMeasList[i][j][k]][0]=NA;
									options->DopplerMeasList[i][j][k][options->numDopplerMeasList[i][j][k]][1]=NA;
									options->DopplerMeasfreq[i][j][k][options->numDopplerMeasList[i][j][k]][0]=freq[0];
									options->DopplerMeasfreq[i][j][k][options->numDopplerMeasList[i][j][k]][1]=freq[0];
									options->numCombDopplerMeas[i][j][k][options->numDopplerMeasList[i][j][k]]=1;
									options->DopplerListWithMeas[i][j][k][options->numDopplerMeasList[i][j][k]]=0;
									options->DopplerListMeasSelected[i][j][k][options->numDopplerMeasList[i][j][k]]=0;
									options->numDopplerMeasList[i][j][k]++;
								}
							}
						}
					}
				}
			}
			//Compute max number of Doppler measurements
			options->maxDopplerMeasurements=0;
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if (options->numDopplerMeasList[ROVERPOS][i][j]>options->maxDopplerMeasurements) {
						options->maxDopplerMeasurements=options->numDopplerMeasList[ROVERPOS][i][j];
					}
				}
			}
		}
	}

	// Smoothing
	// Check if any measurement is smoothed
	AnyMeasSmoothed=0;
	for(i=0;i<NUM_OBSRINEX;i++) {
		if (i==REFSTAPOS && options->DGNSS==0) continue; //Skip reference station
		//Check if user set measurements for Doppler
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
					if (options->filterMeasSmoothed[i][j][k][l]==1) {
						AnyMeasSmoothed=1;
						break;
					}
				}
				if (AnyMeasSmoothed==1) break;
			}
			if (AnyMeasSmoothed==1) break;
		}
		if (AnyMeasSmoothed==1) break;
	}

	if (options->smoothEpochs!=0 && AnyMeasSmoothed==0) {
		//Number of smoothing epochs set, but no measurement set to be smoothed
		if (sopt->userFilterSmoothMeas[ROVERPOS]==0) {
			sprintf(messagestr,"Number of smoothing epochs set to %d, but no measurement to smooth with has been set. Use '-filter:select' to set the measurements to use in the filter and parameter '-pre:smoothmeas' to set the filter measurements to be smoothed'",options->smoothEpochs);
		} else if (sopt->userFilterSmoothMeas[ROVERPOS]==1 && sopt->userFilterMeas[ROVERPOS]==0) {
			sprintf(messagestr,"Number of smoothing epochs set to %d, but no measurement to smooth with has been set. Use '-filter:select' to set the measurements to use in the filter, which must include the measurements to smooth provided in '-pre:smoothmeas' parameter",options->smoothEpochs);

		} else {
			sprintf(messagestr,"Number of smoothing epochs set to %d, but no measurement to smooth with has been set. Check that measurements provided in '-pre:smoothmeas' parameter also appear in '-filter:select' parameter, as measurements to smooth must be included in the filter",options->smoothEpochs);
		}
		printError(messagestr,options);
	} else if (options->smoothEpochs==0 && AnyMeasSmoothed==1) {
		sprintf(messagestr,"Number of smoothing epochs is 0, but a measurement to smooth with was given. Use parameter '-pre:smooth' to set the number of smoothing epochs");
		printError(messagestr,options);
	}

	if (options->totalFilterMeasurements> 1 && options->stanfordesa==1) {
		printError("Stanford-ESA can not be enabled if filter measurements is greater than 1",options);
	}

	//Look for available RINEX navigation message types
	for(l=0;l<2;l++) {
		for(i=0;i<MAX_GNSS;i++) {
			for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
				for(k=0;k<options->BRDCAvailSelOrder[l][i][j][MAX_BRDC_TYPES];k++) {
					switch(i) {
						case GPS:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case GPSCNAV:
									GPSCNAVAvail[l]=1;
									break;
								case GPSCNAV2:
									GPSCNAV2Avail[l]=1;
									break;
								case GPSLNAV:
									GPSLNAVAvail[l]=1;
								default:
									break;
							}
							break;
						case Galileo:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case GalFNAV:
									GalFNAVAvail[l]=1;
									break;
								case GalINAVE1: case GalINAVE5b: case GalINAVE1E5b:
									GalINAVAvail[l]=1;
									break;
								default:
									break;
							}
							break;
						case GLONASS:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case GLOFDMA:
									GLOFDMAAvail[l]=1;
									break;
								case GLOCDMA:
									GLOCDMAAvail[l]=1;
									break;
								default:
									break;
							}
							break;
						case GEO:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case GEOCNAV:
									GEOCNAVAvail[l]=1;
									break;
								default:
									break;
							}
							break;
						case BDS:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case BDSD1:
									BDSD1Avail[l]=1;
									break;
								case BDSD2:
									BDSD2Avail[l]=1;
									break;
								case BDSCNAV1:
									BDSCNAV1Avail[l]=1;
									break;
								case BDSCNAV2:
									BDSCNAV2Avail[l]=1;
									break;
								default:
									break;
							}
							break;
						case QZSS:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case QZSCNAV:
									QZSCNAVAvail[l]=1;
									break;
								case QZSCNAV2:
									QZSCNAV2Avail[l]=1;
									break;
								case QZSLNAV:
									QZSLNAVAvail[l]=1;
								default:
									break;
							}
							break;
						case IRNSS:
							switch(options->BRDCAvailSelOrder[l][i][j][k]) {
								case IRNCNAV:
									IRNCNAVAvail[l]=1;
									break;
								default:
									break;
							}
							break;
						default:
							break;
					}
				}
			}
		}
	}

	//Check if user is correcting DCBs but without having the necessary broadcast message types
	if (options->workMode == wmDOPROCESSING) {

		//Reset freqUsed
		for(i=0;i<MAX_GNSS;i++) {
			for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
				freqUsed[i][j]=0;
			}
		}

		//Check if any frequency is to be read by ANTEX. If none, set the generic value to adSET
		//Disable all constellations that do not have any navigation message available
		//If a constellation is disabled, disable all its DCBs corrections, so the INFO messages
		//with the internal configuration is more consistent (constellation disable, disable its DCBs)
		if (sopt->navMode==NMstandalone) {
			for(j=0;j<MAX_GNSS;j++) {
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					if (options->includeSatellite[j][k]==0) continue; 
					switch(j) {
						case GPS:
							if (GPSLNAVAvail[ORBNAVPOS]==0 && GPSCNAVAvail[ORBNAVPOS]==0 && GPSCNAV2Avail[ORBNAVPOS]==0) {
								printInfo("Forcing disable of all GPS     satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[GPS]=0;
								options->GPSp1c1DCBModel=GPSp1c1NONE;
								options->GPSp1p2DCBModel = DCBNONE;
								options->GPSISCl1caDCBModel=DCBNONE;
								options->GPSISCl1cpDCBModel=DCBNONE;
								options->GPSISCl1cdDCBModel=DCBNONE;
								options->GPSISCl2cDCBModel=DCBNONE;
								options->GPSISCl5i5DCBModel=DCBNONE;
								options->GPSISCl5q5DCBModel=DCBNONE;
								options->DualFreqDCBModel[GPS]=DCBNONE;
							}
							break;
						case Galileo:
							if (GalINAVAvail[ORBNAVPOS]==0 && GalFNAVAvail[ORBNAVPOS]==0) {
								printInfo("Forcing disable of all Galileo satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[Galileo]=0;
								options->GALe1e5aDCBModel= DCBNONE;
								options->GALe1e5bDCBModel= DCBNONE;
								options->DualFreqDCBModel[Galileo]=DCBNONE;
							}
							break;
						case GLONASS:
							if (GLOFDMAAvail[ORBNAVPOS]==0 && GLOCDMAAvail[ORBNAVPOS]==0) {
								printInfo("Forcing disable of all GLONASS satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[GLONASS]=0;
								options->GLOp1p2DCBModel = DCBNONE;
								options->DualFreqDCBModel[GLONASS]=DCBNONE;
							}
							break;
						case GEO:
							//In SBAS 1F and DFMC, GEO navigation message is provided within SBAS messages
							if (GEOCNAVAvail[ORBNAVPOS]==0 && options->SBAScorrections<SBAS1Fused) {
								printInfo("Forcing disable of all GEO     satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[GEO]=0;
								options->DualFreqDCBModel[GEO]=DCBNONE;
							}
							break;
						case BDS:
							if (BDSD1Avail[ORBNAVPOS]==0 && BDSD2Avail[ORBNAVPOS]==0 && BDSCNAV1Avail[ORBNAVPOS]==0 && BDSCNAV2Avail[ORBNAVPOS]==0) {
								printInfo("Forcing disable of all BDS     satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[BDS]=0;
								options->BDSb2b6DCBModel= DCBNONE;
								options->BDSb7b6DCBModel= DCBNONE;
								options->BDSSP3DCBModel= DCBNONE;
								options->BDSb1b6DCBModel= DCBNONE;
								options->BDSb5b6DCBModel= DCBNONE;
								options->BDSISCb1cdDCBModel= DCBNONE;
								options->BDSISCb2adDCBModel= DCBNONE;
								options->BDSSP3DCBModel=DCBNONE;
								options->DualFreqDCBModel[BDS]=DCBNONE;
							}
							break;
						case QZSS:
							if (QZSLNAVAvail[ORBNAVPOS]==0 && QZSCNAVAvail[ORBNAVPOS]==0 && QZSCNAV2Avail[ORBNAVPOS]==0) {
								printInfo("Forcing disable of all QZSS    satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[QZSS]=0;
								options->QZSc1cDCBModel= DCBNONE;
								options->QZSISCl1cpDCBModel= DCBNONE;
								options->QZSISCl1cdDCBModel= DCBNONE;
								options->QZSISCl2cDCBModel= DCBNONE;
								options->QZSISCl5i5DCBModel= DCBNONE;
								options->QZSISCl5q5DCBModel= DCBNONE;
								options->DualFreqDCBModel[QZSS]=DCBNONE;
							}
							break;
						case IRNSS:
							if (IRNCNAVAvail[ORBNAVPOS]==0) {
								printInfo("Forcing disable of all IRNSS   satellites, as no navigation messages are available",options);
								for(m=1;m<=listMaxSatGNSS[j];m++) {
									options->includeSatellite[j][m]=0;
								}
								options->ConstellationUsed[IRNSS]=0;
								options->IRNc9c5DCBModel=DCBNONE;
								options->DualFreqDCBModel[IRNSS]=DCBNONE;
							}
							break;
						default:
							break;
					}
				}
			}
		}

		for(i=0;i<NUM_OBSRINEX;i++) {
			if (i==ROVERPOS) epochPointer=epoch;
			else epochPointer=epochDGNSS;
			if (options->DGNSS==0 && i==REFSTAPOS) continue;
			for(j=0;j<MAX_GNSS;j++) {
				for(k=1;k<=listMaxSatGNSS[j];k++) {
					for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
						if (options->includeSatellite[j][k]==0) continue; //It has to be checked after each measurement for the case a constellation is unselected
						//Check ISC for single frequency measurements and compulsory differencial DCBs
						if (options->filterMeasList[i][j][k][l][0]<ENDMEAS) {
							if (options->filterMeasList[i][j][k][l][0]==NA) {
								strcpy(auxstr,"single frequency measurement");
							} else {
								sprintf(auxstr,"measurement %s",meastype2measstr(options->filterMeasList[i][j][k][l][0]));
							}
							freqUsed[j][options->filterMeasfreq[i][j][k][l][0]]=1; //Save used frequencies for later
							switch(j) {
								case GPS:
									if (options->GPSp1p2DCBModel==DCBRINEX) {
										if (GPSLNAVAvail[TGDNAVPOS]==0 && GPSCNAVAvail[TGDNAVPOS]==0) {
											printInfo("Forcing disable of all GPS     satellites, as no navigation messages for DCB data are available. Disable P1-P2 DCB correction",options);
											for(m=1;m<=listMaxSatGNSS[GPS];m++) {
												options->includeSatellite[GPS][m]=0;
											}
											options->GPSp1c1DCBModel=GPSp1c1NONE;
											options->GPSp1p2DCBModel = DCBNONE;
											options->GPSISCl1caDCBModel=DCBNONE;
											options->GPSISCl1cpDCBModel=DCBNONE;
											options->GPSISCl1cdDCBModel=DCBNONE;
											options->GPSISCl2cDCBModel=DCBNONE;
											options->GPSISCl5i5DCBModel=DCBNONE;
											options->GPSISCl5q5DCBModel=DCBNONE;
											options->DualFreqDCBModel[GPS]=DCBNONE;
										}
									}
									switch (options->filterMeasfreq[i][j][k][l][0]) {
										case 1:
											switch (options->GPSISCl1caDCBModel) {
												case DCBRINEX:
													if (GPSCNAVAvail[TGDNAVPOS]==0 && sopt->GPSISCl1caDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L1C/A DCB for %s with frequency 1, but CNAV navigation message for GPS is not available. Either disable DCB correction or remove frequency 1",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (GPSCNAVAvail[TGDNAVPOS]==0) {
														options->GPSISCl1caDCBModel=DCBNONE;
														printInfo("Forcing disable of GPS ISC L1C/A DCB, as no CNAV navigation messages for GPS are available",options);
													}
													break;
												default:
													break;
											}
											switch (options->GPSISCl1cpDCBModel) {
												case DCBRINEX:
													if (GPSCNAV2Avail[TGDNAVPOS]==0 && sopt->GPSISCl1cpDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L1Cp DCB for %s with frequency 1, but CNAV2 navigation message for GPS is not available. Either disable DCB correction or remove frequency 1",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (GPSCNAV2Avail[TGDNAVPOS]==0) {
														options->GPSISCl1cpDCBModel=DCBNONE;
														printInfo("Forcing disable of GPS ISC L1Cp DCB, as no CNAV2 navigation messages for GPS are available",options);
													}
													break;
												default:
													break;
											}
											switch (options->GPSISCl1cdDCBModel) {
												case DCBRINEX:
													if (GPSCNAV2Avail[TGDNAVPOS]==0 && sopt->GPSISCl1cdDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L1Cd DCB for %s with frequency 1, but CNAV2 navigation message for GPS is not available. Either disable DCB correction or remove frequency 1",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (GPSCNAV2Avail[TGDNAVPOS]==0) {
														options->GPSISCl1cdDCBModel=DCBNONE;
														printInfo("Forcing disable of GPS ISC L1Cd DCB, as no CNAV2 navigation messages for GPS are available",options);
													}
													break;
												default:
													break;
											}
											break;
										case 2:
											switch (options->GPSISCl2cDCBModel) {
												case DCBRINEX:
													if (GPSCNAVAvail[TGDNAVPOS]==0 && sopt->GPSISCl2cDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L2C DCB for %s with frequency 2, but CNAV navigation message for GPS is not available. Either disable DCB correction or remove frequency 2",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (GPSCNAVAvail[TGDNAVPOS]==0) {
														options->GPSISCl2cDCBModel=DCBNONE;
														printInfo("Forcing disable of GPS ISC L2C DCB, as no CNAV navigation messages for GPS are available",options);
													}
													break;
												default:
													break;
											}
											break;
										case 5:
											switch (options->GPSISCl5i5DCBModel) {
												case DCBRINEX:
													if (GPSCNAVAvail[TGDNAVPOS]==0 && sopt->GPSISCl5i5DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L5I5 DCB for %s with frequency 5, but CNAV navigation message for GPS is not available. Either disable DCB correction or remove frequency 5",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (GPSCNAVAvail[TGDNAVPOS]==0) {
														options->GPSISCl5i5DCBModel=DCBNONE;
														printInfo("Forcing disable of GPS ISC L5I5 DCB, as no CNAV navigation messages for GPS are available",options);
													}
													break;
												default:
													break;
											}
											switch (options->GPSISCl5q5DCBModel) {
												case DCBRINEX:
													if (GPSCNAVAvail[TGDNAVPOS]==0 && sopt->GPSISCl5q5DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L5Q5 DCB for %s with frequency 5, but CNAV navigation message for GPS is not available. Either disable DCB correction or remove frequency 5",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (GPSCNAVAvail[TGDNAVPOS]==0) {
														options->GPSISCl5q5DCBModel=DCBNONE;
														printInfo("Forcing disable of GPS ISC L5Q5 DCB, as no CNAV navigation messages for GPS are available",options);
													}
													break;
												default:
													break;
											}
											break;
										default:
											break;
									}
									break;
								case Galileo:
									switch(options->filterMeasfreq[i][j][k][l][0]) {
										case 1:
											switch (options->GALe1e5bDCBModel) {
												case DCBRINEX:
													if (GalINAVAvail[TGDNAVPOS]==0 && GalFNAVAvail[TGDNAVPOS]==0) {
														//No navigation message available. Force disabling all Galileo satellites
														printInfo("Forcing disable of all Galileo satellites, as no navigation message data for DCB data is available. Either disable DCB correction or remove frequency 1",options);
														for(m=1;m<=listMaxSatGNSS[Galileo];m++) {
															options->includeSatellite[Galileo][m]=0;
														}
														options->GALe1e5aDCBModel= DCBNONE;
														options->GALe1e5bDCBModel= DCBNONE;
														options->DualFreqDCBModel[Galileo]=DCBNONE;
													} else if (GalINAVAvail[TGDNAVPOS]==0) {
														//E1-E5b DCB is necessary for single frequency E1
														sprintf(messagestr,"%s needs E1-E5b DCB for %s with frequency 1, but no INAV message available",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													}
													break;
												default:
													break;
											}
											break;
										case 5:
											switch (options->GALe1e5aDCBModel) {
												case DCBRINEX:
													if (GalINAVAvail[TGDNAVPOS]==0 && GalFNAVAvail[TGDNAVPOS]==0) {
														//No navigation message available. Force disabling all Galileo satellites
														printInfo("Forcing disable of all Galileo satellites, as no navigation message data for DCB data is available. Either disable DCB correction or remove frequency 5",options);
														for(m=1;m<=listMaxSatGNSS[Galileo];m++) {
															options->includeSatellite[Galileo][m]=0;
														}
														options->GALe1e5aDCBModel= DCBNONE;
														options->GALe1e5bDCBModel= DCBNONE;
														options->DualFreqDCBModel[Galileo]=DCBNONE;
													} else if (GalFNAVAvail[TGDNAVPOS]==0) {
														//E1-E5a DCB is necessary for single frequency E5a
														sprintf(messagestr,"%s needs E1-E5a DCB for %s with frequency 5, but no FNAV message available",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													}
													break;
												default:
													break;
											}
											break;
										case 7:
											switch (options->GALe1e5bDCBModel) {
												case DCBRINEX:
													if (GalINAVAvail[TGDNAVPOS]==0 && GalFNAVAvail[TGDNAVPOS]==0) {
														//No navigation message available. Force disabling all Galileo satellites
														printInfo("Forcing disable of all Galileo satellites, as no navigation message data for DCB data is available. Either disable DCB correction or remove frequency 7",options);
														for(m=1;m<=listMaxSatGNSS[Galileo];m++) {
															options->includeSatellite[Galileo][m]=0;
														}
														options->GALe1e5aDCBModel= DCBNONE;
														options->GALe1e5bDCBModel= DCBNONE;
														options->DualFreqDCBModel[Galileo]=DCBNONE;
													} else if (GalINAVAvail[TGDNAVPOS]==0) {
														//E1-Eba DCB is necessary for single frequency E5b
														sprintf(messagestr,"%s needs E1-E5b DCB for %s with frequency 7, but no INAV message available",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													}
													break;
												default:
													break;
											}
											break;
										default:
											break;
									}
									break;
								case BDS:
									switch(options->filterMeasfreq[i][j][k][l][0]) {
										case 1:
											switch(options->BDSb1b6DCBModel) {
												case DCBRINEX:
													if (BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 && sopt->BDSb1b6DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs DCB 1-6 (TGDB1Cp) for %s with frequency 1, but CNAV1 or CNAV2 navigation messages for BeiDou are not available. Either disable DCB correction or remove frequency 1 (B1)",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0) {
														options->BDSb1b6DCBModel=DCBNONE;
														printInfo("Forcing disable of BDS DCB 1-6 (TGDB1Cp), as no CNAV1 or CNAV2 navigation messages for BeiDou are available",options);
													}
												default:
													break;
											}
											switch(options->BDSISCb1cdDCBModel) { 
												case DCBRINEX:
													if (BDSCNAV1Avail[TGDNAVPOS]==0 && sopt->BDSISCb1cdDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC B1Cd for %s with frequency 1, but CNAV1 navigation message for BeiDou is not available. Either disable DCB correction or remove frequency 1 (B1)",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (BDSCNAV1Avail[TGDNAVPOS]==0) {
														options->BDSISCb1cdDCBModel=DCBNONE;
														printInfo("Forcing disable of ISC B1Cd, as no CNAV1 navigation messages for BeiDou is available",options);
													}
												default:
													break;
											}
											break;
										case 2:
											switch(options->BDSb2b6DCBModel) {
												case DCBRINEX:
													if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 && sopt->BDSb2b6DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs DCB 2-6 (TGD1) for %s with frequency 2, but D1 or D2 navigation messages for BeiDou are not available. Either disable DCB correction or remove frequency 2 (B1_2)",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0) {
														options->BDSb2b6DCBModel=DCBNONE;
														printInfo("Forcing disable of BDS DCB 2-6 (TGD1), as no D1 or D2 navigation messages for BeiDou are available",options);
													}
												default:
													break;
											}
											break;
										case 5:
											switch(options->BDSb5b6DCBModel) {
												case DCBRINEX:
													if (BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 && sopt->BDSb5b6DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs DCB 5-6 (TGDB2ap) for %s with frequency 5, but CNAV1 or CNAV2 navigation messages for BeiDou are not available. Either disable DCB correction or remove frequency 5 (B2a)",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0) {
														options->BDSb5b6DCBModel=DCBNONE;
														printInfo("Forcing disable of BDS DCB 5-6 (TGDB2ap), as no CNAV1 or CNAV2 navigation messages for BeiDou are available",options);
													}
												default:
													break;
											}
											switch(options->BDSISCb2adDCBModel) { 
												case DCBRINEX:
													if (BDSCNAV2Avail[TGDNAVPOS]==0 && sopt->BDSISCb1cdDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC B1Cd for %s with frequency 5, but CNAV2 navigation message for BeiDou is not available. Either disable DCB correction or remove frequency 5 (B2a)",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (BDSCNAV2Avail[TGDNAVPOS]==0) {
														options->BDSISCb2adDCBModel=DCBNONE;
														printInfo("Forcing disable of ISC B2ad, as no CNAV2 navigation messages for BeiDou is available",options);
													}
												default:
													break;
											}
											break;
										case 7:
											switch(options->BDSb7b6DCBModel) {
												case DCBRINEX:
													if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 && sopt->BDSb7b6DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs DCB 7-6 (TGD2) for %s with frequency 7, but D1 or D2 navigation messages for BeiDou are not available. Either disable DCB correction or remove frequency 7 (B2b)",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 ) {
														options->BDSb7b6DCBModel=DCBNONE;
														printInfo("Forcing disable of BDS DCB 7-6 (TGD2), as no D1 or D2 navigation messages for BeiDou are available",options);
													}
												default:
													break;
											}
											break;
										default:
											break;
									}
									switch (options->BDSSP3DCBModel) { 
										case DCBRINEX:
											if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0  && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 
													&& sopt->BDSSP3DCBModel==DCBRINEX && options->filterMeasfreq[i][j][k][l][0]!=6) {
												sprintf(messagestr,"%s needs DCB for %s with frequency %d, but D1, CNAV1 and CNAV2 navigation messages for BeiDou are not available. Either disable single frequency precise orbits DCB correction or remove frequency %d",gnsstype2gnssstr(j),auxstr,options->filterMeasfreq[i][j][k][l][0],options->filterMeasfreq[i][j][k][l][0]);
												printError(messagestr,options);
											} else if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 
														&& options->filterMeasfreq[i][j][k][l][0]!=6) {
												options->BDSSP3DCBModel=DCBNONE;
												printInfo("Forcing disable of BDS single frequency precise orbits DCB correction, as no D1, CNAV1, or CNAV2 navigation messages for BeiDou are available",options);
											}
											break;
										case DCBNONE:
											if (BDSPreciseOrbitsDCBDualFreqOff==1 && BDSPreciseOrbitsDCBSingleFreqOff==0) {
												BDSPreciseOrbitsDCBSingleFreqOff=1;
												printInfo("Forcing disable of BDS single frequency precise orbits DCB correction, as no D1, CNAV1, or CNAV2 navigation messages for BeiDou are available",options);
											}
											break;
										default:
											break;
									}
									//Remaining DCBs to be implemented when navigation message in RINEX is updated
									break;
								case QZSS:
									if (options->QZSc1cDCBModel==DCBRINEX) {
										if (QZSLNAVAvail[TGDNAVPOS]==0 && QZSCNAVAvail[TGDNAVPOS]==0) {
											printInfo("Forcing disable of all QZSS    satellites, as no navigation messages for DCB data are available. Disable L1C/A DCB correction",options);
											for(m=1;m<=listMaxSatGNSS[QZSS];m++) {
												options->includeSatellite[QZSS][m]=0;
											}
											options->QZSc1cDCBModel= DCBNONE;
											options->QZSISCl1cpDCBModel= DCBNONE;
											options->QZSISCl1cdDCBModel= DCBNONE;
											options->QZSISCl2cDCBModel= DCBNONE;
											options->QZSISCl5i5DCBModel= DCBNONE;
											options->QZSISCl5q5DCBModel= DCBNONE;
											options->DualFreqDCBModel[QZSS]=DCBNONE;
										}
									}
									switch (options->filterMeasfreq[i][j][k][l][0]) {
										case 1:
											switch (options->QZSISCl1cpDCBModel) {
												case DCBRINEX:
													if (QZSCNAV2Avail[TGDNAVPOS]==0 && sopt->QZSISCl1cpDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L1Cp DCB for %s with frequency 1, but CNAV2 navigation message for QZSS is not available. Either disable DCB correction or remove frequency 1",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (QZSCNAV2Avail[TGDNAVPOS]==0) {
														options->QZSISCl1cpDCBModel=DCBNONE;
														printInfo("Forcing disable of QZSS ISC L1Cp DCB, as no CNAV2 navigation messages for QZSS are available",options);
													}
													break;
												default:
													break;
											}
											switch (options->QZSISCl1cdDCBModel) {
												case DCBRINEX:
													if (QZSCNAV2Avail[TGDNAVPOS]==0 && sopt->QZSISCl1cdDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L1Cd DCB for %s with frequency 1, but CNAV2 navigation message for QZSS is not available. Either disable DCB correction or remove frequency 1",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (QZSCNAV2Avail[TGDNAVPOS]==0) {
														options->QZSISCl1cdDCBModel=DCBNONE;
														printInfo("Forcing disable of QZSS ISC L1Cd DCB, as no CNAV2 navigation messages for QZSS are available",options);
													}
													break;
												default:
													break;
											}
											break;
										case 2:
											switch (options->QZSISCl2cDCBModel) {
												case DCBRINEX:
													if (QZSCNAVAvail[TGDNAVPOS]==0 && sopt->QZSISCl2cDCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L2C DCB for %s with frequency 2, but CNAV navigation message for QZSS is not available. Either disable DCB correction or remove frequency 2",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (QZSCNAVAvail[TGDNAVPOS]==0) {
														options->QZSISCl2cDCBModel=DCBNONE;
														printInfo("Forcing disable of QZSS ISC L2C DCB, as no CNAV navigation messages for QZSS are available",options);
													}
													break;
												default:
													break;
											}
											break;
										case 5:
											switch (options->QZSISCl5i5DCBModel) {
												case DCBRINEX:
													if (QZSCNAVAvail[TGDNAVPOS]==0 && sopt->QZSISCl5i5DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L5I5 DCB for %s with frequency 5, but CNAV navigation message for QZSS is not available. Either disable DCB correction or remove frequency 5",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (QZSCNAVAvail[TGDNAVPOS]==0) {
														options->QZSISCl5i5DCBModel=DCBNONE;
														printInfo("Forcing disable of QZSS ISC L5I5 DCB, as no CNAV navigation messages for QZSS are available",options);
													}
													break;
												default:
													break;
											}
											switch (options->QZSISCl5q5DCBModel) {
												case DCBRINEX:
													if (QZSCNAVAvail[TGDNAVPOS]==0 && sopt->QZSISCl5q5DCBModel==DCBRINEX) {
														sprintf(messagestr,"%s needs ISC L5Q5 DCB for %s with frequency 5, but CNAV navigation message for QZSS is not available. Either disable DCB correction or remove frequency 5",gnsstype2gnssstr(j),auxstr);
														printError(messagestr,options);
													} else if (QZSCNAVAvail[TGDNAVPOS]==0) {
														options->QZSISCl5q5DCBModel=DCBNONE;
														printInfo("Forcing disable of QZSS ISC L5Q5 DCB, as no CNAV navigation messages for QZSS are available",options);
													}
													break;
												default:
													break;
											}
											break;
										default:
											break;
									}
									break;
								default:
									//GLONASS has no DCB data in its navigation message (at least in the FDMA navigation messages)
									//SBAS has no DCB data in its navigation message (at least in the current RINEX versions)
									//IRNSS only has two frequencies, so one DCB is enough
									break;
							}
						} else if (options->filterMeasList[i][j][k][l][0]<IGF1012) {
							//Dual-frequency combinations
							switch(j) {
								case GPS:
									if (GPSCNAVAvail[TGDNAVPOS]==0 && sopt->DualFreqDCBModel[GPS]!=DCBRINEX && options->DualFreqDCBModel[GPS]!=DCBNONE) {
										if (options->SBAScorrections==SBASDFMCused) { 
											//For the case of SBAS DFMC, only the TGD is applied, as SBAS DFMC used LNAV messages which has no ISC. 
											//The ISC is included in the SBAS DFMC clock correction
											//printInfo("SBAS DFMC uses only LNAV TGD (in metres of L1) as dual frequency DCB, as the ISC is included in the SBAS DFMC clock correction",options);
										} else {
											printInfo("Forcing disable of all dual-frequency DCB for GPS  satellites, as no CNAV navigation messages for DCB data are available",options);
											options->DualFreqDCBModel[GPS]=DCBNONE;
										}
									} else if (GPSCNAVAvail[TGDNAVPOS]==0 && sopt->DualFreqDCBModel[GPS]==DCBRINEX) {
										printError("User selected to compute dual-frequency DCBs for GPS, but no CNAV navigation messages for DCB data are available",options);
									}
									break;
								case BDS:
									if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 
												&& sopt->DualFreqDCBModel[BDS]!=DCBRINEX && options->DualFreqDCBModel[BDS]!=DCBNONE) {
										printInfo("Forcing disable of all dual-frequency DCB for BDS  satellites, as no CNAV navigation messages for DCB data are available",options);
										options->DualFreqDCBModel[BDS]=DCBNONE;
									} else if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 
											&& sopt->DualFreqDCBModel[BDS]==DCBRINEX) {
										printError("User selected to compute dual-frequency DCBs for BDS, but no CNAV navigation messages for DCB data are available",options);
									}
									//This DCB is a single frequency one, but is only with precise orbits
									//The code is repeated here for the case there is only dual-frequency measurements, this DCB is disabled
									switch (options->BDSSP3DCBModel) { 
										case DCBRINEX:
											if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0  && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 
													&& sopt->BDSSP3DCBModel==DCBRINEX && options->filterMeasfreq[i][j][k][l][0]!=6) {
												sprintf(messagestr,"%s needs DCB for %s with frequency %d, but D1, CNAV1 and CNAV2 navigation messages for BeiDou are not available. Either disable single frequency precise orbits DCB correction or remove frequency %d",gnsstype2gnssstr(j),auxstr,options->filterMeasfreq[i][j][k][l][0],options->filterMeasfreq[i][j][k][l][0]);
												printError(messagestr,options);
											} else if (BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0 
														&& options->filterMeasfreq[i][j][k][l][0]!=6) {
												options->BDSSP3DCBModel=DCBNONE;
												BDSPreciseOrbitsDCBDualFreqOff=1;
												//Disable single frequency precise orbits BeiDou DCB but do not print anything as no single measurements are used
											}
											break;
										default:
											break;
									}
									break;
								case QZSS:
									if (QZSCNAVAvail[TGDNAVPOS]==0 && sopt->DualFreqDCBModel[QZSS]!=DCBRINEX && options->DualFreqDCBModel[QZSS]!=DCBNONE) {
										printInfo("Forcing disable of all dual-frequency DCB for QZSS satellites, as no CNAV navigation messages for DCB data are available",options);
										options->DualFreqDCBModel[QZSS]=DCBNONE;
									} else if (QZSCNAVAvail[TGDNAVPOS]==0 && sopt->DualFreqDCBModel[QZSS]==DCBRINEX) {
										printError("User selected to compute dual-frequency DCBs for QZSS, but no CNAV navigation messages for DCB data are available",options);
									}
									break;
								default:
									break;
							}
						}
					}
				}
			}
		}
		//Loop through the frequencies that have not been used to disable remaining not TGD not available due to no navigation message available
		for(i=0;i<MAX_GNSS;i++) {
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				if (options->includeSatellite[i][j]==1) break;
			}
			if (j==listMaxSatGNSS[i]) continue;
			for(j=0;j<MAX_FREQUENCIES_PER_GNSS;j++) {
				if (availGNSSFreq[i][j]==0) continue;
				if (freqUsed[i][j]==1) continue; //Frequency already scanned in previous loop
				switch(i) {
					case GPS:
						switch(j) {
							case 1:
								if (GPSCNAVAvail[TGDNAVPOS]==0) {
									if (options->GPSISCl1caDCBModel==DCBRINEX) {
										options->GPSISCl1caDCBModel=DCBNONE;
										printInfo("Forcing disable of GPS ISC L1C/A DCB, as no CNAV navigation messages for GPS are available",options);
									}
								}
								if (GPSCNAV2Avail[TGDNAVPOS]==0) {
									if (options->GPSISCl1cpDCBModel==DCBRINEX) {
										options->GPSISCl1cpDCBModel=DCBNONE;
										printInfo("Forcing disable of GPS ISC L1Cp DCB, as no CNAV2 navigation messages for GPS are available",options);
									}
									if (options->GPSISCl1cdDCBModel==DCBRINEX) {
										options->GPSISCl1cdDCBModel=DCBNONE;
										printInfo("Forcing disable of GPS ISC L1Cd DCB, as no CNAV2 navigation messages for GPS are available",options);
									}
								}
								break;
							case 2:
								if (GPSCNAVAvail[TGDNAVPOS]==0) {
									if (options->GPSISCl2cDCBModel==DCBRINEX) {
										options->GPSISCl2cDCBModel=DCBNONE;
										printInfo("Forcing disable of GPS ISC L2C DCB, as no CNAV navigation messages for GPS are available",options);
									}
								}
								break;
							case 5:
								if (GPSCNAVAvail[TGDNAVPOS]==0) {
									if (options->GPSISCl5i5DCBModel==DCBRINEX) {
										options->GPSISCl5i5DCBModel=DCBNONE;
										printInfo("Forcing disable of GPS ISC L5I5 DCB, as no CNAV navigation messages for GPS are available",options);
									}
									if (options->GPSISCl5q5DCBModel==DCBRINEX) {
										options->GPSISCl5q5DCBModel=DCBNONE;
										printInfo("Forcing disable of GPS ISC L5Q5 DCB, as no CNAV navigation messages for GPS are available",options);
									}
								}
								break;
							default:
								break;
						}
						break;
					case BDS:
						switch(j) {
							case 1:
								if (options->BDSb1b6DCBModel==DCBRINEX && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0) {
									options->BDSb1b6DCBModel=DCBNONE;
									printInfo("Forcing disable of BDS DCB 1-6 (TGDB1Cp), as no CNAV1 or CNAV2 navigation messages for BeiDou are available",options);
								}
								if (options->BDSISCb1cdDCBModel==DCBRINEX && BDSCNAV1Avail[TGDNAVPOS]==0 ) {
									options->BDSISCb1cdDCBModel=DCBNONE;
									printInfo("Forcing disable of ISC B1Cd, as no CNAV1 navigation messages for BeiDou is available",options);
								}
								break;
							case 2:
								if (options->BDSb2b6DCBModel==DCBRINEX && BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0) {
									options->BDSb2b6DCBModel=DCBNONE;
									printInfo("Forcing disable of BDS DCB 2-6 (TGD1), as no D1 or D2 navigation messages for BeiDou are available",options);
								}
								break;
							case 5:
								if (options->BDSb5b6DCBModel==DCBRINEX && BDSCNAV1Avail[TGDNAVPOS]==0 && BDSCNAV2Avail[TGDNAVPOS]==0) {
									options->BDSb5b6DCBModel=DCBNONE;
									printInfo("Forcing disable of BDS DCB 5-6 (TGDB2ap), as no CNAV1 or CNAV2 navigation messages for BeiDou are available",options);
								}	
								if (options->BDSISCb2adDCBModel==DCBRINEX && BDSCNAV2Avail[TGDNAVPOS]==0) {
									options->BDSISCb2adDCBModel=DCBNONE;
									printInfo("Forcing disable of ISC B2ad, as no CNAV2 navigation messages for BeiDou is available",options);
								}
								break;
							case 7:
								if (options->BDSb7b6DCBModel==DCBRINEX && BDSD1Avail[TGDNAVPOS]==0 && BDSD2Avail[TGDNAVPOS]==0 ) {
									options->BDSb7b6DCBModel=DCBNONE;
									printInfo("Forcing disable of BDS DCB 7-6 (TGD2), as no D1 or D2 navigation messages for BeiDou are available",options);
								}
								break;
							default:
								break;
						}
						break;
					case QZSS:
						switch(j) {
							case 1:
								if (QZSCNAV2Avail[TGDNAVPOS]==0) {
									if (options->QZSISCl1cpDCBModel==DCBRINEX) {
										options->QZSISCl1cpDCBModel=DCBNONE;
										printInfo("Forcing disable of QZSS ISC L1Cp DCB, as no CNAV2 navigation messages for QZSS are available",options);
									}
									if (options->QZSISCl1cdDCBModel==DCBRINEX) {
										options->QZSISCl1cdDCBModel=DCBNONE;
										printInfo("Forcing disable of QZSS ISC L1Cd DCB, as no CNAV2 navigation messages for QZSS are available",options);
									}
								}
								break;
							case 2:
								if (options->QZSISCl2cDCBModel==DCBRINEX && QZSCNAVAvail[TGDNAVPOS]==0) {
									options->QZSISCl2cDCBModel=DCBNONE;
									printInfo("Forcing disable of QZSS ISC L2C DCB, as no CNAV navigation messages for QZSS are available",options);
								}
								break;
							case 5:
								 if (QZSCNAVAvail[TGDNAVPOS]==0) {
									 if (options->QZSISCl5i5DCBModel==DCBRINEX) {
										 options->QZSISCl5i5DCBModel=DCBNONE;
										 printInfo("Forcing disable of QZSS ISC L5I5 DCB, as no CNAV navigation messages for QZSS are available",options);
									 }
									 if (options->QZSISCl5q5DCBModel==DCBRINEX) {
										options->QZSISCl5q5DCBModel=DCBNONE;
										printInfo("Forcing disable of QZSS ISC L5Q5 DCB, as no CNAV navigation messages for QZSS are available",options);
									 }
								 }
								break;
							default:
								break;
						}
						break;
					default:
						break;
				}
			}
		}	
	}

	//Compute the lambda of the measurements used in the filter (so it does not need to compute it every time a PREFIT is computed)
	for(i=0;i<NUM_OBSRINEX;i++) {
		if (i==ROVERPOS) epochPointer=epoch;
		else epochPointer=epochDGNSS;
		for(j=0;j<MAX_GNSS;j++) {
			for(k=1;k<=listMaxSatGNSS[j];k++) {
				for(l=0;l<options->numfilterMeasList[i][j][k];l++) {
					switch (options->filterMeasTypeList[i][j][k][l]) {
						case IonoFreeCombCode: case IonoFreeCombPhase: 
						case IonoFreeCombDoppler: case IonoFreeCombCodeSmoothed:
							freq1=epochPointer->measOrder[j].freqMeas[options->filterMeasfreq[i][j][k][l][0]][k];
							freq2=epochPointer->measOrder[j].freqMeas[options->filterMeasfreq[i][j][k][l][1]][k];
							if (freq1==1. || freq2==1.) {
								epochPointer->measOrder[j].filterMeaslambda[k][l]=0.;
							} else {
								epochPointer->measOrder[j].filterMeaslambda[k][l]=c0/(freq1+freq2);
							}
							break;
						case SecondIonoFreeCode: case SecondIonoFreePhase: 
						case SecondIonoFreeDoppler: case SecondIonoFreeCodeSmoothed:
							epochPointer->measOrder[j].filterMeaslambda[k][l]=epoch->measOrder[j].lambdaMeas[options->filterMeasfreq[i][j][k][l][0]][k];//To be revised
							break;
						default:
							epochPointer->measOrder[j].filterMeaslambda[k][l]=epoch->measOrder[j].lambdaMeas[options->filterMeasfreq[i][j][k][l][0]][k];
							break;
					}					
				}
			}
		}
	}

	//Count number of constellations used
	options->numConstellationUsed=0;
	for(i=0;i<MAX_GNSS;i++) {
		if (options->ConstellationUsed[i]==1) {
			options->numConstellationUsed++;
		}
	}
}

/*****************************************************************************
 * Name        : readConfig
 * Description : Reads the input parameters from a FILE descriptor
 * Parameters  :
 * Name                           |Da|Unit|Description
 * FILE  *fd                       I  N/A  Input file descriptor
 * TSupportOptions  *sopt          IO N/A  TSupportOptions structure
 * TOptions  *options              IO N/A  TOptions structure
 * Returned value (int)            O  N/A  Status of the function
 *                                         -1 => Some problems with the parameter
 *                                               parsing                                
 *                                         1  => Parsing properly done
 *****************************************************************************/
int readConfig (FILE *fd, TSupportOptions *sopt, TOptions *options) {
	char 		line[MAX_INPUT_LINE];
	char		word[MAX_INPUT_LINE];
	char		auxword[MAX_INPUT_LINE];
	char		*wordlist[MAX_WORDS];
	char		quoteChar,PrevChar;
	char		*PosCurrArg;
	int			len = 0;
	int			ret = 0;
	int			wordindex = 1;
	int			i;
	int			numCharRead,numCharReadTotal;
	int			filenameWithQuotes;
	int			ScannedStringLength;
	int			wordLength;
	
	for (i=0;i<MAX_WORDS;i++) {
		wordlist[i] = NULL;
	}


	while (getLNoComments(line,&len,fd)!=-1) {
		word[0]='#';
		word[1]='\0';
		numCharReadTotal=0;
		ret = sscanf(line,"%s%n",word,&numCharRead);
		if (ret) {
			if (word[0]!='#') { // It is not a comment
				ScannedStringLength=strlen(word);
				wordlist[wordindex] = malloc(sizeof(char)*(ScannedStringLength+1)); // +1 for the '\0'
				strcpy(wordlist[wordindex],word);
				wordindex++;
				if (wordindex>=MAX_WORDS) {
					return -1;
				}
				numCharReadTotal+=numCharRead;
				for(i=0;wordlist[wordindex-1][i];i++) {
					//Transform to lower case characters
					auxword[i]=tolower(wordlist[wordindex-1][i]);
				}
				auxword[i]='\0';
				if( (strstr(auxword,"-input:")!=NULL || strstr(auxword,"-output:")!=NULL) && strstr(auxword,"-input:rtcm:")==NULL  
						&& strstr(auxword,"--output:")==NULL && strstr(auxword,"-output:kml:")==NULL && strstr(auxword,"-output:sp3:")==NULL
						&& strstr(auxword,"-output:refpos:")==NULL && strstr(auxword,"-output:rinexversion")==NULL
						&& strstr(auxword,"-output:satvel")==NULL && strstr(auxword,"-output:peg")==NULL
						&& strstr(auxword,"-output:rinexb")==NULL && strstr(auxword,"-output:ems")==NULL ) {
					//-input:... or -output:file or -output:sbasdir or -output:stfdesa parameter found. 
					//Also we have to exclude all '-input:' and '-output:' parameters that do not provide any filename or path for a proper error control
					//When reading filenames, there may be more than filename in the same line (if filename contain spaces, it must be quoted)
					PosCurrArg=strstr(line,word);
					PosCurrArg=(char *)(PosCurrArg+ScannedStringLength);
					if(sscanf(&line[numCharReadTotal],"%s%n",word,&numCharRead)==1) {
						while(sscanf(PosCurrArg,"%s",word)==1) {
							filenameWithQuotes=0;
							PrevChar=' ';
							PosCurrArg=strstr(PosCurrArg,word);
							wordlist[wordindex] = malloc(sizeof(char)*MAX_INPUT_LINE);
							wordLength=0;
							quoteChar='\0';
							if (word[0]=='"') {
								quoteChar='"';
								filenameWithQuotes=1;
								PosCurrArg++;
							} else if (word[0]=='\'') {
								quoteChar='\'';
								filenameWithQuotes=1;
								PosCurrArg++;
							}
							while(1) {
								if (*PosCurrArg=='\0') {
									//End of line
									wordlist[wordindex][wordLength]='\0';
									break;
								} else if (filenameWithQuotes==1 && *PosCurrArg==quoteChar && PrevChar!='\\' ) {
									//End of filename 
									wordlist[wordindex][wordLength]='\0';
									PrevChar=*PosCurrArg;
									PosCurrArg++;
									//In windows or Cygwin, if last character was an escaped quote, remove the last saved backslash
									#if defined __WIN32__ || defined __CYGWIN__
										wordLength--;
										wordlist[wordindex][wordLength]='\0';
									#endif
									break;
								} else if (*PosCurrArg=='\\') {
									//Skip backslashes when it is not windows or Cygwin
									#if defined __WIN32__ || defined __CYGWIN__
										wordlist[wordindex][wordLength]=*PosCurrArg;
										wordLength++;
									#endif
									PrevChar=*PosCurrArg;
									PosCurrArg++;
								} else if (*PosCurrArg==' ' && filenameWithQuotes==0) {
									//No quotes, so space is end of filename
									wordlist[wordindex][wordLength]='\0';
									PrevChar=*PosCurrArg;
									PosCurrArg++;
									break;
								} else if (*PosCurrArg=='\n' || *PosCurrArg=='\r') {
									//End of line
									wordlist[wordindex][wordLength]='\0';
									*PosCurrArg='\0';
									break;
								} else {
									wordlist[wordindex][wordLength]=*PosCurrArg;
									PrevChar=*PosCurrArg;
									PosCurrArg++;
									wordLength++;
								}
							}
							wordindex++;
							if (wordindex>=MAX_WORDS) {
								return -1;
							}
						}
					} else {
						//Filename missing
						return -1;
					}
				} else {
					wordlist[wordindex] = malloc(sizeof(char)*(MAX_INPUT_LINE));
					while(sscanf(&line[numCharReadTotal],"%s%n",wordlist[wordindex],&numCharRead)==1) {
						wordindex++;
						if (wordindex>=MAX_WORDS) {
							return -1;
						}
						numCharReadTotal+=numCharRead;
						wordlist[wordindex] = malloc(sizeof(char)*(MAX_INPUT_LINE));
					}
					free(wordlist[wordindex]);
				}
			}
		}
	}
	
	wordlist[wordindex] = NULL;
	
	// Parse options
	if ( !parseAllOptions(sopt,options, wordindex, wordlist) ) {
		return -1;
	}
	
	// Free memory
	for ( i = 0; i < wordindex; i++ ) {
		free(wordlist[i]);
	}
	
	return 1;
}

/*****************************************************************************
 * Name        : checkConfigFile
 * Description : Checks if a config file has been specified (cfgFile). If it has
 *               call readConfig function to parse the file
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TSupportOptions  *sopt          IO N/A  TSupportOptions structure
 * TOptions  *options              IO N/A  TOptions structure
 * Returned value (int)            O  N/A  Status of the function
 *                                         -1 => Some problems with the parameter
 *                                               parsing or file not found
 *                                         0  => Config file not used
 *                                         1  => Parsing properly done
 *****************************************************************************/
int checkConfigFile (TSupportOptions *sopt, TOptions *options) {
	FILE	*fd;
	int		ret;
	
	if (sopt->cfgFile[0]!='\0') {
		if ((fd = fopen(sopt->cfgFile,"rb"))) {
			ret = readConfig (fd, sopt, options);
			fclose (fd);
			return ret;
		} else {
			// File does not exist
			return -1;
		}
	}
	return 0;
}

/*****************************************************************************
 * Name        : freeInputMeasString
 * Description : If users sets any measurement for processing (cycle-slips,
 *                smoothing or filter), free memory of the temporary strings
 *                used for storing user input data
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TSupportOptions  *sopt          IO N/A  TSupportOptions structure
 *****************************************************************************/
void freeInputMeasString (TSupportOptions *sopt) {
	int 	i,j;

	for(i=0;i<NUM_OBSRINEX;i++) {
		//Free input SF frequency strings
		if (sopt->csSFfreqtext[i]!=NULL) {
			for(j=0;j<sopt->numcsSFfreqtext[i];j++) {
				free(sopt->csSFfreqtext[i][j]);
			}
			free(sopt->csSFfreqtext[i]);
			sopt->csSFfreqtext[i]=NULL;
			sopt->numcsSFfreqtext[i]=0;
		}
		//Free input SF measurement strings
		if (sopt->csSFtext[i]!=NULL) {
			for(j=0;j<sopt->numcsSFtext[i];j++) {
				free(sopt->csSFtext[i][j]);
			}
			free(sopt->csSFtext[i]);
			sopt->csSFtext[i]=NULL;
			sopt->numcsSFtext[i]=0;
		}

		//Free input MW frequency strings
		if (sopt->csMWfreqtext[i]!=NULL) {
			for(j=0;j<sopt->numcsMWfreqtext[i];j++) {
				free(sopt->csMWfreqtext[i][j]);
			}
			free(sopt->csMWfreqtext[i]);
			sopt->csMWfreqtext[i]=NULL;
			sopt->numcsMWfreqtext[i]=0;
		}
		//Free input MW measurement strings
		if (sopt->csMWtext[i]!=NULL) {
			for(j=0;j<sopt->numcsMWtext[i];j++) {
				free(sopt->csMWtext[i][j]);
			}
			free(sopt->csMWtext[i]);
			sopt->csMWtext[i]=NULL;
			sopt->numcsMWtext[i]=0;
		}

		//Free input LI frequency strings
		if (sopt->csLIfreqtext[i]!=NULL) {
			for(j=0;j<sopt->numcsLIfreqtext[i];j++) {
				free(sopt->csLIfreqtext[i][j]);
			}
			free(sopt->csLIfreqtext[i]);
			sopt->csLIfreqtext[i]=NULL;
			sopt->numcsLIfreqtext[i]=0;
		}
		//Free input LI measurement strings
		if (sopt->csLItext[i]!=NULL) {
			for(j=0;j<sopt->numcsLItext[i];j++) {
				free(sopt->csLItext[i][j]);
			}
			free(sopt->csLItext[i]);
			sopt->csLItext[i]=NULL;
			sopt->numcsLItext[i]=0;
		}

		//Free input IGF frequency strings
		if (sopt->csIGFfreqtext[i]!=NULL) {
			for(j=0;j<sopt->numcsIGFfreqtext[i];j++) {
				free(sopt->csIGFfreqtext[i][j]);
			}
			free(sopt->csIGFfreqtext[i]);
			sopt->csIGFfreqtext[i]=NULL;
			sopt->numcsIGFfreqtext[i]=0;
		}
		//Free input IGF measurement strings
		if (sopt->csIGFtext[i]!=NULL) {
			for(j=0;j<sopt->numcsIGFtext[i];j++) {
				free(sopt->csIGFtext[i][j]);
			}
			free(sopt->csIGFtext[i]);
			sopt->csIGFtext[i]=NULL;
			sopt->numcsIGFtext[i]=0;
		}

		//Free input smoothing strings
		if (sopt->smoothMeasFilterText[i]!=NULL) {
			//Memory already saved. Free it
			for(j=0;j<sopt->numSmoothMeasFilterText[i];j++) {
				free(sopt->smoothMeasFilterText[i][j]);
				free(sopt->smoothWithMeasFilterText[i][j]);
			}
			free(sopt->smoothMeasFilterText[i]);
			free(sopt->smoothWithMeasFilterText[i]);
			sopt->smoothMeasFilterText[i]=NULL;
			sopt->smoothWithMeasFilterText[i]=NULL;
			sopt->numSmoothMeasFilterText[i]=0;
		}

		//Free input filter strings
		if (sopt->measFilterText[i]!=NULL) {
			for(j=0;j<sopt->numMeasFilterText[i];j++) {
				free(sopt->measFilterText[i][j]);
			}
			free(sopt->measFilterText[i]);
			sopt->measFilterText[i]=NULL;
			sopt->numMeasFilterText[i]=0;
		}

		//Free input Doppler strings
		if (sopt->measDopplerText[i]!=NULL) {
			for(j=0;j<sopt->numMeasDopplerText[i];j++) {
				free(sopt->measDopplerText[i][j]);
			}
			free(sopt->measDopplerText[i]);
			sopt->measDopplerText[i]=NULL;
			sopt->numMeasDopplerText[i]=0;
		}
	}
	//Free input weight strings and values
	if (sopt->weightText!=NULL) {
		for(i=0;i<sopt->numweightText;i++) {
			free(sopt->weightText[i]);
			free(sopt->weightTextSat[i]);
			free(sopt->WeightConstantsValues[i]);
		}
		free(sopt->weightText);
		free(sopt->weightTextSat);
		free(sopt->WeightConstantsValues);
		free(sopt->weightMode);
		sopt->weightText=NULL;
		sopt->weightTextSat=NULL;
		sopt->WeightConstantsValues=NULL;
		sopt->weightMode=NULL;
		sopt->numweightText=0;
	}
	
	//Free input weight combination strings and values
	if (sopt->numweightTextComb>0) {
		for(i=0;i<sopt->numweightTextComb;i++) {
			free(sopt->weightTextComb[i]);
			free(sopt->weightTextCombSat[i]);
			free(sopt->SNRweightCombVal[i]);
		}
		free(sopt->weightTextComb);
		free(sopt->weightTextCombSat);
		free(sopt->SNRweightComb);
		free(sopt->SNRweightCombVal);
		sopt->weightTextComb=NULL;
		sopt->weightTextCombSat=NULL;
		sopt->SNRweightComb=NULL;
		sopt->SNRweightCombVal=NULL;
		sopt->numweightTextComb=0;
	}

	//Free input weight mode strings and values
	if (sopt->numweightTextMode>0) {
		for(i=0;i<sopt->numweightTextMode;i++) {
			free(sopt->weightTextMode[i]);
			free(sopt->weightTextModeSat[i]);
		}
		free(sopt->weightTextMode);
		free(sopt->weightTextModeSat);
		free(sopt->CombineWeightMode);
		sopt->weightTextMode=NULL;
		sopt->weightTextModeSat=NULL;
		sopt->CombineWeightMode=NULL;
		sopt->numweightTextMode=0;
	}

	//Free input print Meas strings and values
	if (sopt->numprintMeastext>0) {
		for(i=0;i<sopt->numprintMeastext;i++) {
			free(sopt->printMeastext[i]);
		}
		free(sopt->printMeastext);
		sopt->printMeastext=NULL;
		sopt->numprintMeastext=0;
	}

	//Free input meas order
	for(i=0;i<NUM_OBSRINEX;i++) {
		if (sopt->numMeasTableText[i]>0) {
			for(j=0;j<sopt->numMeasTableText[i];j++) {
				free(sopt->measTableText[i][j]);
			}
			free(sopt->measTableText[i]);
			sopt->measTableText[i]=NULL;
			sopt->numMeasTableText[i]=0;
		}
	}

	//Free input receiver phase center parameters
	if (sopt->numRecPhaseCenterParam>0) {
   		for(i=0;i<sopt->numRecPhaseCenterParam;i++) {
			free(sopt->recPhaseCenterParam[i]);
		}
		free(sopt->recPhaseCenterParam);
		sopt->recPhaseCenterParam=NULL;
		sopt->numRecPhaseCenterParam=0;
	}

	//Free input iono-free reference measurements
	if (sopt->numIFRefMeas>0) {
   		for(i=0;i<sopt->numIFRefMeas;i++) {
			free(sopt->IFRefMeas[i]);
		}
		free(sopt->IFRefMeas);
		sopt->IFRefMeas=NULL;
		sopt->numIFRefMeas=0;
	}

}

/*****************************************************************************
 * Name        : compareOrbits
 * Description : Perform an orbit comparison between two different products
 * Parameters  :
 * Name                           |Da|Unit|Description
 * TGNSSproducts  **products       I  N/A  Products to be compared
 * TGNSSproducts  **pastProducts   I  N/A  Past products to be compared
 * TGNSSproducts  **nextProducts   I  N/A  Next products to be compared
 * FILE **fdRNXnav                 I  N/A  Vector with file descriptors for RINEX navigation
 * int  *retRNXnav                 I  N/A  Vector with the return of the opened RINEX navigation file
 * double  *rinexNavVersion        I  N/A  RINEX navigation version
 * FILE **fdSP3                    I  N/A  Vector with file descriptors for SP3 file (orbits + clocks)
 * int *retSP3                     I  N/A  Vector with the return of the opened SP3 file
 * FILE **fdSP3o                   I  N/A  Vector with file descriptors for SP3 file (orbits)
 * int  *retSP3o                   I  N/A  Vector with the return of the opened SP3 file
 * FILE **fdCLK                    I  N/A  Vector with file descriptors for RINEX clock file
 * int  *retCLK                    I  N/A  Vector with the return of the opened RINEX clock file
 * double *OrbitsMaxDistance       I  s    Vector with orbit max distance for precise each orbit files
 * double *OrbitsToTMaxDistance    I  s    Vector with total orbit max distance for each precise orbit files
 * double *ClocksMaxDistance       I  s    Vector with clock max distance for each precise clock files
 * double *ClocksToTMaxDistance    I  s    Vector with total clock max distance for each precise clock files
 * TConstellation  *constellation  I  N/A  Constellation information on the products
 * TTime startTime                 I  N/A  Start time of products
 * TTime endTime                   I  N/A  End time of products (may not be end of process if files are concatenated)
 * TTime endTimePercentage         I  N/A  End time of products for showing percentage
 * double numberEpochs             I  N/A  Number of epochs for comparing orbits 
 * int startTimeFromNav            I  N/A  0 -> Start Time of products is from a SP3 file
 *                                         1 -> Start Time of products is from a navigation file and only one day read in navigation file
 *                                         2 -> Start Time of products is from a navigation file and two days read in navigation file
 * TSupportOptions  *sopt          I  N/A  TSupportOptions structure
 * TOptions  *options              I  N/A  TOptions structure
 *****************************************************************************/
void compareOrbits (TGNSSproducts **products, TGNSSproducts **pastProducts, TGNSSproducts **nextProducts, FILE **fdRNXnav, int *retRNXnav, double *rinexNavVersion, FILE **fdSP3, int *retSP3, FILE **fdSP3o, int *retSP3o, FILE **fdCLK, int *retCLK, double *OrbitsMaxDistance, double *OrbitsToTMaxDistance, double *ClocksMaxDistance, double *ClocksToTMaxDistance, TConstellation *constellation, TTime startTime, TTime endTime, TTime endTimePercentage, double numberEpochs, int startTimeFromNav, TOptions *options, TSupportOptions *sopt) {
	double					orientation[2][3][3];
	double					orientationACR[3][3];
	int						i, j, k, l;
	TTime					t;
	char					**tStr; //Position 0 will have time in new format (Year DoY SoD HH:MM:SS.zz) and position 1 will have old format (Year DoY SoD)
	double					position[2][3];
	double					velocity[2][3];
	double					ITRFvelocity[2][3];
	double					posDiff[3];
	double					posDiffXYZ[3];
	double					clockValue[2];
	double					SISREDiff;
	double					Orb3DDiff;
	double					OrbDiff;
	double					ClkDiff;
	double					dr[3];
	double					DCB[2];
	double					DCBDiff;
	double					diff;
	int						available;
	double 					tIncrease = 30.;
	int						ret;
	double					sunPos[3];
	double					auxT;
	double					epochsProcessed=0.;
	double					CurrentPercentage=0.;
	double					seconds;
	double					PreviousPercentage=-1;
	int						DataAvailable[2];
	int						end=0;
	int						len;
	int						numReadNav,numReadSP3,numReadOrb;
	int						currentMJDN;
	TSatellite				sat;
	TStat					statSISRE[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statSISRETot;
	TStat					stat3D[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					stat3DTot;
	TStat					statOrb[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statOrbTot;
	TStat					statClk[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statClkTot;
	TStat					statDCB[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statDCBTot;
	TStat					statRadOrb[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statRadOrbTot;
	TStat					statAloOrb[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statAloOrbTot;
	TStat					statCroOrb[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	TStat					statCroOrbTot;
	TSatInfo				satInfo[MAX_GNSS][MAX_SATELLITES_PER_GNSS];
	int						bothSP3,bothBRDC;
	int						BRDCtypes[MAX_GNSS][2];
	int						BRDCmodes[MAX_GNSS][2];
	int						IOD = -1;	//IOD not used here, so the IOD value for BRDC data is -1
	char					auxstr[100];
	struct tm 				tm;
	TBRDCblock 				*block[2];

	double					satPhase[3];

	block[0]=block[1]=NULL;

	// Allocate size for print strings
	tStr=NULL;
	tStr=malloc(sizeof(char*)*2);
	tStr[0]=NULL;
	tStr[0]=malloc(sizeof(char)*50);
	tStr[1]=NULL;
	tStr[1]=malloc(sizeof(char)*50);

	switch (options->BrdcTypeSel[GPS]) {
		case GPSLNAVvsCNAV:
			BRDCtypes[GPS][0]=GPSLNAV;
			BRDCtypes[GPS][1]=GPSCNAV;
			BRDCmodes[GPS][0]=GPSLNAVOnly;
			BRDCmodes[GPS][1]=GPSCNAVOnly;
			break;
		case GPSCNAVvsLNAV:
			BRDCtypes[GPS][0]=GPSCNAV;
			BRDCtypes[GPS][1]=GPSLNAV;
			BRDCmodes[GPS][0]=GPSCNAVOnly;
			BRDCmodes[GPS][1]=GPSLNAVOnly;
			break;
		case GPSLNAVvsCNAV2:
			BRDCtypes[GPS][0]=GPSLNAV;
			BRDCtypes[GPS][1]=GPSCNAV2;
			BRDCmodes[GPS][0]=GPSLNAVOnly;
			BRDCmodes[GPS][1]=GPSCNAV2Only;
			break;
		case GPSCNAV2vsLNAV:
			BRDCtypes[GPS][0]=GPSCNAV2;
			BRDCtypes[GPS][1]=GPSLNAV;
			BRDCmodes[GPS][0]=GPSCNAV2Only;
			BRDCmodes[GPS][1]=GPSLNAVOnly;
			break;
		case GPSCNAVvsCNAV2:
			BRDCtypes[GPS][0]=GPSCNAV;
			BRDCtypes[GPS][1]=GPSCNAV2;
			BRDCmodes[GPS][0]=GPSCNAVOnly;
			BRDCmodes[GPS][1]=GPSCNAV2Only;
			break;
		case GPSCNAV2vsCNAV:
			BRDCtypes[GPS][0]=GPSCNAV2;
			BRDCtypes[GPS][1]=GPSCNAV;
			BRDCmodes[GPS][0]=GPSCNAV2Only;
			BRDCmodes[GPS][1]=GPSCNAVOnly;
			break;
		default:
			BRDCtypes[GPS][0]=BRDCtypes[GPS][1]=GPSANY;
			BRDCmodes[GPS][0]=BRDCmodes[GPS][1]=options->BrdcTypeSel[GPS];
			break;
	}

	switch (options->BrdcTypeSel[Galileo]) {
		case GalINAVvsFNAV:
			BRDCtypes[Galileo][0]=GalINAVANY;
			BRDCtypes[Galileo][1]=GalFNAV;
			BRDCmodes[Galileo][0]=GalINAVOnly;
			BRDCmodes[Galileo][1]=GalFNAVOnly;
			break;
		case GalFNAVvsINAV:
			BRDCtypes[Galileo][0]=GalFNAV;
			BRDCtypes[Galileo][1]=GalINAVANY;
			BRDCmodes[Galileo][0]=GalFNAVOnly;
			BRDCmodes[Galileo][1]=GalINAVOnly;
			break;
		case GalINAVvsCNAV:
			BRDCtypes[Galileo][0]=GalINAVANY;
			BRDCtypes[Galileo][1]=GalCNAV;
			BRDCmodes[Galileo][0]=GalINAVOnly;
			BRDCmodes[Galileo][1]=GalCNAVOnly;
			break;
		case GalCNAVvsINAV:
			BRDCtypes[Galileo][0]=GalCNAV;
			BRDCtypes[Galileo][1]=GalINAVANY;
			BRDCmodes[Galileo][0]=GalCNAVOnly;
			BRDCmodes[Galileo][1]=GalINAVOnly;
			break;
		case GalINAVvsGNAV:
			BRDCtypes[Galileo][0]=GalINAVANY;
			BRDCtypes[Galileo][1]=GalGNAV;
			BRDCmodes[Galileo][0]=GalINAVOnly;
			BRDCmodes[Galileo][1]=GalGNAVOnly;
			break;
		case GalGNAVvsINAV:
			BRDCtypes[Galileo][0]=GalGNAV;
			BRDCtypes[Galileo][1]=GalINAVANY;
			BRDCmodes[Galileo][0]=GalGNAVOnly;
			BRDCmodes[Galileo][1]=GalINAVOnly;
			break;
		case GalFNAVvsCNAV:
			BRDCtypes[Galileo][0]=GalFNAV;
			BRDCtypes[Galileo][1]=GalCNAV;
			BRDCmodes[Galileo][0]=GalFNAVOnly;
			BRDCmodes[Galileo][1]=GalCNAVOnly;
			break;
		case GalCNAVvsFNAV:
			BRDCtypes[Galileo][0]=GalCNAV;
			BRDCtypes[Galileo][1]=GalFNAV;
			BRDCmodes[Galileo][0]=GalCNAVOnly;
			BRDCmodes[Galileo][1]=GalFNAVOnly;
			break;
		case GalFNAVvsGNAV:
			BRDCtypes[Galileo][0]=GalFNAV;
			BRDCtypes[Galileo][1]=GalGNAV;
			BRDCmodes[Galileo][0]=GalFNAVOnly;
			BRDCmodes[Galileo][1]=GalGNAVOnly;
			break;
		case GalGNAVvsFNAV:
			BRDCtypes[Galileo][0]=GalGNAV;
			BRDCtypes[Galileo][1]=GalFNAV;
			BRDCmodes[Galileo][0]=GalGNAVOnly;
			BRDCmodes[Galileo][1]=GalFNAVOnly;
			break;
		case GalCNAVvsGNAV:
			BRDCtypes[Galileo][0]=GalCNAV;
			BRDCtypes[Galileo][1]=GalGNAV;
			BRDCmodes[Galileo][0]=GalCNAVOnly;
			BRDCmodes[Galileo][1]=GalGNAVOnly;
			break;
		case GalGNAVvsCNAV:
			BRDCtypes[Galileo][0]=GalGNAV;
			BRDCtypes[Galileo][1]=GalCNAV;
			BRDCmodes[Galileo][0]=GalGNAVOnly;
			BRDCmodes[Galileo][1]=GalCNAVOnly;
			break;
		default:
			BRDCtypes[Galileo][0]=BRDCtypes[Galileo][1]=GalANY;
			BRDCmodes[Galileo][0]=BRDCmodes[Galileo][1]=options->BrdcTypeSel[Galileo];
			break;
	}

	switch (options->BrdcTypeSel[GLONASS]) {
		case GLOFDMAvsCDMA:
			BRDCtypes[GLONASS][0]=GLOFDMA;
			BRDCtypes[GLONASS][1]=GLOCDMA;
			BRDCmodes[GLONASS][0]=GLOFDMAOnly;
			BRDCmodes[GLONASS][1]=GLOCDMAOnly;
			break;
		case GLOCDMAvsFDMA:
			BRDCtypes[GLONASS][0]=GLOCDMA;
			BRDCtypes[GLONASS][1]=GLOFDMA;
			BRDCmodes[GLONASS][0]=GLOCDMAOnly;
			BRDCmodes[GLONASS][1]=GLOFDMAOnly;
			break;
		default:
			BRDCtypes[GLONASS][0]=BRDCtypes[GLONASS][1]=GLOANY;
			BRDCmodes[GLONASS][0]=BRDCmodes[GLONASS][1]=options->BrdcTypeSel[GLONASS];
			break;
	}

	switch (options->BrdcTypeSel[BDS]) {
		case BDSD1vsD2:
			BRDCtypes[BDS][0]=BDSD1;
			BRDCtypes[BDS][1]=BDSD2;
			BRDCmodes[BDS][0]=BDSD1Only;
			BRDCmodes[BDS][1]=BDSD2Only;
			break;
		case BDSD2vsD1:
			BRDCtypes[BDS][0]=BDSD2;
			BRDCtypes[BDS][1]=BDSD1;
			BRDCmodes[BDS][0]=BDSD2Only;
			BRDCmodes[BDS][1]=BDSD1Only;
			break;
		case BDSD1vsCNAV1:
			BRDCtypes[BDS][0]=BDSD1;
			BRDCtypes[BDS][1]=BDSCNAV1;
			BRDCmodes[BDS][0]=BDSD1Only;
			BRDCmodes[BDS][1]=BDSCNAV1Only;
			break;
		case BDSCNAV1vsD1:
			BRDCtypes[BDS][0]=BDSCNAV1;
			BRDCtypes[BDS][1]=BDSD1;
			BRDCmodes[BDS][0]=BDSCNAV1Only;
			BRDCmodes[BDS][1]=BDSD1Only;
			break;
		case BDSD1vsCNAV2:
			BRDCtypes[BDS][0]=BDSD1;
			BRDCtypes[BDS][1]=BDSCNAV2;
			BRDCmodes[BDS][0]=BDSD1Only;
			BRDCmodes[BDS][1]=BDSCNAV2Only;
			break;
		case BDSCNAV2vsD1:
			BRDCtypes[BDS][0]=BDSCNAV2;
			BRDCtypes[BDS][1]=BDSD1;
			BRDCmodes[BDS][0]=BDSCNAV2Only;
			BRDCmodes[BDS][1]=BDSD1Only;
			break;
		case BDSD2vsCNAV1:
			BRDCtypes[BDS][0]=BDSD2;
			BRDCtypes[BDS][1]=BDSCNAV1;
			BRDCmodes[BDS][0]=BDSD2Only;
			BRDCmodes[BDS][1]=BDSCNAV1Only;
			break;
		case BDSCNAV1vsD2:
			BRDCtypes[BDS][0]=BDSCNAV1;
			BRDCtypes[BDS][1]=BDSD2;
			BRDCmodes[BDS][0]=BDSCNAV1Only;
			BRDCmodes[BDS][1]=BDSD2Only;
			break;
		case BDSD2vsCNAV2:
			BRDCtypes[BDS][0]=BDSD2;
			BRDCtypes[BDS][1]=BDSCNAV2;
			BRDCmodes[BDS][0]=BDSD2Only;
			BRDCmodes[BDS][1]=BDSCNAV2Only;
			break;
		case BDSCNAV2vsD2:
			BRDCtypes[BDS][0]=BDSCNAV2;
			BRDCtypes[BDS][1]=BDSD2;
			BRDCmodes[BDS][0]=BDSCNAV2Only;
			BRDCmodes[BDS][1]=BDSD2Only;
			break;
		case BDSCNAV1vsCNAV2:
			BRDCtypes[BDS][0]=BDSCNAV1;
			BRDCtypes[BDS][1]=BDSCNAV2;
			BRDCmodes[BDS][0]=BDSCNAV1Only;
			BRDCmodes[BDS][1]=BDSCNAV2Only;
			break;
		case BDSCNAV2vsCNAV1:
			BRDCtypes[BDS][0]=BDSCNAV2;
			BRDCtypes[BDS][1]=BDSCNAV1;
			BRDCmodes[BDS][0]=BDSCNAV2Only;
			BRDCmodes[BDS][1]=BDSCNAV1Only;
			break;
		default:
			BRDCtypes[BDS][0]=BRDCtypes[BDS][1]=BDSANY;
			BRDCmodes[BDS][0]=BRDCmodes[BDS][1]=options->BrdcTypeSel[BDS];
			break;
	}

	switch (options->BrdcTypeSel[QZSS]) {
		case QZSLNAVvsCNAV:
			BRDCtypes[QZSS][0]=QZSLNAV;
			BRDCtypes[QZSS][1]=QZSCNAV;
			BRDCmodes[QZSS][0]=QZSLNAVOnly;
			BRDCmodes[QZSS][1]=QZSCNAVOnly;
			break;
		case QZSCNAVvsLNAV:
			BRDCtypes[QZSS][0]=QZSCNAV;
			BRDCtypes[QZSS][1]=QZSLNAV;
			BRDCmodes[QZSS][0]=QZSCNAVOnly;
			BRDCmodes[QZSS][1]=QZSLNAVOnly;
			break;
		case QZSLNAVvsCNAV2:
			BRDCtypes[QZSS][0]=QZSLNAV;
			BRDCtypes[QZSS][1]=QZSCNAV2;
			BRDCmodes[QZSS][0]=QZSLNAVOnly;
			BRDCmodes[QZSS][1]=QZSCNAV2Only;
			break;
		case QZSCNAV2vsLNAV:
			BRDCtypes[QZSS][0]=QZSCNAV2;
			BRDCtypes[QZSS][1]=QZSLNAV;
			BRDCmodes[QZSS][0]=QZSCNAV2Only;
			BRDCmodes[QZSS][1]=QZSLNAVOnly;
			break;
		case QZSCNAVvsCNAV2:
			BRDCtypes[QZSS][0]=QZSCNAV;
			BRDCtypes[QZSS][1]=QZSCNAV2;
			BRDCmodes[QZSS][0]=QZSCNAVOnly;
			BRDCmodes[QZSS][1]=QZSCNAV2Only;
			break;
		case QZSCNAV2vsCNAV:
			BRDCtypes[QZSS][0]=QZSCNAV2;
			BRDCtypes[QZSS][1]=QZSCNAV;
			BRDCmodes[QZSS][0]=QZSCNAV2Only;
			BRDCmodes[QZSS][1]=QZSCNAVOnly;
			break;
		default:
			BRDCtypes[QZSS][0]=BRDCtypes[QZSS][1]=QZSANY;
			BRDCmodes[QZSS][0]=BRDCmodes[QZSS][1]=options->BrdcTypeSel[QZSS];
			break;
	}

	BRDCtypes[GEO][0]=BRDCtypes[GEO][1]=GEOANY;
	BRDCmodes[GEO][0]=BRDCmodes[GEO][1]=options->BrdcTypeSel[GEO];

	BRDCtypes[IRNSS][0]=BRDCtypes[IRNSS][1]=IRNANY;
	BRDCmodes[IRNSS][0]=BRDCmodes[IRNSS][1]=options->BrdcTypeSel[IRNSS];

	// Put this option to 2 so no print buffers are used
	options->printInBuffer = 2;

	for ( j = 0; j < MAX_GNSS; j++ ) {
		for ( i = 0; i < MAX_SATELLITES_PER_GNSS; i++ ) {
			satInfo[j][i].lastEclipse.SoD = 0;
			satInfo[j][i].lastEclipse.MJDN = 0;
		}
	}
	
	// Initialize stats
	initStat(&statSISRETot);
	initStat(&stat3DTot);
	initStat(&statOrbTot);
	initStat(&statClkTot);
	initStat(&statDCBTot);
	initStat(&statRadOrbTot);
	initStat(&statAloOrbTot);
	initStat(&statCroOrbTot);
	for ( k = 0; k < MAX_GNSS; k++ ) {
		for ( i = 0; i <= listMaxSatGNSS[k]; i++ ) {
			initStat(&statSISRE[k][i]);
			initStat(&stat3D[k][i]);
			initStat(&statOrb[k][i]);
			initStat(&statClk[k][i]);
			initStat(&statDCB[k][i]);
			initStat(&statRadOrb[k][i]);
			initStat(&statAloOrb[k][i]);
			initStat(&statCroOrb[k][i]);
		}
	}
	
	// Use decimate option to choose increase interval
	if ( options->decimate != 0. ) {
		tIncrease = options->decimate;
	}
	
	//Print broadcast order
	for(l=0;l<2;l++) {
		if (products[l]->type == BRDC) {
			//Broadcast products
			for(i=0;i<MAX_GNSS;i++) {
				for(j=1;j<=listMaxSatGNSS[i];j++) {
					if(options->includeSatellite[i][j]==1) break;
				}
				if (j>listMaxSatGNSS[i]) continue;
				for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
					if (availGNSSFreq[i][k]==1 && options->usableFreq[i][j][k]==1) {
						break;
					}
				}
				if (k==MAX_FREQUENCIES_PER_GNSS) continue;
				sprintf(auxstr,"[%s]:",gnsstype2gnssname(i));
				fprintf(options->outFileStream,"INFO MODELLING Broadcast message types for product %d %-*s",l+1,maxLenghtConstName+3,auxstr);
				auxstr[0]='\0';
				len=0;
				for(k=0;k<options->BRDCAvailSelOrder[l][i][BRDCmodes[i][l]][MAX_BRDC_TYPES];k++) {
					len+=sprintf(&auxstr[len]," %s",BRDCType2String((enum GNSSystem)i,options->BRDCAvailSelOrder[l][i][BRDCmodes[i][l]][k]));
				}
				if (auxstr[0]=='\0') {
					fprintf(options->outFileStream," No navigation message available\n");
				} else {
					fprintf(options->outFileStream,"%s\n",auxstr);
				}
			}
		}
	}

	//Compare clock message
	sprintf(messagestr, "MODELLING Comparison of satellite clock correction:    %3s", options->satelliteClockCorrection? "ON" : "OFF");
	printInfo(messagestr, options);
	
	//Eclipse condition message
	sprintf(messagestr, "MODELLING Discard satellites under eclipse condition:    %3s", options->discardEclipsedSatellites? "ON" : "OFF");
	printInfo(messagestr, options);

	if ( products[0]->type == SP3 && products[1]->type == SP3 ) bothSP3 = 1;
	else bothSP3 = 0;

	if ( products[0]->type == BRDC && products[1]->type == BRDC ) bothBRDC = 1;
	else bothBRDC = 0;
	
	if ( bothSP3 && options->satellitePhaseCenter ) {
		printInfo("WARNING both input orbits are SP3, and the satellite phase centre corrections are active. These corrections will only be applied to the second SP3 product", options);
	}

	// Tune start time to start at least in an entire hour if user did not set start time
	if (options->StartEpoch.MJDN==-1) {
		startTime.SoD -= modulo(startTime.SoD, 3600);
	}

	// Check if StartTime MJDN is many days before the EndTime MJDN.
	// This can happen if in the brodcast file some messages are very old.
	// This would make gLAB to do a very very long loop checking for broadcast data for so many days
	if (printProgress==1) {
		if ( ((endTime.MJDN - startTime.MJDN) > 10) && ((retRNXnav[0] * retSP3[0] * retSP3o[0] * retCLK[0] * retRNXnav[1] * retSP3[1] * retSP3o[1] * retCLK[1]) == 1) && options->StartEpoch.MJDN==-1 && options->EndEpoch.MJDN==-1) {
			sprintf(messagestr, "WARNING: StartTime day (%5d) is more than 10 days before of the EndTime day (%5d). Only the last 10 days will be shown", startTime.MJDN, endTime.MJDN);
			printInfo(messagestr, options);
			startTime.MJDN = endTime.MJDN - 10;
		}
		sprintf(auxstr,"%s",t2doystr(&endTimePercentage));
		sprintf(messagestr, "StartTime: %17s    EndTime: %17s    IntervalTime: %8.2f", t2doystr(&startTime), auxstr, tIncrease);
		printInfo(messagestr, options);
	} else if ( (retRNXnav[0] * retSP3[0] * retSP3o[0] * retCLK[0] * retRNXnav[1] * retSP3[1] * retSP3o[1] * retCLK[1]) == 1 && options->StartEpoch.MJDN==-1 && options->EndEpoch.MJDN==-1 ) { // Avoid this information if files are concatennated and user did not set any start or end epoch
		if ( (endTime.MJDN - startTime.MJDN) > 10 ) {
			sprintf(messagestr, "WARNING: StartTime day (%5d) is more than 10 days before of the EndTime day (%5d). Only the last 10 days will be shown", startTime.MJDN, endTime.MJDN);
			printInfo(messagestr, options);
			startTime.MJDN = endTime.MJDN - 10;
		}

		sprintf(auxstr,"%s",t2doystr(&endTime));
		sprintf(messagestr, "StartTime: %17s    EndTime: %17s    IntervalTime: %8.2f", t2doystr(&startTime), auxstr, tIncrease);
		printInfo(messagestr, options);
	} else {
		if (endTimePercentage.MJDN!=-1) {
			sprintf(auxstr,"%s",t2doystr(&endTimePercentage));
			sprintf(messagestr, "StartTime: %17s    EndTime: %17s    IntervalTime: %8.2f", t2doystr(&startTime), auxstr, tIncrease);
		} else {
			sprintf(messagestr, "StartTime: %17s    EndTime: %-17s    IntervalTime: %8.2f", t2doystr(&startTime), "-", tIncrease);
		}
		printInfo(messagestr, options);
	}
	

	currentMJDN=startTime.MJDN;

	if ( (sopt->numOrb == sopt->numSP3) && sopt->numOrb>0) {
		if ( retSP3[0] == 2 && retSP3o[0] == 2 ) {
			DataAvailable[0]=DataAvailable[1]=1;
		} else {
			DataAvailable[0]=DataAvailable[1]=0;
		}
	} else if ( (sopt->numNav == sopt->numSP3) && sopt->numNav>0) {
		if ( retSP3[0] == 2 && retRNXnav[0] == 2 ) {
			DataAvailable[0]=DataAvailable[1]=1;
		} else {
			DataAvailable[0]=DataAvailable[1]=0;
		}
	} else if ( (sopt->numNav == sopt->numOrb) && sopt->numNav>0) {
		if ( retSP3o[0] == 2 && retRNXnav[0] == 2 ) {
			DataAvailable[0]=DataAvailable[1]=1;
		} else {
			DataAvailable[0]=DataAvailable[1]=0;
		}
	} else {
		for(i=0;i<2;i++) {
			if (retRNXnav[i]==2 || retSP3[i] == 2 || retSP3o[i] == 2 ) {
				DataAvailable[i]=1;
			} else {
				DataAvailable[i]=0;
			}
		}
	}

	if (startTimeFromNav>0 && options->StartEpoch.MJDN==-1) {
		//Navigation file typically start at the end of the previous day
		//This is avoid reading the next with the condition 'currentMJDN!=t.MJDN' when we start computing position some epochs previous
		//to the current day, as the navigation data files are still valid
		if(startTime.SoD>=75000.) {
			currentMJDN++;
		}
		if(startTimeFromNav==2) {
			currentMJDN++;
		}
	}

	memcpy(&t, &startTime, sizeof(TTime));
	strcpy(tStr[1],t2doystr(&t));
	while ( end==0 ) {
		if (printProgress) {
			CurrentPercentage=100.*epochsProcessed/numberEpochs;
			if ((CurrentPercentage-PreviousPercentage)>=0.1) { //This is to avoid to many prints when percentages changed less than 0.1
				t2tmnolocal (&t, &tm, &seconds);
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Current epoch: %17s / %4d %02d %02d %02d:%02d:%04.1f (%5.1f%%)        %c",tStr[1],tm.tm_year+1900,tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_min,seconds,CurrentPercentage,options->ProgressEndCharac);
					//In Windows, cursor is not disabled
					fflush_function(options->terminalStream);
				} else {
					//Printing for the GUI. Only print if the integer of the percentage have changed (to avoid message spamming)
					if ((int)CurrentPercentage!=(int)PreviousPercentage) {
						fprintf(options->terminalStream,"Current epoch: %17s / %4d %02d %02d %02d:%02d:%04.1f (%5.1f%%)        %c",tStr[1],tm.tm_year+1900,tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_min,seconds,CurrentPercentage,options->ProgressEndCharac);
						fflush_function(options->terminalStream);
					}
				}
				PreviousPercentage=CurrentPercentage;
			}
		}
		// Check if concatenated files. If so and it is needed, read the next file
		diff=tdiff(&t, &endTime);
		if ( (diff  >= DIFFEQTHRESHOLD || currentMJDN<t.MJDN ) && (DataAvailable[0]==1 && DataAvailable[1]==1)  ) {
			currentMJDN=t.MJDN;
			for ( j = 0; j < 2; j++ ) {
				DataAvailable[j]=0;
				if(j==0) {
					numReadNav=numReadSP3=numReadOrb=1;
				}
				if(sopt->numOrb==2 || sopt->numNav==2 || sopt->numSP3==2) {
					l=j;
				} else {
					l=0;
				}
				if ( retRNXnav[l]==2 && (numReadNav<=sopt->numNav) ) {
					retRNXnav[l] = readRinexNav(fdRNXnav[l], sopt->navFile[l], products[j], &rinexNavVersion[l],NEWDAYNAV,options);
					if (retRNXnav[l] == 2 ) DataAvailable[j]=1;
					if (options->EndEpoch.MJDN==-1) {
						endTime = getProductsLastEpoch(products[j]);
					}
					numReadNav++;
					continue;
				}
				if ( retSP3[l]==2 && (numReadSP3<=sopt->numSP3) ) {
					freeSP3data(pastProducts[j]);
					memcpy(pastProducts[j], products[j], sizeof(TGNSSproducts));
					memcpy(products[j],nextProducts[j], sizeof(TGNSSproducts));
					retSP3[l] = readSP3(fdSP3[l], nextProducts[j], 1, 1, 0, options);
					if (retSP3[l]==2 ) {
						DataAvailable[j]=1;
						if (options->EndEpoch.MJDN==-1) {
							endTime = getProductsLastEpoch(products[j]);
						}
					} else {
						if (options->EndEpoch.MJDN==-1) {
							endTime = getProductsLastEpoch(nextProducts[j]);
						}
					}
					ConcatenateSP3(0,products[j],pastProducts[j],nextProducts[j],options);
					numReadSP3++;
					continue;
				}
				if ( retSP3o[l]==2 && (numReadOrb<=sopt->numOrb)) {
					// Sanity check
					if ( retCLK[l] != 2 ) {
						sprintf(messagestr,"Both SP3 orbit file [%s] and clock file [%s] must have the same length",sopt->orbFile[l],sopt->clkFile[l]);
						printError(messagestr, options);
					}
					freeSP3data(pastProducts[j]);
					memcpy(pastProducts[j], products[j], sizeof(TGNSSproducts));
					memcpy(products[j],nextProducts[j], sizeof(TGNSSproducts));
					retSP3o[l] = readSP3(fdSP3o[l], nextProducts[j], 1, 0, 0, options);
					retCLK[l] = readRinexClocks(fdCLK[l], nextProducts[j],options);
					if (retSP3o[l]==2 && retCLK[l]==2 ) {
						DataAvailable[j]=1;
						if (options->EndEpoch.MJDN==-1) {
							endTime = getProductsLastEpoch(products[j]);
						}
					} else {
						if (options->EndEpoch.MJDN==-1) {
							endTime = getProductsLastEpoch(nextProducts[j]);
						}
					}
					ConcatenateSP3(0,products[j],pastProducts[j],nextProducts[j],options);
					numReadOrb++;
				}
			}
		} else if ( ( diff >= DIFFEQTHRESHOLD || currentMJDN<t.MJDN  ) && sopt->numNav==1 && (retRNXnav[0]==2 && (retSP3[0]!=2 || retSP3o[0]!=2) ) )  {
			//For RINEX navigation vs SP3, the navigation file always goes one day behind to avoid Runge effect on precise orbits.
			//Therefore, when we get to the last day concatenated, the SP3 file will have finished but there will be data to read in
			//the navigation file, for comparing the last day
			DataAvailable[0]=DataAvailable[1]=1;
			continue;
		} else if ( diff >= DIFFEQTHRESHOLD) {
			//Products finished
			end=1;
			continue;
		}

		//Print date in new format
		t2tmnolocal (&t, &tm, &seconds);
		sprintf(tStr[0],"%s %02d:%02d:%05.2f",tStr[1],tm.tm_hour,tm.tm_min,seconds);

		if ( options->discardEclipsedSatellites ) {
			findSun(&t, sunPos);
		}
		for ( k = 0; k < MAX_GNSS; k++ ) {
			//if(k==GLONASS && bothSP3==0 ) continue; //Skip GLONASS for navigation files
			for ( i = 1; i <= listMaxSatGNSS[k]; i++ ) {
				available = 1;
				for ( j = 0; j < 2; j++ ) {
					//Set values for orbit and clk max gaps in options struc
					options->OrbitsMaxDistance=OrbitsMaxDistance[j];
					options->OrbitsToTMaxDistance=OrbitsToTMaxDistance[j];
					options->ClocksMaxDistance=ClocksMaxDistance[j];
					options->ClocksToTMaxDistance=ClocksToTMaxDistance[j];
					// Check if satellite has been deselected
					if ( !options->includeSatellite[k][i] ) {
						available = 0;
						break;
					}
					// Satellite positions and velocities
					options->BrdcTypeSel[k]=BRDCmodes[k][j]; //Set the broadcast selection mode for each type
					ret = getSatellitePVT(products[j], &t, 0.0, k, i, position[j], velocity[j], ITRFvelocity[j], NULL, IOD, BRDCtypes[k][j], &block[j], options);
					if ( !ret ) {
						available = 0;
						break;
					} else {
						// Eclipsed satellite check
						memcpy(sat.position, position[j], 3 * sizeof(double));
						memcpy(sat.velocity, velocity[j], 3 * sizeof(double));
						sat.hasOrbitsAndClocks = 1;
						if ( options->discardEclipsedSatellites ) {
							if ( isEclipsed(&t, &sat, &satInfo[k][i], sunPos, &auxT) ) {
								if ( auxT == 0 ) {
									printSatSel(0, i, 46,"Satellite under eclipse", 0, options);
								} else {
									sprintf(messagestr, "Satellite was under eclipse %4.0f seconds ago", auxT);
									printSatSel(0, i, 47, messagestr, 0, options);
								}
								available = 0;
								break;
							}
						}
					}
					// Satellite clock
					if ( options->satelliteClockCorrection ) {
						ret = getSatellitePVT(products[j], &t, 0.0, k, i, NULL, NULL, NULL, &clockValue[j], IOD, BRDCtypes[k][j], &block[j], options);
						if ( !ret ) {
							available = 0;
							break;
						}
					}
					// Satellite orientation
					getSatelliteOrientation(&t, position[j], orientation[j]);
					// Satellite phase center correction
					if ( products[j]->type == SP3 && options->satellitePhaseCenter ) {
						if ( !bothSP3 || j == 1 ) { // The contrary, will mean both SP3 input files, and first product
							switch(k) {
								case GPS: case QZSS:
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 1, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
										break;
									}
									// Coordinate correction
									satPhase[0] = dr[0];
									satPhase[1] = dr[1];
									satPhase[2] = dr[2];
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 2, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
									break;
									}
									// The satellite phase center correction is computed using the Iono-Free with frequencies 12, so the 
									// computed correction should be the combination of the corrections of the two frequencies. 
									// In practice, the corrections are usually the same, so the combined value makes no difference
									position[j][0] += (satPhase[0]*GPSmf1*GPSmf1-dr[0]*GPSmf2*GPSmf2) / (GPSmf1*GPSmf1 - GPSmf2*GPSmf2);
									position[j][1] += (satPhase[1]*GPSmf1*GPSmf1-dr[1]*GPSmf2*GPSmf2) / (GPSmf1*GPSmf1 - GPSmf2*GPSmf2);
									position[j][2] += (satPhase[2]*GPSmf1*GPSmf1-dr[2]*GPSmf2*GPSmf2) / (GPSmf1*GPSmf1 - GPSmf2*GPSmf2);
									break;
								case Galileo:
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 1, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
										break;
									}
									// Coordinate correction
									satPhase[0] = dr[0];
									satPhase[1] = dr[1];
									satPhase[2] = dr[2];
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 5, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
										break;
									}
									// The satellite phase center correction is computed using the Iono-Free with frequencies 15, so the 
									// computed correction should be the combination of the corrections of the two frequencies. 
									// In practice, the corrections are usually the same, so the combined value makes no difference
									position[j][0] += (satPhase[0]*GALmf1*GALmf1-dr[0]*GALmf5a*GALmf5a) / (GALmf1*GALmf1 - GALmf5a*GALmf5a);
									position[j][1] += (satPhase[1]*GALmf1*GALmf1-dr[1]*GALmf5a*GALmf5a) / (GALmf1*GALmf1 - GALmf5a*GALmf5a);
									position[j][2] += (satPhase[2]*GALmf1*GALmf1-dr[2]*GALmf5a*GALmf5a) / (GALmf1*GALmf1 - GALmf5a*GALmf5a);
									break;
								case BDS:
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 2, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
										break;
									}
									// Coordinate correction
									position[j][0] += dr[0];
									position[j][1] += dr[1];
									position[j][2] += dr[2];
									break;
								case IRNSS:
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 5, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
										break;
									}
									// Coordinate correction
									position[j][0] += dr[0];
									position[j][1] += dr[1];
									position[j][2] += dr[2];
									break;
								default:
									ret = satellitePhaseCenterCorrection3D(&t, k, i, 1, orientation[j], constellation, dr);
									if ( !ret ) {
										available = 0;
										break;
									}
									// Coordinate correction
									position[j][0] += dr[0];
									position[j][1] += dr[1];
									position[j][2] += dr[2];
									break;
							}
						}
					} 
					if (bothBRDC==1) {
						switch (k) {
							case GPS:
								if ( options->GPSp1p2DCBModel == DCBRINEX ) {
									DCB[j]=block[j]->TGD*c0;
								} else {
									DCB[j]=0.;
								}
								break;
							case QZSS:
								if ( options->QZSc1cDCBModel == DCBRINEX ) {
									DCB[j]=block[j]->TGD*c0;
								} else {
									DCB[j]=0.;
								}
								break;
							default:
								DCB[j]=0.;
								break;
						}
					} else {
						DCB[j]=0.;
					}
				}
				if ( available ) {
					for ( j = 0; j < 3; j++ ) posDiff[j] = position[1][j] - position[0][j];
	
					memcpy(posDiffXYZ,posDiff,sizeof(posDiff));
					// Satellite orientation in the ACR system (along, cross, radial)
					getSatelliteOrientationACR(position[1], velocity[1], orientationACR);
					changeBase(orientationACR, posDiff);
	
					// Compute orbit and clock differences
					if ( options->satelliteClockCorrection ) {
						ClkDiff = clockValue[1] - clockValue[0];
						SISREDiff = sqrt((posDiff[2] - ClkDiff) * (posDiff[2] - ClkDiff) + (posDiff[0] * posDiff[0] + posDiff[1] * posDiff[1]) / 49);
					} else {
						ClkDiff = 0;
						SISREDiff = 0;
					}
					OrbDiff = sqrt(posDiff[2] * posDiff[2] + (posDiff[0] * posDiff[0] + posDiff[1] * posDiff[1]) / 49);
					Orb3DDiff = sqrt(posDiff[0] * posDiff[0] + posDiff[1] * posDiff[1] + posDiff[2] * posDiff[2]);

					DCBDiff = DCB[1]-DCB[0];

					
					addStat(&statSISRE[k][i], SISREDiff);
					addStat(&statSISRETot, SISREDiff);
					addStat(&statOrb[k][i], OrbDiff);
					addStat(&statOrbTot, OrbDiff);
					addStat(&stat3D[k][i], Orb3DDiff);
					addStat(&stat3DTot, Orb3DDiff);
					addStat(&statClk[k][i], ClkDiff);
					addStat(&statClkTot, ClkDiff);
					//DCB stats to be added only for GPS and QZSS
					switch(k) {
						case GPS: case QZSS:
							addStat(&statDCB[k][i], DCBDiff);
							addStat(&statDCBTot, DCBDiff);
							break;
						default:
							break;
					}
					addStat(&statRadOrb[k][i], posDiff[2]);
					addStat(&statRadOrbTot, posDiff[2]);
					addStat(&statAloOrb[k][i], posDiff[0]);
					addStat(&statAloOrbTot, posDiff[0]);
					addStat(&statCroOrb[k][i], posDiff[1]);
					addStat(&statCroOrbTot, posDiff[1]);
					
					printSatDiff(tStr, k, i, SISREDiff, OrbDiff, Orb3DDiff, ClkDiff, DCBDiff, posDiff, posDiffXYZ, block, options);
				}
			}
		}
		t = tdadd(&t,tIncrease);
		strcpy(tStr[1],t2doystr(&t));
		epochsProcessed++;
	}

	//Free memory for date printing strings
	free(tStr[0]);
	free(tStr[1]);
	free(tStr);

	// Close opened files
	for(i=0;i<2;i++) {
		if ( fdRNXnav[i] != NULL)	fclose(fdRNXnav[i]);
		if ( fdSP3[i] != NULL )		fclose(fdSP3[i]);
		if ( fdSP3o[i] != NULL )	fclose(fdSP3o[i]);
		if ( fdCLK[i] != NULL )		fclose(fdCLK[i]);
	}
	
	if ( options->printSatStat ) {
		for ( k = 0; k < MAX_GNSS; k++ ) {
			for ( i = 1; i <= listMaxSatGNSS[k]; i++ ) {
				printSatStat(k, i, statSISRE[k][i], statOrb[k][i], stat3D[k][i], statClk[k][i], statDCB[k][i], statRadOrb[k][i], statAloOrb[k][i], statCroOrb[k][i], options);
			}
		}
	}
	
	printSatStatTot(statSISRETot, statOrbTot, stat3DTot, statClkTot, statDCBTot, statRadOrbTot, statAloOrbTot, statCroOrbTot, options);
}

/*****************************************************************************
 * Name        : showProduct
 * Description : Read a product file and show SAT messages 
 * Parameters  :
 * Name                                |Da|Unit|Description
 * TGNSSproducts  *products             I  N/A  Products to be shown
 * TGNSSproducts  *pastProduct          I  N/A  past products to be shown
 * TGNSSproducts  *nextProduct          I  N/A  Next products to be shown
 * FILE  *fdRNXnav                      I  N/A  File descriptor for RINEX navigation
 * int  retRNXnav                       I  N/A  Return of the opened RINEX navigation file
 * double  rinexNavVersion              I  N/A  RINEX navigation version
 * FILE  *fdSP3                         I  N/A  File descriptor for SP3 file (orbits + clocks)
 * int  retSP3                          I  N/A  Return of the opened SP3 file
 * FILE  *fdSP3o                        I  N/A  File descriptor for SP3 file (orbits)
 * int  retSP3o                         I  N/A  Return of the opened SP3 file
 * FILE  *fdCLK                         I  N/A  File descriptor for RINEX clock file
 * int  retCLK                          I  N/A  Return of the opened RINEX clock file
 * TConstellation  *constellation       I  N/A  Constellation information on the products
 * TTime startTime                      I  N/A  Start time of products
 * TTime endTime                        I  N/A  End time of products (may not be end of process if files are concatenated)
 * TTime endTimePercentage              I  N/A  End time of products for showing percentage
 * double numberEpochs                  I  N/A  Number of epochs for comparing orbits 
 * TConstellation  *constellationPrint  I  N/A  TConstellation structure for printing 
 *                                                block and SVN in showPRODUCT mode
 * TOptions  *options                   I  N/A  TOptions structure
 * TSupportOptions  *sopt               I  N/A  TSupportOptions structure
 *****************************************************************************/
void showProduct (TGNSSproducts *products, TGNSSproducts *pastProducts, TGNSSproducts *nextProducts, FILE *fdRNXnav, int retRNXnav, double rinexNavVersion, FILE *fdSP3, int retSP3, FILE *fdSP3o, int retSP3o, FILE *fdCLK, int retCLK, TConstellation *constellation, TTime startTime, TTime endTime, TTime endTimePercentage, double numberEpochs, TConstellation *constellationPrint, TOptions *options, TSupportOptions *sopt) {
	double					tIncrease = 30.;
	TTime					t;
	char					**tStr; //Position 0 will have time in new format (Year DoY SoD HH:MM:SS.zz) and position 1 will have old format (Year DoY SoD)
	int						i,j,k;
	int						currentMJDN;
	int						available;
	int						ret;
	int						DataAvailable;
	int						end=0;
	int						len;
	double					position[3];
	double					positionNEU[3];
	double					velocity[3];
	double					ITRFvelocity[3];
	double					clockValue;
	double					dr[3];
	double					orientation[3][3],userPosOrientation[3][3];
	double					elevation,azimuth;
	double					diff;
	char					auxstr[MAX_INPUT_LINE];
	int						IOD = -1;	// IOD not used here, so the IOD value for BRDC data is -1
	double					epochsProcessed=0.;
	double					CurrentPercentage=0.;
	double					seconds;
	double					PreviousPercentage=-1;
	struct tm				tm;
	int						BRDCblocktypes[MAX_GNSS]={GPSANY,GalANY,GLOANY,GEOANY,BDSANY,QZSANY,IRNANY};
    TBRDCblock     			*block=NULL;

	// Allocate size for print strings
	tStr=NULL;
	tStr=malloc(sizeof(char*)*2);
	tStr[0]=NULL;
	tStr[0]=malloc(sizeof(char)*50);
	tStr[1]=NULL;
	tStr[1]=malloc(sizeof(char)*50);

	//Print broadcast order
	if (products->type == SP3) {
		//No broadcast products for orbits
	} else {
		//Broadcast products
		for(i=0;i<MAX_GNSS;i++) {
			for(j=1;j<=listMaxSatGNSS[i];j++) {
				if(options->includeSatellite[i][j]==1) break;
			}
			if (j>listMaxSatGNSS[i]) continue;
			for(k=0;k<MAX_FREQUENCIES_PER_GNSS;k++) {
				if (availGNSSFreq[i][k]==1 && options->usableFreq[i][j][k]==1) {
					break;
				}
			}
			if (k==MAX_FREQUENCIES_PER_GNSS) continue;
			sprintf(auxstr,"[%s]:",gnsstype2gnssname(i));
			fprintf(options->outFileStream,"INFO MODELLING Broadcast message types %-*s",maxLenghtConstName+3,auxstr);
			auxstr[0]='\0';
			len=0;
			for(k=0;k<options->BRDCAvailSelOrder[0][i][options->BrdcTypeSel[i]][MAX_BRDC_TYPES];k++) {
				len+=sprintf(&auxstr[len]," %s",BRDCType2String((enum GNSSystem)i,options->BRDCAvailSelOrder[0][i][options->BrdcTypeSel[i]][k]));
			}
			if (auxstr[0]=='\0') {
				fprintf(options->outFileStream," No navigation message available\n");
			} else {
				fprintf(options->outFileStream,"%s\n",auxstr);
			}
		}
	}

	// Clock message
	sprintf(messagestr, "MODELLING Clock correction computation:    %3s", options->satelliteClockCorrection? "ON" : "OFF");
	printInfo(messagestr, options);

	// Get start and end times
	sprintf(messagestr, "OUTPUT Satellite Velocity:     %s", options->satVel == svINERTIAL? "Inertial" : "ITRF");
	printInfo(messagestr, options);
	
	// Use decimate option to choose increase interval
	if ( options->decimate != 0. ) {
		tIncrease = options->decimate;
	}
	
	// Tune start time to start at least in an entire hour if user did not set any start time
	if (options->StartEpoch.MJDN==-1) {
		startTime.SoD -= modulo(startTime.SoD, 3600);
	}

	// Check if StartTime MJDN is many days before the EndTime MJDN.
	// This can happen if in the brodcast file some messages are very old.
	// This would make gLAB to do a very very long loop checking for broadcast data for so many days
	if (printProgress==1) {
		if ( ((endTime.MJDN - startTime.MJDN) > 10) && ((retRNXnav * retSP3 * retSP3o * retCLK) == 1) && options->StartEpoch.MJDN==-1 && options->EndEpoch.MJDN==-1 ) {
			sprintf(messagestr, "WARNING: StartTime day (%5d) is more than 10 days before of the EndTime day (%5d). Only the last 10 days will be shown", startTime.MJDN, endTime.MJDN);
			printInfo(messagestr, options);
			startTime.MJDN = endTime.MJDN - 10;
		}
		sprintf(auxstr,"%s",t2doystr(&endTimePercentage));
		sprintf(messagestr, "StartTime: %17s    EndTime: %17s    IntervalTime: %8.2f", t2doystr(&startTime), auxstr, tIncrease);
		printInfo(messagestr, options);
	} else if ( ( (retRNXnav * retSP3 * retSP3o * retCLK) == 1 ) && options->StartEpoch.MJDN==-1 && options->EndEpoch.MJDN==-1 ) { // Avoid this information if files are concatenated or if user sets a end or start date
		if ( (endTime.MJDN - startTime.MJDN) > 10 ) {
			sprintf(messagestr, "WARNING: StartTime day (%5d) is more than 10 days before of the EndTime day (%5d). Only the last 10 days will be shown", startTime.MJDN, endTime.MJDN);
			printInfo(messagestr, options);
			startTime.MJDN = endTime.MJDN - 10;
		}
		
		sprintf(auxstr,"%s",t2doystr(&endTime));
		sprintf(messagestr, "StartTime: %17s    EndTime: %17s    IntervalTime: %8.2f", t2doystr(&startTime), auxstr, tIncrease);
		printInfo(messagestr, options);
	} else {
		if (endTimePercentage.MJDN!=-1) {
			sprintf(auxstr,"%s",t2doystr(&endTimePercentage));
			sprintf(messagestr, "StartTime: %17s    EndTime: %17s    IntervalTime: %8.2f", t2doystr(&startTime), auxstr, tIncrease);
		} else {
			sprintf(messagestr, "StartTime: %17s    EndTime: %-17s    IntervalTime: %8.2f", t2doystr(&startTime), "-", tIncrease);
		}
		printInfo(messagestr, options);
	}

	if (retRNXnav==2 || retSP3 == 2 || retSP3o == 2 ) {
		DataAvailable=1;
	} else {
		DataAvailable=0;
	}

	if ( options->receiverPositionSource == rpSET ) {
		//Convert user position to NEU
		XYZ2NEU(options->aprioriReceiverPosition,options->aprioriReceiverPositionGeod);
		//Get user position orientation
		getGroundStationOrientation(options->aprioriReceiverPositionGeod,userPosOrientation);
	}

	memcpy(&t, &startTime, sizeof(TTime));
	strcpy(tStr[1],t2doystr(&t));
	currentMJDN=startTime.MJDN;
	if(sopt->numNav==1 && options->StartEpoch.MJDN==-1) {
		//Navigation file typically start at the end of the previous day
		//This is avoid reading the next with the condition 'currentMJDN!=t.MJDN' when we start computing position some epochs previous
		//to the current day, as the navigation data files are still valid
		if(startTime.SoD>=75000.) {
			currentMJDN++;
		}
	}
	while(end==0) {
		if (printProgress) {
			CurrentPercentage=100.*epochsProcessed/numberEpochs;
			if ((CurrentPercentage-PreviousPercentage)>=0.1) { //This is to avoid to many prints when percentages changed less than 0.1
				t2tmnolocal (&t, &tm, &seconds);
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Current epoch: %17s / %4d %02d %02d %02d:%02d:%04.1f (%5.1f%%)        %c",tStr[1],tm.tm_year+1900,tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_min,seconds,CurrentPercentage,options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				} else {
					//Printing for the GUI. Only print if the integer of the percentage have changed (to avoid message spamming)
					if ((int)CurrentPercentage!=(int)PreviousPercentage) {
						fprintf(options->terminalStream,"Current epoch: %17s / %4d %02d %02d %02d:%02d:%04.1f (%5.1f%%)        %c",tStr[1],tm.tm_year+1900,tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_min,seconds,CurrentPercentage,options->ProgressEndCharac);
						fflush_function(options->terminalStream);
					}
				}
				PreviousPercentage=CurrentPercentage;
			}
		}
		diff=tdiff(&t, &endTime);
		if ( (diff >= DIFFEQTHRESHOLD || currentMJDN<t.MJDN ) && DataAvailable==1 ) {
			// Check if concatennated files. If so and it is needed, read the next file
			DataAvailable=0;
			currentMJDN=t.MJDN;
			if ( retRNXnav == 2 ) {
				retRNXnav = readRinexNav(fdRNXnav, sopt->navFile[0], products, &rinexNavVersion,NEWDAYNAV,options);
				if (retRNXnav == 2 ) DataAvailable=1;
				if (options->EndEpoch.MJDN==-1) {
					endTime = getProductsLastEpoch(products);
				}
				//Check if one or more GLONASS satellites are selected
				for(i=1;i<=MAX_SAT_GLO;i++) {
					if (options->includeSatellite[GLONASS][i]) break;
				}
			}
			if ( retSP3 == 2 ) {
				options->concatenSP3 = 1;
				options->numPreciseFiles = 1;
				freeSP3data(pastProducts);
				memcpy(pastProducts, products, sizeof(TGNSSproducts));
				memcpy(products,nextProducts, sizeof(TGNSSproducts));
				retSP3 = readSP3(fdSP3, nextProducts, 1, 1, 0, options);
				if (retSP3 == 2 ) {
					DataAvailable=1;
					if (options->EndEpoch.MJDN==-1) {
						endTime = getProductsLastEpoch(products);
					}
				} else {
					if (options->EndEpoch.MJDN==-1) {
						endTime = getProductsLastEpoch(nextProducts);
					}
				}
				ConcatenateSP3(0,products,pastProducts,nextProducts,options);	
			}
			if ( retSP3o == 2 ) {
				// Sanity check
				if ( retCLK != 2 ) {
					sprintf(messagestr,"Both SP3 orbit file [%s] and clock file [%s] must have the same length",sopt->orbFile[0],sopt->clkFile[0]);
					printError(messagestr, options);
				}
				options->concatenSP3 = 1;
				options->numPreciseFiles = 2;
				freeSP3data(pastProducts);
				memcpy(pastProducts, products, sizeof(TGNSSproducts));
				memcpy(products,nextProducts, sizeof(TGNSSproducts));
				retSP3o = readSP3(fdSP3o, nextProducts, 1, 0, 0, options);
				retCLK = readRinexClocks(fdCLK, nextProducts,options);
				if (retSP3o == 2 && retCLK==2 ) {
					DataAvailable=1;
					if (options->EndEpoch.MJDN==-1) {
						endTime = getProductsLastEpoch(products);
					}
				} else if ( (retSP3o==2 && retCLK!=2) || (retSP3o!= 2 && retCLK==2) ) {
					printError("Both SP3 orbit and clock products files must have the same length", options);
				} else {
					if (options->EndEpoch.MJDN==-1) {
						endTime = getProductsLastEpoch(nextProducts);
					}
				}
				ConcatenateSP3(0,products,pastProducts,nextProducts,options);	
			}
		} else if ( diff >= DIFFEQTHRESHOLD ) {
			//Products finished
			end=1;
			continue;
		}
		
		//Print date in new format
		t2tmnolocal (&t, &tm, &seconds);
		sprintf(tStr[0],"%s %02d:%02d:%05.2f",tStr[1],tm.tm_hour,tm.tm_min,seconds);

		for ( k = 0; k < MAX_GNSS; k++ ) {
			for ( i = 1; i <= listMaxSatGNSS[k]; i++ ) {
				available = 1;
				// Check if satellite has been deselected
				if ( !options->includeSatellite[k][i] ) continue;
				// Satellite positions and velocities
				ret = getSatellitePVT(products, &t, 0.0, k, i, position, velocity, ITRFvelocity, NULL, IOD, BRDCblocktypes[k], &block, options);
				if (!ret) available = 0;
				// Satellite clock
				if ( options->satelliteClockCorrection ) {
					ret = getSatellitePVT(products, &t, 0.0, k, i, NULL, NULL, NULL, &clockValue, IOD, BRDCblocktypes[k], &block, options);
				} else {
					clockValue=0;
				}
				// Satellite phase center correction
				if ( products->type == SP3 && options->satellitePhaseCenter ) {
					// Satellite orientation
					getSatelliteOrientation(&t, position, orientation);
					ret = satellitePhaseCenterCorrection3D(&t, k, i, 1, orientation, constellation, dr);
					if ( !ret ) available = 0;
					// Coordinate correction
					position[0] += dr[0];
					position[1] += dr[1];
					position[2] += dr[2];
				}
				XYZ2NEU(position,positionNEU);	
				if ( options->receiverPositionSource == rpSET ) {
					getAzimuthElevation(userPosOrientation, options->aprioriReceiverPosition, position, &azimuth, &elevation);
				} else {
					elevation=0.;
					azimuth=0.;
				}				
				if ( available ) {
					if ( options->satVel == svINERTIAL ) {
						printSatPvt(&t, tStr, k, i, position, velocity, positionNEU, clockValue, elevation, azimuth, block, constellationPrint, options);
					} else {
						printSatPvt(&t, tStr, k, i, position, ITRFvelocity, positionNEU, clockValue, elevation, azimuth, block, constellationPrint, options);
					}
				}
			}
		}
		t = tdadd(&t, tIncrease);
		strcpy(tStr[1],t2doystr(&t));
		epochsProcessed++;
	}

	//Free memory for date printing strings
	free(tStr[0]);
	free(tStr[1]);
	free(tStr);

	//Close output files
	if ( fdRNXnav != NULL)	fclose(fdRNXnav);
	if ( fdSP3 != NULL )	fclose(fdSP3);
	if ( fdSP3o != NULL )	fclose(fdSP3o);
	if ( fdCLK != NULL )	fclose(fdCLK);
}

/*****************************************************************************
 * Name        : productsProcessing
 * Description : Do the two different kind of processes, depending on TOptions:
 *                 + Performing an orbit comparison between two different products
 *                 + Parse a single product file
 * Parameters  :
 * Name                                |Da|Unit|Description
 * TSupportOptions  *sopt               I  N/A  TSupportOptions structure
 * TOptions  *options                   I  N/A  TOptions structure
 * TConstellation  *constellation       I  N/A  TConstellation structure
 * TConstellation  *constellationPrint  I  N/A  TConstellation structure for printing 
 *                                                block and SVN in showPRODUCT mode
 *****************************************************************************/
void productsProcessing (TOptions *options, TSupportOptions *sopt, TConstellation *constellation, TConstellation  *constellationPrint) {
	int				sources;
	int				i,j,k,l,m;
	int				retRNXnav[2];
	int				retSP3[2];
	int				retSP3o[2];
	int				retCLK[2];
	int				numConcatSP3[2];
	int				numConcatSP3o[2];
	int				numConcatCLK[2];
	int				startTimeFromNav=0;
	int				ret;
	double			rinexNavVersion[2];
	double			OrbitsMaxDistance[2];
	double			OrbitsToTMaxDistance[2];
	double			ClocksMaxDistance[2];
	double			ClocksToTMaxDistance[2];
	double			tIncrease = 30.;
	double			numberEpochs;
	FILE			*fdRNXnav[2];
	FILE			*fdSP3[2];
	FILE			*fdSP3o[2];
	FILE			*fdCLK[2];
	TGNSSproducts	*products[2];
	TGNSSproducts	*pastProducts[2];
	TGNSSproducts	*nextProducts[2];
	TTime			startTime;
	TTime			startTimeRound;
	TTime			endTime;
	TTime			endTimeFile1,endTimeFile2;
	TTime			endTimePercentage;

	//Init file descriptor variables
	for(i=0;i<2;i++) {
		fdRNXnav[i]=NULL;
		fdSP3[i]=NULL;
		fdSP3o[i]=NULL;
		fdCLK[i]=NULL;
		retRNXnav[i]=1;
		retSP3[i]=1;
		retSP3o[i]=1;
		retCLK[i]=1;
		numConcatSP3o[i]=0;
		numConcatCLK[i]=0;
		rinexNavVersion[i]=0.;
		products[i]     = malloc(sizeof(TGNSSproducts));
		pastProducts[i] = malloc(sizeof(TGNSSproducts));
		nextProducts[i] = malloc(sizeof(TGNSSproducts));
		initGNSSproducts(products[i]);
		initGNSSproducts(pastProducts[i]);
		initGNSSproducts(nextProducts[i]);
		products[i]->BRDC = malloc(sizeof(TBRDCproducts));
		initBRDCproducts(products[i]->BRDC,options->GLOintStep);
	}

	// Body: open the files and call the required function
	sources = 0;
	for ( i = 0; i < sopt->numNav; i++ ) {
		// Open and read the RINEX navigation file
		if ( whatFileTypeIs( sopt->navFile[i]) != ftRINEXbroadcast ) retRNXnav[i] = 0;
		fdRNXnav[i] = fopen(sopt->navFile[i], "rb");
		if ( fdRNXnav[i] != NULL) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading navigation file #%d%50s%c",i+1,"",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			retRNXnav[i] = readRinexNav(fdRNXnav[i], sopt->navFile[i], products[sources], &rinexNavVersion[i], NEWDAYNAV,options);
		}
		else retRNXnav[i] = -1;

		// Check errors
		if ( retRNXnav[i] < 1 ) {
			if ( (int)rinexNavVersion[i] > 3 && rinexNavVersion[i] != 0 ) {
				sprintf(messagestr, "RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3", rinexNavVersion[i],sopt->navFile[i]);
				printError(messagestr, options);
			} else {
				sprintf(messagestr, "Reading RINEX navigation message file [%s]", sopt->navFile[i]);
				printError(messagestr, options);
			}
		}
		products[sources]->BRDC->NavDataPosition=ORBNAVPOS;
		sources++;
	}
	for ( i = 0; i < sopt->numSP3; i++ ) {
		// Open and read the SP3 file
		if ( whatFileTypeIs(sopt->SP3File[i]) != ftSP3 ) retSP3[i] = 0;
		fdSP3[i] = fopen(sopt->SP3File[i], "rb");
		if (fdSP3[i] != NULL) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading SP3 file #%d for orbits and clocks%50s%c",i+1,"",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
		   	retSP3[i] = readSP3(fdSP3[i], pastProducts[sources], 1, 1, 0, options);
		}
		else retSP3[i] = -1;

		// Check errors
		if ( retSP3[i] < 1 ) {
			sprintf(messagestr, "Reading SP3 orbit and clock products file [%s]", sopt->SP3File[i]);
			printError(messagestr, options);
		} else if (retSP3[i]==2) {
			//File concatenaded. read next day
			retSP3[i] = readSP3(fdSP3[i], products[sources], 1, 1, 0, options);
			if (retSP3[i]==2) {
				//Read third day
				retSP3[i] = readSP3(fdSP3[i], nextProducts[sources], 1, 1, 0, options);
				numConcatSP3[i]=3;
			} else {
				numConcatSP3[i]=2;
				nextProducts[sources]->SP3=products[sources]->SP3;
				nextProducts[sources]->type=SP3;
			}
		} else {
			//Not concatenated file
			numConcatSP3[i]=1;
			products[sources]->SP3=pastProducts[sources]->SP3;
			nextProducts[sources]->SP3=pastProducts[sources]->SP3;
			products[sources]->type=SP3;
			nextProducts[sources]->type=SP3;
		}

		sources++;
	}
	for (i=0;i<sopt->numOrb;i++) {
		// Open and read the SP3 file
		if ( whatFileTypeIs(sopt->orbFile[i]) != ftSP3 ) retSP3o[i] = 0;
		fdSP3o[i] = fopen(sopt->orbFile[i], "rb");
		if (fdSP3o[i] != NULL) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading SP3 file #%d for orbits%50s%c",i+1,"",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			retSP3o[i] = readSP3(fdSP3o[i], pastProducts[sources], 1, 0, 0, options);
		}
		else retSP3o[i] = -1;

		// Check errors
		if ( retSP3o[i] < 1 ) {
			sprintf(messagestr, "Reading SP3 orbit product file [%s]", sopt->orbFile[i]);
			printError(messagestr, options);
		} else if (retSP3o[i]==2) {
			//File concatenaded. read next day
			retSP3o[i] = readSP3(fdSP3o[i], products[sources], 1, 0, 0, options);
			if (retSP3o[i]==2) {
				//Read third day
				retSP3o[i] = readSP3(fdSP3o[i], nextProducts[sources], 1, 0, 0, options);
				numConcatSP3o[i]=3;
			} else {
				numConcatSP3o[i]=2;
				//Copy pointer, as products are the same
				nextProducts[sources]->SP3=products[sources]->SP3;
				nextProducts[sources]->type=SP3;
			}
		} else {
			//Not concatenated file
			numConcatSP3o[i]=1;
			//Copy pointer, as products are the same
			products[sources]->SP3=pastProducts[sources]->SP3;
			nextProducts[sources]->SP3=pastProducts[sources]->SP3;
			products[sources]->type=SP3;
			nextProducts[sources]->type=SP3;
		}

		// Clock
		if ( whatFileTypeIs(sopt->clkFile[i]) != ftRINEXclocks ) retCLK[i] = 0;
		if ( (fdCLK[i] = fopen(sopt->clkFile[i], "r")) ) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading precise clocks file #%d%50s%c",i+1,"",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			retCLK[i] = readRinexClocks(fdCLK[i], pastProducts[sources],options);
		}
		else retCLK[i] = -1;

		// Check errors
		if ( retCLK[i] < 1 ) {
			sprintf(messagestr, "Reading clock products file [%s]", sopt->clkFile[i]);
			printError(messagestr, options);
		} else if (retCLK[i]==2) {
			//File concatenaded. read next day
			retCLK[i] = readRinexClocks(fdCLK[i], products[sources],options);
			if (retCLK[i]==2) {
				//Read third day
				retCLK[i] = readRinexClocks(fdCLK[i], nextProducts[sources],options);
				numConcatCLK[i]=3;
			} else {
				numConcatCLK[i]=2;
				//No need to copy data as when reading orbits, the pointers have been copied if SP3 was not concatenated
				//If SP3 and CLK have not the same concatenation length, an error will occur, so integrity of data is assured
			}
		} else {
			//Not concatenated file
			numConcatCLK[i]=1;
			//No need to copy data as when reading orbits, the pointers have been copied if SP3 was not concatenated
			//If SP3 and CLK have not the same concatenation length, an error will occur, so integrity of data is assured
		}

		//Check if both SP3 and CLK are concatenated with the same length
		if ( numConcatCLK[i] != numConcatSP3o[i] ) {
			sprintf(messagestr,"Clock file [%s] has not the same concatenation length as the SP3 file [%s]. Both files must be concatenated with the same length",sopt->clkFile[i],sopt->orbFile[i]);
			printError(messagestr,options);
		}
		sources++;
	}

	//Compare concatenation for both sources
	if ( (sopt->numOrb == sopt->numSP3) && sopt->numOrb>0) {
		//We have an SP3 and a SP3+CLK
		if (numConcatSP3[0]==1 && numConcatSP3o[0]>1 ) {
			//Orbits file is concatenated but SP3 file is not
			sprintf(messagestr,"WARNING: SP3 file for orbit product [%s] is concatenated, but SP3 file for orbit and clock products [%s] is not. Time range will be defined by the latter products file",sopt->orbFile[0],sopt->SP3File[0]);
			printInfo(messagestr,options);
			// Get start and end times from the non concatened SP3 file
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if (numConcatSP3[0]>1 && numConcatSP3o[0]==1) {
			//SP3 is concatenated but orb file not
			sprintf(messagestr,"WARNING: SP3 file for orbit and clock products [%s] is concatenated, but SP3 file for orbit product [%s] is not. Time range will be defined by the latter products file",sopt->SP3File[0],sopt->orbFile[0]);
			printInfo(messagestr,options);
			// Get start and end times from the non concatened SP3 file
			startTime = getProductsFirstEpoch(products[1]);
			endTime = getProductsLastEpoch(products[1]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if ( numConcatSP3[0]!=numConcatSP3o[0]) {
			sprintf(messagestr,"SP3 file for orbit and clock products [%s] has a different concatenation length than SP3 file for orbit product [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->SP3File[0],sopt->orbFile[0]);
			printError(messagestr,options);

		} else {
			//Both files are concatenated (or not) with the same length
			if(retSP3[0]==2 && retSP3o[0]==2) {
				// Get start and end times from the first file
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(products[0]);
				//Get file endTime from first SP3 file
				ret=readSP3LastEpoch(fdSP3[0],&endTimePercentage);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				}
			} else {
				// Get start and end times from the first file
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(nextProducts[0]);
				memcpy(&endTimePercentage,&endTime,sizeof(TTime));
			}
		}

		ConcatenateSP3(0,products[0],pastProducts[0],nextProducts[0],options);	
		ConcatenateSP3(0,products[1],pastProducts[1],nextProducts[1],options);	

	} else if (sopt->numSP3==2) {
		//We have two SP3 for orbits and products
		if (numConcatSP3[0]==1 && numConcatSP3[1]>1 ) {
			//Second SP3 is concatenated but first SP3 file is not
			sprintf(messagestr,"WARNING: SP3 file for orbit and clock products [%s] is concatenated, but SP3 file for orbit and clock products [%s] is not. Time range will be defined by the latter products file",sopt->SP3File[1],sopt->SP3File[0]);
			printInfo(messagestr,options);
			// Get start and end times from the non concatened SP3 file
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if (numConcatSP3[0]>1 && numConcatSP3[1]==1) {
			//First SP3 is concatenated but second SP3 file is not
			sprintf(messagestr,"WARNING: SP3 file for orbit and clock products [%s] is concatenated, but SP3 file for orbit and clock products [%s] is not. Time range will be defined by the latter products file",sopt->SP3File[0],sopt->SP3File[1]);
			printInfo(messagestr,options);
			// Get start and end times from the non concatened SP3 file
			startTime = getProductsFirstEpoch(products[1]);
			endTime = getProductsLastEpoch(products[1]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if ( numConcatSP3[0]!=numConcatSP3[1]) {
			sprintf(messagestr,"SP3 file for orbit and clock products [%s] has a different concatenation length than SP3 file for orbit and clock products [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->SP3File[0],sopt->SP3File[1]);
			printError(messagestr,options);
		} else {
			//Both files are concatenated with the same length
			if(retSP3[0]==2 && retSP3[1]==2) {
				// Get start and end times from the first file
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(products[0]);
				ret=readSP3LastEpoch(fdSP3[0],&endTimePercentage);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				}
			} else {
				// Get start and end times from the first file
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(nextProducts[0]);
				memcpy(&endTimePercentage,&endTime,sizeof(TTime));
			}
		}

		ConcatenateSP3(0,products[0],pastProducts[0],nextProducts[0],options);	
		ConcatenateSP3(0,products[1],pastProducts[1],nextProducts[1],options);	

	} else if (sopt->numOrb==2) {
		//We have two SP3 for orbits and two CLK for clocks
		if (numConcatSP3o[0]==1 && numConcatSP3o[1]>1 ) {
			//Second SP3 is concatenated but first SP3 file is not
			sprintf(messagestr,"WARNING: SP3 file for orbit product [%s] is concatenated, but SP3 file for orbit product [%s] is not. Time range will be defined by the latter product file",sopt->orbFile[1],sopt->orbFile[0]);
			printInfo(messagestr,options);
			// Get start and end times from the non concatened SP3 file
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if (numConcatSP3o[0]>1 && numConcatSP3o[1]==1) {
			//First SP3 is concatenated but second SP3 file is not
			sprintf(messagestr,"WARNING: SP3 file for orbit product [%s] is concatenated, but SP3 file for orbit product [%s] is not. Time range will be defined by the latter product file",sopt->orbFile[0],sopt->orbFile[1]);
			printInfo(messagestr,options);
			// Get start and end times from the non concatened SP3 file
			startTime = getProductsFirstEpoch(products[1]);
			endTime = getProductsLastEpoch(products[1]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if ( numConcatSP3o[0]!=numConcatSP3o[1]) {
			sprintf(messagestr,"SP3 file for orbit product [%s] has a different concatenation length than SP3 file for orbit product [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->orbFile[0],sopt->orbFile[1]);
			printError(messagestr,options);
		} else {
			//Both files are concatenated or not with the same length
			if(retSP3o[0]==2 && retSP3o[1]==2) {
				// Get start and end times from the first file
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(products[0]);
				ret=readSP3LastEpoch(fdSP3o[0],&endTimePercentage);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				}
			} else {
				// Get start and end times from the first file
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(nextProducts[0]);
				memcpy(&endTimePercentage,&endTime,sizeof(TTime));
			}
		}

		ConcatenateSP3(0,products[0],pastProducts[0],nextProducts[0],options);	
		ConcatenateSP3(0,products[1],pastProducts[1],nextProducts[1],options);	

	} else if (sopt->numNav==1 && (sopt->numOrb>0 || sopt->numSP3>0) ) {
		//We have a navigation file and a SP3 file
		if(retRNXnav[0]!=2 && ( (numConcatSP3[0]>1 && sopt->numSP3>0) || (numConcatSP3o[0]>1 && sopt->numOrb>0) ) ) {
			//Navigation file is not concatenated and SP3 are concatenated
			if(sopt->numSP3>0) {
				sprintf(messagestr,"WARNING: SP3 file for orbit and clock products [%s] is concatenated, but navigation file [%s] is not. Time range will be defined by the latter product file",sopt->SP3File[0],sopt->navFile[0]);
			} else {
				sprintf(messagestr,"WARNING: SP3 file for orbit product [%s] is concatenated, but navigation file [%s] is not. Time range will be defined by the latter product file",sopt->orbFile[0],sopt->navFile[0]);
			}
			printInfo(messagestr,options);
			// Get start and end times from navigation file
			startTimeFromNav=1;
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if (retRNXnav[0]==2 && ( (numConcatSP3[0]==1 && sopt->numSP3>0) || (numConcatSP3o[0]==1 && sopt->numOrb>0) ) ) {
			//Navigation file concatenated but not SP3 file
			//Read the next or two next days available for the navigation file
			retRNXnav[0] = readRinexNav(fdRNXnav[0], sopt->navFile[0], products[0], &rinexNavVersion[0], NEWDAYNAV,options);
			if(retRNXnav[0]==2) {
				//The third day is added to the data of the second day
				retRNXnav[0] = readRinexNav(fdRNXnav[0], sopt->navFile[0], products[0], &rinexNavVersion[0], SAMEDAYNAV,options);
			}
			if(sopt->numSP3>0) {
				sprintf(messagestr,"WARNING: Navigation file [%s] is concatenated, but SP3 for orbit and clock products file [%s] is not. Time range will be defined by the latter product file",sopt->navFile[0],sopt->SP3File[0]);
			} else {
				sprintf(messagestr,"WARNING: Navigation file [%s] is concatenated, but SP3 for orbit product file [%s] is not. Time range will be defined by the latter product file",sopt->navFile[0],sopt->orbFile[0]);
			}
			printInfo(messagestr,options);
			// Get start and end times from non concatenated SP3 file
			startTime = getProductsFirstEpoch(products[1]);
			endTime = getProductsLastEpoch(nextProducts[1]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));

		} else if (retRNXnav[0]==2 && ( (numConcatSP3[0]>1 && sopt->numSP3>0) || (numConcatSP3o[0]>1 && sopt->numOrb>0) ) ) {
			//Navigation file is concatenated and SP3 are concatenated
			//Get start time from navigation file before reading the next day (if done later, the start time would be from the second day, not the first day read)
			startTime = getProductsFirstEpoch(products[0]);
			retRNXnav[0] = readRinexNav(fdRNXnav[0], sopt->navFile[0], products[0], &rinexNavVersion[0], NEWDAYNAV,options);
			if (retRNXnav[0]==2 && ( (numConcatSP3[0]<3 && sopt->numSP3>0) || (numConcatSP3o[0]<3 && sopt->numOrb>0) ) ) {
				//Three days for navigation files but only two days for SP3 files
				if(sopt->numSP3>0) {
					sprintf(messagestr,"SP3 file for orbit and clocks products [%s] has a different concatenation length than navigation file [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->SP3File[0],sopt->navFile[0]);
				} else {
					sprintf(messagestr,"SP3 file for orbit product [%s] has a different concatenation length than navigation file [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->orbFile[0],sopt->navFile[0]);
				}
				printError(messagestr,options);

			} else if (retRNXnav[0]!=2 && ( (numConcatSP3[0]==3 && sopt->numSP3>0) || (numConcatSP3o[0]==3 && sopt->numOrb>0)) ) {
				//Only two days for navigation files but three days for SP3 files
				if(sopt->numSP3>0) {
					sprintf(messagestr,"SP3 file for orbit and clocks products [%s] has a different concatenation length than navigation file [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->SP3File[0],sopt->navFile[0]);
				} else {
					sprintf(messagestr,"SP3 file for orbit product [%s] has a different concatenation length than navigation file [%s]. Both files must have the same concatenation length, or, for a single day, one file can be concantenated and the other one cannot",sopt->orbFile[0],sopt->navFile[0]);
				}
				printError(messagestr,options);

			} else {
				//Concatenation length matches for both files
				//We will not read the third day (if it is available) on the navigation file, so
				// the following days when navigation data ends, but the SP3 file will still have date from the following day
				//Get end time from navigation file
				endTime = getProductsLastEpoch(products[0]);
				startTimeFromNav=2;
				//Get last epoch of file from SP3 file (which can orbit+clock or only orbit)
				if (sopt->numSP3>0 && retSP3[0]==2) {
					//SP3 orbit+clock concatenated
					ret=readSP3LastEpoch(fdSP3[0],&endTimePercentage);
					if (ret==0) {
						printProgress=0;
						endTimePercentage.MJDN=-1;
					}
				} else if (sopt->numOrb>0 && retSP3o[0]==2) {
					//SP3 orbit concatenated
					ret=readSP3LastEpoch(fdSP3o[0],&endTimePercentage);
					if (ret==0) {
						printProgress=0;
						endTimePercentage.MJDN=-1;
					}
				} else {
					//SP3 of any time not concatenated more than 3 days
					endTimePercentage=getProductsLastEpoch(nextProducts[1]);
				}
			}
		} else {
			//Navigation and SP3 files are not concatenated
			//Get start and end times from SP3 file
			startTime = getProductsFirstEpoch(products[1]);
			endTime = getProductsLastEpoch(nextProducts[1]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));
		}

		ConcatenateSP3(0,products[1],pastProducts[1],nextProducts[1],options);	

	} else if (sopt->numNav==2) {
		//Two navigation files
		if (retRNXnav[0]==2 && retRNXnav[1]!=2) {
			//First navigation file is concatenated but not the second
			sprintf(messagestr,"Navigation file [%s] is concatenated, but navigation file [%s] is not. Both navigation files must have the same concatenation length",sopt->navFile[0],sopt->navFile[1]);
			printError(messagestr,options);
		} else if (retRNXnav[0]!=2 && retRNXnav[1]==2) {
			//Second navigation file is concatenated but not the first
			sprintf(messagestr,"Navigation file [%s] is concatenated, but navigation file [%s] is not. Both navigation files must have the same concatenation length",sopt->navFile[1],sopt->navFile[0]);
			printError(messagestr,options);
		} else if (retRNXnav[0]==2 && retRNXnav[1]==2) {
			//Both files have the same concatenated length
			//Get start and end times from the first navigation file
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			//Search for last epoch in RINEX navigation files
			ret=readRinexNavLastEpoch(fdRNXnav[0],&endTimeFile1,sopt->navFile[0],options);
			if (ret==0) {
				printProgress=0;
				endTimePercentage.MJDN=-1;
			} else {
				ret=readRinexNavLastEpoch(fdRNXnav[1],&endTimeFile2,sopt->navFile[1],options);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				} else {
					if (tdiff(&endTimeFile1,&endTimeFile2)<0.) {
						//endTimeFile1 is before endTimeFile2. Last epoch will be endTimeFile1
						memcpy(&endTimePercentage,&endTimeFile1,sizeof(TTime));
					} else {
						memcpy(&endTimePercentage,&endTimeFile2,sizeof(TTime));
					}
				}
			}
		} else {
			//Both files are not concatenated
			//Get start and end times from the first navigation file
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			memcpy(&endTimePercentage,&endTime,sizeof(TTime));
		}
		startTimeFromNav=1;
	} else {
		//Only have product file
		if (sopt->numNav==1) {
			//One navigation file
			//Get start and end times
			startTime = getProductsFirstEpoch(products[0]);
			endTime = getProductsLastEpoch(products[0]);
			if (retRNXnav[0]==2) {
				ret=readRinexNavLastEpoch(fdRNXnav[0],&endTimePercentage,sopt->navFile[0],options);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				}
			} else {
				memcpy(&endTimePercentage,&endTime,sizeof(TTime));
			}
		} else if (sopt->numSP3==1) {
			//One SP3 file for orbits and clocks
			if(retSP3[0]==2) {
				//Get start and end times 
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(products[0]);
				ret=readSP3LastEpoch(fdSP3[0],&endTimePercentage);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				}
			} else {
				//Get start and end times 
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(nextProducts[0]);
				memcpy(&endTimePercentage,&endTime,sizeof(TTime));
			}

			ConcatenateSP3(0,products[0],pastProducts[0],nextProducts[0],options);	

		} else {
			//One SP3 file for orbits and one for clocks
			if(retSP3o[0]==2) {
				//Get start and end times 
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(products[0]);
				ret=readSP3LastEpoch(fdSP3o[0],&endTimePercentage);
				if (ret==0) {
					printProgress=0;
					endTimePercentage.MJDN=-1;
				}
			} else {
				//Get start and end times 
				startTime = getProductsFirstEpoch(pastProducts[0]);
				endTime = getProductsLastEpoch(nextProducts[0]);
				memcpy(&endTimePercentage,&endTime,sizeof(TTime));
			}

			ConcatenateSP3(0,products[0],pastProducts[0],nextProducts[0],options);	
		}
	}

	if ( sopt->numSP3>0 || sopt->numOrb >0 ) {	

		//Compute Max total distance between interpolation samples for orbits
		if(options->OrbitsMaxGaps==-1) {
			options->OrbitsMaxGaps=8;
		} 
		if(options->OrbitsMaxGaps!=0 && options->orbitInterpolationDegree!=0) {
			if (sopt->numNav==0) {
				options->OrbitsMaxDistance=OrbitsMaxDistance[0]=(double)(options->OrbitsMaxGaps)*products[0]->SP3->orbits.interval;
				if ( sopt->numSP3==2 || sopt->numOrb ==2 ) {
					OrbitsMaxDistance[1]=(double)(options->OrbitsMaxGaps)*products[1]->SP3->orbits.interval;
				}
			} else {
				OrbitsMaxDistance[1]=(double)(options->OrbitsMaxGaps)*products[1]->SP3->orbits.interval;
			}
		} else {
			options->OrbitsMaxDistance=0.;
			OrbitsMaxDistance[0]=OrbitsMaxDistance[1]=0.;
		}

		//Compute Max total distance between first and last interpolation samples for orbits
		if(options->OrbitsToTMaxGaps==-1) {
			options->OrbitsToTMaxGaps=16;
		}
		if (options->OrbitsToTMaxGaps!=0) {
			if (sopt->numNav==0) {
				options->OrbitsToTMaxDistance=OrbitsToTMaxDistance[0]=(double)(options->orbitInterpolationDegree)*products[0]->SP3->orbits.interval+(double)(options->OrbitsToTMaxGaps)*products[0]->SP3->orbits.interval;
				if ( sopt->numSP3==2 || sopt->numOrb ==2 ) {
					OrbitsToTMaxDistance[1]=(double)(options->orbitInterpolationDegree)*products[1]->SP3->orbits.interval+(double)(options->OrbitsToTMaxGaps)*products[1]->SP3->orbits.interval;
				}
			} else {
				OrbitsToTMaxDistance[1]=(double)(options->orbitInterpolationDegree)*products[1]->SP3->orbits.interval+(double)(options->OrbitsToTMaxGaps)*products[1]->SP3->orbits.interval;
			}
		} else {
			options->OrbitsToTMaxDistance=0.;
			OrbitsToTMaxDistance[0]=OrbitsToTMaxDistance[1]=0.;
		}

		//Compute Max total distance between interpolation samples for clocks
		if(options->ClocksMaxGaps==-1) {
			options->ClocksMaxGaps=4;
		} 
		if(options->ClocksMaxGaps!=0) {
			if (sopt->numNav==0) {
				options->ClocksMaxDistance=ClocksMaxDistance[0]=(double)(options->ClocksMaxGaps)*products[0]->SP3->clocks.interval;
				if ( sopt->numSP3==2 || sopt->numOrb ==2 ) {
					ClocksMaxDistance[1]=(double)(options->ClocksMaxGaps)*products[1]->SP3->clocks.interval;
				}
			} else {
				ClocksMaxDistance[1]=(double)(options->ClocksMaxGaps)*products[1]->SP3->clocks.interval;
			}
		} else {
			options->ClocksMaxDistance=0.;
			ClocksMaxDistance[0]=ClocksMaxDistance[1]=0.;
		}

		//Compute Max total distance between first and last interpolation samples for clocks
		if(options->ClocksToTMaxGaps==-1) {
			options->ClocksToTMaxGaps=8;
		}
		if(options->ClocksToTMaxGaps!=0 && options->clockInterpolationDegree!=0) {
			if (sopt->numNav==0) {
				options->ClocksToTMaxDistance=ClocksToTMaxDistance[0]=(double)(options->clockInterpolationDegree)*products[0]->SP3->clocks.interval+(double)(options->ClocksToTMaxGaps)*products[0]->SP3->clocks.interval;
				if ( sopt->numSP3==2 || sopt->numOrb ==2 ) {
					ClocksToTMaxDistance[1]=(double)(options->clockInterpolationDegree)*products[1]->SP3->clocks.interval+(double)(options->ClocksToTMaxGaps)*products[1]->SP3->clocks.interval;
				}
			} else {
				ClocksToTMaxDistance[1]=(double)(options->clockInterpolationDegree)*products[1]->SP3->clocks.interval+(double)(options->ClocksToTMaxGaps)*products[1]->SP3->clocks.interval;
			}
		} else {
			options->ClocksToTMaxDistance=0.;
			ClocksToTMaxDistance[0]=ClocksToTMaxDistance[1]=0.;
		}

		if(options->OrbitsToTMaxGaps<options->OrbitsMaxGaps) {
			sprintf(messagestr,"Maximum total number of data gaps in orbit interpolation given (%d) has to be equal or greater than the maximum number of data gaps between samples (%d)",options->OrbitsToTMaxGaps,options->OrbitsMaxGaps);
			printError(messagestr,options);
		}

		//Print messages for specific for SP3 products

		sprintf(messagestr,"MODELLING Orbit interpolation degree: %2d", options->orbitInterpolationDegree);
		printInfo(messagestr,options);
		sprintf(messagestr,"MODELLING Clock interpolation degree: %2d", options->clockInterpolationDegree);
		printInfo(messagestr,options);

		if(options->OrbitsMaxGaps!=0) {
			if ( sopt->numSP3==2 || sopt->numOrb==2 ) {
				if (OrbitsMaxDistance[0]==OrbitsMaxDistance[1]) {
					sprintf(messagestr,"MODELLING Max data gaps between orbit interpolation samples (both files):  %2d (%d seconds)",options->OrbitsMaxGaps,(int)OrbitsMaxDistance[0]);
					printInfo(messagestr, options);
				} else {
					sprintf(messagestr,"MODELLING Max data gaps between orbit interpolation samples (File 1):  %2d (%d seconds)",options->OrbitsMaxGaps,(int)OrbitsMaxDistance[0]);
					printInfo(messagestr, options);
					sprintf(messagestr,"MODELLING Max data gaps between orbit interpolation samples (File 2):  %2d (%d seconds)",options->OrbitsMaxGaps,(int)OrbitsMaxDistance[1]);
					printInfo(messagestr, options);
				}
			} else if ( sopt->numNav==0) {
				sprintf(messagestr,"MODELLING Max data gaps between orbit interpolation samples:  %2d (%d seconds)",options->OrbitsMaxGaps,(int)OrbitsMaxDistance[0]);
				printInfo(messagestr, options);
			} else {
				sprintf(messagestr,"MODELLING Max data gaps between orbit interpolation samples:  %2d (%d seconds)",options->OrbitsMaxGaps,(int)OrbitsMaxDistance[1]);
				printInfo(messagestr, options);
			}
		} else {
			sprintf(messagestr,"MODELLING Max data gaps between orbit interpolation samples: Unlimited");
			printInfo(messagestr, options);
		}
		if (options->OrbitsToTMaxGaps!=0) {
			if ( sopt->numSP3==2 || sopt->numOrb==2 ) {
				if (OrbitsToTMaxDistance[0]==OrbitsToTMaxDistance[1]) {
					sprintf(messagestr,"MODELLING Max data gaps in all  orbit interpolation samples (both files):  %2d (%d seconds)",options->OrbitsToTMaxGaps,(int)OrbitsToTMaxDistance[0]);
					printInfo(messagestr, options);
				} else {
					sprintf(messagestr,"MODELLING Max data gaps in all  orbit interpolation samples (File 1):  %2d (%d seconds)",options->OrbitsToTMaxGaps,(int)OrbitsToTMaxDistance[0]);
					printInfo(messagestr, options);
					sprintf(messagestr,"MODELLING Max data gaps in all  orbit interpolation samples (File 2):  %2d (%d seconds)",options->OrbitsToTMaxGaps,(int)OrbitsToTMaxDistance[1]);
					printInfo(messagestr, options);
				}
			} else if ( sopt->numNav==0) {
				sprintf(messagestr,"MODELLING Max data gaps in all  orbit interpolation samples:  %2d (%d seconds)",options->OrbitsToTMaxGaps,(int)OrbitsToTMaxDistance[0]);
				printInfo(messagestr, options);
			} else {
				sprintf(messagestr,"MODELLING Max data gaps in all  orbit interpolation samples:  %2d (%d seconds)",options->OrbitsToTMaxGaps,(int)OrbitsToTMaxDistance[1]);
				printInfo(messagestr, options);
			}
		} else {
			sprintf(messagestr,"MODELLING Max data gaps in all  orbit interpolation samples: Unlimited");
			printInfo(messagestr, options);
		}
		if (options->clockInterpolationDegree!=0) {
			if (options->ClocksToTMaxGaps!=0) {
				if ( sopt->numSP3==2 || sopt->numOrb==2 ) {
					if (ClocksMaxDistance[0]==ClocksMaxDistance[1]) {
						sprintf(messagestr,"MODELLING Max data gaps between clock interpolation samples (both files):  %2d (%d seconds)",options->ClocksMaxGaps,(int)ClocksMaxDistance[0]);
						printInfo(messagestr, options);
					} else {
						sprintf(messagestr,"MODELLING Max data gaps between clock interpolation samples (File 1):  %2d (%d seconds)",options->ClocksMaxGaps,(int)ClocksMaxDistance[0]);
						printInfo(messagestr, options);
						sprintf(messagestr,"MODELLING Max data gaps between clock interpolation samples (File 2):  %2d (%d seconds)",options->ClocksMaxGaps,(int)ClocksMaxDistance[1]);
						printInfo(messagestr, options);
					}
				} else if ( sopt->numNav==0) {
					sprintf(messagestr,"MODELLING Max data gaps between clock interpolation samples:  %2d (%d seconds)",options->ClocksMaxGaps,(int)ClocksMaxDistance[0]);
					printInfo(messagestr, options);
				} else {
					sprintf(messagestr,"MODELLING Max data gaps between clock interpolation samples:  %2d (%d seconds)",options->ClocksMaxGaps,(int)ClocksMaxDistance[1]);
					printInfo(messagestr, options);
				}
			} else {
				sprintf(messagestr,"MODELLING Max data gaps between clock interpolation samples: Unlimited");
				printInfo(messagestr, options);
			}
			if (options->ClocksToTMaxGaps!=0) {
				if ( sopt->numSP3==2 || sopt->numOrb==2 ) {
					if ( ClocksToTMaxDistance[0]==ClocksToTMaxDistance[1]) {
						sprintf(messagestr,"MODELLING Max data gaps in all  clock interpolation samples (both files):  %2d (%d seconds)",options->ClocksToTMaxGaps,(int)ClocksToTMaxDistance[0]);
						printInfo(messagestr, options);
					} else {
						sprintf(messagestr,"MODELLING Max data gaps in all  clock interpolation samples (File 1):  %2d (%d seconds)",options->ClocksToTMaxGaps,(int)ClocksToTMaxDistance[0]);
						printInfo(messagestr, options);
						sprintf(messagestr,"MODELLING Max data gaps in all  clock interpolation samples (File 2):  %2d (%d seconds)",options->ClocksToTMaxGaps,(int)ClocksToTMaxDistance[1]);
						printInfo(messagestr, options);
					}
				} else if ( sopt->numNav==0) {
					sprintf(messagestr,"MODELLING Max data gaps in all  clock interpolation samples:  %2d (%d seconds)",options->ClocksToTMaxGaps,(int)ClocksToTMaxDistance[0]);
					printInfo(messagestr, options);
				} else {
					sprintf(messagestr,"MODELLING Max data gaps in all  clock interpolation samples:  %2d (%d seconds)",options->ClocksToTMaxGaps,(int)ClocksToTMaxDistance[1]);
					printInfo(messagestr, options);
				}
			} else {
				sprintf(messagestr,"MODELLING Max data gaps in all  clock interpolation samples: Unlimited");
				printInfo(messagestr, options);
			}
		}
		sprintf(messagestr, "MODELLING Satellite Phase Centre Modelling:     %3s",options->satellitePhaseCenter? "YES" : "NO");
		printInfo(messagestr, options);
	}
		
	if ( sopt->numNav>=1 ) {
		sprintf(messagestr,"MODELLING Check transmission time of navigation message is behind current epoch: %s",options->timeTrans?"ON":"OFF");
		printInfo(messagestr, options);

		sprintf(messagestr,"MODELLING Use satellite 'SV Health' flag of navigation message: %s",BRDCHealthSel2String(options->satHealthMode));
		printInfo(messagestr, options);
	}

	if (sopt->numNav>0) {
		//Build list of available RINEX navigation message types
		for(l=0;l<MAXNAVSOURCES;l++) {
			for(i=0;i<MAX_GNSS;i++) {
				//Reset BRDCTypesAvail variables
				for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
					//Reset BRDCAvailSelOrder list
					for(k=0;k<=MAX_BRDC_TYPES;k++) {
						options->BRDCAvailSelOrder[l][i][j][k]=0;
					}
					//Fill with available messages
					m=0;
					if (sopt->numNav==1) {
						for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
							if (products[0]->BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
								options->BRDCAvailSelOrder[l][i][j][m]=options->BRDCSelOrder[i][j][k];
								m++;
							}
						}
					} else {
						for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
							if (products[0]->BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1||
									products[1]->BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
								options->BRDCAvailSelOrder[l][i][j][m]=options->BRDCSelOrder[i][j][k];
								m++;
							}
						}
					}
					options->BRDCAvailSelOrder[l][i][j][MAX_BRDC_TYPES]=m;
				}
			}
		}
		if (sopt->numNav==2) {
			//If one of the files have the leap second but not the other, copy it to the other product structure
			if (products[0]->BRDC->LeapSecondsAvail==1 && products[1]->BRDC->LeapSecondsAvail==0) {
				products[1]->BRDC->LeapSecondsAvail=1;
				products[1]->BRDC->AT_LS=products[0]->BRDC->AT_LS;
			} else if (products[0]->BRDC->LeapSecondsAvail==0 && products[1]->BRDC->LeapSecondsAvail==1) {
				products[0]->BRDC->LeapSecondsAvail=1;
				products[0]->BRDC->AT_LS=products[1]->BRDC->AT_LS;
			}
			if (products[0]->BRDC->LeapSecondsAvailPast==1 && products[1]->BRDC->LeapSecondsAvailPast==0) {
				products[1]->BRDC->LeapSecondsAvailPast=1;
				products[1]->BRDC->AT_LSpast=products[0]->BRDC->AT_LSpast;
			} else if (products[0]->BRDC->LeapSecondsAvailPast==0 && products[1]->BRDC->LeapSecondsAvailPast==1) {
				products[0]->BRDC->LeapSecondsAvailPast=1;
				products[0]->BRDC->AT_LSpast=products[1]->BRDC->AT_LSpast;
			}
		} else {
			//Only one navigation file provided. Free memory for the second slot to avoid losing it when using concatenaded SP3
			freeBRDCproducts(FREEALLNAV,pastProducts[1]);
			freeBRDCproducts(FREEALLNAV,nextProducts[1]);
			freeBRDCproducts(FREEALLNAV,products[1]);
			free(pastProducts[1]->BRDC);
			free(nextProducts[1]->BRDC);
			free(products[1]->BRDC);
			pastProducts[1]->BRDC=NULL;
			nextProducts[1]->BRDC=NULL;
			products[1]->BRDC=NULL;
		}
		//Check if one or more GLONASS satellites are selected
		for(i=1;i<=MAX_SAT_GLO;i++) {
			if (options->includeSatellite[GLONASS][i]) break;
		}
		//Print a warning in the case that leap seconds is set from hardcoded values
		if (sopt->numNav==2) {
			if(i<=MAX_SAT_GLO && (products[0]->BRDC->LeapSecondsAvail==0||products[0]->BRDC->LeapSecondsAvail==0)) {
				sprintf(messagestr,"WARNING Number of current leap seconds (%d) is read from internal hardcoded table. Provide leap seconds in RINEX navigation file header if it is incorrect",
						getLeapSeconds(&products[0]->BRDC->block[0][0][0].Ttoc,products[0]->BRDC->LeapSecondsTimeList,products[0]->BRDC->LeapSecondsNumList));
				printInfo(messagestr,options);
			}
		} else {
			if(i<=MAX_SAT_GLO && products[0]->BRDC->LeapSecondsAvail==0) {
				sprintf(messagestr,"WARNING Number of current leap seconds (%d) is read from internal hardcoded table. Provide leap seconds in RINEX navigation file header if it is incorrect",
						getLeapSeconds(&products[0]->BRDC->block[0][0][0].Ttoc,products[0]->BRDC->LeapSecondsTimeList,products[0]->BRDC->LeapSecondsNumList));
				printInfo(messagestr,options);
			}
		}
	} else {
		//No navigation file provided. Free memory for the two slot to avoid losing it when using concatenaded SP3
		for(i=0;i<2;i++) {
			freeBRDCproducts(FREEALLNAV,pastProducts[i]);
			freeBRDCproducts(FREEALLNAV,nextProducts[i]);
			freeBRDCproducts(FREEALLNAV,products[i]);
			free(pastProducts[i]->BRDC);
			free(nextProducts[i]->BRDC);
			free(products[i]->BRDC);
			pastProducts[i]->BRDC=NULL;
			nextProducts[i]->BRDC=NULL;
			products[i]->BRDC=NULL;
		}
	}

	if (options->StartEpoch.MJDN!=-1) {
		memcpy(&startTime,&options->StartEpoch,sizeof(TTime));
	}

	if (options->EndEpoch.MJDN!=-1) {
		memcpy(&endTime,&options->EndEpoch,sizeof(TTime));
		memcpy(&endTimePercentage,&options->EndEpoch,sizeof(TTime));
	}
	//Compute number of epochs to be processed
	if (printProgress==1) {
		if ( options->decimate != 0. ) {
			tIncrease = options->decimate;
		}

		// Tune start time to start at least in an entire hour
		memcpy(&startTimeRound,&startTime,sizeof(TTime));
		if (options->StartEpoch.MJDN==-1) {
			startTimeRound.SoD -= modulo(startTimeRound.SoD, 3600);
		}

		//Compute number of epochs to be processed
		numberEpochs=tdiff(&endTimePercentage,&startTimeRound)/tIncrease;

	}

	if ( options->workMode == wmCOMPAREORBITS ) {
		compareOrbits(products, pastProducts, nextProducts, fdRNXnav, retRNXnav, rinexNavVersion, fdSP3, retSP3, fdSP3o, retSP3o, fdCLK, retCLK, OrbitsMaxDistance, OrbitsToTMaxDistance, ClocksMaxDistance, ClocksToTMaxDistance, constellation, startTime, endTime, endTimePercentage, numberEpochs, startTimeFromNav, options, sopt);
	} else if ( options->workMode == wmSHOWPRODUCT ) {
		showProduct(products[0], pastProducts[0], nextProducts[0], fdRNXnav[0], retRNXnav[0], rinexNavVersion[0], fdSP3[0], retSP3[0], fdSP3o[0], retSP3o[0], fdCLK[0], retCLK[0], constellation, startTime, endTime, endTimePercentage, numberEpochs, constellationPrint, options, sopt);
	}
	//Free memory
	for(i=0;i<2;i++) {
		if(products[i]->BRDC!=NULL) {
			freeBRDCproducts(FREEALLNAV,products[i]);
			free(products[i]->BRDC);
		}
		if (products[i]->SP3==nextProducts[i]->SP3) {
			nextProducts[i]->SP3=NULL;
		}
		if (products[i]->SP3==pastProducts[i]->SP3) {
			pastProducts[i]->SP3=NULL;
		}
		freeSP3data(pastProducts[i]);
		freeSP3data(nextProducts[i]);
		freeSP3data(products[i]);
		free(pastProducts[i]);
		free(nextProducts[i]);
		free(products[i]);
	}
}

/*****************************************************************************
 * Name        : AddUserError2RINEX
 * Description : Read an observation file epoch by epoch, add user defined
 *                 error to measurements and write a new RINEX observation
 *                 file (the same version as the input observation file)
 * Parameters  :
 * Name                           |Da|Unit|Description
 * char *ObsFilename               I  N/A  Input observation file name
 * char *UserErrorFilename         I  N/A  Input user added error file name
 * char *gloNavFile                I  N/A  Input glonass navigation file for frequency offsets
 * char *OutputObsFile             I  N/A  Output observation file name
 * TEpoch  *epoch                  O  N/A  Structure to save the data
 * TUserError *UserError           O  N/A  TUserError structure
 * TOptions  *options              I  N/A  TOptions structure
 *****************************************************************************/
void AddUserError2RINEX (char *ObsFilename, char *UserErrorFilename, char *gloNavFile, char *OutputObsFile, TEpoch *epoch, TUserError *UserError, TOptions *options) {

    //int i;
	int 			ret;
	int				nextgloNav=0;
	FILE			*fdRNX = NULL;
	FILE			*fdNoise = NULL;
	FILE			*fdRNXoAddedError = NULL;
	FILE			*fdRNXGlo = NULL;
	char			Epochstr[80];
	char			navFile[5];
	TGNSSproducts	productsGLO;

	initGNSSproducts(&productsGLO);

	navFile[0]='\0'; //This is for getGLOFreqOffsets function

	//Open Observation file
	fdRNX = fopen(ObsFilename,"rb");
	if ( fdRNX == NULL) {
		sprintf(messagestr,"Opening RINEX observation file [%s]",ObsFilename);
		printError(messagestr,options);
	} else if ( whatFileTypeIs(ObsFilename)!=ftRINEXobservation) {
		sprintf(messagestr,"Reading RINEX observation file [%s]",ObsFilename);
		printError(messagestr,options);
	}
	//Open user adder error file
	fdNoise = fopen(UserErrorFilename,"rb");
	if ( fdNoise == NULL ) {
		sprintf(messagestr,"Opening file [%s] for user added error to measurements",UserErrorFilename);
		printError(messagestr,options);
	}
	//Create directories for output file
	ret=mkdir_recursive(OutputObsFile);
	if(ret!=0) {
	   //Error when creating the directory, and it is not due to that the directory already exists
	   sprintf(messagestr,"When creating [%s] folder for writing corrections",OutputObsFile);
	   printError(messagestr,options);
	}
	fdRNXoAddedError = fopen(OutputObsFile,"w");
	if ( fdRNXoAddedError == NULL) {
		sprintf(messagestr,"When creating [%s] file for output RINEX observation file",OutputObsFile);
		printError(messagestr,options);
	}

	ret = readRinexObsHeader(fdRNX,fdRNXoAddedError,epoch,options);

	if (ret==0) {
		sprintf(messagestr,"Reading observation file [%s] header",ObsFilename);
		printError(messagestr,options);
	}

	//Read first epoch
	ret = readRinexObsEpoch(fdRNX,epoch,Epochstr,options);

	//Check if GLONASS frequency offset values (k) is available in the header of the RINEX observation file
	if (epoch->measOrder[GLONASS].hasGlonassSlotsFreq==0) {
		//Data not available. Check if navigation data is available
		if (gloNavFile[0]=='\0') {
			sprintf(messagestr,"WARNING: No GLONASS frequency offsets available in RINEX observation file and no GLONASS navigation file was provided. GLONASS measurements will be left untouched. Provide a GLONASS navigation file with parameter '-input:navglo' for reading the frequency offsets");
			printInfo(messagestr,options);
		} else {
			getGLOFreqOffsets(epoch,navFile,gloNavFile,&fdRNXGlo,&nextgloNav,NULL,&productsGLO,options);
		}
	}


	while ( ret ) {

		//Update progress
		if (epoch->NewPercentage) { 
			epoch->NewPercentage=0;
			if (options->ProgressEndCharac=='\r') {
				//Printing to a terminal
				fprintf(options->terminalStream,"%s%c",Epochstr,options->ProgressEndCharac);
				fflush_function(options->terminalStream);
			} else {
				//Printing for the GUI. Only print if the integer of the percentage have changed (to avoid message spamming)
				if ((int)epoch->CurrentPercentage!=(int)epoch->PreviousPercentage) {
					fprintf(options->terminalStream,"%s%c",Epochstr,options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			epoch->PreviousPercentage=epoch->CurrentPercentage;
		}
		//Add Error
		addUserError(fdNoise,UserErrorFilename,epoch,UserError,options);
		//Write output RINEX file
		writeObsRinexEpochUserAddedError(fdRNXoAddedError,epoch);

		//Read next epoch (it is done at the end so when end of file is reached the while ends,
		//whilst if it was at the beginning the last epoch would be done twice
		ret = readRinexObsEpoch(fdRNX,epoch,Epochstr,options);
		if (ret==2) {
			// Read the RINEX header (if header is found, readRinexObsEpoch function does not read any data!)
			ret = readRinexObsHeader(fdRNX,fdRNXoAddedError,epoch,options);
			//If header is found, readRinexObsEpoch function does not read any data!
			//Therefore, we need to read the new header and the next epoch
			if (ret==0) {
				sprintf(messagestr,"Reading observation file [%s] header",ObsFilename);
				printError(messagestr,options);
			} else {
				ret = readRinexObsEpoch(fdRNX,epoch,Epochstr,options);
			}
		}
	}

	//Free GLONASS data for frequency factors
	if (productsGLO.BRDC!=NULL) {
		freeBRDCproducts(FREEALLNAV,&productsGLO);
		free(productsGLO.BRDC);
	}
	fclose(fdRNX);
	fclose(fdNoise);
	fclose(fdRNXoAddedError);
	if (fdRNXGlo!=NULL) fclose(fdRNXGlo);
}

/*****************************************************************************
 * Name        : main
 * Description : Main executable function
 *****************************************************************************/
int main (int argc, char* argv[]) {
	TOptions					*options=NULL;
	TSupportOptions				*sopt=NULL;
	TConstellation				constellation,constellationSatBlock;
	TConstellation				*constellationPrint=NULL;
	TAntennaList				antennaList,antennaListSatBlock;
	TStationList				stationList;
	TReceiverList 				recList;
	TStation					*station=NULL;
	TGNSSproducts				products;
	TGNSSproducts				productsGLO;
	TGNSSproducts				productsHealthforPPP;
	TGNSSproducts				nextSP3Prod;
	TGNSSproducts				pastSP3Prod;
	TGNSSproducts				productsKlb;
	TGNSSproducts				productsBei;
	TGNSSproducts				productsNeq;
	TGNSSproducts				productsTgd;
	TGNSSproducts				ReferencePos;
	TIONEX						ionex;
	TIONEX						productsIonex;
	TFPPPIONEX					fppp;
	TFPPPIONEX					productsFppp;
	TTROPOGal					tropoGal;
	TSBASdatabox				SBASdatabox;
	TTGDdata					tgdData;
	TEpoch						*epoch = NULL;
	TEpoch						*epochDGNSS = NULL;
	TEpoch						*epochDGNSSfillSat= NULL; //Will only be different of NULL if using DGNSS in RTCM3 or RINEX observation file
	TEpoch						*epochPointer = NULL;
	TUserError					UserError;
	TStdESA						StdESA;
	enum    GenericDCBModel		auxDCBModel = DCBNONE;
	FILE						*fdRNX = NULL;
	FILE						*fdRNXnav[MAX_NAV_FILES];
	FILE						*fdRNXglonav = NULL;
	FILE						*fdRNXHealthPPP[MAX_NAV_FILES];
	FILE						*fdRNXKlb = NULL;
	FILE						*fdRNXBei = NULL;
	FILE						*fdRNXNeq = NULL;
	FILE						*fdIONEX = NULL;
	FILE						*fdSP3 = NULL;			// Full file (orbits plus clocks)
	FILE						*fdSP3o = NULL;			// Read only orbits
	FILE						*fdOutSP3 = NULL;		// Output SP3 file
	FILE						*fdOutRefFile = NULL;	// Output reference file
	FILE						*fdCLK = NULL;
	FILE						*fdNoise = NULL;
	FILE						*fdstdESA = NULL;
	FILE						*fdRNXdgnss = NULL;
	FILE						*fdRTCM = NULL;
	FILE						*fdRTCM2 = NULL;
	FILE						*fdRTCM3 = NULL;
	FILE						*fdTGD[MAX_DCB_FILE_SOURCES];
	long						CurrentPosSP3file;
	int							ret, ret1, ret2, ret3, retDGNSS = 1;
	int							retsbas, retPosFile;
	int							i,j,k,l;
	int							len;
	int							newDayRinexNav;
	unsigned int				m; //to avoid warning: comparison between signed and unsigned integer expressions
	double						r;
	double						ionexVersion = 0;
	double						rinexBVersion = 0;
	double						rinexNavVersion = 0;
	double						fpppVersion = 0;
	double						freq1,freq2,freq3,freq4;
	int							kalmanRes;
	int							numsatellites;
	enum fileType				auxft1;
	int							processedEpochs;
	int							filterIterations;
	TTime						endProductsTime;
	TTime						startProductsTime;
	TTime						TmpTTime;
	int							anyInsideProducts = 0;
	int							kalmanIterations;
	int							chdirret;
	double						deltaTime=10.;
	double						auxd;
	int							computeDGNSScor;
	TRTCM2						*rtcm2 = NULL;
	TRTCM3						*rtcm3 = NULL;
	char						*fileRINEXpointer = NULL;
	int							concatCount = 1;
	int							Measprinted;
	int							RTCMversion;
	int							DoY,MJDNValue,MJDNEpoch;
	int							Summary=0,summaryPrinted=0;
	int							ProcTimeLength=0,PosProcTime=0;
	int							firstEpoch=1;
	int							CheckFirstEpoch=1;
	int							OrbInterpDegree;
	double						OrbMaxDistance;
	int							nextNav[MAX_NAV_FILES];
	int							nextNavHealth[MAX_NAV_FILES];
	int							nextgloNav=0;
	int							retTGD[MAX_DCB_FILE_SOURCES];
	int							newNavDataRead;
	int							enabledSat;
	int							navFilesVersion[MAXNAVSOURCESWITHIONO][MAX_GNSS];
	int							numNavFilesVersion[MAXNAVSOURCESWITHIONO]={0,0,0,0};

	// Filter
	TFilterSolution				*solution=NULL;
	TUnkinfo					prevUnkinfo;

	//Variables for SBAS plot mode
	int							GEOused;
	int							currenttime;
	int							currenthour;
	int							ionoerror;
	int							latPos;
	int							lonPos;
	int							totalAvailabilityEpochs;
	int							totalAvailabilityEpochsHourly;
	int							totalIonoEpochs;
	int							totalIonoEpochsHourly;
	int							InitialSBASPlotsEpoch;
	int    					    SBASPlotYear;
	int							InsideInclusionArea;
	int							InsideExclusionArea;
	int							Epochsleft;
	int							excludedGEOs=0;
	double				 	    SBASPlotDoY;
	double						latitude,longitude;
	double						SecondDecimalNavStart,SecondDecimalCurrEpoch;
	FILE						*fdSBASAvail = NULL;
	FILE						*fdSBASAvailHour[24];
	FILE						*fdSBASRisk = NULL;
	FILE						*fdSBASRiskHour[24];
	FILE						*fdSBASRiskMar = NULL;
	FILE						*fdSBASRiskMarHour[24];
	FILE						*fdSBASDiscont = NULL;
	FILE						*fdSBASDiscontHour[24];
	FILE						*fdSBASIono = NULL;
	FILE						*fdSBASIonoHour[24];
	FILE						*fdSBASHDOP = NULL;
	FILE						*fdSBASHDOPHour[24];
	FILE						*fdSBASPDOP = NULL;
	FILE						*fdSBASPDOPHour[24];
	FILE						*fdSBASGDOP = NULL;
	FILE						*fdSBASGDOPHour[24];
	FILE						*fdSBASCombDOP = NULL;
	FILE						*fdSBASCombDOPHour[24];
	TSBAScorr 					SBAScorr;
	TSBASPlots 					*SBASplots = NULL;
	char						HourFileName[MAX_OUTPUT_FILENAME];
	char						Epochstr[80];
	char						auxstr[400],auxstr2[400];
	TTime						tproducts;
	struct tm					tmNavStart,tmCurrEpoch;
	long long unsigned int		StartTimeRealPCTime,totalprocessingTime;

	#if defined __WIN32__ 
		FILETIME 				WinStartTimeRealPCTime;
	#else
		struct timeval 			POSIXStartTimeRealPCTime;
	#endif

	#if defined _OPENMP
		int						numsatdiscardedSBAS;
	#endif

	// IMPORTANT NOTE: TEpoch structures have been declared as pointers and initialized to NULL. 
	// Later they will have memory allocated in the heap using the malloc function.
	// If they had not been declared as pointers, but as local variables, the memory for the structures
	// would have been allocated in the stack. The difference between the stack and the heap is that
	// the stack has a fixed size, which depends on the OS (normally around 10MB). If we try
	// to allocate too much memory in the stack, a stack overflow will occur, resulting in a
	// segmentation fault. When a segmentation fault occurs due to a stack overflow, any debugger
	// will point that the segmentation fault has been produced just when entering the function
	// that has produced the stack overflow (but without saying explicitly that it was a stack
	// overflow). For example, if the structures epoch and epochDGNSS had been declared as local variables,
	// a segmentation fault would have been produced just when entering the main function.

	// Variables for paths
	char	path_save[1000];
	char	*p;

	//Get start epoch (computer current epoch measured since 1st January 1970) from system
	#if defined __WIN32__ 
		GetSystemTimeAsFileTime(&WinStartTimeRealPCTime);
		//The structure FILETIME provides the value in number of 100 nanoseconds or 0.1 microseconds in a 64 bit number splitted in two 32 bit variables
		//dwHighDateTime of FILETIME structure has the upper 32 bits and dwLowDateTime have the lower 32 bits
		//To add them toguether in a 64 bit unsigned integer, convert the upper 32 bits to a 64 bits unsigned integer and shift them 32 bits, so they occupy the upper 32 bits on the 64 bit integer.
		//Then, make an OR operation of the latter value with the lower 32 bits, so we have the 64 bit integer with the upper and lower values
		StartTimeRealPCTime=((long long unsigned int)(WinStartTimeRealPCTime.dwHighDateTime)<< 32) | WinStartTimeRealPCTime.dwLowDateTime;
		//Convert from Windows start epoch to Linux start epoch (1st January 1601 to 1st January 1970)
		StartTimeRealPCTime-=(long long unsigned int)(116444736000000000);
		//As Linux timestamps are in microseconds and windows timestamps are in 0.1 microseconds, divide by 10 so precision in Windows matches the one in Linux
		StartTimeRealPCTime/=10;
	#else
		gettimeofday(&POSIXStartTimeRealPCTime, NULL);
		StartTimeRealPCTime=(long long unsigned int)(POSIXStartTimeRealPCTime.tv_sec)*(long long unsigned int)(1E6) + (long long unsigned int)(POSIXStartTimeRealPCTime.tv_usec);
	#endif



	// Allocate memory
	options = malloc(sizeof(TOptions));
	sopt = malloc(sizeof(TSupportOptions));
	epoch = malloc(sizeof(TEpoch));
	rtcm2 = malloc(sizeof(TRTCM2));
	rtcm3 = malloc(sizeof(TRTCM3));
	solution = malloc(sizeof(TFilterSolution));
	Epochstr[0]='\0';
	printProgress=-1;
	for(i=0;i<MAX_NAV_FILES;i++) {
		fdRNXnav[i]=NULL;
		fdRNXHealthPPP[i]=NULL;
		nextNav[i]=0;
		nextNavHealth[i]=0;
	}

	 #if !defined __WIN32__ && !defined __APPLE__
	// Variables for gathering linux or Cygwin path
	char	path[1000];
	int		execlength,pathlen;
	#endif

	// Auxiliary variables for gathering path in linux and signal handling
	#if !defined (__WIN32__)
		enableCursor[0]='\0';
		disableCursor[0]='\0';
		StdoutStream=NULL;
		pid = getpid();
		//Set signal functions
		if (signal(SIGINT, &sigIntSignal) == SIG_ERR) {
			//If signals are not caught, do not disable cursor
			sopt->disableCursor=0;
		}
		if (signal(SIGTSTP, &sigStpSignal) == SIG_ERR) {
			//If signals are not caught, do not disable cursor
			sopt->disableCursor=0;
		}
		if (signal(SIGCONT, &sigContSignal) == SIG_ERR) {
			//If signals are not caught, do not disable cursor
			sopt->disableCursor=0;
		}
		if (signal(SIGPIPE, &sigPipeSignal) == SIG_ERR) {
			//If signals are not caught, do not disable cursor
			sopt->disableCursor=0;
		}
	#else
		sopt->disableCursor=0; //In Windows, do not disable cursor
	#endif

	// Save absolute path of the executable, not the actual path. Needed for reading Galileo troposphere and NeQuick model files
	#if defined __WIN32__
		if ( !(p = strrchr(argv[0],'\\')) ) {
			//No backslashes in path
			p = getcwd(options->abs_exe_path,sizeof(options->abs_exe_path));
	#elif defined __CYGWIN__
		if ( (!(p = strrchr(argv[0],'\\'))) && (!(p = strrchr(argv[0],'/'))) ) {
			//No backslashes or slahes in path
			//In Cygwin (like in Linux), the executable path is in the softlink /proc/<pid>/exe
			sprintf(path,"/proc/%d/exe",pid);
			if ( readlink(path,options->abs_exe_path,sizeof(path)) == -1) {
				sprintf(messagestr,"When reading gLAB executable folder through the softlink [%s]",path);
				printError(messagestr,options);
			}
			//Readlink returns the path with the executable, the name of the executable must be taken out from the path
			pathlen = strlen(options->abs_exe_path);
			execlength = strlen(strrchr(options->abs_exe_path,'/'));
			options->abs_exe_path[pathlen-execlength] = '\0';
	#elif defined __APPLE__
		//Apple has no /proc folder
		if ( !(p = strrchr(argv[0],'/')) ) {
			//No slashes in path
			p = getcwd(options->abs_exe_path,sizeof(options->abs_exe_path));
	#else
		if ( !(p = strrchr(argv[0],'/')) ) {
			//No slashes in path
			//In Linux, the executable path is in the softlink /proc/<pid>/exe
			sprintf(path,"/proc/%d/exe",pid);
			if ( readlink(path,options->abs_exe_path,sizeof(path)) == -1) {
				sprintf(messagestr,"When reading gLAB executable folder through the softlink [%s]",path);
				printError(messagestr,options);
			}
			//Readlink returns the path with the executable, the name of the executable must be taken out from the path
			pathlen = strlen(options->abs_exe_path);
			execlength = strlen(strrchr(options->abs_exe_path,'/'));
			options->abs_exe_path[pathlen-execlength] = '\0';
	#endif
		} else {
			*p = '\0';
			p = getcwd(path_save, sizeof(path_save));
			chdirret = chdir(argv[0]);
			if ( chdirret==-1) {
				printError("When accessing gLAB executable folder",options);
			}
			p = getcwd(options->abs_exe_path, sizeof(options->abs_exe_path));
			chdirret = chdir(path_save);
		}



	//Initialize printbuffers
	for ( i = 0; i < MAX_SATELLITES_VIEWED; i++ ) {
		printbufferSBASCORR[i][0] = '\0';
		printbufferSBASVAR[i][0] = '\0';
		printbufferSBASIONO[i][0] = '\0';
		printbufferSBASUNSEL[i][0] = '\0';

	}
	for ( i = 0; i < MAX_GNSS; i++ ) {
		for( j=0; j < MAX_MEASKIND_PRINT_MEASUREMENTS; j++ ) {
			for (k = 0; k < MAX_FILTER_MEASUREMENTS_SAT; k++ ) {
				for ( l = 0; l < MAX_LINES_BUFFEREDPREFIT; l++ ) {
					printbufferPREFIT[i][j][k][l][0] = '\0';
					printbufferPOSTFIT[i][j][k][l][0] = '\0';
				}
				linesstoredPREFIT[i][j][k] = 0;
				linesstoredPOSTFIT[i][j][k] = 0;
			}
		}
	}
	for ( i = 0; i < MAX_GNSS; i++ ) {
		for ( j = 0; j < MAX_SATELLITES_PER_GNSS; j++ ) {
			printbufferSBASDFMCCORR[i][j][0] = '\0';
			printbufferSBASDFMCVAR[i][j][0] = '\0';
			printbufferSBASDFMCUNSEL[i][j][0] = '\0';
			for ( k = 0; k < MAX_LINES_BUFFEREDCS; k++ ) {
				printbufferCS[i][j][k][0] = '\0';
				printbufferSFCSdata[i][j][k][0] = '\0';
				printbufferMWCSdata[i][j][k][0] = '\0';
				printbufferLICSdata[i][j][k][0] = '\0';
				printbufferIGFCSdata[i][j][k][0] = '\0';
			}
			for ( k = 0; k < MAX_LINES_BUFFERED; k++ ) {
				printbufferMODEL[i][j][k][0] = '\0';
				printbufferSATSEL[i][j][k][0] = '\0';
			}
			printbufferUserError[i][j] = NULL;
			printbufferDGNSS[i][j][0] = '\0';
			linesstoredUserError[i][j] = 0;
			linesstoredCS[i][j] = 0;
			linesstoredSFCSdata[i][j] = 0;
			linesstoredMWCSdata[i][j] = 0;
			linesstoredLICSdata[i][j] = 0;
			linesstoredIGFCSdata[i][j] = 0;
			linesstoredMODEL[i][j] = 0;
			linesstoredSATSEL[i][j] = 0;
		}
	}
	for( i=0; i < MAX_MEASKIND_PRINT_MEASUREMENTS; i++ ) {
		linesstoredEPOCHSAT[i]=0;
		for ( j = 0; j < MAX_FILTER_MEASUREMENTS_SAT*MAX_GNSS; j++ ) {
			printbufferEPOCHSAT[i][j][0] = '\0';
		}
	}
	printbufferFILTER[0] = '\0';

	// Initialise structures
	initSupportOptions(sopt);
	initOptions(options);
	initGNSSproducts(&products);
	initGNSSproducts(&productsHealthforPPP);
	initGNSSproducts(&productsGLO);
	initGNSSproducts(&nextSP3Prod);
	initGNSSproducts(&pastSP3Prod);
	initGNSSproducts(&productsTgd);
	initGNSSproducts(&productsKlb);
	initGNSSproducts(&productsBei);
	initGNSSproducts(&productsNeq);
	initGNSSproducts(&ReferencePos);
	initConstellation(&constellation);
	initConstellation(&constellationSatBlock);
	initFilterSolution(solution);
	init0Unkinfo(&prevUnkinfo);
	initAntennaList(&antennaList);
	initAntennaList(&antennaListSatBlock);
	initReceiverList(&recList);
	initStationList(&stationList);
	initIONEX(&ionex);
	initIONEX(&productsIonex);
	initFPPPIONEX(&fppp);
	initFPPPIONEX(&productsFppp);
	initSBASdatabox(&SBASdatabox);
	initTropoGalData(&tropoGal);
	initSBASdata(SBASdatabox.SBASdata,0);
	initUserError(&UserError);
	initRTCM2(rtcm2);
	initRTCM3(rtcm3);

	//Init TGD values
	for(i=0;i<MAX_DCB_FILE_SOURCES;i++) {
		fdTGD[i]=NULL;
		retTGD[i]=0;
	}

	// Copy tmout values to options storage. Therefore, initially it will have the default values
	// Note that as SBAS 1F and DFMC have different messages, their timeouts do not overlap, except for
	// messages 0, 62 and 63 which are the same message but they don't have a timeout
	memcpy(options->usertmout, SBASdatabox.SBASdata[0].timeoutmessages[SBAS1FFREQPOS], sizeof(options->usertmout));
	
	// Parse options
	if ( !parseAllOptions(sopt, options, argc, argv) ) {
		exit(-1);
	}
	//Free memory used for reading measurements
	freeInputMeasString(sopt);
	for ( i = 0; i < 2; i++ ) {
		// This loop is done twice in order to override defaults of PPP and 
		// standalone once options are processed
		sopt->numNav = 0;
		sopt->numSP3 = 0;
		sopt->numOrb = 0;
		sopt->numClk = 0;
		sopt->numTGD = 0;
		sopt->numAntRec = 0;
		sopt->numNavHealth = 0;
		sopt->csPos = 0;
		sopt->csAllPosOn  = -1;
		sopt->csAllPosOff = -1;
		sopt->csLIPosOn   = -1;
		sopt->csLIPosOff  = -1;
		sopt->csMWPosOn   = -1;
		sopt->csMWPosOff  = -1;
		sopt->csLLIPosOn  = -1;
		sopt->csLLIPosOff = -1;
		sopt->csSFPosOn   = -1;
		sopt->csSFPosOff  = -1;
		sopt->csIGFPosOn  = -1;
		sopt->csIGFPosOff = -1;
		sopt->deprecatedMessages[0] = '\0';
		
		// Check if configuration file parameter exists
		ret = checkConfigFile(sopt, options);
		if ( ret == -1 ) {
			sprintf(messagestr, "Problems with config file [%s]", sopt->cfgFile);
			printError(messagestr, options);
		} else { // Configuration file parameter found and file parsed properly
			// Parse all command-line options again
			if ( !parseAllOptions(sopt, options, argc, argv) ) {
				exit(-1);
			}
		}
		// Process options
		if ( i == 0 ) {
			if ( !processOptions(sopt, options) ) {
				exit(-1);
			}
			//Free memory used for reading measurements only in first run,
			//as weights measurements will be parsed later, after the default
			//measurements are set
			freeInputMeasString(sopt);
		}
	}

	if (options->dateConversionMode!=DateConversionModeNone && options->coordConversionMode!=CoordConversionModeNone) {
		printError("Date conversion and coordinate conversion modes cannot be both selected",options);
	}

	//Check if date conversion is selected
	if (options->dateConversionMode!=DateConversionModeNone) {
		switch(options->dateConversionMode) {
			case DateConversionModeCalendar:
				if (options->dateConversionYear<1980||(options->dateConversionYear==1980 && options->dateConversionMonth==1 && options->dateConversionDay<6)) {
					//Date below /06/01/1980, where GPS time starts
					printError("Minimum accepted date is 1980/01/06 (YYYY/MM/DD) or 1980/006 (Year/DoY) or 0/0 (GPSWeek/SoW) or 44244/0 (MJDN/SoD)",options);
				}
				ConvertCalendarDate(options->dateConversionYear,options->dateConversionMonth,options->dateConversionDay,
						options->dateConversionHour,options->dateConversionMinute,options->dateConversionSeconds,options);
				break;
			case DateConversionModeDoY:
				if (options->dateConversionYear<1980 || (options->dateConversionYear==1980 && options->dateConversionDoY<6)) {
					//06/01/1980 or GPSWeek/DoW 0/0, the start of GPS time
					printError("Minimum accepted date is 1980/01/06 (YYYY/MM/DD) or 1980/006 (Year/DoY) or 0/0 (GPSWeek/SoW) or 44244/0 (MJDN/SoD)",options);
				}
				ConvertDoYDate(options->dateConversionYear,options->dateConversionDoY,options->dateConversionSoD,options);
				break;
			case DateConversionModeGPSWeek:
				ConvertGPSWeekDate(options->dateConversionGPSWeek,options->dateConversionSoW,options);
				break;
			default:	//DateConversionModeMJDN
				if(options->dateConversionMJDN<44244) {
					//MJDN 44244 is 06/01/1980, or GPSWeek/DoW 0/0, the start of GPS time
					printError("Minimum accepted date is 1980/01/06 (YYYY/MM/DD) or 1980/006 (Year/DoY) or 0/0 (GPSWeek/SoW) or 44244/0 (MJDN/SoD)",options);
				}
				ConvertMJDNDate(options->dateConversionMJDN,options->dateConversionSoD,options);
				break;
		}
	}
	if (options->coordConversionMode!=CoordConversionModeNone) {
		switch(options->coordConversionMode) {
			case CoordConversionModeXYZ:
				ConvertCartesianCoord(options->coordConversionX,options->coordConversionY,options->coordConversionZ,options);
				break;
			case CoordConversionModeGeod:
				ConvertGeodeticCoord(options->coordConversionLon,options->coordConversionLat,options->coordConversionHgt,options);
				break;
			default: //CoordConversionModeSph
				ConvertSphericalCoord(options->coordConversionLon,options->coordConversionLat,options->coordConversionRadius,options);
				break;
		}
	}

	//If there has been DGNSS/date/coordinate conversion, free memory and exit
	if (options->RTCMmode == ConvertRTCM2||options->RTCMmode == ConvertRTCM3 || 
			options->dateConversionMode!=DateConversionModeNone || options->coordConversionMode!=CoordConversionModeNone) {
		if (printProgress) {
			if (options->ProgressEndCharac=='\r') {		
				//This is to clear terminal for characters after finishing (in Windows is not necessary as it adds a newline when the process finishes)
				fprintf(options->terminalStream,"%95s%c","",options->ProgressEndCharac); 
			}
			#if !defined (__WIN32__)
				//Enable cursor if necessary
				if (sopt->disableCursor==1) {
					fprintf(options->terminalStream,"%s",enableCursor);
				}
				fflush_function(options->terminalStream);
			#endif
		}
		if (SBASdatabox.numlinesmissing!=NULL) {
			free(SBASdatabox.numlinesmissing);
		}
		if (SBASdatabox.missingmessagesvector!=NULL) {
			free(SBASdatabox.missingmessagesvector);
		}
		for(i=0;i<MAX_LINES_BUFFERED_SBAS_MESSAGES;i++) {
			free(SBASdatabox.bufferlines[i]);
		}
		freeInputMeasString(sopt);
		free(SBASdatabox.SBASdata);
		free(epoch);
		free(solution);
		free(sopt);
		free(rtcm2);
		free(rtcm3);
		//Print processing time
		if (options->printInfo==1 && (options->RTCMmode == ConvertRTCM2||options->RTCMmode == ConvertRTCM3)) {
			computeProcessingTime(StartTimeRealPCTime,&totalprocessingTime,1,options);
		}
		//Free options structure
		freeOptions(options);
		free(options);
		exit(0);
	}
	
	//Init epoch after reading options
	initEpoch(epoch,options);

	//Disable HDOPorPDOP flag if any of HDOP or PDOP are not enabled
	if (options->workMode==wmSBASPLOTS) {
		if (options->HDOPPlot!=1 || options->PDOPPlot!=1) {
			options->HDOPorPDOP=0;
		}
	} else {
		if (options->HDOPthreshold!=1 || options->PDOPthreshold!=1) {
			options->HDOPorPDOP=0;
		}
	}

	//Add User Error to RINEX measurements
	if (options->workMode == wmUSERERROR2RINEX) {
		sprintf(messagestr,"Input RINEX observation file: %s",sopt->obsFile);
		printInfo(messagestr,options);
		if (sopt->glonavFile[0]!='\0') {
			sprintf(messagestr,"Input RINEX navigation file for GLONASS frequencies: %s",sopt->glonavFile);
			printInfo(messagestr,options);
		}	
		sprintf(messagestr,"User defined error input file: %s",sopt->addederrorFile);
		printInfo(messagestr,options);
		sprintf(messagestr,"Output RINEX observation file: %s",sopt->rnxFile);
		printInfo(messagestr,options);
		
		AddUserError2RINEX(sopt->obsFile,sopt->addederrorFile,sopt->glonavFile,sopt->rnxFile,epoch,&UserError,options);
		//Enable cursor
		if (printProgress) {
			fprintf(options->terminalStream,"%.56s (100%%)%10s%c",Epochstr,"",options->ProgressEndCharac);
			//The fflush_function of the terminal is to avoid flickering of the cursor due to the high output write rate
			fflush_function(options->terminalStream);
			#if !defined (__WIN32__)
				//This is to clear terminal for characters after finishing (in Windows is not necessary as it adds a newline when the process finishes)
				fprintf(options->terminalStream,"%70s%c","",options->ProgressEndCharac); 
				//Enable cursor if necessary
				if (sopt->disableCursor==1) {
					fprintf(options->terminalStream,"%s",enableCursor);
				}
				fflush_function(options->terminalStream);
			#endif
		}
		//Print processing time
		if (options->printInfo==1) {
			computeProcessingTime(StartTimeRealPCTime,&totalprocessingTime,1,options);
		}
		if (SBASdatabox.numlinesmissing!=NULL) {
			free(SBASdatabox.numlinesmissing);
		}
		if (SBASdatabox.missingmessagesvector!=NULL) {
			free(SBASdatabox.missingmessagesvector);
		}
		for(i=0;i<MAX_LINES_BUFFERED_SBAS_MESSAGES;i++) {
			free(SBASdatabox.bufferlines[i]);
		}
		freeInputMeasString(sopt);
		free(SBASdatabox.SBASdata);
		free(epoch);
		//Free options structure
		freeOptions(options);
		free(options);
		free(solution);
		free(sopt);
		free(rtcm2);
		free(rtcm3);
		exit(0);
	}

	// SBAS data. It must be at the beginning because we can do only file format conversion
	if ( options->SBAScorrections>=SBASionoOnly ) {

		// If the option of using Klobuchar in first epochs is enabled or select GEO with highest elevation is enabled, set the receiver solution to not converged
		if ( (options->initcoordNPA == 1 || options->GEOPRNSelected==-1 || options->GEOPRNSelected==2) && options->receiverPositionSource >= rpCALCULATE ) epoch->receiver.receiverSolConverged = 0;

		//Unselect model all measurements option
		if (options->SBAScorrections>=SBAS1Fused) {
			if (options->ModelAllMeas==1) {
				options->ModelAllMeas=0;
				options->ForcedNoModelAllMeas=1;
			}
		}

		//In SBAS plots mode, disable GEO constellations at set the initial
		//constellations tracked to 0. The constellation tracked will be set
		//the tracked ones (except GEO as it is disabled) when a mask
		//message is read, which will be just some lines below,
		//where readSBASFile is called (in SBAS plots mode, it will read data
		//until start of day is found)
		if (options->SBAScorrections>=SBASMaps1freqUsed) {
			epoch->numSatellites=0;
			options->ConstellationUsed[GEO]=0;
			for(i=0;i<MAX_SAT_GEO;i++) {
				options->numSBASConstList[i][SBAS1FMODEPOS]=0;
				options->numSBASConstList[i][SBASDFMCMODEPOS]=0;
				for(j=0;j<MAX_GNSS;j++) {
					options->SBASConstList[i][SBAS1FMODEPOS][j]=-1;
					options->SBASConstList[i][SBASDFMCMODEPOS][j]=-1;
				}
			}
		}

		// Save user tmout values
		for(i=0;i<NUMPOSFREQSBASMSG;i++) {
			memcpy(SBASdatabox.SBASdata[0].timeoutmessages[i],options->usertmout,sizeof(options->usertmout));
		}

		epoch->t.MJDN = -1;
		epoch->t.SoD = 0.0;
		if ( sopt->sbasFile[0] != '\0' ) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading SBAS data%60s%c","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			if ( readSBASFile(sopt->sbasFile, &SBASdatabox, &rinexBVersion, &epoch->t, options) != 1 ) {
				if ( (int)rinexBVersion > 2 && rinexBVersion != 0 ) {
					sprintf(messagestr, "RINEX-B version %1.2f from file [%s] not supported. Supported version is 2", rinexBVersion, sopt->sbasFile);
					printError(messagestr, options);
				} else {
					sprintf(messagestr, "Reading SBAS input file [%s]", sopt->sbasFile);
					printError(messagestr, options);
				}
			}
		} else {
			printError("No SBAS file provided, but SBAS corrections are selected", options);
		}
		if ( options->onlyconvertSBAS == 1 ) {
			if (printProgressConvert==1 ) {
				fprintf(options->terminalStream,"Percentage converted: %5d%%%60s%c",100,"",options->ProgressEndCharac);
				#if !defined (__WIN32__)
					if (sopt->disableCursor==1) {
						//Enable cursor again
						fprintf(options->terminalStream,"%s",enableCursor);
					}
				#endif
				fflush_function(options->terminalStream);
			}
			//Print processing time
			if (options->printInfo==1) {
				computeProcessingTime(StartTimeRealPCTime,&totalprocessingTime,1,options);
			}
			if (SBASdatabox.numlinesmissing!=NULL) {
				free(SBASdatabox.numlinesmissing);
			}
			if (SBASdatabox.missingmessagesvector!=NULL) {
				free(SBASdatabox.missingmessagesvector);
			}
			for(i=0;i<MAX_LINES_BUFFERED_SBAS_MESSAGES;i++) {
				free(SBASdatabox.bufferlines[i]);
			}
			freeInputMeasString(sopt);
			free(SBASdatabox.SBASdata);
			free(epoch);
			free(solution);
			free(sopt);
			free(rtcm2);
			free(rtcm3);
			//Free options structure
			freeOptions(options);
			free(options);
			exit(0);
		}

		// Check if there is a user sigma multipath model to be read
		if ( options->usersigmamultipath == 1 ) {
			if ( sopt->sigmamultipathFile[0] != '\0' )	 {
				if ( readsigmamultipathFile(sopt->sigmamultipathFile,SBASdatabox.SBASdata,options) != 1 ) {
					sprintf(messagestr,"Reading SBAS sigma multipath file [%s]",sopt->sigmamultipathFile);
					printError(messagestr,options);
				}
			} else {
				printError("No user defined sigma multipath model file provided, but user defined sigma multipath model is selected",options);
			}
		}
	} else {
        //In non SBAS mode, if NeQuick model is enabled, position is set to calculate and initcoordNPA is enabled (option iniitally set
        //for SBAS to use Klobuchar when converging, now reused for NeQuick also for converging), then set receiver solution not converged
        if ( options->initcoordNPA == 1 && options->ionoModel==neQuickIonoModel && options->receiverPositionSource >= rpCALCULATE ) epoch->receiver.receiverSolConverged = 0;
	}

	if(options->useDatasummary == 1) {
		Summary=1;
	} else {
		Summary=0;
	}

	// If Stanford-ESA plot is selected, compute the number of pixels and give size to StdEsa.count matrix
	if ( options->stanfordesa == 1 ) {
		// Open file for writing Stanford-ESA plot data
		//Create directory recursively if needed
		ret=mkdir_recursive(sopt->stanfordESAFile);
		if(ret!=0) {
		   //Error when creating the directory, and it is not due to that the directory already exists
		   sprintf(messagestr,"When creating [%s] folder for writing Stanford-ESA plot data",sopt->stanfordESAFile);
		   printError(messagestr,options);
		}

		fdstdESA = fopen(sopt->stanfordESAFile,"w");
		if ( fdstdESA == NULL ) {
			sprintf(messagestr,"Opening [%s] file for writing Stanford-ESA plot data",sopt->stanfordESAFile);
			printError(messagestr,options);
		}

		if (options->stanfordesaLOI == 1) {
			// Open file for writing Stanford-ESA plot data
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->stanfordESALOIFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing Stanford-ESA LOI data",sopt->stanfordESALOIFile);
			   printError(messagestr,options);
			}
			options->fdstdESALOI = fopen(sopt->stanfordESALOIFile,"w");
			if ( options->fdstdESALOI == NULL ) {
				sprintf(messagestr,"Opening [%s] file for writing Stanford-ESA LOI data",sopt->stanfordESALOIFile);
				printError(messagestr,options);
			}
			//Write header to file
			if (options->printV5format==0) {
				fprintf(options->fdstdESALOI,"#YEAR DoY      SoD HH:MM:SS.zz GPSWeek       SoW HIR_THR VIR_THR       HPE       VPE       HPL       VPL       HIR       VIR TOTALSAT USEDSAT LISTSAT\n");
			} else {
				fprintf(options->fdstdESALOI,"#YEAR DoY      SoD GPSWeek       SoW HIR_THR VIR_THR       HPE       VPE       HPL       VPL       HIR       VIR TOTALSAT USEDSAT LISTSAT\n");
			}
		}

		// Copy values from sopt structure
		StdESA.xmax = sopt->stfdesaxmax;
		StdESA.ymax = sopt->stfdesaymax;
		StdESA.xstep = sopt->stfdesaxres;
		StdESA.ystep = sopt->stfdesayres;

		// Initialize StdESA structure
		initStfdESA(&StdESA,options->stanfordesa);
	} else {
		//Initialize StdESA values so values are 0 when printing last line of summary
		// Copy values from sopt structure
		StdESA.xmax = sopt->stfdesaxmax;
		StdESA.ymax = sopt->stfdesaymax;
		StdESA.xstep = sopt->stfdesaxres;
		StdESA.ystep = sopt->stfdesayres;

		// Initialize StdESA structure
		initStfdESA(&StdESA,options->stanfordesa);
	}

	// Set Minimum Arc Length for Cycle Slip Detectors
	options->minArcLength = max(options->csSFsamples*options->csSF,max(options->csLIsamples*options->csLI,options->csMWsamples*options->csMW));
	options->minArcLength = max(options->minArcLength,options->csIGFsamples*options->csIGF);

	// Read files
	if ( sopt->obsFile[0] != '\0' ) {
		// Note that the file is opened in "rb" mode, "r" is for readonly, and "b" is for binary mode. In Linux, the "b" flag is ignored,
		// but, in Windows it will make to not merge multibyte character into a single one (for example the windows newline \r\n to a \n)
		// This is important if you are going to use the fseek function with this file, because if you are reading a text file with a
		// Linux end of file ("\n") in Windows, fseek will not work well unless the file is opened with binary mode (due to fseek expects
		// the Windows end of line ("\r\n") when opening the file in normal mode.
		// The only downside of opening a file in binary mode is that you can't use the fseek function with the "SEEK_END" flag, because
		// it may have undefined behaviour (according to C Standard "because of possible trailing null characters")
		// In gLAB, the fseek function is only used in the getLback function
		fdRNX = fopen(sopt->obsFile,"rb");
		if ( fdRNX == NULL) {
			sprintf(messagestr,"Opening RINEX observation file [%s]",sopt->obsFile);
			printError(messagestr,options);
		} else if (whatFileTypeIs(sopt->obsFile)!=ftRINEXobservation) {
			sprintf(messagestr,"Reading RINEX observation file [%s]",sopt->obsFile);
			printError(messagestr,options);
		}
	}
	

	if ( sopt->dgnssFile[0] != '\0' ) {
		fdRNXdgnss = fopen(sopt->dgnssFile,"rb");
		if ( fdRNXdgnss == NULL) {
			sprintf(messagestr, "Opening RINEX observation file [%s] for reference station in DGNSS mode", sopt->dgnssFile);
			printError(messagestr, options);
		} else if ( whatFileTypeIs(sopt->dgnssFile)!=ftRINEXobservation) {
			sprintf(messagestr, "Reading RINEX observation file [%s] for reference station in DGNSS mode", sopt->dgnssFile);
			printError(messagestr, options);
		} else {
			sprintf(messagestr, "RINEX observation input file as reference station: %s", sopt->dgnssFile);
			printInfo(messagestr, options);
		}
	}

	// RTCM unknown version
	RTCMversion = 0;
	if ( sopt->rtcmFile[0] != '\0' ) {
		options->RTCMmode = RTCMCheckVersion; // Check what version of RTCM is the binary file
		if ( !(fdRTCM = fopen(sopt->rtcmFile, "rb")) ) {
			sprintf(messagestr, "Opening the RTCM binary file [%s]", sopt->rtcmFile);
			printError(messagestr, options);
		}
		RTCMversion = converterRTCM2(fdRTCM, rtcm2, NULL, NULL, NULL, options);
		if ( RTCMversion == 2 ) strcpy(sopt->rtcm2File, sopt->rtcmFile);
		else {
			RTCMversion = converterRTCM3(fdRTCM, rtcm3, NULL, NULL, epoch, options);
			if ( RTCMversion != 3 ) {
				fclose(fdRTCM);
				free(rtcm2);
				free(rtcm3);
				sprintf(messagestr, "File [%s] format unknown.", sopt->rtcmFile);
				printError(messagestr, options);
			} else strcpy(sopt->rtcm3File, sopt->rtcmFile);
		}
	}
	// RTCM v2.x
	if ( sopt->rtcm2File[0] != '\0' ) {
		if ( !(fdRTCM2 = fopen(sopt->rtcm2File, "rb")) ) {
			sprintf(messagestr, "Opening RTCM v2.x binary file [%s] for reference station in DGNSS mode", sopt->rtcm2File);
			printError(messagestr, options);
		} else if ( options->rtcmYear == 0 || options->rtcmMonth == 0 || options->rtcmDay == 0 ) {
			sprintf(messagestr, "Option \"-input:rtcm:initdate\" must be set");
			printError(messagestr, options);
		} else if ( options->rtcmHour == -1 ) {
			sprintf(messagestr, "Option \"-input:rtcm:inithour\" must be set");
			printError(messagestr, options);
		} else {
			options->RTCMmode = RTCMCheckVersion;
			RTCMversion = converterRTCM2(fdRTCM2, rtcm2, NULL, NULL, NULL, options);
			if ( RTCMversion != 2 ) {
				fclose(fdRTCM2);
				free(rtcm2);
				free(rtcm3);
				sprintf(messagestr, "File [%s] does not have RTCM v2.x format.", sopt->rtcm2File);
				printError(messagestr, options);
			}
			sprintf(messagestr, "RTCM v2.x as reference station input file: %s", sopt->rtcm2File);
			printInfo(messagestr, options);
			options->RTCMmode = ProcessRTCM2;
		}
	}
	// RTCM v3.x
	if ( sopt->rtcm3File[0] != '\0' ) {
		if ( !(fdRTCM3 = fopen(sopt->rtcm3File, "rb")) ) {
			sprintf(messagestr, "Opening RTCM v3.x binary file [%s] for reference station in DGNSS mode", sopt->rtcm3File);
			printError(messagestr,options);
		} else if ( options->rtcmYear == 0 || options->rtcmMonth == 0 || options->rtcmDay == 0 ) {
			sprintf(messagestr, "Option \"-input:rtcm:initdate\" must be set");
			printError(messagestr, options);
		} else {
			options->RTCMmode = RTCMCheckVersion;
			RTCMversion = converterRTCM3(fdRTCM3, rtcm3, NULL, NULL, epoch, options);
			if ( RTCMversion != 3 ) {
				fclose(fdRTCM3);
				free(rtcm2);
				free(rtcm3);
				sprintf(messagestr, "File [%s] does not have RTCM v3.x format.", sopt->rtcm3File);
				printError(messagestr, options);
			}
			sprintf(messagestr, "RTCM v3.x as reference station input file: %s", sopt->rtcm3File);
			printInfo(messagestr, options);
			options->RTCMmode = ProcessRTCM3;
		}
	}
	// Actions in case of DGNSS mode
	if ( options->DGNSS ) {
		epochDGNSS = malloc(sizeof(TEpoch));
		initEpoch(epochDGNSS,options);
		epochDGNSS->DGNSSstruct=1;
		//Unselect model all measurements option
		if (options->ModelAllMeas==1) {
			options->ModelAllMeas=0;
			options->ForcedNoModelAllMeas=1;
		}

		// Check if S/A was enabled or not
		if ( options->RTCMmode > ConvertRTCM3 && options->RTCMmode < ProcessRINEX ) {
			DoY = date2doy((int)options->rtcmYear, (int)options->rtcmMonth, (int)options->rtcmDay);
			MJDNValue = (int)yeardoy2MJDN((int)options->rtcmYear, DoY, 0);
			// We do not apply Range Rate Corrections because we assume S/A disabled.
			// In case of S/A enabled, the maximum age is set to 1 seconds
			if ( MJDNValue < epoch->FirstEpochSAoff.MJDN /*May 2nd, 2000*/ ) {
				options->maxAgeDGNSS = 1;
				printInfo("WARNING the maximum age to apply DGNSS corrections is forced to 1 seconds due to S/A", options);
			}
		}

		//Only set value to epochDGNSSfillSat when DGNSS mode is RTCM3 or RINEX observation file, so
		//the function fillUsableSatellites only prints SATSEL in these DGNSS modes
		if (options->RTCMmode==ProcessRTCM3 || options->RTCMmode==ProcessRINEX ) {
			epochDGNSSfillSat=epochDGNSS;
		}

		//Check receiver position mode in DGNSS is valid (user defined reference station is only allowed with RINEX files)
		if ( options->receiverPositionSource >= rpRTCMUserbaseline && ( sopt->rtcmFile[0] != '\0' || sopt->rtcm3File[0] != '\0' || sopt->rtcm3File[0] != '\0' ) ) {
			printError("Receiver position modes 'DGNSSUserRoverRef', 'DGNSSUserRoverRefGeod', 'DGNSSUserbaseline', 'DGNSSUserGeodbaseline',  'DGNSSUserRinexRover', 'DGNSSUserGeodRinexRover', 'DGNSSRefRoverUSER', 'DGNSSRefGeodRoverUSERGeod', 'DGNSSRefCarRoverUSERGeod' or 'DGNSSRefGeodRoverUSERCar' are only allowed when the reference station data is from a RINEX file. Convert the RTCM file to RINEX and process with the converted RINEX file",options);
		}
	}
	for(i=0;i<sopt->numNav;i++) {
		if ( sopt->navFile[i][0] != '\0' ) {
			fdRNXnav[i] = fopen(sopt->navFile[i],"rb");
			if (fdRNXnav[i] == NULL) {
				sprintf(messagestr,"Opening RINEX navigation file [%s]",sopt->navFile[i]);
				printError(messagestr,options);
			} else if (whatFileTypeIs(sopt->navFile[i])!=ftRINEXbroadcast) {
				sprintf(messagestr,"Reading RINEX navigation file [%s]",sopt->navFile[i]);
				printError(messagestr,options);
			}
		}
	}
	if ( sopt->klbFile[0] != '\0' ) {
		fdRNXKlb = fopen(sopt->klbFile,"rb");
		if (fdRNXKlb == NULL) {
			sprintf(messagestr,"Opening RINEX navigation file [%s]",sopt->klbFile);
			printError(messagestr,options);
		} else if (whatFileTypeIs(sopt->klbFile)!=ftRINEXbroadcast) {
			sprintf(messagestr,"Reading RINEX navigation file [%s]",sopt->klbFile);
			printError(messagestr,options);
		}
	}
	if ( sopt->beiFile[0] != '\0' ) {
		fdRNXBei = fopen(sopt->beiFile,"rb");
		if ( fdRNXBei == NULL) {
			sprintf(messagestr,"Opening RINEX navigation file [%s]",sopt->beiFile);
			printError(messagestr,options);
		} else if (whatFileTypeIs(sopt->beiFile)!=ftRINEXbroadcast) {
			sprintf(messagestr,"Reading RINEX navigation file [%s]",sopt->beiFile);
			printError(messagestr,options);
		}
	}
	if ( sopt->neqFile[0] != '\0' ) {
		fdRNXNeq = fopen(sopt->neqFile,"rb");
		if ( fdRNXNeq == NULL ) {
			sprintf(messagestr,"Opening RINEX navigation file [%s]",sopt->neqFile);
			printError(messagestr,options);
		} else if (whatFileTypeIs(sopt->neqFile)!=ftRINEXbroadcast) {
			sprintf(messagestr,"Reading RINEX navigation file [%s]",sopt->neqFile);
			printError(messagestr,options);
		}
	}
	if ( sopt->inxFile[0] != '\0' ) {
		fdIONEX = fopen(sopt->inxFile,"rb");
		if ( fdIONEX == NULL ) {
			sprintf(messagestr,"Opening IONEX file [%s]",sopt->inxFile);
			printError(messagestr,options);
		} else if (whatFileTypeIs(sopt->inxFile)!=ftIONEX) {
			sprintf(messagestr,"Reading IONEX file [%s]",sopt->inxFile);
			printError(messagestr,options);
		}
	}
	if ( options->workMode == wmDOPROCESSING || options->workMode == wmSHOWINPUT ) {
		if ( sopt->SP3File[0][0] != '\0' ) {
			if (!(fdSP3 = fopen(sopt->SP3File[0],"rb"))) {
				sprintf(messagestr,"Opening SP3 orbit products file [%s]",sopt->SP3File[0]);
				printError(messagestr,options);
			}
		}
		if ( sopt->orbFile[0][0] != '\0' ) {
			if (!(fdSP3o = fopen(sopt->orbFile[0],"rb"))) {
				sprintf(messagestr,"Opening SP3 orbit products file [%s]",sopt->orbFile[0]);
				printError(messagestr,options);
			}
		}
		if ( sopt->clkFile[0][0] != '\0' ) {
			if (!(fdCLK = fopen(sopt->clkFile[0],"rb"))) {
				sprintf(messagestr,"Opening clock products file [%s]",sopt->clkFile[0]);
				printError(messagestr,options);
			}
		}
	}

	// Open navigation health file (for PPP), output KML, KML0, SP3 and reference files
	if ( options->workMode == wmDOPROCESSING ) {

		if (sopt->numNavHealth > 0 ) {
			if (sopt->navMode!=NMppp) {
				printError("Option '-input:navhealth' can only be used when processing with precise products",options);
			} else if (options->satHealthMode==BRDCUseAnyHealth) {
				printError("Option '-input:navhealth' set, but user also set option '--model:satellitehealth' for ignoring health flags",options);
			} else if (options->brdcHealthSkip[BRDCUnhealthy]==1) {
				printError("Option '-input:navhealth' set, but user also set option '-model:skipunhealthymarg' or '-model:skipunhealthy' for skipping unhealthy messages",options);
			}
			for(i=0;i<sopt->numNavHealth;i++) {
				fdRNXHealthPPP[i] = fopen(sopt->navHealthFile[i],"rb");
				if (fdRNXHealthPPP[i] == NULL ) {
					sprintf(messagestr,"Opening broadcast navigation file [%s]",sopt->navHealthFile[i]);
					printError(messagestr,options);
				} else if (whatFileTypeIs(sopt->navHealthFile[i])!=ftRINEXbroadcast) {
					sprintf(messagestr,"Reading broadcast navigation file [%s]",sopt->navHealthFile[i]);
					printError(messagestr,options);
				}
			}
		}

		if ( sopt->kmlFile[0] != '\0' && sopt->kml0File[0] != '\0' && strcmp(sopt->kmlFile,sopt->kml0File)==0) {
			sprintf(messagestr,"KML files with the solution and the ground projection cannot have the same filename");
			printError(messagestr,options);
		}
		if ( sopt->kmlFile[0] != '\0' ) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->kmlFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing KML file",sopt->kmlFile);
			   printError(messagestr,options);
			}
			options->fdkml=fopen(sopt->kmlFile,"w");
			if (options->fdkml==NULL) {
				sprintf(messagestr,"Opening KML output file [%s]",sopt->kmlFile);
				printError(messagestr,options);
			} else {
				//Insert XML opening tags
				writeKMLtags(options->fdkml,epoch,sopt->obsFile,0,0,VERSION,options);
			}
		}
		if ( sopt->kml0File[0] != '\0' ) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->kml0File);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing KML (ground projection) file",sopt->kml0File);
			   printError(messagestr,options);
			}
			options->fdkml0=fopen(sopt->kml0File,"w");
			if (options->fdkml0==NULL) {
				sprintf(messagestr,"Opening KML (ground projection) output file [%s]",sopt->kml0File);
				printError(messagestr,options);
			} else {
				//Insert XML opening tags
				writeKMLtags(options->fdkml0,epoch,sopt->obsFile,0,1,VERSION,options);
			}
		}

		if ( sopt->SP3OutputFile[0] != '\0' ) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->SP3OutputFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SP3 file",sopt->SP3OutputFile);
			   printError(messagestr,options);
			}
			fdOutSP3=fopen(sopt->SP3OutputFile,"w");
			if (fdOutSP3==NULL) {
				sprintf(messagestr,"Opening SP3 output file [%s]",sopt->SP3OutputFile);
				printError(messagestr,options);
			} 
		}
		if ( sopt->RefPosOutputFile[0] != '\0' ) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->RefPosOutputFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing reference file",sopt->RefPosOutputFile);
			   printError(messagestr,options);
			}
			fdOutRefFile=fopen(sopt->RefPosOutputFile,"w");
			if (fdOutRefFile==NULL) {
				sprintf(messagestr,"Opening reference position output file [%s]",sopt->RefPosOutputFile);
				printError(messagestr,options);
			} 
			#if defined _OPENMP
				fprintf(fdOutRefFile,"#gLAB version v%s (with OpenMP multithread), built on %s %s\n",VERSION,__DATE__,__TIME__);
			#else
				fprintf(fdOutRefFile,"#gLAB version v%s, built on %s %s\n",VERSION,__DATE__,__TIME__);
			#endif
			fprintf(fdOutRefFile,"#Solution in %s mode for file %s\n",SolutionModeNum2SolutionModeChar(options->solutionMode),sopt->obsFile);
			if (options->DGNSS) {
				fprintf(fdOutRefFile,"#Solutions in SPP are%s included\n",options->WriteSPPsolInDGNSSmodeRefFile?"":" not");
			}
			if (options->GPSWeekRefFile==1) {
				if (options->GeodeticCoordRefFile==1) {
				 	fprintf(fdOutRefFile,"#Geodetic coordinates are in WGS84 datum\n#Latitude is in degrees [-90º..90º]\n#Longitude is in degrees [-180º..180º]\n#Height is in metres\n");
					fprintf(fdOutRefFile,"GPSWeek    SoW      Longitude       Latitude         Height\n");
				} else {
					fprintf(fdOutRefFile,"#Cartesian coordinates are in WGS84 datum\n#X, Y and Z are in metres\n");
					fprintf(fdOutRefFile,"GPSWeek    SoW              X              Y              Z\n");
				}
			} else if (options->CalendarTimeRefFile==1) {
				if (options->GeodeticCoordRefFile==1) {
				 	fprintf(fdOutRefFile,"#Geodetic coordinates are in WGS84 datum\n#Latitude is in degrees [-90º..90º]\n#Longitude is in degrees [-180º..180º]\n#Height is in metres\n");
					fprintf(fdOutRefFile,"Date               Time      Longitude       Latitude         Height\n");
				} else {
					fprintf(fdOutRefFile,"#Cartesian coordinates are in WGS84 datum\n#X, Y and Z are in metres\n");
					fprintf(fdOutRefFile,"Date               Time              X              Y              Z\n");
				}
			} else {
				if (options->GeodeticCoordRefFile==1) {
					fprintf(fdOutRefFile,"#Geodetic coordinates are in WGS84 datum\n#Latitude is in degrees [-90º..90º]\n#Longitude is in degrees [-180º..180º]\n#Height is in metres\n");
					fprintf(fdOutRefFile,"Year DoY       SoD      Longitude       Latitude         Height\n");
				} else {
					fprintf(fdOutRefFile,"#Cartesian coordinates are in WGS84 datum\n#X, Y and Z are in metres\n");
					fprintf(fdOutRefFile,"Year DoY       SoD              X              Y              Z\n");
				}
			}
		}
	}

	// Initialise sigma from user options
	for ( i=0;i<MAX_SATELLITES_VIEWED;i++ ) {
		for(j=0;j<MAX_CS_LIST;j++) {
			epoch->cycleslip.SFsigma[i][j] = pow(options->csSFinit,2);
		}
	}
	if ( options->DGNSS == 1 ) {
		for ( i=0;i<MAX_SATELLITES_VIEWED;i++ ) {
			for(j=0;j<MAX_CS_LIST;j++) {
				epochDGNSS->cycleslip.SFsigma[i][j] = pow(options->csSFinit, 2);
			}
		}
	}
	
	// Satellite Constellation Data
	// Priority is given to the ANTEX file
	if ( sopt->antFile[0] != '\0' ) { // ANTEX file
		if (printProgress==1) {	
			if (options->ProgressEndCharac=='\r') {
				//Printing to a terminal
				fprintf(options->terminalStream,"Reading ANTEX file%50s%c","",options->ProgressEndCharac);
				fflush_function(options->terminalStream);
			}
		}
		if ( readAntexFile(sopt->antFile,&constellation,&antennaList,0,options) != 1 ) {
			sprintf(messagestr,"Reading ANTEX file [%s]",sopt->antFile);
			printError(messagestr,options);
		}

		//Use the ANTEX used for computing APC corrections for printing block type and SVN if
		//APC correction is enabled and SP3 files is used (otherwise APC corrections is not enabled)
		if (options->satellitePhaseCenter && (sopt->SP3File[0][0] != '\0' || sopt->orbFile[0][0] != '\0') ) {
			constellationPrint=&constellation;
		}

		if (sopt->numAntRec>0) {
			for(i=0;i<sopt->numAntRec;i++) {
				if (sopt->antrecFile[i][0]=='\0') continue;
				if ( readAntexFile(sopt->antrecFile[i],&constellation,&antennaList,1,options) != 1 ) {
					sprintf(messagestr,"Reading receiver ANTEX file [%s]",sopt->antrecFile[i]);
					printError(messagestr,options);
				}
			}
		}
	} else if ( sopt->conFile[0] != '\0' ) { // Constellation Status file
		if ( readConstellationFile(sopt->conFile,&constellation,options) != 1 ) {
			sprintf(messagestr,"Reading constellation file [%s]",sopt->conFile);
			printError(messagestr,options);
		}
	} 

	//Read satellite block type from ANTEX file
	if ( sopt->antsatblockFile[0] != '\0' ) { // ANTEX file for reading block data
		if (printProgress==1) {	
			if (options->ProgressEndCharac=='\r') {
				//Printing to a terminal
				fprintf(options->terminalStream,"Reading ANTEX file for satellite blocks%50s%c","",options->ProgressEndCharac);
				fflush_function(options->terminalStream);
			}
		}
		if ( readAntexFile(sopt->antsatblockFile,&constellationSatBlock,&antennaListSatBlock,0,options) != 1 ) {
			sprintf(messagestr,"Reading ANTEX file for satellite blocks [%s]",sopt->antsatblockFile);
			printError(messagestr,options);
		}
		//Use the ANTEX used for computing APC corrections for printing block type and SVN if APC corrections are not applied
		if (constellationPrint==NULL) {
			constellationPrint=&constellationSatBlock;
		}
	} else if (sopt->antFile[0] != '\0' ) {
		//File for constellation data not provided, use data for ANTEX file
		memcpy(&constellationSatBlock,&constellation,sizeof(TConstellation));
		memcpy(&antennaListSatBlock,&antennaList,sizeof(TAntennaList));
		if (constellationPrint==NULL) {
			constellationPrint=&constellationSatBlock;
		}
	} else {
		//No ANTEX data available
		options->SatBlockMeasDiscard = 0;
		if (constellationPrint==NULL) {
			constellationPrint=&constellation;
		}
	}

	// Processing data
	if ( options->workMode == wmCOMPAREORBITS || options->workMode == wmSHOWPRODUCT ) {
		//Init TGD data for initializing variables (to avoid incorrect frees at the end)
		initTGD(&tgdData,options,0);
		//Enter comparison or show products mode
		productsProcessing(options,sopt,&constellation,constellationPrint);
	} else if ( options->workMode == wmDOPROCESSING || options->workMode == wmSHOWINPUT ) {
		if (printProgress==1 && sopt->numNav>0) {	
			if (options->ProgressEndCharac=='\r') {
				//Printing to a terminal
				fprintf(options->terminalStream,"Reading navigation file%s%50s%c",sopt->numNav==1?"":"s","",options->ProgressEndCharac);
				fflush_function(options->terminalStream);
			}
		}

		//In show Products mode, there are no orbit products, so we set start of products far in the past
		//and end of products far in the future so the checks regarding orbit time validity do not trigger
		if (options->workMode == wmSHOWINPUT ) {
			startProductsTime.MJDN=44244;
			startProductsTime.SoD=0.;
			endProductsTime.MJDN=999999999;
			endProductsTime.SoD=0;
		}

		newDayRinexNav=1;
		for(i=0;i<sopt->numNav;i++) {
			if ( fdRNXnav[i] != NULL ) {
				ret=readRinexNav(fdRNXnav[i],sopt->navFile[i], &products,&rinexNavVersion,newDayRinexNav==1?NEWDAYNAV:SAMEDAYNAV,options);
				navFilesVersion[ORBNAVPOS][numNavFilesVersion[ORBNAVPOS]]=(int)(rinexNavVersion*100);
				numNavFilesVersion[ORBNAVPOS]++;
				newDayRinexNav++;
				if ( ret < 1 ) {
					if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
						sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->navFile[i]);
						printError(messagestr,options);
					} else {
						sprintf(messagestr,"Reading RINEX navigation message file [%s]",sopt->navFile[i]);
						printError(messagestr,options);
					}
				} else if (ret==2) {
					nextNav[i]=1;
				} else {
					nextNav[i]=0;
					fclose(fdRNXnav[i]);
					fdRNXnav[i]=NULL;
				}
			}
		}
		if (sopt->numNav>0) {
			// Set products end time
			if ( options->workMode == wmDOPROCESSING ) {
				startProductsTime = getProductsFirstEpoch(&products);
				endProductsTime = getProductsLastEpoch(&products);
			}
			//Build list of available RINEX navigation message types
			for(m=0;m<2;m++) { 
				//Loop twice for orbits and DCB. 
				//If DCB files is given, data for DCB willbe overwritten
				for(i=0;i<MAX_GNSS;i++) {
					for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
						//Reset BRDCAvailSelOrder list
						for(k=0;k<=MAX_BRDC_TYPES;k++) {
							options->BRDCAvailSelOrder[m][i][j][k]=0;
						}
						//Fill with available messages
						l=0;
						for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
							if (products.BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
								options->BRDCAvailSelOrder[m][i][j][l]=options->BRDCSelOrder[i][j][k];
								l++;
							}
						}
						options->BRDCAvailSelOrder[m][i][j][MAX_BRDC_TYPES]=l;
					}
				}
			}
			products.BRDC->NavDataPosition=ORBNAVPOS;
		}
		if (sopt->numNavHealth>0 && options->workMode == wmDOPROCESSING) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading navigation file%s for satellite health%50s%c",sopt->numNavHealth==1?"":"s","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			newDayRinexNav=1;
			for(i=0;i<sopt->numNavHealth;i++) {
				if ( fdRNXHealthPPP[i] != NULL ) {
					ret=readRinexNav(fdRNXHealthPPP[i],sopt->navHealthFile[i], &productsHealthforPPP,&rinexNavVersion,newDayRinexNav==1?NEWDAYNAV:SAMEDAYNAV,options);
					navFilesVersion[HEALTHNAVPOS][numNavFilesVersion[HEALTHNAVPOS]]=(int)(rinexNavVersion*100);
					numNavFilesVersion[HEALTHNAVPOS]++;
					newDayRinexNav++;
					if ( ret < 1 ) {
						if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
							sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->navHealthFile[i]);
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"Reading RINEX navigation message file [%s]",sopt->navHealthFile[i]);
							printError(messagestr,options);
						}
					} else if (ret==2) {
						nextNavHealth[i]=1;
					} else {
						nextNavHealth[i]=0;
						fclose(fdRNXHealthPPP[i]);
						fdRNXHealthPPP[i]=NULL;
					}
				}
			}
			//Build list of available RINEX navigation message types for health data
			for(i=0;i<MAX_GNSS;i++) {
				for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
					//Reset BRDCAvailSelOrder list
					for(k=0;k<=MAX_BRDC_TYPES;k++) {
						options->BRDCAvailSelOrder[HEALTHNAVPOS][i][j][k]=0;
					}
					//Fill with available messages
					l=0;
					for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
						if (productsHealthforPPP.BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
							options->BRDCAvailSelOrder[HEALTHNAVPOS][i][j][l]=options->BRDCSelOrder[i][j][k];
							l++;
						}
					}
					options->BRDCAvailSelOrder[HEALTHNAVPOS][i][j][MAX_BRDC_TYPES]=l;
				}
			}
			productsHealthforPPP.BRDC->NavDataPosition=HEALTHNAVPOS;
		}
		// SP3 with orbits and clocks
		if ( fdSP3 != NULL ) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading SP3 file for orbits and clocks%50s%c","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			ret = readSP3(fdSP3,&pastSP3Prod,1,1,0,options);
			if ( ret == 2 ) { // Large SP3, so read next products
				options->concatenSP3 = 1;
				options->numPreciseFiles = 1;
				ret = readSP3(fdSP3,&products,1,1,0,options);
				if ( ret == 2 ) {
					options->NextSP3 = 1;
					options->concatenSP3 = 1;
					options->numPreciseFiles = 1;
					ret = readSP3(fdSP3,&nextSP3Prod,1,1,0,options);
					if ( ret == 2 ) {
						options->NextSP3 = 1;
						// Set products end time
						if ( options->workMode == wmDOPROCESSING ) {
							startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
							endProductsTime = getProductsLastEpoch(&products);
						}
					} else {
						options->NextSP3 = 0;
						// Set products end time
						if ( options->workMode == wmDOPROCESSING ) {
							startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
							endProductsTime = getProductsLastEpoch(&nextSP3Prod);
						}
					}
				} else {
					memcpy(&nextSP3Prod,&products,sizeof(TGNSSproducts));
					options->NextSP3 = 0;
					// Set products end time
					if ( options->workMode == wmDOPROCESSING ) {
						startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
						endProductsTime = getProductsLastEpoch(&products);
					}
				}
			} else if ( ret < 1 ) {
				sprintf(messagestr,"Reading SP3 orbit and clock products file [%s]",sopt->SP3File[0]);
				printError(messagestr,options);
			} else {
				options->NextSP3 = 0;
				memcpy(&products,&pastSP3Prod,sizeof(TGNSSproducts));
				memcpy(&nextSP3Prod,&products,sizeof(TGNSSproducts));
				// Set products end time
				if ( options->workMode == wmDOPROCESSING ) {
					startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
					endProductsTime = getProductsLastEpoch(&pastSP3Prod);
				}
			}

		}
		// SP3 and CLK
		if ( fdSP3o != NULL && fdCLK != NULL ) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading SP3 file for orbits%50s%c","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			ret1 = readSP3(fdSP3o,&pastSP3Prod,1,0,0,options);
			if ( ret1 < 1 ) {
				sprintf(messagestr,"Reading SP3 orbit product file [%s]",sopt->orbFile[0]);
				printError(messagestr,options);
			}
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading precise clocks file%50s%c","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			ret2 = readRinexClocks(fdCLK,&pastSP3Prod,options);
			if ( ret2 < 1 ) {
				sprintf(messagestr,"Reading clock products file [%s]",sopt->clkFile[0]);
				printError(messagestr,options);
			}
			if ( ret1 == 2 && ret2 ==2 ) { // Large SP3 and clocks, so read next products
				options->concatenSP3 = 1;
				options->numPreciseFiles = 2;
				ret1 = readSP3(fdSP3o,&products,1,0,0,options);
				ret2 = readRinexClocks(fdCLK,&products,options);
				if ( ret1 == 2 && ret2 == 2 ) {
					options->NextSP3 = 1;
					ret1 = readSP3(fdSP3o,&nextSP3Prod,1,0,0,options);
					ret2 = readRinexClocks(fdCLK,&nextSP3Prod,options);
					if (ret1==2 && ret2==2) {
						options->NextSP3 = 1;
						// Set products end time
						if ( options->workMode == wmDOPROCESSING ) {
							startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
							endProductsTime = getProductsLastEpoch(&products);
						}
					} else {
						options->NextSP3 = 0;
						// Set products end time
						if ( options->workMode == wmDOPROCESSING ) {
							startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
							endProductsTime = getProductsLastEpoch(&nextSP3Prod);
						}
					}
				} else {
					options->NextSP3 = 0;	
					memcpy(&nextSP3Prod,&products,sizeof(TGNSSproducts));
					// Set products end time
					if ( options->workMode == wmDOPROCESSING ) {
						startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
						endProductsTime = getProductsLastEpoch(&nextSP3Prod);
					}
				}
				if(ret2 < 1 ) {
					options->NextSP3 = 0;	
					sprintf(messagestr,"Reading clock products file [%s]",sopt->clkFile[0]);
					printError(messagestr,options);
				}
			} else if ( ret1 == 2 ) {
				//Only SP3 concatenated
				options->concatenSP3 = 1;
				CurrentPosSP3file=ftell(fdSP3o);
				ret1 = readSP3(fdSP3o,&products,1,0,0,options);
				if (ret1==2) {
					ret1 = readSP3(fdSP3o,&nextSP3Prod,1,0,0,options);
				} else {
					//Read again SP3 file, so memory is allocated again for nextSP3Prod,
					//therefore avoding double free when freeing SP3 data
					fseek(fdSP3o,CurrentPosSP3file,SEEK_SET);
					ret1 = readSP3(fdSP3o,&nextSP3Prod,1,0,0,options);
					
				}
				printInfo("WARNING: SP3 orbit file is concatenated, but CLK file is not. Assuming it is to avoid Runge interpolation effect for a single day observation file",options);
				options->NextSP3 = 0;	
				//Read again CLK file, so memory is allocated again for nextSP3Prod and products,
				//therefore avoding double free when freeing CLK data
				fseek(fdCLK,0,SEEK_SET);
				ret2 = readRinexClocks(fdCLK,&products,options);
				fseek(fdCLK,0,SEEK_SET);
				ret2 = readRinexClocks(fdCLK,&nextSP3Prod,options);
				// Set products end time
				if ( options->workMode == wmDOPROCESSING ) {
					startProductsTime = getProductsFirstEpoch(&products);
					endProductsTime = getProductsLastEpoch(&products);
				}
			} else {
				if ( ret2 ==2 ) {
					printError("Clock file is concatenated, but SP3 file is not. Both files must be concatenated or at least the SP3 file",options);
				}
				options->NextSP3 = 0;
				memcpy(&products,&pastSP3Prod,sizeof(TGNSSproducts));
				memcpy(&nextSP3Prod,&products,sizeof(TGNSSproducts));
				// Set products end time
				if ( options->workMode == wmDOPROCESSING ) {
					startProductsTime = getProductsFirstEpoch(&pastSP3Prod);
					endProductsTime = getProductsLastEpoch(&nextSP3Prod);
				}
			}
		}

		//Concatenate SP3 and clocks
		if( fdSP3 != NULL || (fdSP3o != NULL && fdCLK != NULL)) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Ordering precise products data%50s%c","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			ConcatenateSP3(0,&products,&pastSP3Prod,&nextSP3Prod,options);	

			//Compute Max total distance between interpolation samples for orbits
			if(options->OrbitsMaxGaps==-1) {
				options->OrbitsMaxGaps=8;
			} 
			if(options->OrbitsMaxGaps!=0 && options->orbitInterpolationDegree!=0) {
				options->OrbitsMaxDistance=(double)(options->OrbitsMaxGaps)*products.SP3->orbits.interval;
			} else {
				options->OrbitsMaxDistance=0.;
			}

			//Compute Max total distance between first and last interpolation samples for orbits
			if(options->OrbitsToTMaxGaps==-1) {
				options->OrbitsToTMaxGaps=16;
			}
			if (options->OrbitsToTMaxGaps!=0) {
				options->OrbitsToTMaxDistance=(double)(options->orbitInterpolationDegree)*products.SP3->orbits.interval+(double)(options->OrbitsToTMaxGaps)*products.SP3->orbits.interval;
			} else {
				options->OrbitsToTMaxDistance=0.;
			}

			//Compute Max total distance between interpolation samples for clocks
			if(options->ClocksMaxGaps==-1) {
				options->ClocksMaxGaps=4;
			} 
			if(options->ClocksMaxGaps!=0) {
				options->ClocksMaxDistance=(double)(options->ClocksMaxGaps)*products.SP3->clocks.interval;
			} else {
				options->ClocksMaxDistance=0.;
			}

			//Compute Max total distance between first and last interpolation samples for clocks
			if(options->ClocksToTMaxGaps==-1) {
				options->ClocksToTMaxGaps=8;
			}
			if(options->ClocksToTMaxGaps!=0 && options->clockInterpolationDegree!=0) {
				options->ClocksToTMaxDistance=(double)(options->clockInterpolationDegree)*products.SP3->clocks.interval+(double)(options->ClocksToTMaxGaps)*products.SP3->clocks.interval;
			} else {
				options->ClocksToTMaxDistance=0.;
			}

			if(options->OrbitsToTMaxGaps<options->OrbitsMaxGaps) {
				sprintf(messagestr,"Maximum total number of data gaps in orbit interpolation given (%d) has to be equal or greater than the maximum number of data gaps between samples (%d)",options->OrbitsToTMaxGaps,options->OrbitsMaxGaps);
				printError(messagestr,options);
			}
		}

		if(options->ClocksToTMaxGaps<options->ClocksMaxGaps && options->clockInterpolationDegree!=0) {
			sprintf(messagestr,"Maximum total number of data gaps in clock interpolation given (%d) has to be equal or greater than the maximum number of data gaps between samples (%d)",options->ClocksToTMaxGaps,options->ClocksMaxGaps);
			printError(messagestr,options);
		}

		//Disable APC corrections if there are no SP3 orbits or no constellation data
		if ( sopt->antFile[0]=='\0' || products.type != SP3 ) {
			if ( options->satellitePhaseCenter == 1 ) {
				if ( sopt->antFile[0]=='\0' && products.type != SP3 ) {
					printInfo("Forcing disabling of satellite Antenna Phase corrections because there is no ANTEX file for satellite data and SP3 orbits are not used",options);
				} else {
					sprintf(messagestr,"Forcing disabling of satellite Antenna Phase corrections because %s",sopt->antFile[0]=='\0'?"ANTEX file for satellite data":"SP3 orbits are not used");
					printInfo(messagestr,options);
				}
			}
			options->satellitePhaseCenter = 0;
		}

		//Check if there no concatenated files when backwards processing is enabled
		if(options->filterIterations==2) {
			for(i=0;i<sopt->numNav;i++) {
				if (nextNav[i]==1) break;
			}
		   	if (options->concatenSP3==1||i<sopt->numNav) {
				printError("Concatening product files is incompatible with backward processing",options);
			}
		}

		//Check for user added error file
		if ( options->useraddednoise == 1 ) {
			if ( sopt->addederrorFile[0] == '\0' ) {
				printError("User added error option selected, but no filename given",options);
			}
			fdNoise = fopen(sopt->addederrorFile,"rb");
			if ( fdNoise == NULL ) {
				sprintf(messagestr,"Reading file [%s] for user added error to measurements",sopt->addederrorFile);
				printError(messagestr,options);
			}
			if (options->useraddednoisepreprocess==1) {
				options->useraddednoise = 2;
			}
		}

		// Ionosphere data
		switch(options->ionoModel) {
			case IONEXIonoModel:
				if ( fdIONEX != NULL ) {
					if (printProgress==1) {	
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading IONEX file%50s%c","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					ret = readIONEX(fdIONEX,&ionex,&ionexVersion,options);
					if ( ret < 1 ) {
						if ( (int)ionexVersion != 1 && ionexVersion != 0 ) {
							sprintf(messagestr,"IONEX version %1.2f from file [%s] is not supported. Supported version is 1",ionexVersion,sopt->inxFile);
							printError(messagestr,options);
						} else if (ret==-2) {
							sprintf(messagestr,"Number of records in IONEX header in file [%s] does not match the number of records read",sopt->inxFile);
							printError(messagestr,options);
						} else if (ret==-3) {
							sprintf(messagestr,"IONEX header in file [%s] is incorrect or there are missing records",sopt->inxFile);
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"Reading IONEX file [%s] for ionospheric data" ,sopt->inxFile);
							printError(messagestr,options);
						}
					} else if ( ret == 2 ) {
						sprintf(messagestr,"WARNING: IONEX file [%s] has no 'END OF FILE' line. File may not be complete",sopt->inxFile);
						printInfo(messagestr,options);
						fclose(fdIONEX);
						fdIONEX=NULL;
					} else if ( ret == 4 ) {
						sprintf(messagestr,"WARNING: IONEX file [%s] is concatenated, but has no 'END OF FILE' line. File may not be complete",sopt->inxFile);
						printInfo(messagestr,options);
					} else if ( ret != 3 ) {
						fclose(fdIONEX);
						fdIONEX=NULL;
					}
					
					// If there is no RMS data in IONEX file, do not use this data even though it is indicated in gLAB parameters.
					if ( ionex.RMSavailable == 0 ) {
						if (options->useSigmaIono ==1) {
							sprintf(messagestr,"WARNING: IONEX file [%s] has no RMS values. Disconnecting sigma iono in filter",sopt->inxFile);
							printInfo(messagestr,options);
							options->useSigmaIono = 0;
						}
					}
				}
				break;
			case FPPPIonoModel:
				if ( sopt->fppFile[0] != '\0' ) {
					if (printProgress==1) {	
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading F-PPP file%50s%c","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					if ( readFPPPFile(sopt->fppFile,&fppp,&fpppVersion,options) != 1 ) {
						if ( (int)fpppVersion != 1 && fpppVersion != 0 ) {
							sprintf(messagestr,"FPPP version %1.2f from file [%s] is not supported. Supported version is 1",fpppVersion,sopt->fppFile);
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"Reading FPPP file [%s] for ionospheric data",sopt->fppFile);
							printError(messagestr,options);
						}
					}
				}
				break;
			case KlobucharIonoModel:
				if ( fdRNXKlb != NULL ) {
					if (printProgress==1) {	
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading navigation file for Klobuchar%50s%c","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					ret=readRinexNav(fdRNXKlb,sopt->klbFile,&productsKlb,&rinexNavVersion,NEWDAYNAV,options);
					if ( ret < 1 ) {
						if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
							sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->klbFile);
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"Reading RINEX navigation message file [%s] for Klobuchar data",sopt->klbFile);
							printError(messagestr,options);
						}
					} else if (ret!=2) {
						fclose(fdRNXKlb);
						fdRNXKlb=NULL;
					}
				} else if ( products.type == BRDC ) {
					productsKlb.BRDC = products.BRDC;
					productsKlb.type = products.type;
				} else {
					printError("Klobuchar model selected for ionospheric corrections, but no source is found",options);
				}
				break;
			case BeiDouIonoModel:
				if ( fdRNXBei != NULL ) {
					if (printProgress==1) {	
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading navigation file for BeiDou%50s%c","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					ret=readRinexNav(fdRNXBei,sopt->beiFile,&productsBei,&rinexNavVersion,NEWDAYNAV,options);
					navFilesVersion[IONONAVPOS][numNavFilesVersion[IONONAVPOS]]=(int)(rinexNavVersion*100);
					numNavFilesVersion[IONONAVPOS]++;
					if ( ret < 1 ) {
						if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
							sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->beiFile);
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"Reading RINEX navigation message file [%s] for BeiDou data",sopt->beiFile);
							printError(messagestr,options);
						}
					} else if (ret!=2) {
						fclose(fdRNXBei);
						fdRNXBei=NULL;
					}
				} else if ( products.type == BRDC ) {
					productsBei.BRDC = products.BRDC;
					productsBei.type = products.type;
				} else {
					printError("BeiDou model selected for ionospheric corrections, but no source is found",options);
				}
				break;
			case neQuickIonoModel:
				if ( fdRNXNeq != NULL ) {
					if (printProgress==1) {	
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading navigation file for NeQuick%50s%c","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					ret=readRinexNav(fdRNXNeq,sopt->neqFile,&productsNeq,&rinexNavVersion,NEWDAYNAV,options);
					navFilesVersion[IONONAVPOS][numNavFilesVersion[IONONAVPOS]]=(int)(rinexNavVersion*100);
					numNavFilesVersion[IONONAVPOS]++;
					if ( ret < 1 ) {
						if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
							sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->neqFile);
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"Reading RINEX navigation message file [%s] for NeQuick data",sopt->neqFile);
							printError(messagestr,options);
						}
					} else if ( (int)rinexNavVersion < 3 ) {
						sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is below 3. This version does not contain NeQuick data",rinexNavVersion,sopt->neqFile);
						printError(messagestr,options);
					} else if (ret!=2) {
						fclose(fdRNXNeq);
						fdRNXNeq=NULL;
					}
				} else if ( products.type == BRDC && (int)rinexNavVersion < 3 ) {
					sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is below 3. This version does not contain NeQuick data",rinexNavVersion,sopt->navFile[0]);
					printError(messagestr,options);
				} else if ( products.type == BRDC ) {
					productsNeq.BRDC = products.BRDC;
					productsNeq.type = products.type;
				} else {
					printError("NeQuick model selected for ionospheric corrections, but no source is found",options);
				}
				break;
			case SBASIonoModel:
				// If we are processing with SBAS, we need to copy Klobuchar parameters to its structure
				if (products.BRDC==NULL) {
					//If we have not read any product type, allocate memory and initialize to 0 the productsKlb structure
					productsKlb.BRDC = malloc(sizeof(TBRDCproducts));
					initBRDCproducts(productsKlb.BRDC,options->GLOintStep);
				} else {
					productsKlb.BRDC = products.BRDC;
					productsKlb.type = products.type;
				}
				break;
			default:
				break;
		}
		// Troposphere data, only in case Galileo model is selected
		if ( options->tropNominal == TropoGalileo ) {
			if ( readGalileoTroposphericData(&tropoGal,sopt->GalFile,options) != 1 ) {
				sprintf(messagestr,"Reading Galileo Tropospheric data file [%s]",sopt->GalFile);
				printError(messagestr,options);
			}
		}


		// TGD file management
		initTGD(&tgdData,options,0);
		if ( options->GPSp1c1DCBModel == GPSp1c1STRICT ) {
			if ( sopt->numP1C1DCB == 0 ) {
				printError("No P1-C1 DCB file provided, but P1-C1 model set to strict",options);
			}
			if ( sopt->recFile[0] == '\0' && sopt->setRecType[ROVERPOS] == rtNA ) {
				printError("No 'GPS_Receiver_Types' file provided or no receiver set by the user, but P1-C1 model set to strict. Include a 'GPS_Receiver_Types' with '-input:rec' or set a receiver type with '-pre:setrectype'",options);
			}
		}
		
		if (options->GPSp1p2DCBModel!=DCBNONE) {
			auxDCBModel=options->GPSp1p2DCBModel;
		} else if (options->GLOp1p2DCBModel!=DCBNONE) {
			auxDCBModel=options->GLOp1p2DCBModel;
		} else if (options->GALe1e5aDCBModel!=DCBNONE) {
			auxDCBModel=options->GALe1e5aDCBModel;
		} else if (options->GALe1e5bDCBModel!=DCBNONE) {
			auxDCBModel=options->GALe1e5bDCBModel;
		} else if (options->BDSb1b6DCBModel!=DCBNONE) {
			auxDCBModel=options->BDSb1b6DCBModel;
		} else if (options->BDSb2b6DCBModel!=DCBNONE) {
			auxDCBModel=options->BDSb2b6DCBModel;
		} else if (options->BDSb5b6DCBModel!=DCBNONE) {
			auxDCBModel=options->BDSb5b6DCBModel;
		} else if (options->BDSb7b6DCBModel!=DCBNONE) {
			auxDCBModel=options->BDSb7b6DCBModel;
		} else if (options->QZSc1cDCBModel!=DCBNONE) {
			auxDCBModel=options->QZSc1cDCBModel;
		} else if (options->IRNc9c5DCBModel!=DCBNONE) {
			auxDCBModel=options->IRNc9c5DCBModel;
		} else {
			for (i=0;i<MAX_GNSS;i++) {
				if (tgdData.DualFreqDCBModel[i]!=DCBNONE) {
					auxDCBModel=tgdData.DualFreqDCBModel[i];
					break;
				}
			}
		}
		switch (auxDCBModel) {
			case DCBRINEX:
				if ( sopt->numP1P2RINEX == 0 ) {
					if ( products.type != BRDC ) {
						printError("Navigation message is selected for GPS P1-P2 DCB corrections, but no source is found, include it with '-input:dcb'",options);
					} else {
						tgdData.BRDC = products.BRDC;
					}
				}
				break;
			case DCBFILE:
				if ( sopt->numP1P2DCB == 0 ) {
					printError("No P1-P2 DCB file provided, but P1-P2 model set to DCB",options);
				}
				break;
			case DCBIONEX:
				if ( sopt->numP1P2IONEX == 0 ) {
					if(sopt->inxFile[0] != '\0' && options->ionoModel == IONEXIonoModel) {
						if(ionex.ionexDCB.DCBavailable==0) {
							sprintf(messagestr,"IONEX file [%s] selected for GPS P1-P2 DCB corrections, but no DCB data was found in the file",sopt->inxFile);
							printError(messagestr,options);
						} else {
							tgdData.ionexDCB = ionex.ionexDCB;
						}
					} else {
						printError("No IONEX file provided, but GPS P1-P2 model set to IONEX",options);
					}
				}
				break;
			case DCBFPPP:
				if ( sopt->numP1P2FPPP == 0 ) {
					if(sopt->fppFile[0] != '\0' && options->ionoModel == FPPPIonoModel) {
						if(fppp.fpppDCB.DCBavailable==0) {
							sprintf(messagestr,"FPPP file [%s] selected for GPS P1-P2 DCB corrections, but no DCB data was found in the file",sopt->fppFile);
							printError(messagestr,options);
						} else {
							tgdData.fpppDCB = fppp.fpppDCB;
						}
					} else {
						printError("No FPPP file provided, but GPS P1-P2 model set to FPPP",options);
					}
				}
				break;
			default:
				break;
		}


		if ( options->OSBdcbModel == OSBSINEXBIAS ) {
			if ( sopt->numSINEXBIASOSB == 0 ) {
				if (sopt->numSINEXBIASDSB > 0) {
					printError("SINEX BIAS for measurement DCBs selected, but the provided SINEX BIAS is for measurement conversion",options);
				} else {
					printError("SINEX BIAS for measurement DCBs selected, but no SINEX BIAS with this data provided",options);
				}
			}
		}

		if ( options->DSBdcbModel == DSBSINEXBIAS ) {
			if ( sopt->numSINEXBIASDSB == 0 ) {
				if (sopt->numSINEXBIASOSB > 0) {
					printError("SINEX BIAS for measurement conversion selected, but the provided SINEX BIAS is for measurement DCB corrections",options);
				} else {
					printError("SINEX BIAS for measurement conversion selected, but no SINEX BIAS with this data provided",options);
				}
			}
		}

		newDayRinexNav=1;
		for (i=0;i<sopt->numTGD;i++) {
			auxft1 = whatFileTypeIs(sopt->tgdFile[i]);
			switch(auxft1) {
				case ftP1C1DCB: case ftP1P2DCB:
					if ( (auxft1 == ftP1C1DCB && options->GPSp1c1DCBModel == GPSp1c1STRICT) || (auxft1 == ftP1P2DCB && options->GPSp1p2DCBModel == DCBFILE) || (auxft1 == ftP1P2DCB && options->GLOp1p2DCBModel == DCBFILE) ) {
						//DCB files for GPS only
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Reading GPS DCB file%50s%c","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						retTGD[i]=readDCBFile(sopt->tgdFile[i],&tgdData,options);
						if ( retTGD[i] != 1 ) {
							if (retTGD[i]==-2) {
								sprintf(messagestr,"DCB file [%s] header not recognized. It may be due to an unsupported DCB file type, or for P1-C1 and P1-P2 files, because the header line has changed its format",sopt->tgdFile[i]);
								printError(messagestr,options);
							} else {
								sprintf(messagestr,"Reading DCB file for TGD data [%s]",sopt->tgdFile[i]);
								printError(messagestr,options);
							}
						}
					}
					break;
				case ftSINEXBIASOSB:
					if (options->OSBdcbModel==OSBSINEXBIAS ) {
						//Multiconstellation DCB file with observation specific biases
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Reading SINEX OSB Bias file with observation specific DCB%50s%c","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						retTGD[i]=readSINEXBIASFile(sopt->tgdFile[i],auxft1,&tgdData.SNXBias,options);
						if ( retTGD[i] != 1 ) {
							if (retTGD[i]==-2) {
								//REVISAR
								printError(messagestr,options);
							} else {
								sprintf(messagestr,"Reading SINEX OSB Bias file with observation specific DCB data [%s]",sopt->tgdFile[i]);
								printError(messagestr,options);
							}
						}
					}
					break;
				case ftSINEXBIASDSB:
					if (options->DSBdcbModel==DSBSINEXBIAS ) {
						//Multiconstellation DCB file with measurement conversion biases
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Reading SINEX DSB Bias file with differential DCB%50s%c","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						retTGD[i]=readSINEXBIASFile(sopt->tgdFile[i],auxft1,&tgdData.SNXBias,options);
						if ( retTGD[i] != 1 ) {
							if (retTGD[i]==-2) {
								//REVISAR
								printError(messagestr,options);
							} else {
								sprintf(messagestr,"Reading SINEX DSB Bias file with differential DCB data [%s]",sopt->tgdFile[i]);
								printError(messagestr,options);
							}
						}
					}
					break;
				case ftRINEXbroadcast:
					for(j=0;j<sopt->numNav;j++) {
						if (strcmp(sopt->tgdFile[i],sopt->navFile[j])==0) {
							break;
						}
					}
					if (j==sopt->numNav) {
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Reading navigation file for DCB%50s%c","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						if(!(fdTGD[i]=fopen(sopt->tgdFile[i],"rb"))) {
							sprintf(messagestr,"Reading RINEX navigation message file for DCB data [%s]",sopt->tgdFile[i]);
							printError(messagestr,options);
						} else {
							retTGD[i]=readRinexNav(fdTGD[i],sopt->tgdFile[i],&productsTgd,&rinexNavVersion,newDayRinexNav==1?NEWDAYNAV:SAMEDAYNAV,options);
							navFilesVersion[TGDNAVPOS][numNavFilesVersion[TGDNAVPOS]]=(int)(rinexNavVersion*100);
							numNavFilesVersion[TGDNAVPOS]++;
							newDayRinexNav++;
							if ( retTGD[i]<1 ) {
								if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
									sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->tgdFile[i]); 	
									printError(messagestr,options);
								} else {
									sprintf(messagestr,"Reading RINEX navigation message file for DCB data [%s]",sopt->tgdFile[i]);
									printError(messagestr,options);
								}
							} else if (retTGD[i]!=2) {
								fclose(fdTGD[i]);
								fdTGD[i]=NULL;
							}
						}
						tgdData.BRDC = productsTgd.BRDC;
						tgdData.BRDC->NavDataPosition=TGDNAVPOS;
					} else {
						tgdData.BRDC = products.BRDC;
					}
					//Build list of available RINEX navigation message types for TGD
					for(j=0;j<MAX_GNSS;j++) {
						for(k=0;k<MAX_BRDC_SELECTION_TYPES;k++) {
							//Reset BRDCAvailSelOrder list
							for(l=0;l<=MAX_BRDC_TYPES;l++) {
								options->BRDCAvailSelOrder[TGDNAVPOS][j][k][l]=0;
							}
							//Fill with available messages
							m=0;
							for(l=0;l<options->BRDCSelOrder[j][k][MAX_BRDC_TYPES];l++) {
								if (tgdData.BRDC->AvailBRDCType[j][options->BRDCSelOrder[j][k][l]]==1) {
									options->BRDCAvailSelOrder[TGDNAVPOS][j][k][m]=options->BRDCSelOrder[j][k][l];
									m++;
								}
							}
							options->BRDCAvailSelOrder[TGDNAVPOS][j][k][MAX_BRDC_TYPES]=m;
						}
					}
					break;
				case ftIONEX:
					if ( options->GPSp1p2DCBModel==DCBIONEX || options->GLOp1p2DCBModel==DCBIONEX || options->FPPPDCBModel==DCBIONEX  ) {
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Reading IONEX for DCB%50s%c","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						if(!(fdTGD[i]=fopen(sopt->tgdFile[i],"rb"))) {
							sprintf(messagestr,"Reading IONEX file for DCB data [%s]",sopt->tgdFile[i]);
							printError(messagestr,options);
						} else {
							retTGD[i]=readIONEX(fdTGD[i],&productsIonex,&ionexVersion,options);
							if ( retTGD[i] < 1 ) {
								if ((int)ionexVersion!=1 && ionexVersion!=0){
									sprintf(messagestr,"IONEX version %1.2f from file [%s] is not supported. Supported version is 1",ionexVersion,sopt->tgdFile[i]);
									printError(messagestr,options);
								} else if (retTGD[i]==-2) {
									sprintf(messagestr,"Number of records in IONEX header in file [%s] does not match the number of records read",sopt->tgdFile[i]);
									printError(messagestr,options);
								} else {
									sprintf(messagestr,"Reading IONEX file [%s] for DCB data" ,sopt->tgdFile[i]);
									printError(messagestr,options);
								}
							} else if ( productsIonex.ionexDCB.DCBavailable == 0 ) {
								sprintf(messagestr,"IONEX file [%s] selected for DCB corrections, but no DCB data was found in the file",sopt->tgdFile[i]);
								printError(messagestr,options);
							} else {
								tgdData.ionexDCB = productsIonex.ionexDCB;
								if ( retTGD[i] == 2 ) {
									sprintf(messagestr,"WARNING: IONEX file [%s] for DCB data has no 'END OF FILE' line. File may not be complete",sopt->tgdFile[i]);
									printInfo(messagestr,options);
								} else if ( retTGD[i] == 4 ) {
									sprintf(messagestr,"WARNING: IONEX file [%s] for DCB data is concatenated, but has no 'END OF FILE' line. File may not be complete",sopt->tgdFile[i]);
									printInfo(messagestr,options);
								} else {
									fclose(fdTGD[i]);
									fdTGD[i]=NULL;
								}
							}
						}
					}
					break;
				case ftFPPP:
					if ( options->GPSp1p2DCBModel == DCBFPPP ) {
						if ( readFPPPFile(sopt->tgdFile[i],&productsFppp,&fpppVersion,options) != 1 ) {
							if ( (int)fpppVersion != 1 && fpppVersion != 0 ) {
								sprintf(messagestr,"FPPP version %1.2f from file [%s] is not supported. Supported version is 1",fpppVersion,sopt->tgdFile[i]);
								printError(messagestr,options);
							} else {
								sprintf(messagestr,"Reading FPPP file [%s] for DCB data" ,sopt->tgdFile[i]);
								printError(messagestr,options);
							}
						} else if ( productsFppp.fpppDCB.DCBavailable == 0 ) {
							sprintf(messagestr,"FPPP file [%s] selected for P1-P2 DCB corrections, but no data was found in the file",sopt->tgdFile[i]);
							printError(messagestr,options);
						} else {
							tgdData.fpppDCB = productsFppp.fpppDCB;
						}
					}
					break;
				default:
					break;
			}
		}

		// GPS Receiver type file
		if ( sopt->recFile[0] != '\0' ) {
			if ( sopt->setRecType[ROVERPOS] == rtNA || sopt->setRecType[REFSTAPOS] == rtNA ) {
				if (printProgress==1) {	
					if (options->ProgressEndCharac=='\r') {
						//Printing to a terminal
						fprintf(options->terminalStream,"Reading receiver type file%50s%c","",options->ProgressEndCharac);
						fflush_function(options->terminalStream);
					}
				}
				if ( readRecTypeFile(sopt->recFile,&recList) != 1 ) {
					sprintf(messagestr,"Reading GPS Receiver type file [%s]",sopt->recFile);
					printError(messagestr,options);
				}
			} else {
				sprintf(messagestr,"WARNING setrectype specified, ignoring GPS receiver types file (%s)",sopt->recFile);
				printInfo(messagestr,options);
			}
		}
		
		// SINEX file
		if ( sopt->snxFile[0] != '\0' ) {
			if (printProgress==1) {	
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"Reading SINEX file%50s%c","",options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				}
			}
			if (readSINEXFile(sopt->snxFile,&stationList)!=1) {
				sprintf(messagestr,"Reading SINEX input file [%s]",sopt->snxFile);
				printError(messagestr,options);
			}
		}
		
		// If receiver antenna reference point is set, dump it to the receiver structure
		if ( options->ARPData == arpSET ) {
			for (i=0;i<3;i++) {
				epoch->receiver.ARP[i] = options->receiverARP[i];
			}
		}
				
		// Read RINEX Observation header
		if (printProgress==1) {	
			if (options->ProgressEndCharac=='\r') {
				//Printing to a terminal
				fprintf(options->terminalStream,"Reading rover observation header file%50s%c","",options->ProgressEndCharac);
				fflush_function(options->terminalStream);
			}
		}
		ret = readRinexObsHeader(fdRNX,NULL,epoch,options);
		if ( options->DGNSS == 1 ) {
			if ( options->RTCMmode == ProcessRTCM3 ) {
				// Process the binary RTCM v3.x
				ret = converterRTCM3(fdRTCM3,rtcm3,fileRINEXpointer,epoch,epochDGNSS,options);
			} else if ( options->RTCMmode == ProcessRINEX ) {
				// Read the RINEX header
				if (printProgress==1) {	
					if (options->ProgressEndCharac=='\r') {
						//Printing to a terminal
						fprintf(options->terminalStream,"Reading reference station observation header file%50s%c","",options->ProgressEndCharac);
						fflush_function(options->terminalStream);
					}
				}
				ret = readRinexObsHeader(fdRNXdgnss,NULL,epochDGNSS,options);
				if ( options->receiverPositionSource >= rpRTCMbaseline ) {
					for ( i = 0; i < 3; i++ ) epoch->receiver.aproxPosition[i] = epochDGNSS->receiver.aproxPosition[i];
				}
				epoch->receiver.numRecStation=epochDGNSS->receiver.numRecStation;
				epoch->receiver.RecStationCoord=epochDGNSS->receiver.RecStationCoord;
				epoch->receiver.ChangedStaEpoch=epochDGNSS->receiver.ChangedStaEpoch;
				//Check if DiscardUnpairedMeas has to be disabled due to RINEX2 version
				if (options->DiscardUnpairedMeas[REFSTAPOS]==1 && epochDGNSS->source==RINEX2 ) {
					options->DiscardUnpairedMeas[REFSTAPOS]=0;
					options->ForcedDiscardUnpairedMeas[REFSTAPOS]=1;
				}
			}
		}

		//Check if DiscardUnpairedMeas has to be disabled due to RINEX2 version, except when we are estimaing DCBsm where in the case L1P will be copied to L1C if necessary
		if (options->DiscardUnpairedMeas[ROVERPOS]==1 && epoch->source==RINEX2 && options->estimateSatDCB==0 && options->estimateRecDCB==0) {
			options->DiscardUnpairedMeas[ROVERPOS]=0;
			options->ForcedDiscardUnpairedMeas[ROVERPOS]=1;
		}
		
		// If position receiver is set, dump it to the receiver structure 
		switch (options->receiverPositionSource) {
			case rpSET: case rpCALCULATEUSER: case rpCALCULATEUSERREF:
				for (i=0;i<3;i++) {
					epoch->receiver.aproxPosition[i] = options->aprioriReceiverPosition[i];
				}
				epoch->receiver.aproxPositionError = 1e4; // 10 Km
				break;
			case rpSINEX: // If the position is read from SINEX, get it
				station = getStation(epoch->receiver.name,&stationList);
				if ( station == NULL ) {
					sprintf(messagestr,"Receiver marker name '%s' not found in SINEX file [%s]. Use '-pre:setrecpos x y z' to set it",epoch->receiver.name,sopt->snxFile);
					printError(messagestr,options);
				} else {
					for (i=0;i<3;i++) {
						epoch->receiver.aproxPosition[i] = station->pos[i];
					}
					epoch->receiver.aproxPositionError = 0.01; // 1 cm
				}
				break;
			case rpRTCMRoverUSER:
				for (i=0;i<3;i++) {
					epoch->receiver.aproxPositionRover[i] = options->aprioriReceiverPosition[i];
					epoch->receiver.aproxPosition[i] = options->aprioriReceiverPosition[i];
				}
				break;
			case rpRTCMUserbaseline:
				for (i=0;i<3;i++) {
					epochDGNSS->receiver.aproxPosition[i] = options->ReferenceStationPosition[i];
					epoch->receiver.aproxPosition[i] = options->ReferenceStationPosition[i];
				}
				break;
			case rpRTCMUserRINEXROVER:
				for (i=0;i<3;i++) {
					epochDGNSS->receiver.aproxPosition[i] = options->ReferenceStationPosition[i];
				}
				break;
			case rpRTCMRefRoverUSER:
				for (i=0;i<3;i++) {
					epoch->receiver.aproxPositionRover[i] = options->aprioriReceiverPosition[i];
					epochDGNSS->receiver.aproxPosition[i] = options->ReferenceStationPosition[i];
					epoch->receiver.aproxPosition[i] = options->aprioriReceiverPosition[i];
				}
				break;
			case rpRTCMRefUSERRoverREF:
				for (i=0;i<3;i++) {
					epochDGNSS->receiver.aproxPosition[i] = options->ReferenceStationPosition[i];
				}
				break;
			default:
				break;
		}

		if (options->workMode == wmDOPROCESSING) {
			//Only read reference file if we are in processing mode
			switch(options->receiverPositionSource) {
				case rpSETREF: case rpCALCULATEREF: case rpCALCULATERINEXREF:
				case rpCALCULATEUSERREF: case rpRTCMRoverUSERREF: case rpRTCMRefUSERRoverREF:
					//Rover position read by reference file
					options->UseReferenceFile=1;
					OrbInterpDegree=options->orbitInterpolationDegree;
					OrbMaxDistance=options->OrbitsMaxDistance;
					epoch->receiver.aproxPositionError = 0.1; // 10 cm
					if (sopt->posReferenceFile[0]=='\0') {
						printError("Receiver position set to be read from reference file, but no reference file given. Use option '-input:refpos' to set one.",options);
					}
					if (printProgress==1) {	
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading reference position file%50s%c","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					ret = readReferenceFile(sopt->posReferenceFile,&ReferencePos,options);
					if (ret == -1) {
						sprintf(messagestr,"Opening reference file [%s]",sopt->posReferenceFile);
						printError(messagestr,options);
					} else if (ret ==-2) {
						sprintf(messagestr,"Reference file [%s] must be a SP3 file or a columnar text file. See option '-referenceposfile' for help on the columnar text file format",sopt->posReferenceFile);
						printError(messagestr,options);
					} else if (ret ==-3) {
						sprintf(messagestr,"Reference SP3 file [%s] has an incorrect number of entries in the header",sopt->posReferenceFile);
						printError(messagestr,options);
					} else if (ret ==-4) {
						sprintf(messagestr,"Reference SP3 file [%s] cannot be concatenated. Data may be from several days, but it must contain only one header",sopt->posReferenceFile);
						printError(messagestr,options);
					} else if (ret ==-5) {
						sprintf(messagestr,"Reference SP3 file [%s] cannot contain more than one satellite",sopt->posReferenceFile);
						printError(messagestr,options);
					} else if (ret ==-6) {
						sprintf(messagestr,"Reading reference SP3 file [%s]",sopt->posReferenceFile);
						printError(messagestr,options);
					}
					break;
				default:
					break;
			}
		}
		switch(options->receiverPositionSource) {
			case rpRTCMRINEXROVER: case rpRTCMUserRINEXROVER:
				//Use Rover Rinex position as a priori
				for (i=0;i<3;i++) {
					epoch->receiver.aproxPosition[i] = epoch->receiver.aproxPositionRover[i];
				}
				break;
			case rpCALCULATE: case rpCALCULATERINEX: case rpCALCULATEUSER:
				//Set OUTPUT differential fields to 0
				epoch->receiver.RefPositionAvail=0;
				//Disable computing convergence time using positioning error
				options->computeConvTimePosErrHor = 0;
				options->computeConvTimePosErrVer = 0;
				options->computeConvTimePosErr3D = 0;
				options->computeConvTimePeriodPosErrHor = 0;
				options->computeConvTimePeriodPosErrVer = 0;
				options->computeConvTimePeriodPosErr3D = 0;
				/* Falls through. */ //To avoid warning -Wimplicit-fallthrough=
			case rpCALCULATEREF: case rpCALCULATERINEXREF: case rpCALCULATEUSERREF:
				//When coordinates are set to calculate, do not believe any coordinate, even if it is from user or RINEX file
				//Setting a error higher than 1e5 makes gLAB not discard satellites by elevation
				epoch->receiver.aproxPositionError = 1e10; 
				break;
			default:
				break;
		}

		//Set differential OUTPUT fields computation mode
		switch(options->receiverPositionSource) {
			case rpRTCMbaseline: case rpRTCMUserbaseline:
				epoch->receiver.OUTPUTDiffFieldsMode=RTCMBaseline;
				break;
			case rpCALCULATEREF: case rpCALCULATERINEXREF: case rpCALCULATEUSERREF:
				epoch->receiver.OUTPUTDiffFieldsMode=CalculateWithRefFile;
				break;
			case rpRTCMRINEXROVER: case rpRTCMRoverUSER: case rpRTCMRoverUSERREF:  
			case rpRTCMUserRINEXROVER: case rpRTCMRefRoverUSER: case rpRTCMRefUSERRoverREF:
				epoch->receiver.OUTPUTDiffFieldsMode=RTCMNoBaseline;
				break;
			default:
				epoch->receiver.OUTPUTDiffFieldsMode=FromAPriori;
				break;
		}
		
		// Abnormal a priori receiver position
		// Check if station is at least above than -1 km from the earth surface 
		if ( options->workMode != wmSHOWINPUT ) {
			switch(options->receiverPositionSource) {
				case rpRINEX: case rpSINEX: case rpSET:
					r = sqrt(epoch->receiver.aproxPosition[0]*epoch->receiver.aproxPosition[0] + 
							 epoch->receiver.aproxPosition[1]*epoch->receiver.aproxPosition[1] + 
							 epoch->receiver.aproxPosition[2]*epoch->receiver.aproxPosition[2]);
					if ( r < (MIN_EARTH_RADIUS-1000.) ) {
						sprintf(messagestr,"Receiver a priori position must be above Earth surface (%.2f vs %.2f).",r,MIN_EARTH_RADIUS-1000.0);
						printError(messagestr,options);
					} 
					break;
				case rpRTCMRINEXROVER: case rpRTCMRoverUSER:
				case rpRTCMUserRINEXROVER: case rpRTCMRefRoverUSER:
					r = sqrt(epoch->receiver.aproxPositionRover[0]*epoch->receiver.aproxPositionRover[0] + 
							 epoch->receiver.aproxPositionRover[1]*epoch->receiver.aproxPositionRover[1] + 
							 epoch->receiver.aproxPositionRover[2]*epoch->receiver.aproxPositionRover[2]);
					if ( r < (MIN_EARTH_RADIUS-1000.) ) {
						sprintf(messagestr,"Rover a priori position must be above Earth surface (%.2f vs %.2f).",r,MIN_EARTH_RADIUS-1000.0);
						printError(messagestr,options);
					} 
					break;
				case rpCALCULATERINEX: case rpCALCULATEUSER:
				case rpCALCULATERINEXREF: case rpCALCULATEUSERREF:
					//Check initial coordinates are not 0,0,0
					if (epoch->receiver.aproxPosition[0]==0. && epoch->receiver.aproxPosition[1]==0. && epoch->receiver.aproxPosition[2]==0.) {
						if (options->receiverPositionSource ==rpCALCULATEUSER || options->receiverPositionSource ==rpCALCULATEUSERREF) {
							sprintf(messagestr,"Initial coordinates for computing solution cannot be (0,0,0)");
							printError(messagestr,options);
						} else {
							sprintf(messagestr,"WARNING RINEX a priori coordinates are (0,0,0), which are not allowed as a initial position. (%d,0,0) coordinates will be used instead",(int)EARTH_RADIUS);
							printInfo(messagestr,options);
							epoch->receiver.aproxPosition[0]=EARTH_RADIUS;
							epoch->receiver.aproxPosition[1]=0.;
							epoch->receiver.aproxPosition[2]=0.;
						}
					}	
					break;
				default:
					break;
			}
			//Check reference station coordinates
			switch(options->receiverPositionSource) {
				case rpRTCMUserbaseline: case rpRTCMUserRINEXROVER: case rpRTCMRefRoverUSER:
					r = sqrt(epochDGNSS->receiver.aproxPosition[0]*epochDGNSS->receiver.aproxPosition[0] + 
							 epochDGNSS->receiver.aproxPosition[1]*epochDGNSS->receiver.aproxPosition[1] + 
							 epochDGNSS->receiver.aproxPosition[2]*epochDGNSS->receiver.aproxPosition[2]);
					if ( r < (MIN_EARTH_RADIUS-1000.) ) {
						sprintf(messagestr,"Reference station position must be above Earth surface (%.2f vs %.2f).",r,MIN_EARTH_RADIUS-1000.0);
						printError(messagestr,options);
					} 
					break;
				default:
					break;
			}
		}
		
		//Read timestamp of first epoch
		getEpochFromObsFile(fdRNX,epoch->source,&epoch->t);	

		//Check if GLONASS frequency offset values (k) also in navigation files (if provided)
		getGLOFreqOffsets(epoch,sopt->navFile[0],sopt->glonavFile,&fdRNXglonav,&nextgloNav,&products,&productsGLO,options);

		//Check if observation system time is in GLONASS time (UTC in RINEX)
		if(epoch->SystemTime==GLONASS) {
			if (products.BRDC!=NULL && products.BRDC->LeapSecondsAvail==1) {
				epoch->ObsTimeToGPSTime=(double)products.BRDC->AT_LS;
			} else if (productsGLO.BRDC!=NULL && productsGLO.BRDC->LeapSecondsAvail==1) {
				epoch->ObsTimeToGPSTime=(double)productsGLO.BRDC->AT_LS;
			} else {
				epoch->ObsTimeToGPSTime=(double)getLeapSeconds(&epoch->FirstEpochHeader,epoch->LeapSecondsTimeList,epoch->LeapSecondsNumList);
			}
		}
		//Copy leap seconds read from RINEX navigation header if available
		if (products.BRDC!=NULL && products.BRDC->LeapSecondsAvail==1) {
			epoch->leapSecondsAvail=1;
			epoch->leapSeconds=products.BRDC->AT_LS;
			if (options->DGNSS==1) {
				epochDGNSS->leapSecondsAvail=1;
				epochDGNSS->leapSeconds=products.BRDC->AT_LS;
			}
		} else if (productsGLO.BRDC!=NULL && productsGLO.BRDC->LeapSecondsAvail==1) {
			epoch->leapSecondsAvail=1;
			epoch->leapSeconds=productsGLO.BRDC->AT_LS;
			if (options->DGNSS==1) {
				epochDGNSS->leapSecondsAvail=1;
				epochDGNSS->leapSeconds=productsGLO.BRDC->AT_LS;
			}
			if (products.BRDC!=NULL) {
				//If navigation data is available, copy the leap second from the GLONASS products
				products.BRDC->LeapSecondsAvail=1;
				products.BRDC->AT_LS=productsGLO.BRDC->AT_LS;
			}
		} else {
			epoch->leapSeconds=getLeapSeconds(&epoch->FirstEpochHeader,epoch->LeapSecondsTimeList,epoch->LeapSecondsNumList);
			if (options->DGNSS==1) {
				epochDGNSS->leapSeconds=epoch->leapSeconds;
			}
		}


		if (options->DGNSS) {
			//Copy GLONASS offsets frequencies to EpochDGNSS
			memcpy(&epochDGNSS->measOrder[GLONASS].lambdaMeas[1],&epoch->measOrder[GLONASS].lambdaMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].lambdaMeas[2],&epoch->measOrder[GLONASS].lambdaMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].freqMeas[1],&epoch->measOrder[GLONASS].freqMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].freqMeas[2],&epoch->measOrder[GLONASS].freqMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].mfreqMeas[1],&epoch->measOrder[GLONASS].mfreqMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].mfreqMeas[2],&epoch->measOrder[GLONASS].mfreqMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].TECU2metres[1],&epoch->measOrder[GLONASS].TECU2metres[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->measOrder[GLONASS].TECU2metres[2],&epoch->measOrder[GLONASS].TECU2metres[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
			memcpy(&epochDGNSS->GLOfreqnumber,&epoch->GLOfreqnumber,sizeof(int)*MAX_SATELLITES_PER_GNSS);
			//Check DGNSS system time
			if(epochDGNSS->SystemTime==GLONASS) {
				if (products.BRDC!=NULL) {
					if (products.BRDC->LeapSecondsAvail==1) {
						epochDGNSS->ObsTimeToGPSTime=(double)products.BRDC->AT_LS;
					}
				} else if (productsGLO.BRDC!=NULL) {
					if (productsGLO.BRDC->LeapSecondsAvail==1) {
						epochDGNSS->ObsTimeToGPSTime=(double)productsGLO.BRDC->AT_LS;
					}
				}
			}
		}

		//Check available GLONASS frequency offset number (k). 
		//If not available, disable GLONASS frequencies 1 and 2
		for(i=1;i<=listMaxSatGNSS[GLONASS];i++) {
			if (options->usableFreq[GLONASS][i][1]==1 && epoch->measOrder[GLONASS].lambdaMeas[1][i]==1.) {
				options->GLOsatFDMAdisabled[GLONASS][i][1] = 1;
				options->usableFreq[GLONASS][i][1]=0;
			}
			if (options->usableFreq[GLONASS][i][2]==1 && epoch->measOrder[GLONASS].lambdaMeas[2][i]==1.) {
				options->GLOsatFDMAdisabled[GLONASS][i][2] = 1;
				options->usableFreq[GLONASS][i][2]=0;
			}
		}

		//Set default measurements
		setDefaultMeasurements(epoch,epochDGNSS,&constellationSatBlock,sopt,options);

		//Parse again options for weight, as we have the measurements set
		//Read measurements for the weights in the filter 
		if (sopt->numweightText>0) {
			parseMeasurements(parseWeightFiltermeas,0,1,sopt,options);
		}

		//Read measurements for the weights combining mode in the filter 
		if (sopt->numweightTextComb>0) {
			parseMeasurements(parseWeightCombFiltermeas,0,1,sopt,options);
		}

		//Read measurements for the weights mode in the filter 
		if (sopt->numweightTextMode>0) {
			parseMeasurements(parseWeightModeFiltermeas,0,1,sopt,options);
		}

		//Check if there is available leap seconds if GLONASS is uses with broadcast products
		if (products.BRDC!=NULL) {
			//Check if one or more GLONASS satellites are selected
			for(i=1;i<=MAX_SAT_GLO;i++) {
				if (options->includeSatellite[GLONASS][i]) break;
			}
			//Print a warning in the case that leap seconds is set from hardcoded values
			if(i<=MAX_SAT_GLO && products.BRDC->LeapSecondsAvail==0) {
				sprintf(messagestr,"WARNING Number of current leap seconds (%d) is read from internal hardcoded table. Provide leap seconds in RINEX navigation file header if it is incorrect",epoch->leapSeconds);
				printInfo(messagestr,options);
			}
		}

		//Update values for rover after reading header
		posRINEXHeaderDataUpdate(ROVERPOS,sopt->setRecType[ROVERPOS],sopt->recFile,&recList,&antennaList,&constellationSatBlock,epoch,options);	
		//Update values for reference station after reading header
		if (options->DGNSS==1) {
			posRINEXHeaderDataUpdate(REFSTAPOS,sopt->setRecType[REFSTAPOS],sopt->recFile,&recList,&antennaList,&constellationSatBlock,epochDGNSS,options);	
		}

		//Check data gap size versus observation file interval. 
		//If data gap size has not been manually set and it is smaller than the observation file, set it to a value higher than the observation data rate
		if (options->csDataGapSizeMode==csDataGapSizeDefault) {
			if (epoch->receiver.interval>0.) {
				auxd=epoch->receiver.interval;
			} else {
				auxd=epoch->receiver.intervalEstimate;
			}
			if (auxd>=options->csDataGap) {
				options->csDataGapSizeMode=csDataGapSizeAuto;
				if (auxd<=10.) {
					options->csDataGap=10.;
				} else {
					options->csDataGap=auxd+10.;
				}
			}
		}

		//Check smoothing versus file interval in SBAS and DGNSS 
		//If file interval is not 1Hz or higher, reduce smoothing time and smoothing convergence time by the data rate
		if (options->SBAScorrections>=SBAS1Fused || options->DGNSS) {
			if (epoch->receiver.interval>0.) {
				auxd=epoch->receiver.interval;
			} else {
				auxd=epoch->receiver.intervalEstimate;
			}
			if (auxd>1. && sopt->anySmoothOptionSetByUser==0 ) {
				//Interval is greater than 1Hz and user has not set any smoothing option
				//Disable smoothing and smoothing convergence time
				options->smoothEpochs=(int)((double)(options->smoothEpochs)/auxd);
				options->excludeSmoothingConvergence=(int)((double)(options->excludeSmoothingConvergence)/auxd);
				options->excludeSmoothingConvergenceDGNSS=(int)((double)(options->excludeSmoothingConvergenceDGNSS)/auxd);
				sprintf(messagestr,"WARNING Number of smoothing epochs and smooth convergence time reduced by a factor %d according to RINEX observation file data rate (as it is smaller than 1Hz)",(int)auxd);
				printInfo(messagestr,options);
			}
		}

		//TGD options might have changed after setting default measurements and checked for available navigation messages
		//Copy again the TGD options in tgdData structure
		initTGD(&tgdData,options,1);
		
		//Set initial values for main processing loop
		processedEpochs = 0;
		filterIterations = 1;

		//This is to avoid reading the next day of ephemeris data when the observation file starts at the end of the previous day (for converging values)
		MJDNEpoch=epoch->t.MJDN;
		if(epoch->t.SoD>=75000.) {
			MJDNEpoch++;
		}

		//Set processing to forward
		epoch->direction = pFORWARD;

		//Save position of first epoch
		epoch->maxNumEpochReadFilePos=86400*2;//Add space for two days in each iteration
		epoch->epochReadFilePos=malloc(sizeof(off_t)*epoch->maxNumEpochReadFilePos);
		epoch->epochReadFilePos[0]=ftell(fdRNX);
		epoch->numEpochReadFilePos=1;

		// Print input parameters
		printParameters(options,epoch,&products,&tgdData,(int)sopt->navMode,sopt->stanfordESAFile,sopt->stanfordESALOIFile,sopt->kmlFile,sopt->kml0File,sopt->SP3OutputFile,sopt->RefPosOutputFile,navFilesVersion,numNavFilesVersion);

		/////////////////////////
		///MAIN PROCESSING LOOP
		/////////////////////////

		while ( ret ) {
			ret = readRinexObsEpoch(fdRNX,epoch,Epochstr,options);
			// ret == 2 means that RINEX observables is "large/concatenated", so we need to read
			// the new header and the next epoch (if header is found, readRinexObsEpoch function does not read any data!)
			if ( ret == 2 ) {
				ret = readRinexObsHeader(fdRNX,NULL,epoch, options);
				//Update values for rover after reading header
				posRINEXHeaderDataUpdate(ROVERPOS,sopt->setRecType[ROVERPOS],sopt->recFile,&recList,&antennaList,&constellationSatBlock,epoch,options);	
				//Copy GLONASS offsets frequencies to EpochDGNSS
				if (options->DGNSS) {
					memcpy(&epochDGNSS->measOrder[GLONASS].lambdaMeas[1],&epoch->measOrder[GLONASS].lambdaMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].lambdaMeas[2],&epoch->measOrder[GLONASS].lambdaMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].freqMeas[1],&epoch->measOrder[GLONASS].freqMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].freqMeas[2],&epoch->measOrder[GLONASS].freqMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].mfreqMeas[1],&epoch->measOrder[GLONASS].mfreqMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].mfreqMeas[2],&epoch->measOrder[GLONASS].mfreqMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].TECU2metres[1],&epoch->measOrder[GLONASS].TECU2metres[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->measOrder[GLONASS].TECU2metres[2],&epoch->measOrder[GLONASS].TECU2metres[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
					memcpy(&epochDGNSS->GLOfreqnumber,&epoch->GLOfreqnumber,sizeof(int)*MAX_SATELLITES_PER_GNSS);
				}
				//Read the next epoch
				if ( ret == 1 ) {
					//Save position of epoch after header
					epoch->epochReadFilePos[epoch->numEpochReadFilePos-1]=ftell(fdRNX);
					//Read next epoch
					ret = readRinexObsEpoch(fdRNX, epoch, Epochstr, options);
				}
			}
			if (ret) {
				//Check the first epoch of the RINEX. If it is greater-equal than HOURSPREVDAYCONVERGENCE we have to wait 
				//for the next day until we use results for the SBAS summary
				if(Summary) {
					if (options->firstEpochSummary.MJDN!=-1) {
						if (tdiff(&epoch->t,&options->firstEpochSummary)>=0.) {
							options->useDatasummary=1;
							//Save first epoch of summary 
							memcpy(&epoch->StartSummaryEpoch,&epoch->t,sizeof(TTime));
							//Initialize values for continuity risk computation
							memcpy(&SBASdatabox.FirstEpochAvailAfterPrevDisc,&epoch->t,sizeof(TTime));
							TmpTTime=tdadd(&epoch->t,-epoch->receiver.interval);
							memcpy(&SBASdatabox.LastEpochAvailPrevCurrDisc,&TmpTTime,sizeof(TTime));
							//Turn off Summary to avoid continously checking this condition
							Summary=0;
						} else {
							options->useDatasummary=0;
						}
					} else if (firstEpoch) {
						//First epoch read
						firstEpoch=0;
						if(options->waitForNextDay==1 && epoch->t.SoD>=(double)HOURSPREVDAYCONVERGENCE*3600.) {
							options->useDatasummary=0;
						} else {
							options->useDatasummary=1;
							//Save first epoch of summary 
							memcpy(&epoch->StartSummaryEpoch,&epoch->t,sizeof(TTime));
							//Initialize values for continuity risk computation
							memcpy(&SBASdatabox.FirstEpochAvailAfterPrevDisc,&epoch->t,sizeof(TTime));
							TmpTTime=tdadd(&epoch->t,-epoch->receiver.interval);
							memcpy(&SBASdatabox.LastEpochAvailPrevCurrDisc,&TmpTTime,sizeof(TTime));
							//Turn off Summary to avoid continously checking this condition
							Summary=0;
						}
					} else if (options->useDatasummary==0) {
						//The 3600 seconds is an arbitrary value just to make sure that at the start of the next day,
						//even though there may be epochs missing at the beginning of the observation file, 
						//the first epoch at the beginning of the observation file will make this condition true
						if(epoch->t.SoD<3600.) {
							options->useDatasummary=1;
							//Save first epoch of summary 
							memcpy(&epoch->StartSummaryEpoch,&epoch->t,sizeof(TTime));
							//Initialize values for continuity risk computation
							memcpy(&SBASdatabox.FirstEpochAvailAfterPrevDisc,&epoch->t,sizeof(TTime));
							TmpTTime=tdadd(&epoch->t,-epoch->receiver.interval);
							memcpy(&SBASdatabox.LastEpochAvailPrevCurrDisc,&TmpTTime,sizeof(TTime));
							//Turn off Summary to avoid continously checking this condition
							Summary=0;
						}
					}
				}
			}

			//// DGNSS
			//// Adjust time between Reference Station and Rover Station (user) in DGNSS mode
			//// It is just done to speed up the software and make it work as in real-time behaviour
			if ( options->DGNSS == 1 ) {
				computeDGNSScor = 1;
				if ( deltaTime == 0.0 && retDGNSS == 1 ) { // Normal procedure (read both Rover and Reference Stations)
					if ( options->RTCMmode == ProcessRTCM2 ) {
						// Process the binary RTCM v2.x
						retDGNSS = converterRTCM2(fdRTCM2, rtcm2, NULL, NULL, epochDGNSS, options);
					} else if ( options->RTCMmode == ProcessRTCM3 ) {
						// Process the binary RTCM v3.x
						retDGNSS = converterRTCM3(fdRTCM3, rtcm3, NULL, epoch, epochDGNSS, options);
						if (retDGNSS==1) {
							//Only preprocess if we have not reached end of file
							preprocess(epochDGNSS,options,2);
						}
					} else {
						// Read the RINEX observables
						retDGNSS = readRinexObsEpoch(fdRNXdgnss,epochDGNSS,Epochstr,options);
						if(retDGNSS==2) {
							// Read the RINEX header and next epoch (if header is found, readRinexObsEpoch function does not read any data!)
							retDGNSS = readRinexObsHeader(fdRNXdgnss,NULL,epochDGNSS,options);
							//Update values for reference station after reading header
							posRINEXHeaderDataUpdate(REFSTAPOS,sopt->setRecType[REFSTAPOS],sopt->recFile,&recList,&antennaList,&constellationSatBlock,epochDGNSS,options);	
							//Read next epoch
							retDGNSS = readRinexObsEpoch(fdRNXdgnss,epochDGNSS,Epochstr,options);
						}
						if (retDGNSS==1) {
							//Only preprocess if we have not reached end of file
							preprocess(epochDGNSS,options,2);
						}
						epoch->receiver.numRecStation=epochDGNSS->receiver.numRecStation;
						epoch->receiver.RecStationCoord=epochDGNSS->receiver.RecStationCoord;
						epoch->receiver.ChangedStaEpoch=epochDGNSS->receiver.ChangedStaEpoch;
					}
					if(options->RTCMmode == ProcessRINEX ){
						//Check for data gaps in the reference file
						if (epochDGNSS->CurrentDataGapSize>0 ) {
							if (epoch->direction == pFORWARD) {
								epochDGNSS->NumDataGapsTotal++;
								epochDGNSS->NumEpochsMissingTotal+=epochDGNSS->CurrentDataGapSize;
								if (epochDGNSS->CurrentDataGapSize>=epochDGNSS->MaxDataGapSizeTotal) {
									epochDGNSS->MaxDataGapSizeTotal=epochDGNSS->CurrentDataGapSize;
									memcpy(&epochDGNSS->DataGapTotal,&epochDGNSS->t,sizeof(TTime));
								}
								if (options->useDatasummary==1) {
									epochDGNSS->NumDataGapsSum++;
									epochDGNSS->NumEpochsMissingSum+=epochDGNSS->CurrentDataGapSize;
									if (epochDGNSS->CurrentDataGapSize>=epochDGNSS->MaxDataGapSizeSum) {
										epochDGNSS->MaxDataGapSizeSum=epochDGNSS->CurrentDataGapSize;
										memcpy(&epochDGNSS->DataGapSum,&epochDGNSS->t,sizeof(TTime));
									}
								}
							}
						}
					}
				} else if ( deltaTime > 0.0 && retDGNSS == 1 ) {
					// Advance the Reference Station corrections; Rover Station (user) has data gap
					while ( deltaTime >= 1.0 && retDGNSS == 1 ) {
						if ( options->RTCMmode == ProcessRTCM2 ) {
							// Process the binary RTCM v2.x
							retDGNSS = converterRTCM2(fdRTCM2, rtcm2, NULL, NULL, epochDGNSS, options);
						} else if ( options->RTCMmode == ProcessRTCM3 ) {
							// Process the binary RTCM v3.x
							retDGNSS = converterRTCM3(fdRTCM3, rtcm3, NULL, epoch, epochDGNSS, options);
							if (retDGNSS==1) {
								//Only preprocess if we have not reached end of file
								preprocess(epochDGNSS,options,2);
							}
						} else {
							// Read the RINEX observables
							retDGNSS = readRinexObsEpoch(fdRNXdgnss, epochDGNSS, Epochstr,options);
							if(retDGNSS==2) {
								// Read the RINEX header and next epoch (if header is found, readRinexObsEpoch function does not read any data!)
								retDGNSS = readRinexObsHeader(fdRNXdgnss,NULL,epochDGNSS,options);
								//Update values for reference station after reading header
								posRINEXHeaderDataUpdate(REFSTAPOS,sopt->setRecType[REFSTAPOS],sopt->recFile,&recList,&antennaList,&constellationSatBlock,epochDGNSS,options);	
								//Read next epoch
								retDGNSS = readRinexObsEpoch(fdRNXdgnss, epochDGNSS, Epochstr,options);
							}
							if (retDGNSS==1) {
								//Only preprocess if we have not reached end of file
								preprocess(epochDGNSS,options,2);
							}
							epoch->receiver.numRecStation=epochDGNSS->receiver.numRecStation;
							epoch->receiver.RecStationCoord=epochDGNSS->receiver.RecStationCoord;
							epoch->receiver.ChangedStaEpoch=epochDGNSS->receiver.ChangedStaEpoch;
						}
						deltaTime = tdiff(&epoch->t, &epochDGNSS->t);
						if(options->RTCMmode == ProcessRINEX ){
							//Check for data gaps in the reference file
							if (epochDGNSS->CurrentDataGapSize>0 ) {
								if (epoch->direction == pFORWARD) {
									epochDGNSS->NumDataGapsTotal++;
									epochDGNSS->NumEpochsMissingTotal+=epochDGNSS->CurrentDataGapSize;
									if (epochDGNSS->CurrentDataGapSize>=epochDGNSS->MaxDataGapSizeTotal) {
										epochDGNSS->MaxDataGapSizeTotal=epochDGNSS->CurrentDataGapSize;
										memcpy(&epochDGNSS->DataGapTotal,&epochDGNSS->t,sizeof(TTime));
									}
									if (options->useDatasummary==1) {
										epochDGNSS->NumDataGapsSum++;
										epochDGNSS->NumEpochsMissingSum+=epochDGNSS->CurrentDataGapSize;
										if (epochDGNSS->CurrentDataGapSize>=epochDGNSS->MaxDataGapSizeSum) {
											epochDGNSS->MaxDataGapSizeSum=epochDGNSS->CurrentDataGapSize;
											memcpy(&epochDGNSS->DataGapSum,&epochDGNSS->t,sizeof(TTime));
										}
									}
								}
							}
						}
					}
				}
				deltaTime = tdiff(&epoch->t, &epochDGNSS->t);
				//Check for the case that Rover is advanced to Reference station due to Rover has decimal in the epoch (e.g 1.001. 1.1)
				if ( deltaTime >= 1.0 && retDGNSS == 1 ) { 
					if ( options->RTCMmode == ProcessRTCM2 ) {
						// Process the binary RTCM v2.x
						retDGNSS = converterRTCM2(fdRTCM2, rtcm2, NULL, NULL, epochDGNSS, options);
					} else if ( options->RTCMmode == ProcessRTCM3 ) {
						// Process the binary RTCM v3.x
						retDGNSS = converterRTCM3(fdRTCM3, rtcm3, NULL, epoch, epochDGNSS, options);
						if (retDGNSS==1) {
							//Only preprocess if we have not reached end of file
							preprocess(epochDGNSS,options,2);
						}
					} else {
						// Read the RINEX observables
						retDGNSS = readRinexObsEpoch(fdRNXdgnss, epochDGNSS, Epochstr, options);
						if(retDGNSS==2) {
							// Read the RINEX header and next epoch (if header is found, readRinexObsEpoch function does not read any data!)
							retDGNSS = readRinexObsHeader(fdRNXdgnss,NULL,epochDGNSS,options);
							//Update values for reference station after reading header
							posRINEXHeaderDataUpdate(REFSTAPOS,sopt->setRecType[REFSTAPOS],sopt->recFile,&recList,&antennaList,&constellationSatBlock,epochDGNSS,options);	
							//Read next epoch
							retDGNSS = readRinexObsEpoch(fdRNXdgnss, epochDGNSS, Epochstr, options);
						}
						if (retDGNSS==1) {
							//Only preprocess if we have not reached end of file
							preprocess(epochDGNSS,options,2);
						}
						epoch->receiver.numRecStation=epochDGNSS->receiver.numRecStation;
						epoch->receiver.RecStationCoord=epochDGNSS->receiver.RecStationCoord;
						epoch->receiver.ChangedStaEpoch=epochDGNSS->receiver.ChangedStaEpoch;
					}
					deltaTime = tdiff(&epoch->t, &epochDGNSS->t);
					if(options->RTCMmode == ProcessRINEX ){
						//Check for data gaps in the reference file
						if (epochDGNSS->CurrentDataGapSize>0 ) {
							if (epoch->direction == pFORWARD) {
								epochDGNSS->NumDataGapsTotal++;
								epochDGNSS->NumEpochsMissingTotal+=epochDGNSS->CurrentDataGapSize;
								if (epochDGNSS->CurrentDataGapSize>=epochDGNSS->MaxDataGapSizeTotal) {
									epochDGNSS->MaxDataGapSizeTotal=epochDGNSS->CurrentDataGapSize;
									memcpy(&epochDGNSS->DataGapTotal,&epochDGNSS->t,sizeof(TTime));
								}
								if (options->useDatasummary==1) {
									epochDGNSS->NumDataGapsSum++;
									epochDGNSS->NumEpochsMissingSum+=epochDGNSS->CurrentDataGapSize;
									if (epochDGNSS->CurrentDataGapSize>=epochDGNSS->MaxDataGapSizeSum) {
										epochDGNSS->MaxDataGapSizeSum=epochDGNSS->CurrentDataGapSize;
										memcpy(&epochDGNSS->DataGapSum,&epochDGNSS->t,sizeof(TTime));
									}
								}
							}
						}
					}
				}
				// Base Station is advanced with respect to the Rover
				// Therefore, do not compute corrections
				if ( deltaTime < 0 && retDGNSS == 1 ) {
					computeDGNSScor = 0;
					for ( i=0; i<epoch->numSatellites; i++ ) {
						epoch->sat[i].hasDGNSScor = 7;
					}
				}

				// In case of S/A enabled, the maximum age is set to 1 seconds
				if ( processedEpochs == 0 && options->RTCMmode == ProcessRINEX ) {
					if ( epoch->t.MJDN < epoch->FirstEpochSAoff.MJDN /*May 2nd, 2000*/ ) {
						options->maxAgeDGNSS = 1;
						printInfo("WARNING the maximum age to apply DGNSS corrections is forced to 1 seconds due to S/A", options);
					}
				}
			}
			//// End of Adjust time between Reference Station and Rover Station (user) in DGNSS mode

			if ( ret ) {
				//Increment counter of number of epochs read
				//It has to be incremented inside the ret to avid adding an extra epoch when calling 
				//readRinexObsEpoch after the last epoch has been read (in this case ret will be 0)
				if (epoch->direction==pFORWARD) {
					epoch->TotalEpochsFile++;
					//Save position of current epoch
					if (epoch->numEpochReadFilePos>=epoch->maxNumEpochReadFilePos) {
						//Buffer filled, we need to expand it
						epoch->maxNumEpochReadFilePos+=86400*2;//Add space for two days in each iteration
						epoch->epochReadFilePos=realloc(epoch->epochReadFilePos,sizeof(off_t)*epoch->maxNumEpochReadFilePos);
					}
					epoch->epochReadFilePos[epoch->numEpochReadFilePos]=ftell(fdRNX);
					epoch->numEpochReadFilePos++;
				}

				//Check if first epoch set by user is reached
				if (options->StartEpoch.MJDN!=-1) {
					if(tdiff(&epoch->t,&options->StartEpoch)<0.) {
						//Not arrived to first epoch set by user
						//Show epochs being skipped if printing progress in command line
						if (epoch->NewPercentage) { 
							epoch->NewPercentage=0;
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"%s%c",Epochstr,options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						continue;
					} else {
						//Set MJDN to -1 to stop checking the condition
						options->StartEpoch.MJDN=-1;
					}
				} else if (options->EndEpoch.MJDN!=-1) {
					if(tdiff(&epoch->t,&options->EndEpoch)>DIFFEQTHRESHOLD) { //The DIFFEQTHRESHOLD is to avoid problems with decimals
						//Last epoch set by user reached
						break;
					}
				}

				//Check for data gaps in the rover observation file
				if (epoch->CurrentDataGapSize>0 ) {
					if (epoch->direction == pFORWARD) {
						epoch->NumDataGapsTotal++;
						if (epoch->CurrentDataGapSize>=epoch->MaxDataGapSizeTotal) {
							epoch->MaxDataGapSizeTotal=epoch->CurrentDataGapSize;
							memcpy(&epoch->DataGapTotal,&epoch->t,sizeof(TTime));
						}
						if (options->useDatasummary==1) {
							epoch->NumDataGapsSum++;
							if (epoch->CurrentDataGapSize>=epoch->MaxDataGapSizeSum) {
								epoch->MaxDataGapSizeSum=epoch->CurrentDataGapSize;
								memcpy(&epoch->DataGapSum,&epoch->t,sizeof(TTime));
							}
						}
					}
				}

				if ( tdiff(&epoch->t,&endProductsTime) > 0 && options->filterIterations > 1 ) ret = 0;
			}
			if ( ret ) {
				if ( tdiff(&epoch->t,&endProductsTime) > 0 && options->filterIterations > 1 ) {
					ret = 0;
				} else if (tdiff(&epoch->t,&endProductsTime) > 0 || MJDNEpoch<epoch->t.MJDN ) {
					// Read the following day of the RINEX navigation file
					ret1=ret2=1;
					newNavDataRead=0;
					if (printProgress==1 && sopt->numNav>0) {
						if (options->ProgressEndCharac=='\r') {
							//Printing to a terminal
							fprintf(options->terminalStream,"Reading navigation file%s%50s%c",sopt->numNav==1?"":"s","",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					j=0;
					newDayRinexNav=1;
					for(i=0;i<sopt->numNav;i++) {
						if ( fdRNXnav[i] != NULL) {
							if(nextNav[i]==1) {
								newNavDataRead=1;
								ret1 = readRinexNav(fdRNXnav[i],sopt->navFile[i],&products,&rinexNavVersion,newDayRinexNav==1?NEWDAYNAV:SAMEDAYNAV,options);
								newDayRinexNav++;
								// Set products end time
								if ( options->workMode == wmDOPROCESSING ) {
									endProductsTime = getProductsLastEpoch(&products);
								}
								if ( ret1 < 1 ) {
									if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
										sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->navFile[i]);
										printError(messagestr,options);
									} else {
										sprintf(messagestr,"Reading RINEX navigation message file [%s]",sopt->navFile[i]);
										printError(messagestr,options);
									}
								} else if (ret1==2) {
									nextNav[i]=1;
								} else {
									nextNav[i]=0;
									fclose(fdRNXnav[i]);
									fdRNXnav[i]=NULL;
								}
							} else {
								ret1=0;
							}
							if ( ret1 >= 1 ) {
								if(j==0) concatCount++;
								j++;
							}
						}
					}
					if (sopt->numNav>0) {
						//Rebuild list of available RINEX navigation message types
						for(i=0;i<MAX_GNSS;i++) {
							for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
								//Reset BRDCAvailSelOrder list
								for(k=0;k<=MAX_BRDC_TYPES;k++) {
									options->BRDCAvailSelOrder[ORBNAVPOS][i][j][k]=0;
								}
								//Fill with available messages
								l=0;
								for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
									if (products.BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
										options->BRDCAvailSelOrder[ORBNAVPOS][i][j][l]=options->BRDCSelOrder[i][j][k];
										l++;
									}
								}
								options->BRDCAvailSelOrder[ORBNAVPOS][i][j][MAX_BRDC_TYPES]=l;
							}
						}
					}
					//Update GLONASS frequency offsets
					if (epoch->measOrder[GLONASS].hasGlonassSlotsFreq>=1) {
						if (newNavDataRead==1 || nextgloNav==1) {
							//Only update if a new navigation data is available
							getGLOFreqOffsets(epoch,sopt->navFile[0],sopt->glonavFile,&fdRNXglonav,&nextgloNav,&products,&productsGLO,options);
						}
					}
					//Copy GLONASS offsets frequencies to EpochDGNSS
					if (options->DGNSS) {
						memcpy(&epochDGNSS->measOrder[GLONASS].lambdaMeas[1],&epoch->measOrder[GLONASS].lambdaMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].lambdaMeas[2],&epoch->measOrder[GLONASS].lambdaMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].freqMeas[1],&epoch->measOrder[GLONASS].freqMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].freqMeas[2],&epoch->measOrder[GLONASS].freqMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].mfreqMeas[1],&epoch->measOrder[GLONASS].mfreqMeas[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].mfreqMeas[2],&epoch->measOrder[GLONASS].mfreqMeas[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].TECU2metres[1],&epoch->measOrder[GLONASS].TECU2metres[1],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->measOrder[GLONASS].TECU2metres[2],&epoch->measOrder[GLONASS].TECU2metres[2],sizeof(double)*MAX_SATELLITES_PER_GNSS);
						memcpy(&epochDGNSS->GLOfreqnumber,&epoch->GLOfreqnumber,sizeof(int)*MAX_SATELLITES_PER_GNSS);
					}

					//Recompute frequencies for GLONASS, as they might have changed
					for(i=0;i<NUM_OBSRINEX;i++) {
						if (i==ROVERPOS) epochPointer=epoch;
						else epochPointer=epochDGNSS;
						for(j=1;j<=listMaxSatGNSS[GLONASS];j++) {
							for(k=0;k<options->numfilterMeasList[i][GLONASS][j];k++) {
								switch (options->filterMeasTypeList[i][GLONASS][j][k]) {
									case IonoFreeCombCode: case IonoFreeCombPhase: 
									case IonoFreeCombDoppler: case IonoFreeCombCodeSmoothed:
										freq1=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][0]][j];
										freq2=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][1]][j];
										if (freq1==1. || freq2==1.) {
											epochPointer->measOrder[GLONASS].filterMeaslambda[j][k]=0.;
											options->filterMeasFreqMissng[GLONASS][j]=1;
										} else {
											epochPointer->measOrder[GLONASS].filterMeaslambda[j][k]=c0/(freq1+freq2);
											options->filterMeasFreqMissng[GLONASS][j]=0;
										}
										break;
									case SecondIonoFreeCode: case SecondIonoFreePhase: 
									case SecondIonoFreeDoppler: case SecondIonoFreeCodeSmoothed:
										freq1=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][0]][j];
										freq2=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][1]][j];
										freq3=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][2]][j];
										freq4=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][3]][j];
										if (freq1==1. || freq2==1. || freq3==1. || freq4==1.) {
											epochPointer->measOrder[GLONASS].filterMeaslambda[j][k]=0.;
											options->filterMeasFreqMissng[GLONASS][j]=1;
										} else {
											epochPointer->measOrder[GLONASS].filterMeaslambda[j][k]=epoch->measOrder[GLONASS].lambdaMeas[options->filterMeasfreq[i][GLONASS][j][k][0]][j];//To be revised
											options->filterMeasFreqMissng[GLONASS][j]=0;
										}
										break;
									default:
										freq1=epochPointer->measOrder[GLONASS].freqMeas[options->filterMeasfreq[i][GLONASS][j][k][0]][j];
										if (freq1==1.) {
											epochPointer->measOrder[GLONASS].filterMeaslambda[j][k]=0.;
											options->filterMeasFreqMissng[GLONASS][j]=1;
										} else {
											epochPointer->measOrder[GLONASS].filterMeaslambda[j][k]=epoch->measOrder[GLONASS].lambdaMeas[options->filterMeasfreq[i][GLONASS][j][k][0]][j];
											options->filterMeasFreqMissng[GLONASS][j]=0;
										}
										break;
								}					
							}
						}
					}

					//Check available GLONASS frequency offset values (k). 
					//If not available, disable GLONASS frequencies 1 and 2
					for(i=1;i<=listMaxSatGNSS[GLONASS];i++) {
						enabledSat=0;
						if (options->GLOsatFDMAdisabled[GLONASS][i][1] == 1 && epoch->measOrder[GLONASS].lambdaMeas[1][i]!=1.) {
							options->GLOsatFDMAdisabled[GLONASS][i][1] = 0;
							options->usableFreq[GLONASS][i][1]=1;
							enabledSat=1;
						} else if (options->usableFreq[GLONASS][i][1]==1 && epoch->measOrder[GLONASS].lambdaMeas[1][i]==1.) {
							options->GLOsatFDMAdisabled[GLONASS][i][1] = 1;
							options->usableFreq[GLONASS][i][1]=0;
						}
						if (options->GLOsatFDMAdisabled[GLONASS][i][2] == 1 && epoch->measOrder[GLONASS].lambdaMeas[2][i]!=1.) {
							options->GLOsatFDMAdisabled[GLONASS][i][2] = 0;
							options->usableFreq[GLONASS][i][2]=1;
							enabledSat=1;
						} else if (options->usableFreq[GLONASS][i][2]==1 && epoch->measOrder[GLONASS].lambdaMeas[2][i]==1.) {
							options->GLOsatFDMAdisabled[GLONASS][i][2] = 1;
							options->usableFreq[GLONASS][i][2]=0;
						}
						//Compute IGF factors if necessary
						if (enabledSat==1 && options->csIGF==1 && options->csIGFminNoise==1 && options->includeSatellite[GLONASS][i]==1) {
							for(j=0;j<options->numcsIGFMeasList[ROVERPOS][GLONASS][i];j++) {
								computeIGFfactors(epoch,GLONASS,i,options->csIGFMeasList[ROVERPOS][GLONASS][i][j][0]-IGF1012,options->csIGFMeasFreq[ROVERPOS][GLONASS][i][j]);
							}
							if (options->DGNSS==1) {
								for(j=0;j<options->numcsIGFMeasList[REFSTAPOS][GLONASS][i];j++) {
									computeIGFfactors(epoch,GLONASS,i,options->csIGFMeasList[REFSTAPOS][GLONASS][i][j][0]-IGF1012,options->csIGFMeasFreq[REFSTAPOS][GLONASS][i][j]);
								}
							}
						}
					}
					//Update leap seconds for the new day (a leap second may have ocurred after changing the day) 
					if(epoch->SystemTime==GLONASS) {
						if (products.BRDC!=NULL && products.BRDC->LeapSecondsAvail==1) {
							epoch->ObsTimeToGPSTime=(double)products.BRDC->AT_LS;
						} else if (productsGLO.BRDC!=NULL && productsGLO.BRDC->LeapSecondsAvail==1) {
							epoch->ObsTimeToGPSTime=(double)productsGLO.BRDC->AT_LS;
						} else {
							epoch->ObsTimeToGPSTime=getLeapSeconds(&epoch->t,epoch->LeapSecondsTimeList,epoch->LeapSecondsNumList);
						}
					}
					if (options->DGNSS==1) {
						if(epochDGNSS->SystemTime==GLONASS) {
							if (products.BRDC!=NULL && products.BRDC->LeapSecondsAvail==1) {
								epochDGNSS->ObsTimeToGPSTime=(double)products.BRDC->AT_LS;
							} else if (productsGLO.BRDC!=NULL && productsGLO.BRDC->LeapSecondsAvail==1) {
								epochDGNSS->ObsTimeToGPSTime=(double)productsGLO.BRDC->AT_LS;
							} else {
								epochDGNSS->ObsTimeToGPSTime=getLeapSeconds(&epoch->t,epoch->LeapSecondsTimeList,epoch->LeapSecondsNumList);
							}
						}
					}
					//Copy leap seconds read from RINEX navigation header if available
					if (products.BRDC!=NULL && products.BRDC->LeapSecondsAvail==1) {
						epoch->leapSecondsAvail=1;
						epoch->leapSeconds=products.BRDC->AT_LS;
						if (options->DGNSS==1) {
							epochDGNSS->leapSecondsAvail=1;
							epochDGNSS->leapSeconds=products.BRDC->AT_LS;
						}
					} else if (productsGLO.BRDC!=NULL && productsGLO.BRDC->LeapSecondsAvail==1) {
						epoch->leapSecondsAvail=1;
						epoch->leapSeconds=productsGLO.BRDC->AT_LS;
						if (options->DGNSS==1) {
							epochDGNSS->leapSecondsAvail=1;
							epochDGNSS->leapSeconds=productsGLO.BRDC->AT_LS;
						}
					} else {
						epoch->leapSeconds=getLeapSeconds(&epoch->t,epoch->LeapSecondsTimeList,epoch->LeapSecondsNumList);
						if (options->DGNSS==1) {
							epochDGNSS->leapSeconds=getLeapSeconds(&epoch->t,epoch->LeapSecondsTimeList,epoch->LeapSecondsNumList);
						}
					}

					//Read new data for navigation health data for PPP
					if (sopt->numNavHealth>0 && options->workMode == wmDOPROCESSING) {
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Reading navigation file%s for satellite health%50s%c",sopt->numNavHealth==1?"":"s","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						newDayRinexNav=1;
						for(i=0;i<sopt->numNavHealth;i++) {
							if ( fdRNXHealthPPP[i] != NULL) {
								if(nextNavHealth[i]==1) {
									ret3 = readRinexNav(fdRNXHealthPPP[i],sopt->navHealthFile[i], &productsHealthforPPP,&rinexNavVersion,newDayRinexNav==1?NEWDAYNAV:SAMEDAYNAV,options);
									newDayRinexNav++;
									if ( ret3 < 1 ) {
										if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
											sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->navHealthFile[i]);
											printError(messagestr,options);
										} else {
											sprintf(messagestr,"Reading RINEX navigation message file [%s]",sopt->navHealthFile[i]);
											printError(messagestr,options);
										}
									} else if (ret3==2) {
										nextNavHealth[i]=1;
									} else {
										nextNavHealth[i]=0;
										fclose(fdRNXHealthPPP[i]);
										fdRNXHealthPPP[i]=NULL;
									}
								}
							}
						}
						//Rebuild list of available RINEX navigation message types for health data
						for(i=0;i<MAX_GNSS;i++) {
							for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
								//Reset BRDCAvailSelOrder list
								for(k=0;k<=MAX_BRDC_TYPES;k++) {
									options->BRDCAvailSelOrder[HEALTHNAVPOS][i][j][k]=0;
								}
								//Fill with available messages
								l=0;
								for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
									if (productsHealthforPPP.BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
										options->BRDCAvailSelOrder[HEALTHNAVPOS][i][j][l]=options->BRDCSelOrder[i][j][k];
										l++;
									}
								}
								options->BRDCAvailSelOrder[HEALTHNAVPOS][i][j][MAX_BRDC_TYPES]=l;
							}
						}
					}

					//Read new SP3 data
					if ( options->NextSP3 ) {
						freeSP3data(&pastSP3Prod);
						memcpy(&pastSP3Prod,&products,sizeof(TGNSSproducts));
						memcpy(&products,&nextSP3Prod,sizeof(TGNSSproducts));
						if ( fdSP3 != NULL )	{
							if (printProgress==1) {	
								if (options->ProgressEndCharac=='\r') {
									//Printing to a terminal
									fprintf(options->terminalStream,"Reading SP3 file for orbits and clocks%50s%c","",options->ProgressEndCharac);
									fflush_function(options->terminalStream);
								}
							}
							ret1 = readSP3(fdSP3,&nextSP3Prod,1,1,0,options);
						}
						if ( fdSP3o != NULL )	{
							if (printProgress==1) {	
								if (options->ProgressEndCharac=='\r') {
									//Printing to a terminal
									fprintf(options->terminalStream,"Reading SP3 file for orbits%50s%c","",options->ProgressEndCharac);
									fflush_function(options->terminalStream);
								}
							}
							ret1 = readSP3(fdSP3o,&nextSP3Prod,1,0,0,options);
						}
						if ( fdCLK != NULL )	{
							if (printProgress==1) {	
								if (options->ProgressEndCharac=='\r') {
									//Printing to a terminal
									fprintf(options->terminalStream,"Reading precise clocks file%50s%c","",options->ProgressEndCharac);
									fflush_function(options->terminalStream);
								}
							}
							ret2 = readRinexClocks(fdCLK,&nextSP3Prod,options);
						} else {
							ret2 = 1;
						}
						if ( ret1 != 2 ) options->NextSP3 = 0;
						if ( fdCLK != NULL && ret2 != 2 ) 	options->NextSP3 = 0; //Both SP3 and CLK must be equal length, otherwise do not concatenate more

						if(options->NextSP3==0) {
							// Set products end time
							if ( options->workMode == wmDOPROCESSING ) {
								endProductsTime = getProductsLastEpoch(&nextSP3Prod);
							}
						} else {
							// Set products end time
							if ( options->workMode == wmDOPROCESSING ) {
								endProductsTime = getProductsLastEpoch(&products);
							}
						}

						//Concatenate SP3 and clocks
						if (printProgress==1) {	
							if (options->ProgressEndCharac=='\r') {
								//Printing to a terminal
								fprintf(options->terminalStream,"Ordering precise products data%50s%c","",options->ProgressEndCharac);
								fflush_function(options->terminalStream);
							}
						}
						ConcatenateSP3(0,&products,&pastSP3Prod,&nextSP3Prod,options);	
					} else if (fdSP3 != NULL || fdSP3o != NULL) {
						endProductsTime = getProductsLastEpoch(&nextSP3Prod);
					}
					// End gLAB because no products are available
					if ( ret1 == 0 && ret2==0 ) {
						if ( concatCount == 1 ) {
							if (printProgress==1) {
								fprintf(options->terminalStream,"Percentage converted: %3d%%%50s%c",100,"",options->ProgressEndCharac);
								#if !defined(__WIN32__)
									if (options->ProgressEndCharac=='\r') {
										fprintf(options->terminalStream,"%95s%c","",options->ProgressEndCharac);
									}
									//Enable cursor again
									if (sopt->disableCursor==1) {
										fprintf(options->terminalStream,"%s",enableCursor);
									}
								#endif
								fflush_function(options->terminalStream);
							}
							printError("Orbit and clock products are of a different time than the observation RINEX",options);
						}
						return 1;
					}

					// Check DCB
					newDayRinexNav=1;
					for (i=0;i<sopt->numTGD;i++) {
						auxft1 = whatFileTypeIs(sopt->tgdFile[i]);
						if ( auxft1 == ftRINEXbroadcast && options->GPSp1p2DCBModel == DCBRINEX ) {
							if ( fdTGD[i]!=NULL ) {
								if (printProgress==1) {	
									if (options->ProgressEndCharac=='\r') {
										//Printing to a terminal
										fprintf(options->terminalStream,"Reading navigation file for DCB%50s%c","",options->ProgressEndCharac);
										fflush_function(options->terminalStream);
									}
								}
								retTGD[i]=readRinexNav(fdTGD[i],sopt->tgdFile[i],&productsTgd,&rinexNavVersion,newDayRinexNav==1?NEWDAYNAV:SAMEDAYNAV,options);
								newDayRinexNav++;
								if ( retTGD[i] < 1 ) {
									if ((int)rinexNavVersion>3 && rinexNavVersion!=0) {
										sprintf(messagestr,"RINEX navigation version %1.2f from file '%s' is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->tgdFile[i]); 	
										printError(messagestr,options);
									} else {
										sprintf(messagestr,"Reading RINEX navigation message file for DCB data '%s'",sopt->tgdFile[i]);
										printError(messagestr,options);
									}
								} else if (retTGD[i]!=2) {
									fclose(fdTGD[i]);
									fdTGD[i]=NULL;
								}
								tgdData.BRDC = productsTgd.BRDC;
							}
							//Rebuild list of available RINEX navigation message types for TGD
							for(j=0;j<MAX_GNSS;j++) {
								for(k=0;k<MAX_BRDC_SELECTION_TYPES;k++) {
									//Reset BRDCAvailSelOrder list
									for(l=0;l<=MAX_BRDC_TYPES;l++) {
										options->BRDCAvailSelOrder[TGDNAVPOS][j][k][l]=0;
									}
									//Fill with available messages
									m=0;
									for(l=0;l<options->BRDCSelOrder[j][k][MAX_BRDC_TYPES];l++) {
										if (tgdData.BRDC->AvailBRDCType[j][options->BRDCSelOrder[j][k][l]]==1) {
											options->BRDCAvailSelOrder[TGDNAVPOS][j][k][m]=options->BRDCSelOrder[j][k][l];
											m++;
										}
									}
									options->BRDCAvailSelOrder[TGDNAVPOS][j][k][MAX_BRDC_TYPES]=m;
								}
							}
						} else if ( auxft1==ftIONEX && (options->GPSp1p2DCBModel==DCBIONEX || options->GLOp1p2DCBModel==DCBIONEX || options->FPPPDCBModel==DCBIONEX ) && MJDNEpoch<epoch->t.MJDN) {
							//Read new DCB parameters only if we have changed day
							if (fdTGD[i]!=NULL ) { 
								if (printProgress==1) {	
									if (options->ProgressEndCharac=='\r') {
										//Printing to a terminal
										fprintf(options->terminalStream,"Reading IONEX file for DCB data%50s%c","",options->ProgressEndCharac);
										fflush_function(options->terminalStream);
									}
								}
								retTGD[i]=readIONEX(fdTGD[i],&productsIonex,&ionexVersion,options);
								if ( retTGD[i] < 1 ) {
									if ((int)ionexVersion!=1 && ionexVersion!=0){
										sprintf(messagestr,"IONEX version %1.2f from file [%s] is not supported. Supported version is 1",ionexVersion,sopt->tgdFile[i]);
										printError(messagestr,options);
									} else if (retTGD[i]==-2) {
										sprintf(messagestr,"Number of records in IONEX header in file [%s] does not match the number of records read",sopt->tgdFile[i]);
										printError(messagestr,options);
									} else {
										sprintf(messagestr,"Reading IONEX file [%s] for DCB data" ,sopt->tgdFile[i]);
										printError(messagestr,options);
									}
								} else if ( productsIonex.ionexDCB.DCBavailable == 0 ) {
									sprintf(messagestr,"IONEX file [%s] selected for DCB corrections, but no DCB data was found in the file",sopt->tgdFile[i]);
									printError(messagestr,options);
								} else {
									tgdData.ionexDCB = productsIonex.ionexDCB;
									if ( retTGD[i] == 2 ) {
										sprintf(messagestr,"WARNING: IONEX file [%s] for DCB data has no 'END OF FILE' line. File may not be complete",sopt->tgdFile[i]);
										printInfo(messagestr,options);
										fclose(fdTGD[i]);
										fdTGD[i]=NULL;
									} else if ( retTGD[i] == 4 ) {
										sprintf(messagestr,"WARNING: IONEX file [%s] for DCB data is concatenated, but has no 'END OF FILE' line. File may not be complete",sopt->tgdFile[i]);
										printInfo(messagestr,options);
									} else if (retTGD[i] != 3 ) {
										fclose(fdTGD[i]);
										fdTGD[i]=NULL;
									}
								}
							}
						}
					}
					if (MJDNEpoch<epoch->t.MJDN ) {
						switch(options->ionoModel) {
							case KlobucharIonoModel:
								//Read new Klobuchar parameters only if we have changed day
								if ( fdRNXKlb != NULL ) {
									if (printProgress==1) {	
										if (options->ProgressEndCharac=='\r') {
											//Printing to a terminal
											fprintf(options->terminalStream,"Reading navigation file for Klobuchar%50s%c","",options->ProgressEndCharac);
											fflush_function(options->terminalStream);
										}
									}
									ret1=readRinexNav(fdRNXKlb,sopt->klbFile,&productsKlb,&rinexNavVersion,NEWDAYNAV,options);
									if ( ret1 < 1 ) {
										if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
											sprintf(messagestr,"RINEX navigation version %1.2f from file '%s' is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->klbFile);
											printError(messagestr,options);
										} else {
											sprintf(messagestr,"Reading RINEX navigation message file '%s'",sopt->klbFile);
											printError(messagestr,options);
										}
									} else if (ret1!=2) {
										fclose(fdRNXKlb);
										fdRNXKlb=NULL;
									}
								} else if ( products.type == BRDC ) {
									productsKlb.BRDC = products.BRDC;
									productsKlb.type = products.type;
								}
								break;
							case BeiDouIonoModel:
								//Read new BeiDou parameters only if we have changed day
								if ( fdRNXBei != NULL ) {
									if (printProgress==1) {	
										if (options->ProgressEndCharac=='\r') {
											//Printing to a terminal
											fprintf(options->terminalStream,"Reading navigation file for BeiDou%50s%c","",options->ProgressEndCharac);
											fflush_function(options->terminalStream);
										}
									}
									ret1=readRinexNav(fdRNXBei,sopt->beiFile,&productsBei,&rinexNavVersion,NEWDAYNAV,options);
									if ( ret1 < 1 ) {
										if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
											sprintf(messagestr,"RINEX navigation version %1.2f from file '%s' is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->beiFile);
											printError(messagestr,options);
										} else {
											sprintf(messagestr,"Reading RINEX navigation message file '%s'",sopt->beiFile);
											printError(messagestr,options);
										}
									} else if (ret1!=2) {
										fclose(fdRNXBei);
										fdRNXBei=NULL;
									}
								} else if ( products.type == BRDC ) {
									productsBei.BRDC = products.BRDC;
									productsBei.type = products.type;
								}
								break;
							case neQuickIonoModel:
								//Read new NeQuick parameters only if we have changed day
								if ( fdRNXNeq != NULL ) {
									if (printProgress==1) {	
										if (options->ProgressEndCharac=='\r') {
											//Printing to a terminal
											fprintf(options->terminalStream,"Reading navigation file for NeQuick%50s%c","",options->ProgressEndCharac);
											fflush_function(options->terminalStream);
										}
									}
									ret1=readRinexNav(fdRNXNeq,sopt->neqFile,&productsNeq,&rinexNavVersion,NEWDAYNAV,options);
									if ( ret1 < 1 ) {
										if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
											sprintf(messagestr,"RINEX navigation version %1.2f from file '%s' is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->neqFile);
											printError(messagestr,options);
										} else {
											sprintf(messagestr,"Reading RINEX navigation message file '%s' for NeQuick data",sopt->neqFile);
											printError(messagestr,options);
										}
									} else if ( (int)rinexNavVersion < 3 ) {
										sprintf(messagestr,"RINEX navigation version %1.2f from file '%s' is below 3. This version does not contain NeQuick data",rinexNavVersion,sopt->neqFile);
										printError(messagestr,options);
									} else if (ret1!=2) {
										fclose(fdRNXNeq);
										fdRNXNeq=NULL;
									}
								} else if ( products.type == BRDC && (int)rinexNavVersion < 3 ) {
									sprintf(messagestr,"RINEX navigation version %1.2f from file '%s' is below 3. This version does not contain NeQuick data",rinexNavVersion,sopt->navFile[0]);
									printError(messagestr,options);
								} else if ( products.type == BRDC ) {
									productsNeq.BRDC = products.BRDC;
									productsNeq.type = products.type;
								}
								break;
							case IONEXIonoModel:
								//Read new IONEX only if we have changed day
								if ( fdIONEX != NULL ) {
									if (printProgress==1) {	
										if (options->ProgressEndCharac=='\r') {
											//Printing to a terminal
											fprintf(options->terminalStream,"Reading IONEX file%50s%c","",options->ProgressEndCharac);
											fflush_function(options->terminalStream);
										}
									}
									ret1 = readIONEX(fdIONEX,&ionex,&ionexVersion,options);
									if ( ret1 < 1 ) {
										if ( (int)ionexVersion != 1 && ionexVersion != 0 ) {
											sprintf(messagestr,"IONEX version %1.2f from file [%s] is not supported. Supported version is 1",ionexVersion,sopt->inxFile);
											printError(messagestr,options);
										} else if (ret1==-2) {
											sprintf(messagestr,"Number of records in IONEX header in file [%s] does not match the number of records read",sopt->inxFile);
											printError(messagestr,options);
										} else if (ret1==-3) {
											sprintf(messagestr,"IONEX header in file [%s] is incorrect or there are missing records",sopt->inxFile);
											printError(messagestr,options);
										} else {
											sprintf(messagestr,"Reading IONEX file [%s] for ionospheric data" ,sopt->inxFile);
											printError(messagestr,options);
										}
									} else if ( ret1 == 2 ) {
										sprintf(messagestr,"WARNING: IONEX file [%s] has no 'END OF FILE' line. File may not be complete",sopt->inxFile);
										printInfo(messagestr,options);
										fclose(fdIONEX);
										fdIONEX=NULL;
									} else if ( ret1 == 4 ) {
										sprintf(messagestr,"WARNING: IONEX file [%s] is concatenated, but has no 'END OF FILE' line. File may not be complete",sopt->inxFile);
										printInfo(messagestr,options);
									} else if ( ret1 != 3 ) {
										fclose(fdIONEX);
										fdIONEX=NULL;
									}
									
									// If there is no RMS data in IONEX file, do not use this data even though it is indicated in gLAB parameters.
									if ( ionex.RMSavailable == 0 ) {
										if (options->FastPPP==1) {
											sprintf(messagestr,"IONEX file [%s] has no RMS values, but they are necessary for Fast-PPP",sopt->inxFile);
											printError(messagestr,options);
										} else if (options->useSigmaIono ==1) {
											sprintf(messagestr,"WARNING: IONEX file [%s] has no RMS values. Disconnecting sigma iono in filter",sopt->inxFile);
											printInfo(messagestr,options);
											options->useSigmaIono = 0;
										}
									}
								}
								break;
							case SBASIonoModel:
								//Read new Klobuchar parameters only if we have changed day
								// If we are processing with SBAS, we need to copy Klobuchar parameters to its struct
								if (products.BRDC==NULL) {
									//If we have not read any product type, allocate memory and initialize to 0 the productsKlb structure (only if before had not been done)
									if (productsKlb.BRDC==NULL) {
										productsKlb.BRDC = malloc(sizeof(TBRDCproducts));
										initBRDCproducts(productsKlb.BRDC,options->GLOintStep);
									}
								} else {
									productsKlb.BRDC = products.BRDC;
									productsKlb.type = products.type;
								}
								break;
							default:
								break;
						}

						//Only update last day read if we have changed day
						MJDNEpoch=epoch->t.MJDN;
					}
				}
			}

			// Check if SBAS mode has been selected
			if ( options->SBAScorrections>=SBASionoOnly ) {
				// Read SBAS data until current epoch	
				retsbas = readSBASFile(sopt->sbasFile,&SBASdatabox,&rinexBVersion,&epoch->t,options);
				//Select GEO if we don't have one (it has to be each time an epoch starts, as it is when GEO data is updated)
				SBASGEOselection(epoch,SBASdatabox.SBASdata,options);
				//Check GEO alarm status
				SBASGEOAlarmCheck(epoch,SBASdatabox.SBASdata,options);
				//Update number of GEO satellites in Epoch structure
				epoch->numSBASsatellites=SBASdatabox.SBASdata[0].numSBASsatellites;
			}
			if ( options->useraddednoise == 1) {
				addUserError(fdNoise,sopt->addederrorFile,epoch,&UserError,options);
			}
			//Update progress
			if (epoch->NewPercentage) { 
				epoch->NewPercentage=0;
				if (options->ProgressEndCharac=='\r') {
					//Printing to a terminal
					fprintf(options->terminalStream,"%s%c",Epochstr,options->ProgressEndCharac);
					fflush_function(options->terminalStream);
				} else {
					//Printing for the GUI. Only print if the integer of the percentage have changed (to avoid message spamming)
					if ((int)epoch->CurrentPercentage!=(int)epoch->PreviousPercentage) {
						fprintf(options->terminalStream,"%s%c",Epochstr,options->ProgressEndCharac);
						fflush_function(options->terminalStream);
					}
				}
				epoch->PreviousPercentage=epoch->CurrentPercentage;
			}

			if ( ret ) {
				if ( options->DGNSS == 1 ) { // DGNSS mode
					preprocess(epoch, options, 1);
					if (options->RTCMmode == ProcessRTCM2) {
						for ( i = 0; i < epochDGNSS->numSatellites; i++ ) epochDGNSS->cycleslip.arcLength[i]++;
					}
				} else {
					preprocess(epoch, options, 0);
				}
				if ( options->useraddednoise == 2) {
					addUserError(fdNoise,sopt->addederrorFile,epoch,&UserError,options);
				}
				if ( !anyInsideProducts ) {
					if ( tdiff(&epoch->t,&startProductsTime) >= 0 && tdiff(&epoch->t,&endProductsTime) <= 0 ) anyInsideProducts = 1;
				}
				if ( !isEpochDecimated(epoch, options) ) {
					printInput(epoch, &tgdData,options);
					if ( options->workMode == wmDOPROCESSING ) {

						if (options->useDatasummary == 1) {
							epoch->TotalEpochs++;	//Add 1 to total epochs processed for summary
							//Save last epoch of summary 
							memcpy(&epoch->LastSummaryEpoch,&epoch->t,sizeof(TTime));
							if(epoch->direction==pFORWARD) {
								epoch->TotalEpochsForward++;
							}

						}
						//Get reference coordinates if they are read from file	
						if (options->UseReferenceFile==1) {
							//Orbit SP3 uses orbit interpolation degree, change it temporary to reference interpolation degree
							if (options->stanfordesa==4) {
								//Reenable Stanford-ESA if in previous epoch there was no position from reference file
								options->stanfordesa=1;
							}
							epoch->receiver.RefPositionAvail=1;
							options->orbitInterpolationDegree=options->RefDegInterp; //Set interpolation degree for reference position
							options->OrbitsMaxDistance=0.; //Do not check for time between samples, as it will be different from orbit file
							retPosFile=getPositionSP3(&ReferencePos,&epoch->t,0,0,epoch->receiver.aproxPositionRef,options);
							options->orbitInterpolationDegree=OrbInterpDegree; //Recover orbit SP3 interpolation degree
							options->OrbitsMaxDistance=OrbMaxDistance; //Recover orbit SP3 max distance between samples
							if(retPosFile==0) {
								//Reference position could not be computed
								if (options->receiverPositionSource == rpSETREF) {
									//A priori position is used for modelling, As no position is available, skip epoch
									if (options->useDatasummary == 1) epoch->NumNoRefSolSkipped++;
									sprintf(messagestr,"%29s A priori position for modelling and differential OUTPUT fields could not be computed. Epoch skipped",epoch->tSoDHourStr);
									printInfo(messagestr,options);
									continue;
								} else {
									if (options->stanfordesa==1) {
										//Disable temporary Stanford-ESA when no reference position is available
										options->stanfordesa=4;
									}
									epoch->receiver.RefPositionAvail=0;
									sprintf(messagestr,"%29s Reference position could not be computed. Differential OUTPUT fields for this epoch will be 0",epoch->tSoDHourStr);
									printInfo(messagestr,options);
								}
							} else {
								//Compute reference position orientation (necessary for the summary)
								XYZ2NEU(epoch->receiver.aproxPositionRef,epoch->receiver.aproxPositionNEURef);
								getGroundStationOrientation(epoch->receiver.aproxPositionNEURef,epoch->receiver.orientationRef);
								if (options->receiverPositionSource == rpSETREF) {
									memcpy(epoch->receiver.aproxPosition,epoch->receiver.aproxPositionRef,sizeof(double)*3);
									sprintf(messagestr,"%29s A priori position for modelling and differential OUTPUT fields updated to %13.4f %13.4f %13.4f",epoch->tSoDHourStr,epoch->receiver.aproxPosition[0],epoch->receiver.aproxPosition[1],epoch->receiver.aproxPosition[2]);
									printInfo(messagestr,options);
								} else {
									sprintf(messagestr,"%29s Reference position for differential OUTPUT fields updated to %13.4f %13.4f %13.4f",epoch->tSoDHourStr,epoch->receiver.aproxPositionRef[0],epoch->receiver.aproxPositionRef[1],epoch->receiver.aproxPositionRef[2]);
									printInfo(messagestr,options);
									//Copy coordinates to aproxPositionRover in DGNSS mode
									if ( options->receiverPositionSource == rpRTCMRoverUSERREF ||  options->receiverPositionSource == rpRTCMRefUSERRoverREF) {
										memcpy(epoch->receiver.aproxPositionRover,epoch->receiver.aproxPositionRef,sizeof(double)*3);
									}
								}
							}
						}

						kalmanRes = 2;
						kalmanIterations = 0;
						Measprinted = 0;
						epoch->SwitchPossible=1;	//Enable switches in current epoch (only applicable if mode or GEO switch is enabled)
						epoch->TryGEOChange=0;		//Reset flag for changing GEO (can be for DOP, singular matrix or protection levels over alarm limits)
						while ( kalmanRes >= 2 ) {
							if( kalmanRes == 2 ) {
								kalmanIterations++;
								if ( kalmanIterations > options->maxKalmanIterations ) {
									if (printProgress==1 && options->ProgressEndCharac=='\r') {
										//This for cleaning the screen of the progress bar
										fprintf(options->terminalStream,"%80s%c","",options->ProgressEndCharac); 
									}
									printError("No convergence to solution",options);
								}
							}
							modelEpoch(epoch,options);
							if ( options->SBAScorrections>=SBAS1Fused ) {
								retsbas=1;
								if ( kalmanRes == 3 || kalmanRes == 4 ) {
									if (messagestrSwitchGEO[0]!='\0') {
										printInfo(messagestrSwitchGEO,options);
									}
									if (messagestrSwitchMode[0]!='\0') {
										printInfo(messagestrSwitchMode,options);
									}
									retsbas = SwitchSBASGEOMode(epoch,epoch->usableSatellites,epoch->numsatdiscardedSBAS,SBASdatabox.SBASdata,options);
								}
								while ( retsbas >= 1 ) {
									numsatellites = 0;
									#if defined _OPENMP
										numsatdiscardedSBAS=0;
									#else
										epoch->numsatdiscardedSBAS = 0;
									#endif
									if(options->GEOindex>=0) {
										epoch->SBASUsedGEO=SBASdatabox.SBASdata[options->GEOindex].PRN;
										epoch->SBASUsedGEOindex=options->GEOindex;
									}
									epoch->SBASUsedMode=options->precisionapproach;
									#pragma omp parallel for private(ret1) reduction(+:numsatdiscardedSBAS)
									for ( i = 0; i < epoch->numSatellites; i++ ) {
										ret1 = modelSatellite(epoch,NULL,i,&products,&productsHealthforPPP,&productsKlb,&productsBei,&productsNeq,&ionex,&fppp,&tropoGal,&tgdData,&constellation,constellationPrint,SBASdatabox.SBASdata,options);
										if ( ret1 == 1 ) {
											#pragma omp atomic
											numsatellites++;
										} else {
											if ( epoch->sat[i].hasSBAScor == 0) { 
												if ( options->SBASConstUsed[epoch->SBASUsedGEOindex][options->SBASmodePos][epoch->sat[i].GNSS]==1 ) {
													// We need to check that the satellite has been discarded due to SBAS corrections
													// and not due to other reasons. This is important because if satellites are discarded
													// for other reasons, changing GEO will be useless
													#if defined _OPENMP
														//For multi-threading, the reduction clause does not allow to use variables on structures
														numsatdiscardedSBAS++;
													#else
														epoch->numsatdiscardedSBAS++;
													#endif
												}
											}
										}
									}
									#if defined _OPENMP
										epoch->numsatdiscardedSBAS=numsatdiscardedSBAS;
									#endif
									// When computing with SBAS, if there are not 4 satellites available, we should try to change GEO or mode if we can
									if (options->selectBestGEO==0) {
										retsbas = SwitchSBASGEOMode(epoch,numsatellites,epoch->numsatdiscardedSBAS,SBASdatabox.SBASdata,options);
									} else {
										retsbas=0;
									}
								} 
							} else if ( options->DGNSS == 1 ) {
								// DGNSS mode
								//Note for multithreading with openmp: It is slower with multithreading than single thread due to
								//the overhead for creating multiple threads
								if( kalmanRes != 3 ) {
									if (options->stanfordesa==3) {
										//Enable again Stanford-ESA if it had been disabled in DGNSS mode when solution is in SPP
										options->stanfordesa=1;
									}
									if ( computeDGNSScor == 1 ) {
										// options->RTCMmode == ProcessRINEX => processing two RINEXs files in DGNSS (RTCM v3.x)
										// options->RTCMmode ==  ProcessRTCM3 => processing the RTCM v3.x directly
										switch (options->RTCMmode) {
											case ProcessRINEX: case ProcessRTCM3:
												// RTCM v3.x
												computeDGNSScorrections(epoch,epochDGNSS,&products,options);
												break;
											case ProcessRTCM2:
												// RTCM v2.x
												prepareDGNSScorrections(epochDGNSS);
												break;
											default:
												break;
										}
									}
									preFillUsableSatellites(epoch,epochDGNSS,&products,options);
									for ( i=0;i<epoch->numSatellites;i++ ) {
										modelSatellite(epoch,epochDGNSS,i,&products,&productsHealthforPPP,&productsKlb,&productsBei,&productsNeq,&ionex,&fppp,&tropoGal,&tgdData,&constellation,constellationPrint,SBASdatabox.SBASdata,options);
									}
								} else {
									//Solution moved to SPP
									for ( i=0;i<epoch->numSatellites;i++ ) {
										epoch->sat[i].hasDGNSScor = 1;
										modelSatellite(epoch, epochDGNSS, i, &products, &productsHealthforPPP,&productsKlb, &productsBei, &productsNeq, &ionex, &fppp, &tropoGal, &tgdData, &constellation,constellationPrint,SBASdatabox.SBASdata, options);
									}
								}
							} else {
								// Normal processing mode
								#pragma omp parallel for
								for ( i=0;i<epoch->numSatellites;i++ ) {
									modelSatellite(epoch,epochDGNSS,i,&products,&productsHealthforPPP,&productsKlb,&productsBei,&productsNeq,&ionex,&fppp,&tropoGal,&tgdData,&constellation,constellationPrint,SBASdatabox.SBASdata,options);
								}
							}
							if ( Measprinted == 0 ) {
								printMeas(epoch, &tgdData,constellationPrint,options);
								Measprinted = 1;
							}

							kalmanRes = Kalman(epoch,epochDGNSSfillSat,solution,&prevUnkinfo,&StdESA,constellationPrint,options);
							switch (kalmanRes) {
								case 1:
									processedEpochs++;
									if (CheckFirstEpoch) {
										if (options->DGNSS) {
											//In DGNSS, we need to check that solution is in DGNSS mode
											if (options->solutionMode==DGNSSMode) {
												memcpy(&epoch->FirstEpochSolution,&epoch->t,sizeof(TTime));
												CheckFirstEpoch=0;
											}
										} else {
											//Save first epoch with solution
											memcpy(&epoch->FirstEpochSolution,&epoch->t,sizeof(TTime));
											CheckFirstEpoch=0;
										}
									}
									if(options->DGNSS == 1 ) {
										printOutput(epoch, epochDGNSS, solution, options, &prevUnkinfo,sopt->obsFile,VERSION);
										//In DGNSS mode, we can choose wheter to write SPP solution or not
										if ((options->solutionMode==SPPMode && options->WriteSPPsolInDGNSSmodeSP3==1) || options->solutionMode==DGNSSMode) {
											//Write SP3 file if needed
											if(fdOutSP3!=NULL) {
												writeSP3file(fdOutSP3,epoch, solution,&prevUnkinfo,0,VERSION,options);
											}
										}
										if ((options->solutionMode==SPPMode && options->WriteSPPsolInDGNSSmodeRefFile==1) || options->solutionMode==DGNSSMode) {
											//Write Reference file if needed
											if(fdOutRefFile!=NULL) {
												writeReffile(fdOutRefFile,epoch, solution,&prevUnkinfo,options);
											}
										}
										if (options->useDatasummary == 1) {
											DGNSSSummaryDataUpdate(epoch, solution, options);
										}
									} else {
										printOutput(epoch, NULL, solution, options, &prevUnkinfo,sopt->obsFile,VERSION);
										if ( options->SBAScorrections>=SBAS1Fused ) {
											printSBASOUT(epoch, solution, options, &prevUnkinfo);
											// Compute SBAS summary
											if (options->useDatasummary == 1) {
												//Only update variables if we are navigating in PA or we are always in NPA forced by user parameters
												if (options->precisionapproach==PAMODE || options->UserForcedNPA==1) {
													SBASSummaryDataUpdate(epoch, solution, &SBASdatabox, options);	
												} else if ( options->precisionapproach==NPAMODE && options->UserForcedNPA==0) {
													SBASdatabox.TotalNPAEpochs++;
												}
											}
										} else if (options->useDatasummary == 1) {
											SummaryDataUpdate(epoch, solution, options);
										}
										//Write SP3 file if needed
										if(fdOutSP3!=NULL) {
											writeSP3file(fdOutSP3,epoch, solution,&prevUnkinfo,0,VERSION,options);
										}
										//Write Reference file if needed
										if(fdOutRefFile!=NULL) {
											writeReffile(fdOutRefFile,epoch, solution,&prevUnkinfo,options);
										}
									}
									//Print GEO or mode fallback INFO message after the OUTPUT and SBASOUT message
									if (messagestrSwitchGEO[0]!='\0') {
										printInfo(messagestrSwitchGEO,options);
									}
									if (messagestrSwitchMode[0]!='\0') {
										printInfo(messagestrSwitchMode,options);
									}
									break;
								case 0:
									//No solution due to lack of satellites
									if (options->useDatasummary == 1) {
										epoch->NumNoSatSkipped++;
									}
									break;
								case -1: case -3: case -4:
									//No solution due to geometry matrix or correlation matrix is singular
									if (options->useDatasummary == 1) {
										epoch->NumSingularMatrixSkipped++;
									}
									break;
								case -2:
									//No solution due to bad DOP
									//DOP skipped epoch have to be counted here and not in the calculateDOP function
									//to avoid computing twice or more an epoch (due to GEO switch, mode switch or switch from DGNSS to SPP)
									if (options->useDatasummary == 1) {
										epoch->NumDOPSkipped++;
										if (epoch->overMaxHDOP==1) {
											epoch->NumHDOPSkipped++;
										}
										if (epoch->overMaxPDOP==1) {
											epoch->NumPDOPSkipped++;
										}
										if (epoch->overMaxGDOP==1) {
											epoch->NumGDOPSkipped++;
										}
										if (epoch->overMaxHDOPorPDOP==1) {
											epoch->NumHDOPorPDOPSkipped++;
										}
									}
									break;
								case -5:
									//No solution due to reference constellation not available and it is not allowed to change the reference clock
									if (options->useDatasummary == 1) {
										epoch->NumNoRefGNSSSkipped++;
									}
									break;
								default:
									//kalmanRes==2, kalmanRes==3 or kalmanRes==4
									//The while loop continues
									break;
							} //End switch (kalmanRes)
						}//End  while ( kalmanRes >= 2 )
					} else if ( options->workMode == wmSHOWINPUT ) {
						printMeas(epoch, &tgdData,constellationPrint,options);
					}
				} else {
					//Epoch decimated
					if ( options->SBAScorrections>=SBASionoOnly ) {
						SBAShandlespecialevents(&epoch->t,SBASdatabox.SBASdata,options);
					}
					if (options->useDatasummary == 1) {
						//Save the number of epochs decimated during summary
						epoch->TotalEpochsDecimated++;
						if (epoch->direction==pFORWARD) {
							epoch->TotalEpochsDecimatedForward++;
						}
					}
				}
			} else { // ret == 0
				if ( options->filterIterations >= ( filterIterations + 1 ) ) {
					filterIterations++;
					if ( filterIterations%2 == 0 ) { // Backward direction
						epoch->direction = pBACKWARD;
						memcpy(&epoch->BackwardTurningEpoch,&epoch->t,sizeof(TTime));
						//We have to substract three to 'epoch->numEpochReadFilePos' because the counter has the value for the next position and  
						// the previous positions points to the end of file, and last we do not want to process again the last epoch of the file
						epoch->numEpochReadFilePos-=3;
						//rewindEpochRinexObs(fdRNX, epoch->source);
						printInfo("Finished forward processing, starting backwards processing",options);
					}
					ret = 1;
				}
			}
		}
		if ( !anyInsideProducts && options->workMode == wmDOPROCESSING )  {
			if (printProgress==1) {
				fprintf(options->terminalStream,"Percentage converted: %3d%%%10s%c",100,"",options->ProgressEndCharac);
				#if !defined(__WIN32__)
					//This is to clear terminal for characters after finishing (in Windows is not necessary as it adds a newline when the process finishes)
					if (options->ProgressEndCharac=='\r') {
						fprintf(options->terminalStream,"%95s%c","",options->ProgressEndCharac);
					}
					//Enable cursor again
					if (sopt->disableCursor==1) {
						fprintf(options->terminalStream,"%s",enableCursor);
					}
				#endif
				fflush_function(options->terminalStream);
			}
			if (epoch->t.MJDN==-1) {
				printError("Observation file only has header data (no epochs)",options);
			} else if(tdiff(&epoch->t,&options->StartEpoch)<0.) {
				printError("Start epoch provided by user is ahead of all observation file records",options);
			} else {
				printError("Orbit and clock products are of a different time than the observation RINEX",options);
			}
		}
	} else if (options->workMode == wmSBASPLOTS ) {
		//////////////////////////
		///SBAS Plots mode
		/////////////////////////

		initTGD(&tgdData,options,0); //To avoid using unitialized values when checking for necessity for freeing memomry at end of gLAB.c
		HourFileName[0]='\0';

		//To avoid problems if the user sets a value with more than 2 decimals, all decimals from the third one will be erased
		//Check minimum latitude
		sprintf(auxstr,"%.2f",options->minLatplots);
		options->minLatplots=atof(auxstr);
		//Check maximum latitude
		sprintf(auxstr,"%.2f",options->maxLatplots);
		options->maxLatplots=atof(auxstr) + DIFFEQTHRESHOLD; //The DIFFEQTHRESHOLD is to avoid problems with decimals
		//Check minimum longitude
		sprintf(auxstr,"%.2f",options->minLonplots);
		options->minLonplots=atof(auxstr);
		//Check maximum longitude
		sprintf(auxstr,"%.2f",options->maxLonplots);
		options->maxLonplots=atof(auxstr) + DIFFEQTHRESHOLD; //The DIFFEQTHRESHOLD is to avoid problems with decimals
		//Check Availability and Continuity plot step
		//In case of resolution higher or equal than 0.1º, we will only use one decimal for resolution (for avoiding values such as 0.17)
		//In case of resolution higher or equal than 1º, we will use no decimal resolution (for avoiding values such as 1.15)
		if(options->AvailabilityPlotStep<0.1) {
			sprintf(auxstr,"%.2f",options->AvailabilityPlotStep);
		} else if (options->AvailabilityPlotStep<1) {
			sprintf(auxstr,"%.1f",options->AvailabilityPlotStep);
		} else {
			sprintf(auxstr,"%.0f",options->AvailabilityPlotStep);
		}
		options->AvailabilityPlotStep=atof(auxstr);

		//Check Iono corrections availability plot step. We will use the same criteria as in Availability and Continuity plot step
		if(options->IonoPlotStep<0.1) {
			sprintf(auxstr,"%.2f",options->IonoPlotStep);
		} else if (options->IonoPlotStep<1) {
			sprintf(auxstr,"%.1f",options->IonoPlotStep);
		} else {
			sprintf(auxstr,"%.0f",options->IonoPlotStep);
		}
		options->IonoPlotStep=atof(auxstr);

		//Select GEO and print it
		if(options->GEOindex<0) {
			if(SBASdatabox.SBASdata[0].numSBASsatellites==0) {
				//No GEO available. Print Error
				sprintf(messagestr,"No SBAS GEO satellite found in file [%s]",sopt->sbasFile);
				printError(messagestr,options);
			} else if(options->GEOPRN==-1) {
				//User didn't provide any input. Use the first GEO read as default
				options->GEOindex=1;
				options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
			} else if (options->GEOPRN==0) {
				//Use data from all GEO
				options->GEOindex=0;
				options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
			} else if (options->GEOPRN==1) {
				//Use the GEO PRN from the first SBAS data read, which will be in position one of the SBASdata vector
				options->GEOindex=1;
				options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
			} else { //MINGEOPRN<=options->GEOPRN<=MAXGEOPRN
				//The user has given the GEO PRN
				options->GEOindex=SBASdatabox.SBASdata[0].GEOPRN2pos[options->GEOPRN];
				if(options->GEOindex==-1) {
					//We have no data from this satellite. Print Error
					sprintf(messagestr,"SBAS GEO PRN %3d not found in file [%s]",options->GEOPRN,sopt->sbasFile);
					printError(messagestr,options);
				}
			}
		}
		if(options->switchGEO==1) {
			sprintf(messagestr,"Initial GEO-PRN selected for SBAS corrections: %3d (it may change during processing)",options->GEOPRN);
		} else {
			sprintf(messagestr,"GEO-PRN for SBAS corrections: %3d",options->GEOPRN);
		}
		printInfo(messagestr,options);

		messagestr[0]='\0';
		auxstr2[0]='\0';
		len=0;
		for(i=MINGEOPRN;i<=MAXGEOPRN;i++) {
			if (options->GEOPRNunsel[i]==1) {
				len+=sprintf(&auxstr2[len]," %3d",i);
				excludedGEOs=1;
			}
		}

		messagestr[0]='\0';
		auxstr[0]='\0';
		len=0;
		for(i=1;i<=SBASdatabox.SBASdata[0].numSBASsatellites;i++) {
			if (options->GEOPRNunsel[SBASdatabox.SBASdata[i].PRN]==1) {
				continue;
			}
			len+=sprintf(&auxstr[len]," %3d",SBASdatabox.SBASdata[i].PRN);
		}

		sprintf(messagestr,"GEO-PRN list in SBAS file%s%s:%s",excludedGEOs==1?" (and not excluded)":"",options->switchGEO==1?" that may be used during processing":"",auxstr);
		printInfo(messagestr,options);

		if (excludedGEOs==1) {
			sprintf(messagestr,"GEO-PRN excluded:%s",auxstr2);
			printInfo(messagestr,options);
		}

		sprintf(messagestr,"SBAS GEO switching: %3s",options->switchGEO==1?"ON":"OFF");
		printInfo(messagestr,options);
		#if defined _OPENMP
			sprintf(messagestr,"Number of threads used: %d",options->numthreads);
			printInfo(messagestr,options);
		#endif

		//Open output files
		if(options->NoAvailabilityPlot==0) {
			//Show warning message to advert users of the long computation time needed
			sprintf(messagestr,"WARNING SBAS Availability plots requires a lot of computation time. With the default options it takes around 2 hours");
			printInfo(messagestr,options);
			#if !defined _OPENMP
				printInfo("The user might consider to use the multithread version of gLAB for reducing computation time. Use the gLAB_Multithread executable or compile using the \"Makefile_multithread\" makefile",options);
			#endif
			if (options->DOPPercentile==1) {
				printInfo("WARNING Computation of DOP percentiles requires a lot of memory (around 1GB for each DOP map with the default options)",options);
			}

			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasAvailplotsFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS availability plot file",sopt->sbasAvailplotsFile);
			   printError(messagestr,options);
			}
			fdSBASAvail=fopen(sopt->sbasAvailplotsFile,"w");
			if(fdSBASAvail==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS availability plot",sopt->sbasAvailplotsFile);
				printError(messagestr,options);
			}
			//Open 24 hours availability plot files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASAvailHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasAvailplotsFileNoExtension,i);
					fdSBASAvailHour[i]=fopen(HourFileName,"w");
					if(fdSBASAvailHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS availability plot for hour %02d",HourFileName,i);
						printError(messagestr,options);
					}
				}
			}
		}

		if(options->ComputeRiskPlots==1) {
			if (options->NoContRiskPlot==0) {
				//Create directory recursively if needed
				ret=mkdir_recursive(sopt->sbasRiskplotsFile);
				if(ret!=0) {
				   //Error when creating the directory, and it is not due to that the directory already exists
				   sprintf(messagestr,"When creating [%s] folder for writing SBAS continuity risk plot file",sopt->sbasRiskplotsFile);
				   printError(messagestr,options);
				}
				fdSBASRisk=fopen(sopt->sbasRiskplotsFile,"w");
				if(fdSBASRisk==NULL) {
					sprintf(messagestr,"Opening output file [%s] for SBAS continuity risk plots",sopt->sbasRiskplotsFile);
					printError(messagestr,options);
				}
				//Open 24 hours continuity risk plot files if necessary
				if(options->SBASHourlyMaps==1) {
					for(i=0;i<24;i++) {
						fdSBASRiskHour[i]=NULL;
						sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasRiskplotsFileNoExtension,i);
						fdSBASRiskHour[i]=fopen(HourFileName,"w");
						if(fdSBASRiskHour[i]==NULL) {
							sprintf(messagestr,"Opening output file [%s] for SBAS continuity risk plot for hour %02d",HourFileName,i);
							printError(messagestr,options);
						}
					}
				}
			}

			if (options->NoContRiskMarPlot==0) {
				//Create directory recursively if needed
				ret=mkdir_recursive(sopt->sbasRiskMarplotsFile);
				if(ret!=0) {
				   //Error when creating the directory, and it is not due to that the directory already exists
				   sprintf(messagestr,"When creating [%s] folder for writing SBAS continuity risk for maritime plot file",sopt->sbasRiskplotsFile);
				   printError(messagestr,options);
				}
				fdSBASRiskMar=fopen(sopt->sbasRiskMarplotsFile,"w");
				if(fdSBASRiskMar==NULL) {
					sprintf(messagestr,"Opening output file [%s] for SBAS continuity risk for maritime plots",sopt->sbasRiskMarplotsFile);
					printError(messagestr,options);
				}
				//Open 24 hours continuity risk plot files if necessary
				if(options->SBASHourlyMaps==1) {
					for(i=0;i<24;i++) {
						fdSBASRiskMarHour[i]=NULL;
						sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasRiskMarplotsFileNoExtension,i);
						fdSBASRiskMarHour[i]=fopen(HourFileName,"w");
						if(fdSBASRiskMarHour[i]==NULL) {
							sprintf(messagestr,"Opening output file [%s] for SBAS continuity risk for maritime plot for hour %02d",HourFileName,i);
							printError(messagestr,options);
						}
					}
				}
			}

			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasDiscontinuityFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS solution discontinuities file",sopt->sbasDiscontinuityFile);
			   printError(messagestr,options);
			}
			fdSBASDiscont=fopen(sopt->sbasDiscontinuityFile,"w");
			if(fdSBASDiscont==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS solution discontinuities",sopt->sbasDiscontinuityFile);
				printError(messagestr,options);
			} else {
				t2doy(&epoch->t,&SBASPlotYear,&SBASPlotDoY);
				//Write file header file.
				if (options->switchGEO==1) {
					GEOused=0;
				} else {
					GEOused=options->GEOPRN;
				}
				fprintf(fdSBASDiscont,"#MINLAT MAXLAT  MINLON  MAXLON RESOLUTION REC-HEIGHT    HAL    VAL DoY YEAR GEO-PRN ELEV-MASK\n");
				fprintf(fdSBASDiscont," %6.2f %6.2f %7.2f %7.2f %10.2f %10.2f %6.*f %6.*f %03d %4d %7d %9.2f\n",options->minLatplots,options->maxLatplots,options->minLonplots,options->maxLonplots,options->AvailabilityPlotStep,options->SBASPlotsRecHeight,options->HorAlarmLimit>=1000?0:2,options->HorAlarmLimit,options->VerAlarmLimit>=1000?0:2,options->VerAlarmLimit,(int)SBASPlotDoY,SBASPlotYear,GEOused,options->elevationMask*r2d);
				fprintf(fdSBASDiscont,"#  LAT     LON INIT-EPOCH END-EPOCH DURATION STABLE-PERIOD\n"); 
			}
			//Open 24 hours discontinuity files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASDiscontHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasDiscontinuityFileNoExtension,i);
					fdSBASDiscontHour[i]=fopen(HourFileName,"w");
					if(fdSBASDiscontHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS solution discontinuities for hour %02d",HourFileName,i);
						printError(messagestr,options);
					} else {
						t2doy(&epoch->t,&SBASPlotYear,&SBASPlotDoY);
						//Write file header file.
						fprintf(fdSBASDiscontHour[i],"#MINLAT MAXLAT  MINLON  MAXLON RESOLUTION REC-HEIGHT    HAL    VAL DoY YEAR GEO-PRN ELEV-MASK HOUR\n");
						fprintf(fdSBASDiscontHour[i]," %6.2f %6.2f %7.2f %7.2f %10.2f %10.2f %6.*f %6.*f %03d %4d %7d %9.2f   %02d\n",options->minLatplots,options->maxLatplots,options->minLonplots,options->maxLonplots,options->AvailabilityPlotStep,options->SBASPlotsRecHeight,options->HorAlarmLimit>=1000?0:2,options->HorAlarmLimit,options->VerAlarmLimit>=1000?0:2,options->VerAlarmLimit,(int)SBASPlotDoY,SBASPlotYear,options->GEOPRN,options->elevationMask*r2d,i);
						fprintf(fdSBASDiscontHour[i],"#  LAT     LON INIT-EPOCH END-EPOCH DURATION STABLE-PERIOD\n"); 
					
					}
				}
			}
		}

		if(options->NoIonoPlot==0) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasIonoplotsFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS ionosphere correction availability plot file",sopt->sbasIonoplotsFile);
			   printError(messagestr,options);
			}
			fdSBASIono=fopen(sopt->sbasIonoplotsFile,"w");
			if(fdSBASIono==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS ionosphere correction availability plots",sopt->sbasIonoplotsFile);
				printError(messagestr,options);
			}
			//Open 24 hours iono plot files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASIonoHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasIonoplotsFileNoExtension,i);
					fdSBASIonoHour[i]=fopen(HourFileName,"w");
					if(fdSBASIonoHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS ionosphere correction availability plot for hour %02d",HourFileName,i);
						printError(messagestr,options);
					}
				}
			}
		}
		
		if(options->HDOPPlot==1) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasHDOPplotsFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS HDOP plot file",sopt->sbasHDOPplotsFile);
			   printError(messagestr,options);
			}
			fdSBASHDOP=fopen(sopt->sbasHDOPplotsFile,"w");
			if(fdSBASHDOP==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS HDOP plot",sopt->sbasHDOPplotsFile);
				printError(messagestr,options);
			}
			//Open 24 hours availability plot files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASHDOPHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasHDOPplotsFileNoExtension,i);
					fdSBASHDOPHour[i]=fopen(HourFileName,"w");
					if(fdSBASHDOPHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS HDOP plot for hour %02d",HourFileName,i);
						printError(messagestr,options);
					}
				}
			}
		}

		if(options->PDOPPlot==1) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasPDOPplotsFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS PDOP plot file",sopt->sbasPDOPplotsFile);
			   printError(messagestr,options);
			}
			fdSBASPDOP=fopen(sopt->sbasPDOPplotsFile,"w");
			if(fdSBASPDOP==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS PDOP plot",sopt->sbasPDOPplotsFile);
				printError(messagestr,options);
			}
			//Open 24 hours availability plot files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASPDOPHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasPDOPplotsFileNoExtension,i);
					fdSBASPDOPHour[i]=fopen(HourFileName,"w");
					if(fdSBASPDOPHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS PDOP plot for hour %02d",HourFileName,i);
						printError(messagestr,options);
					}
				}
			}
		}

		if(options->GDOPPlot==1) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasGDOPplotsFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS GDOP plot file",sopt->sbasGDOPplotsFile);
			   printError(messagestr,options);
			}
			fdSBASGDOP=fopen(sopt->sbasGDOPplotsFile,"w");
			if(fdSBASGDOP==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS GDOP plot",sopt->sbasGDOPplotsFile);
				printError(messagestr,options);
			}
			//Open 24 hours availability plot files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASGDOPHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasGDOPplotsFileNoExtension,i);
					fdSBASGDOPHour[i]=fopen(HourFileName,"w");
					if(fdSBASGDOPHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS GDOP plot for hour %02d",HourFileName,i);
						printError(messagestr,options);
					}
				}
			}
		}

		if(options->CombinedDOPPlot==1) {
			//Create directory recursively if needed
			ret=mkdir_recursive(sopt->sbasCombDOPplotsFile);
			if(ret!=0) {
			   //Error when creating the directory, and it is not due to that the directory already exists
			   sprintf(messagestr,"When creating [%s] folder for writing SBAS combined HDOP, PDOP and GDOP plot file",sopt->sbasCombDOPplotsFile);
			   printError(messagestr,options);
			}
			fdSBASCombDOP=fopen(sopt->sbasCombDOPplotsFile,"w");
			if(fdSBASCombDOP==NULL) {
				sprintf(messagestr,"Opening output file [%s] for SBAS combined HDOP, PDOP and GDOP plot",sopt->sbasCombDOPplotsFile);
				printError(messagestr,options);
			}
			//Open 24 hours availability plot files if necessary
			if(options->SBASHourlyMaps==1) {
				for(i=0;i<24;i++) {
					fdSBASCombDOPHour[i]=NULL;
					sprintf(HourFileName,"%s_%02dh.txt",sopt->sbasCombDOPplotsFileNoExtension,i);
					fdSBASCombDOPHour[i]=fopen(HourFileName,"w");
					if(fdSBASCombDOPHour[i]==NULL) {
						sprintf(messagestr,"Opening output file [%s] for SBAS combined HDOP, PDOP and GDOP plot for hour %02d",HourFileName,i);
						printError(messagestr,options);
					}
				}
			}
		}

		//Read RINEX navigation data
		if ( readRinexNav(fdRNXnav[0],sopt->navFile[0],&products,&rinexNavVersion,NEWDAYNAV,options) != 1 ) {
			if ( (int)rinexNavVersion > 3 && rinexNavVersion != 0 ) {
				sprintf(messagestr,"RINEX navigation version %1.2f from file [%s] is not supported. Supported versions are 2 and 3",rinexNavVersion,sopt->navFile[0]);
				printError(messagestr,options);
			} else {
				sprintf(messagestr,"Reading RINEX navigation message file [%s]",sopt->navFile[0]);
				printError(messagestr,options);
			}
		}

		//Check start epoch of products
		tproducts=getProductsFirstEpochBRDC(&products);
		if (epoch->t.MJDN==tproducts.MJDN || (epoch->t.MJDN==(tproducts.MJDN+1) && tproducts.SoD>79200.)) {
			//Not 2 hours of data from previous day
			sprintf(messagestr,"WARNING Navigation message data should start around 2 hours previous to the current day (around 22h of the previous day). Otherwise there is a high risk that some navigation message may be missing at the start of the day");
			printInfo(messagestr,options);
		} else if (epoch->t.MJDN==(tproducts.MJDN+1) && tproducts.SoD<=79200.) {
			//Initial packages OK
		} else {
			//Navigation data does not match the day from the SBAS data file
			//Print the date of SBAS data and start date of navigation data
			t2tmnolocal(&tproducts, &tmNavStart, &SecondDecimalNavStart);
			t2tmnolocal(&epoch->t, &tmCurrEpoch, &SecondDecimalCurrEpoch);
			sprintf(messagestr,"Navigation data is not from the same day as the SBAS data (SBAS data date: %02d/%02d/%4d Navigation start data date: %02d/%02d/%4d). Check navigation messages time of clock and transmission time",tmCurrEpoch.tm_mday,tmCurrEpoch.tm_mon+1,tmCurrEpoch.tm_year+1900,tmNavStart.tm_mday,tmNavStart.tm_mon+1,tmNavStart.tm_year+1900);
			printInfo(messagestr,options);
		}

		//Check end epoch of products
		tproducts=getProductsLastEpochBRDC(&products);
		if (epoch->t.MJDN==tproducts.MJDN || ((epoch->t.MJDN+1)==tproducts.MJDN && tproducts.SoD<7200.)) {
			//Not 2 hours of data from previous day
			sprintf(messagestr,"WARNING Navigation message data should end 2 hours after the current day (around 2h of the next day). Otherwise there is a high risk that some navigation message may be missing at the end of the day");
			printInfo(messagestr,options);
		}

		// Read GLONASS navigation file for frequency offset values (k)
		memcpy(&epoch->t,&options->StartEpoch,sizeof(TTime));
		if (options->ConstellationUsed[GLONASS]==1 && sopt->glonavFile[0]!='\0') {
			getGLOFreqOffsets(epoch,sopt->navFile[0],sopt->glonavFile,&fdRNXglonav,&nextgloNav,&products,&productsGLO,options);
		}


		//Check if filename starts with "mixn" or "gage" (default consolidated files of gAGE)
		#if defined __WIN32__
			p = strrchr(sopt->navFile[0],'\\');
		#elif defined __CYGWIN__
			p = strrchr(sopt->navFile[0],'\\'); 
			if ( p == NULL ) {
				p = strrchr(sopt->navFile[0],'/');
			}
		#else
			p = strrchr(sopt->navFile[0],'/');
		#endif

		if ( p == NULL ) {
			p = sopt->navFile[0];
		} else {
			//p points to the slash or backslash character.
			//Move one position forward to get the start of the filename
			p++;
		}

		if (strncasecmp("mixn",p,4)!=0 && strncasecmp("gage",p,4)!=0 ) {
			printInfo("WARNING Navigation data files on FTP sites usually have missing navigation messages for SBAS plots (for instance 'brdc' consolidated file). User should create a navigation file with data from several sources",options);
		}
		//Save products for Klobuchar
		if (products.BRDC==NULL) {
			//If we have not read any product type, allocate memory and initialize to 0 the productsKlb structure
			productsKlb.BRDC = malloc(sizeof(TBRDCproducts));
			initBRDCproducts(productsKlb.BRDC,options->GLOintStep);
		} else {
			productsKlb.BRDC = products.BRDC;
		}

		//Build list of available RINEX navigation message types
		for(m=0;m<2;m++) { 
			//Loop twice for orbits and DCB. 
			//If DCB files is given, data for DCB willbe overwritten
			for(i=0;i<MAX_GNSS;i++) {
				for(j=0;j<MAX_BRDC_SELECTION_TYPES;j++) {
					//Reset BRDCAvailSelOrder list
					for(k=0;k<=MAX_BRDC_TYPES;k++) {
						options->BRDCAvailSelOrder[m][i][j][k]=0;
					}
					//Fill with available messages
					l=0;
					for(k=0;k<options->BRDCSelOrder[i][j][MAX_BRDC_TYPES];k++) {
						if (products.BRDC->AvailBRDCType[i][options->BRDCSelOrder[i][j][k]]==1) {
							options->BRDCAvailSelOrder[m][i][j][l]=options->BRDCSelOrder[i][j][k];
							l++;
						}
					}
					options->BRDCAvailSelOrder[m][i][j][MAX_BRDC_TYPES]=l;
				}
			}
		}
		products.BRDC->NavDataPosition=ORBNAVPOS;


		//Allocate memory for TSBASplots and initialize this structure and also TEpoch for this mode
		SBASplots=malloc(sizeof(TSBASPlots));
		initSBASPlotsMode(epoch,SBASplots,options,&ret1);
		if(ret1==-1) {
			if (options->DOPPercentile==1 && (options->HDOPPlot==1 || options->PDOPPlot==1 || options->GDOPPlot==1 || options->CombinedDOPPlot==1)) {
				printError("Not enough memory available for SBAS plots. Try disabling DOP percentile computation or reducing map size",options);
			} else if(options->NoAvailabilityPlot==0 && options->NoIonoPlot==0) {				
				if (options->SBASHourlyMaps==1) {
					printError("Not enough memory available for SBAS plots. Try disabling hourly maps, reducing resolution, map size or just doing only one plot a time",options);
				} else {
					printError("Not enough memory available for SBAS plots. Try reducing resolution, map size or just doing only one plot a time",options);
				}
			} else {
				if (options->SBASHourlyMaps==1) {
					printError("Not enough memory available for SBAS plots. Try disabling hourly maps, reducing resolution or map size",options);
				} else {
					printError("Not enough memory available for SBAS plots. Try reducing resolution or map size",options);
				}
			}
		}

		//Initialize values for initial epochs
		InitialSBASPlotsEpoch=(int)epoch->t.SoD;
		//Initialize counter for number of epochs
		totalAvailabilityEpochs=0;
		totalAvailabilityEpochsHourly=0;
		totalIonoEpochs=0;
		totalIonoEpochsHourly=0;
		epoch->SwitchPossible=0; //Set by default no GEO switching (user input will be checked later)
		//Initialize FirstEpochAvailAfterPrevDisc and LastEpochAvailPrevCurrDisc
		if(options->NoContRiskPlot==0) {
			if (options->SBASHourlyMaps==1) {
				for(k=0;k<SBASplots->AvailabilityLatSize;k++) {
					for(l=0;l<SBASplots->AvailabilityLonSize;l++) {
						SBASplots->FirstEpochAvailAfterPrevDisc[k][l]=epoch->t.SoD;
						SBASplots->LastEpochAvailPrevCurrDisc[k][l]=epoch->t.SoD-1.;
						SBASplots->FirstEpochAvailAfterPrevDiscHourly[k][l]=epoch->t.SoD;
						SBASplots->LastEpochAvailPrevCurrDiscHourly[k][l]=epoch->t.SoD-1.;
					}
				}
			} else {
				for(k=0;k<SBASplots->AvailabilityLatSize;k++) {
					for(l=0;l<SBASplots->AvailabilityLonSize;l++) {
						SBASplots->FirstEpochAvailAfterPrevDisc[k][l]=epoch->t.SoD;
						SBASplots->LastEpochAvailPrevCurrDisc[k][l]=epoch->t.SoD-1.;
					}
				}
			}
		}

		//Compute number of loops to compute percentage
		epoch->numEpochsfile=(86400-InitialSBASPlotsEpoch);
		epoch->numEpochsprocessed=-1;
		epoch->CurrentPercentage=0.;
		epoch->PreviousPercentage=-0.2; //This is to make percentage appear with 0.0%, as it takes some time to get to 0.1%

		//Set AvailPlotTimeStep in decimal formats for computing continuity risk
		options->AvailPlotTimeStepCmp = (double)(options->AvailPlotTimeStep)+.1; //The 0.1 is to avoid problems with decimals when comparing
		options->AvailPlotTimeStepDec = (double)options->AvailPlotTimeStep;

		//Compute SBAS plots. We need to do three loops: one for the time, one for the latitude and another for the longitude
		//Loop for time. From second 0 if SBAS file started at second 0 or at the end of the previous day, or otherwise from the first epoch of the SBAS data file.
		//The final epoch wiil be always the end of the day (second of day 86399)
		for(currenttime=InitialSBASPlotsEpoch;currenttime<86400;currenttime++) {
			//Update current time
			epoch->t.SoD=(double)currenttime;
			strcpy(epoch->tStr,t2doystr(&epoch->t));
			sprintf(epoch->tSoDHourStr,"%s %02d:%02d:%05.2f",epoch->tStr,(int)(epoch->t.SoD/3600.),(int)(epoch->t.SoD/60.)%60,(double)(currenttime%60));
			ttime2gpswsnoroll(&epoch->t, &epoch->GPSweek, &epoch->SoW);
			//Update progress bar
			if (printProgress) { 
				epoch->numEpochsprocessed++;
				epoch->CurrentPercentage=100.*epoch->numEpochsprocessed/epoch->numEpochsfile;
				if ((epoch->CurrentPercentage-epoch->PreviousPercentage)>=0.1) {
					Epochsleft=86400-currenttime;
					if (options->ProgressEndCharac=='\r') {
						//Printing to a terminal
						fprintf(options->terminalStream,"Current Epoch: %d (%d epochs left) / %02d:%02d:%02d (%02d:%02d:%02d left) (%.1f%%)%10s%c",currenttime,Epochsleft,(int)(epoch->t.SoD/3600.),(int)(epoch->t.SoD/60.)%60,currenttime%60,(int)(Epochsleft/3600.),(int)(Epochsleft/60)%60,Epochsleft%60,epoch->CurrentPercentage,"",options->ProgressEndCharac);
						fflush_function(options->terminalStream);
					} else {
						//Printing for the GUI. Only print if the integer of the percentage have changed (to avoid message spamming)
						if ((int)epoch->CurrentPercentage!=(int)epoch->PreviousPercentage) {
							fprintf(options->terminalStream,"Current Epoch: %5d (%5d epochs left) / %02d:%02d:%02d (%02d:%02d:%02d left) (%5.1f%%)%10s%c",currenttime,Epochsleft,(int)(epoch->t.SoD/3600.),(int)(epoch->t.SoD/60.)%60,currenttime%60,(int)(Epochsleft/3600.),(int)(Epochsleft/60)%60,Epochsleft%60,epoch->CurrentPercentage,"",options->ProgressEndCharac);
							fflush_function(options->terminalStream);
						}
					}
					epoch->PreviousPercentage=epoch->CurrentPercentage;
				}
			}
			
			// Read SBAS data until current epoch	
			retsbas = readSBASFile(sopt->sbasFile,&SBASdatabox,&rinexBVersion,&epoch->t,options);
			if(retsbas==-2) {
				//Reached End of file before getting to current epoch
				if(currenttime<86399) {
					//If it not the last epoch stop processing
					epoch->t.SoD=(double)(currenttime-1);
					break;
				}
			}
			//Select GEO if we don't have one (it has to be each time an epoch starts, as it is when GEO data is updated)
			SBASGEOselection(epoch,SBASdatabox.SBASdata,options);
			//Check GEO alarm status
			SBASGEOAlarmCheck(epoch,SBASdatabox.SBASdata,options);
			//Update number of GEO satellites in Epoch structure
			epoch->numSBASsatellites=SBASdatabox.SBASdata[0].numSBASsatellites;
			//Check if there are GEO satellites with no elevation computed
			if (SBASplots->numGEOWithElevComputed!=SBASdatabox.SBASdata[0].numSBASsatellites) {
				if (options->SBASPlotsMinGEOElev == -99.99f) {
					//No elevation filter, so no need to compute anything
					SBASplots->numGEOWithElevComputed=SBASdatabox.SBASdata[0].numSBASsatellites;
				} else {
					FillGEOelevationGrid(SBASdatabox.SBASdata,epoch,SBASplots,options,&ret1);
					if (ret1==-1) {
						printError("Not enough memory available for SBAS plots. Try reducing resolution or map size",options);
					}
				}
			}


			if(options->SBASHourlyMaps==1) {
				if(options->NoAvailabilityPlot==0) {
					if (currenttime%3600==0) {
						//We are the beginning of the hour
						if (currenttime!=InitialSBASPlotsEpoch) {
							//It is not the first epoch
							currenthour=(int)((double)(currenttime)/3600.)-1;
							writeSBASAvailFile(fdSBASAvailHour[currenthour],fdSBASRiskHour[currenthour],fdSBASRiskMarHour[currenthour],fdSBASDiscontHour[currenthour],fdSBASHDOPHour[currenthour],fdSBASPDOPHour[currenthour],fdSBASGDOPHour[currenthour],fdSBASCombDOPHour[currenthour],epoch,SBASplots,totalAvailabilityEpochsHourly,currenthour,options);
							fclose(fdSBASAvailHour[currenthour]);
							if(options->ComputeRiskPlots==1) {
								fclose(fdSBASDiscontHour[currenthour]);
							}
							if (options->NoContRiskPlot==0) {
								fclose(fdSBASRiskHour[currenthour]);
							}
							if (options->NoContRiskMarPlot==0) {
								fclose(fdSBASRiskMarHour[currenthour]);
							}
							if (options->HDOPPlot==1) {
								fclose(fdSBASHDOPHour[currenthour]);
							}
							if (options->PDOPPlot==1) {
								fclose(fdSBASPDOPHour[currenthour]);
							}
							if (options->GDOPPlot==1) {
								fclose(fdSBASGDOPHour[currenthour]);
							}
							if (options->CombinedDOPPlot==1) {
								fclose(fdSBASCombDOPHour[currenthour]);
							}

							for(k=0;k<SBASplots->AvailabilityLatSize;k++) {
								for(l=0;l<SBASplots->AvailabilityLonSize;l++) {
									SBASplots->SBASNumEpochsAvailHourly[k][l]=0;
									SBASplots->SBASNumEpochsDOPHourly[k][l]=0;
									if(options->NoContRiskPlot==0) {
										SBASplots->SBASNumEpochsRiskHourly[k][l]=0;
										SBASplots->SBASNumEpochsRiskHourlyMar[k][l]=0;
										SBASplots->FirstEpochAvailAfterPrevDiscHourly[k][l]=epoch->t.SoD;
										SBASplots->LastEpochAvailPrevCurrDiscHourly[k][l]=epoch->t.SoD-options->AvailPlotTimeStepDec;
									}
									if(options->CombinedDOPPlot==1) {
										SBASplots->HDOPMeanHourly[k][l]=0.;
										SBASplots->PDOPMeanHourly[k][l]=0.;
										SBASplots->GDOPMeanHourly[k][l]=0.;
									} else {										
										if (options->HDOPPlot==1) {
											SBASplots->HDOPMeanHourly[k][l]=0.;
										}
										if (options->PDOPPlot==1) {
											SBASplots->PDOPMeanHourly[k][l]=0.;
										}
										if (options->GDOPPlot==1) {
											SBASplots->GDOPMeanHourly[k][l]=0.;
										}
									}
								}
							}
							totalAvailabilityEpochsHourly=0;
						}
					}
				}
			}

			if(currenttime%options->AvailPlotTimeStep==0) {
				totalAvailabilityEpochsHourly++;

				totalAvailabilityEpochs++;
				if(options->NoAvailabilityPlot==0) {
					if (epoch->numSatellites==0) {
						if (options->GEOindex>=0) {
							//No satellites selected and there is a GEO selected. 
							//Fill the number of satellites if there is a PRN mask
							SetSatellitesSBASPlotsMode(epoch,SBASdatabox.SBASdata,options);
						}
					}
					if (epoch->numSatellites!=0) {
						//Loop for latitude
						latPos=-1;
						for(latitude=options->minLatplots;latitude<=options->maxLatplots;latitude+=options->AvailabilityPlotStep) {
							//Compute latitude vector position
							latPos++;

							//Loop for longitude
							lonPos=-1;
							for(longitude=options->minLonplots;longitude<=options->maxLonplots;longitude+=options->AvailabilityPlotStep) {
								//Compute longitude vector position
								lonPos++;
								//Check inclusion and exclusion area
								if (options->NumSBASPlotsExclusionArea>0 && options->NumSBASPlotsInclusionArea>0) {
									//Inclusion area. Only do areas inside the given region
									InsideInclusionArea=0;
									for(k=0;k<options->NumSBASPlotsInclusionArea;k++) {
										if (longitude>=options->SBASPlotsInclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsInclusionAreaDelimeters[k][1]) {
											if (latitude>=options->SBASPlotsInclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsInclusionAreaDelimeters[k][3]) {
												InsideInclusionArea=1;
												break;
											}
										}
									}
									if (InsideInclusionArea==0) continue;
									//Exclusion area. Do not process area inside exclusion area
									InsideExclusionArea=0;
									for(k=0;k<options->NumSBASPlotsExclusionArea;k++) {
										if (longitude>=options->SBASPlotsExclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsExclusionAreaDelimeters[k][1]) {
											if (latitude>=options->SBASPlotsExclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsExclusionAreaDelimeters[k][3]) {
												InsideExclusionArea=1;
												break;
											}
										}
									}
									if (InsideExclusionArea==1) continue;
								} else if (options->NumSBASPlotsExclusionArea>0) {
									//Exclusion area. Do not process area inside exclusion area
									InsideExclusionArea=0;
									for(k=0;k<options->NumSBASPlotsExclusionArea;k++) {
										if (longitude>=options->SBASPlotsExclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsExclusionAreaDelimeters[k][1]) {
											if (latitude>=options->SBASPlotsExclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsExclusionAreaDelimeters[k][3]) {
												InsideExclusionArea=1;
												break;
											}
										}
									}
									if (InsideExclusionArea==1) continue;
								} else if (options->NumSBASPlotsInclusionArea>0) {
									//Inclusion area. Only do areas inside the given region
									InsideInclusionArea=0;
									for(k=0;k<options->NumSBASPlotsInclusionArea;k++) {
										if (longitude>=options->SBASPlotsInclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsInclusionAreaDelimeters[k][1]) {
											if (latitude>=options->SBASPlotsInclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsInclusionAreaDelimeters[k][3]) {
												InsideInclusionArea=1;
												break;
											}
										}
									}
									if (InsideInclusionArea==0) continue;
								}
							
								//Reset number of switches (in normal positioning mode, num switches is tied to epoch, not to latitude and longitude)
								epoch->ResetNumSwitch=1;

								//If print SBASUNSEL message is activated, print an INFO message showing the current latitude and longitude
								if ( options->printSBASUNSEL == 1 ) {
									fprintf(options->outFileStream,"INFO Latitude %6.2f Longitude %7.2f\n",latitude,longitude);
								}

								
								//Transform from latitude, longitude, height to XYZ. If non height value set, we will assume we are on height 0 (over the WGS84 geoid)
								epoch->receiver.aproxPositionNEU[0]=latitude*d2r;
								epoch->receiver.aproxPositionNEU[1]=longitude*d2r;
								epoch->receiver.aproxPositionNEU[2]=options->SBASPlotsRecHeight;
								NEU2XYZ(epoch->receiver.aproxPositionNEU,epoch->receiver.aproxPosition);
								fillGroundStationOrientation(epoch);

								if (options->switchGEO == 1) epoch->SwitchPossible=1;	//Enable switches in current epoch (only applicable if mode or GEO switch is enabled)
								//Do While loop to allow switching GEO in processing
								if ( options->SBAScorrections==SBASMaps1freqUsed) {
									//SBAS 1F processing
									do {
										//Set available satellites to 0
										epoch->usableSatellites=0;
										#if defined _OPENMP
											numsatdiscardedSBAS=0;
										#else
											epoch->numsatdiscardedSBAS=0;
										#endif
										//Check GEO is in view
										if (SBASplots->GEOelevPos[(options->GEOindex-1)*SBASplots->GEOelevNullPos][latPos*SBASplots->GEOelevNullPos][lonPos*SBASplots->GEOelevNullPos]>=options->SBASPlotsMinGEOElev) {
											//Reset values for computing the number of inter-system clock bias
											k=FIRST_POS_IS_CLK;
											for(i=0;i<MAX_GNSS;i++) {
												epoch->constellationUsed[i]=0;
												epoch->InterSystemClocksPosDOP[i]=-1;
											}
											epoch->numInterSystemClocksFilter=0;
											epoch->InterSystemClocksPosDOP[options->ClkRefPriorityList[0]]=3;
											
											//Model each satellite. Unselect it if it is not in view or below the elevation mask
											#pragma omp parallel for private(ret1,SBAScorr) reduction(+:numsatdiscardedSBAS)
											for(i=0;i<epoch->numSatellites;i++) {
												// Check if satellite has been deselected
												if (!options->includeSatellite[epoch->sat[i].GNSS][epoch->sat[i].PRN]) {
													epoch->sat[i].available=0;
													continue;
												}
												//Initialize SBAScorr struct
												initSBAScorrections(&SBAScorr);	

												epoch->sat[i].available=1; //Set the satellite as available
												ret1 = computeSBAS1F(epoch,&products,&productsKlb,NULL,NULL,NULL,NULL,i,C1C,SBASdatabox.SBASdata,&SBAScorr,options);
												if ( ret1 <= 0 ) {
													epoch->sat[i].available=0;
													if (ret1>-47) { //Return -47 and -48 are discarded satellites due to elevation mask or not visible
														#if defined _OPENMP
															//For multi-threading, the reduction clause does not allow to use variables on structures
															numsatdiscardedSBAS++;
														#else
															epoch->numsatdiscardedSBAS++;
														#endif
													}
												} else {
													//Save SBAS sigma in epoch structure
													//Sanity check for the case all the sigmas are set to 0
													if(SBAScorr.SBASsatsigma2==0.) {
														//Set a sigma of 1 mm to avoid dividing by 0
														SBAScorr.SBASsatsigma2=0.001*0.001;
													}
													epoch->sat[i].measurementWeights[0]=sqrt(SBAScorr.SBASsatsigma2);
													//The following section is only executed in single threaded mode.
													//In multithreaded mode, it will be done outside the the for loop to avoid a hard
													//performance impact due to the synchronization for exclusive area
													#if !defined _OPENMP
														epoch->usableSatellites++;
														if (epoch->constellationUsed[epoch->sat[i].GNSS]==0) {
															if (epoch->sat[i].GNSS!=options->ClkRefPriorityList[0] && options->GNSSclockSource[options->ClkRefPriorityList[0]][epoch->sat[i].GNSS]==ClkSrcCalculate) {
																epoch->numInterSystemClocksFilter++;
																epoch->InterSystemClocksPosDOP[epoch->sat[i].GNSS]=k;
																k++;
															}
															epoch->constellationUsed[epoch->sat[i].GNSS]=1;
														}
													#endif
												}

												if ( options->printSBASUNSEL == 1 ) {
													if(ret1==1) ret1=0;
													printSBASUNSEL(epoch,i,ret1,SBASdatabox.SBASdata,&SBAScorr,options);
												}
											}
											//The following section is only executed in single threaded only if we are in multithread mode
											//This is done in single threaded mode to avoid synchronization penalties, but it is slower
											//than the single mode because we need to repeat the for loop
											#if defined _OPENMP
												for(i=0;i<epoch->numSatellites;i++) {
													if (epoch->sat[i].available==1) {
														epoch->usableSatellites++;
														if (epoch->constellationUsed[epoch->sat[i].GNSS]==0) {
															if (epoch->sat[i].GNSS!=options->ClkRefPriorityList[0] && options->GNSSclockSource[options->ClkRefPriorityList[0]][epoch->sat[i].GNSS]==ClkSrcCalculate) {
																epoch->numInterSystemClocksFilter++;
																epoch->InterSystemClocksPosDOP[epoch->sat[i].GNSS]=k;
																k++;
															}
															epoch->constellationUsed[epoch->sat[i].GNSS]=1;
														}
													}
												}
												epoch->numsatdiscardedSBAS=numsatdiscardedSBAS;
											#endif
										} else {
											//GEO below elevation threshold. Set all satellites discarded by SBAS (so GEO change can be done)
											epoch->numsatdiscardedSBAS=epoch->numSatellites;
										}
										if(epoch->usableSatellites>=(4+epoch->numInterSystemClocksFilter)) {
											currenthour=(int)((double)(currenttime)/3600.);
											retsbas=calculateSBASAvailability(fdSBASDiscont,fdSBASDiscontHour[currenthour],latPos,lonPos,latitude,longitude,epoch,SBASplots,options);
											if (retsbas<0) {
												//If solution is not available due to high DOP, high protection levels or matrix not invertible, try to switch GEO
												 if (epoch->SwitchPossible==1) {
													retsbas = SwitchSBASGEOMode(epoch,epoch->usableSatellites,epoch->numsatdiscardedSBAS,SBASdatabox.SBASdata,options);
													if (retsbas==1) {
														//Fill the number of satellites with the current PRN mask
														SetSatellitesSBASPlotsMode(epoch,SBASdatabox.SBASdata,options);
														options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
													}
												 } else {
													retsbas=0;
													break;
												}
											} else {
												break;
											}
										} else if (epoch->SwitchPossible==1) {
											retsbas = SwitchSBASGEOMode(epoch,epoch->usableSatellites,epoch->numsatdiscardedSBAS,SBASdatabox.SBASdata,options);
											if (retsbas==1) {
												//Fill the number of satellites with the current PRN mask
												SetSatellitesSBASPlotsMode(epoch,SBASdatabox.SBASdata,options);
												options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
											}
										} else {
											retsbas=0;
											break;
										}
									 } while (retsbas==1); //Repeat loop only if GEO has changed
								} else {
									//SBAS DFMC processing
									do {
										//Set available satellites to 0
										epoch->usableSatellites=0;
										#if defined _OPENMP
											numsatdiscardedSBAS=0;
										#else
											epoch->numsatdiscardedSBAS=0;
										#endif
										//Check GEO is in view
										//If GEO elevation filter is disabled, SBASplots->GEOelevNullPos will be 0 and it will always read position 0,0,0
										if (SBASplots->GEOelevPos[(options->GEOindex-1)*SBASplots->GEOelevNullPos][latPos*SBASplots->GEOelevNullPos][lonPos*SBASplots->GEOelevNullPos]>=options->SBASPlotsMinGEOElev) {
											//Reset values for computing the number of inter-system clock bias
											k=FIRST_POS_IS_CLK;
											for(i=0;i<MAX_GNSS;i++) {
												epoch->constellationUsed[i]=0;
												epoch->InterSystemClocksPosDOP[i]=-1;
											}
											epoch->numInterSystemClocksFilter=0;
											epoch->InterSystemClocksPosDOP[options->ClkRefPriorityList[0]]=3;
											
											//Model each satellite. Unselect it if it is not in view or below the elevation mask
											#pragma omp parallel for private(ret1,SBAScorr) reduction(+:numsatdiscardedSBAS)
											for(i=0;i<epoch->numSatellites;i++) {
												// Check if satellite has been deselected
												if (!options->includeSatellite[epoch->sat[i].GNSS][epoch->sat[i].PRN]) {
													epoch->sat[i].available=0;
													continue;
												}
												//Initialize SBAScorr struct
												initSBAScorrections(&SBAScorr);	

												epoch->sat[i].available=1; //Set the satellite as available
												ret1 = computeSBASDFMC(epoch,&products,i,SBASdatabox.SBASdata,&SBAScorr,options);
												if ( ret1 <= 0 ) {
													epoch->sat[i].available=0;
													if (ret1>=-26) { //Return -26 and -27 are discarded satellites due to elevation mask or not visible
														#if defined _OPENMP
															//For multi-threading, the reduction clause does not allow to use variables on structures
															numsatdiscardedSBAS++;
														#else
															epoch->numsatdiscardedSBAS++;
														#endif
													}
												} else {
													//Save SBAS sigma in epoch structure
													//Sanity check for the case all the sigmas are set to 0
													if(SBAScorr.SBASsatsigma2==0.) {
														//Set a sigma of 1 mm to avoid dividing by 0
														SBAScorr.SBASsatsigma2=0.001*0.001;
													}
													epoch->sat[i].measurementWeights[0]=sqrt(SBAScorr.SBASsatsigma2);
													//The following section is only executed in single threaded mode.
													//In multithreaded mode, it will be done outside the the for loop to avoid a hard
													//performance impact due to the synchronization for exclusive area
													#if !defined _OPENMP
														epoch->usableSatellites++;
														if (epoch->constellationUsed[epoch->sat[i].GNSS]==0) {
															if (epoch->sat[i].GNSS!=options->ClkRefPriorityList[0] && options->GNSSclockSource[options->ClkRefPriorityList[0]][epoch->sat[i].GNSS]==ClkSrcCalculate) {
																epoch->numInterSystemClocksFilter++;
																epoch->InterSystemClocksPosDOP[epoch->sat[i].GNSS]=k;
																k++;
															}
															epoch->constellationUsed[epoch->sat[i].GNSS]=1;
														}
													#endif
												}

												if ( options->printSBASDFMCUNSEL == 1 ) {
													if(ret1==1) ret1=0;
													printSBASDFMCUNSEL(epoch,i,ret1,SBASdatabox.SBASdata,&SBAScorr,options);
												}
											}
											//The following section is only executed in single threaded only if we are in multithread mode
											//This is done in single threaded mode to avoid synchronization penalties, but it is slower
											//than the single mode because we need to repeat the for loop
											#if defined _OPENMP
												for(i=0;i<epoch->numSatellites;i++) {
													if (epoch->sat[i].available==1) {
														epoch->usableSatellites++;
														if (epoch->constellationUsed[epoch->sat[i].GNSS]==0) {
															if (epoch->sat[i].GNSS!=options->ClkRefPriorityList[0] && options->GNSSclockSource[options->ClkRefPriorityList[0]][epoch->sat[i].GNSS]==ClkSrcCalculate) {
																epoch->numInterSystemClocksFilter++;
																epoch->InterSystemClocksPosDOP[epoch->sat[i].GNSS]=k;
																k++;
															}
															epoch->constellationUsed[epoch->sat[i].GNSS]=1;
														}
													}
												}
												epoch->numsatdiscardedSBAS=numsatdiscardedSBAS;
											#endif
										} else {
											//GEO below elevation threshold. Set all satellites discarded by SBAS (so GEO change can be done)
											epoch->numsatdiscardedSBAS=epoch->numSatellites;
										}
										if(epoch->usableSatellites>=(4+epoch->numInterSystemClocksFilter)) {
											currenthour=(int)((double)(currenttime)/3600.);
											retsbas=calculateSBASAvailability(fdSBASDiscont,fdSBASDiscontHour[currenthour],latPos,lonPos,latitude,longitude,epoch,SBASplots,options);
											if (retsbas<0) {
												//If solution is not available due to high DOP, high protection levels or matrix not invertible, try to switch GEO
												 if (epoch->SwitchPossible==1) {
													retsbas = SwitchSBASGEOMode(epoch,epoch->usableSatellites,epoch->numsatdiscardedSBAS,SBASdatabox.SBASdata,options);
													if (retsbas==1) {
														//Fill the number of satellites with the current PRN mask
														SetSatellitesSBASPlotsMode(epoch,SBASdatabox.SBASdata,options);
														options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
													}
												 } else {
													retsbas=0;
													break;
												}
											} else {
												break;
											}
										} else if (epoch->SwitchPossible==1) {
											retsbas = SwitchSBASGEOMode(epoch,epoch->usableSatellites,epoch->numsatdiscardedSBAS,SBASdatabox.SBASdata,options);
											if (retsbas==1) {
												//Fill the number of satellites with the current PRN mask
												SetSatellitesSBASPlotsMode(epoch,SBASdatabox.SBASdata,options);
												options->GEOPRN=SBASdatabox.SBASdata[options->GEOindex].PRN;
											}
										} else {
											retsbas=0;
											break;
										}
									 } while (retsbas==1); //Repeat loop only if GEO has changed
								}
							} //End for(longitude=options->minLonplots
						} // End for(latitude=options->minLatplots...
					} //End if (epoch->numSatellites==0) 
				} //End if(options->NoAvailabilityPlot==0)
			} //End if(currenttime%options->AvailPlotTimeStep==0)

			//Compute SBAS iono corrections availability every 5 minutes (300 seconds)
			if(options->NoIonoPlot==0) {
				if(currenttime%options->IonoPlotTimeStep==0) {
					totalIonoEpochs++;
					if(options->SBASHourlyMaps==1) {
						if (currenttime%3600==0) {
							//We are the beginning of the hour
							if (currenttime!=InitialSBASPlotsEpoch) {
								//It is not the first epoch
								currenthour=(int)((double)(currenttime)/3600.)-1;
								writeSBASIonoAvailFile(fdSBASIonoHour[currenthour],epoch,SBASplots,totalIonoEpochsHourly,currenthour,options);
								fclose(fdSBASIonoHour[currenthour]);
								for(k=0;k<SBASplots->IonoLatSize;k++) {
									for(l=0;l<SBASplots->IonoLonSize;l++) {
										SBASplots->IonoNumEpochsAvailHourly[k][l]=0;
									}
								}
								totalIonoEpochsHourly=0;
							}
						}
					}
					totalIonoEpochsHourly++;
					//Loop for latitude
					latPos=-1;
					for(latitude=options->minLatplots;latitude<=options->maxLatplots;latitude+=options->IonoPlotStep) {
						latPos++;

						//Loop for longitude
						lonPos=-1;
						for(longitude=options->minLonplots;longitude<=options->maxLonplots;longitude+=options->IonoPlotStep) {
							lonPos++;
							if (options->NumSBASPlotsExclusionArea>0 && options->NumSBASPlotsInclusionArea>0) {
								//Inclusion area. Only do areas inside the given region
								InsideInclusionArea=0;
								for(k=0;k<options->NumSBASPlotsInclusionArea;k++) {
									if (longitude>=options->SBASPlotsInclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsInclusionAreaDelimeters[k][1]) {
										if (latitude>=options->SBASPlotsInclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsInclusionAreaDelimeters[k][3]) {
											InsideInclusionArea=1;
											break;
										}
									}
								}
								if (InsideInclusionArea==0) continue;
								//Exclusion area. Do not process area inside exclusion area
								InsideExclusionArea=0;
								for(k=0;k<options->NumSBASPlotsExclusionArea;k++) {
									if (longitude>=options->SBASPlotsExclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsExclusionAreaDelimeters[k][1]) {
										if (latitude>=options->SBASPlotsExclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsExclusionAreaDelimeters[k][3]) {
											InsideExclusionArea=1;
											break;
										}
									}
								}
								if (InsideExclusionArea==1) continue;
							} else if (options->NumSBASPlotsExclusionArea>0) {
								//Exclusion area. Do not process area inside exclusion area
								InsideExclusionArea=0;
								for(k=0;k<options->NumSBASPlotsExclusionArea;k++) {
									if (longitude>=options->SBASPlotsExclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsExclusionAreaDelimeters[k][1]) {
										if (latitude>=options->SBASPlotsExclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsExclusionAreaDelimeters[k][3]) {
											InsideExclusionArea=1;
											break;
										}
									}
								}
								if (InsideExclusionArea==1) continue;
							} else if (options->NumSBASPlotsInclusionArea>0) {
								//Inclusion area. Only do areas inside the given region
								InsideInclusionArea=0;
								for(k=0;k<options->NumSBASPlotsInclusionArea;k++) {
									if (longitude>=options->SBASPlotsInclusionAreaDelimeters[k][0] && longitude<=options->SBASPlotsInclusionAreaDelimeters[k][1]) {
										if (latitude>=options->SBASPlotsInclusionAreaDelimeters[k][2] && latitude<=options->SBASPlotsInclusionAreaDelimeters[k][3]) {
											InsideInclusionArea=1;
											break;
										}
									}
								}
								if (InsideInclusionArea==0) continue;
							}
							//Initialize SBAScorr struct
							initSBAScorrections(&SBAScorr);	
							//Set flag to indicate that we are just computing SBAS iono availability
							//In this case, the Pierce Point is given by our current latitude and longitude
							SBAScorr.SBASplotIonoAvail=1;
							//Reset number of switches (in normal positioning mode, num switches is tied to epoch, not to latitude and longitude)
							epoch->ResetNumSwitch=1;
							if (options->switchGEO == 1) epoch->SwitchPossible=1;	//Enable switches in current epoch (only applicable if mode or GEO switch is enabled)
							//Save Pierce Point in epoch structure
							epoch->IPPlat=latitude;
							epoch->IPPlon=longitude;
							//Do While loop to allow switching GEO in processing
							do {
								//Check GEO elevation
								if (SBASplots->GEOelevPosIono[(options->GEOindex-1)*SBASplots->GEOelevNullPos][latPos*SBASplots->GEOelevNullPos][lonPos*SBASplots->GEOelevNullPos]>=options->SBASPlotsMinGEOElev) {
									//Compute Iono availability. As we are fixing the Pierce Point, we only need to do it for one satellite
									ret1 = SBASionoModel(epoch,0,&ionoerror,&SBAScorr,SBASdatabox.SBASdata,options);	
								} else {
									ret1=9999;
								}
								//Save result
								if(ret1!=9999 && ionoerror==1) {
									//Ionosphere available
									SBASplots->IonoNumEpochsAvail[latPos][lonPos]++;
									if(options->SBASHourlyMaps==1) {
										SBASplots->IonoNumEpochsAvailHourly[latPos][lonPos]++;
									}
									retsbas=0;
									break;
								} else if (epoch->SwitchPossible==1) {
									//Set 100 satellites discarded by SBAS to let know the function SwitchSBASGEOMode
									//that we want to change GEO in the computation of SBAS Iono availability
									retsbas = SwitchSBASGEOMode(epoch,3,100,SBASdatabox.SBASdata,options); 
								} else {
									retsbas=0;
									break;
								}
							} while (retsbas==1); //Repeat loop only if GEO has changed
						} //End for(longitude=options->minLonplots
					} //End for(latitude=options->minLatplots
				} //End if(currenttime%options->IonoPlotTimeStep==0) 
			} //End  if(options->NoIonoPlot==0)
		} //End for loop of time

		//Write files and close them
		if(options->NoAvailabilityPlot==0) {
			writeSBASAvailFile(fdSBASAvail,fdSBASRisk,fdSBASRiskMar,fdSBASDiscont,fdSBASHDOP,fdSBASPDOP,fdSBASGDOP,fdSBASCombDOP,epoch,SBASplots,totalAvailabilityEpochs,-1,options);
			fclose(fdSBASAvail);
			if(options->NoContRiskPlot==0) {
				fclose(fdSBASRisk);
			}
			if(options->NoContRiskMarPlot==0) {
				fclose(fdSBASRiskMar);
			}
			if (options->ComputeRiskPlots==1) {
				fclose(fdSBASDiscont);
			}
			if (options->HDOPPlot==1) {
				fclose(fdSBASHDOP);
			}
			if (options->PDOPPlot==1) {
				fclose(fdSBASPDOP);
			}
			if (options->GDOPPlot==1) {
				fclose(fdSBASGDOP);
			}
			if (options->CombinedDOPPlot==1) {
				fclose(fdSBASCombDOP);
			}

			if(options->SBASHourlyMaps==1) {
				writeSBASAvailFile(fdSBASAvailHour[23],fdSBASRiskHour[23],fdSBASRiskMarHour[23],fdSBASDiscontHour[23],fdSBASHDOPHour[23],fdSBASPDOPHour[23],fdSBASGDOPHour[23],fdSBASCombDOPHour[23],epoch,SBASplots,totalAvailabilityEpochsHourly,23,options);
				fclose(fdSBASAvailHour[23]);
				if(options->NoContRiskPlot==0) {
					fclose(fdSBASRiskHour[23]);
				}
				if(options->NoContRiskMarPlot==0) {
					fclose(fdSBASRiskMarHour[23]);
				}
				if (options->ComputeRiskPlots==1) {
					fclose(fdSBASDiscontHour[23]);
				}
				if (options->HDOPPlot==1) {
					fclose(fdSBASHDOPHour[23]);
				}
				if (options->PDOPPlot==1) {
					fclose(fdSBASPDOPHour[23]);
				}
				if (options->GDOPPlot==1) {
					fclose(fdSBASGDOPHour[23]);
				}
				if (options->CombinedDOPPlot==1) {
					fclose(fdSBASCombDOPHour[23]);
				}
			}

		}
		if(options->NoIonoPlot==0) {
			writeSBASIonoAvailFile(fdSBASIono,epoch,SBASplots,totalIonoEpochs,-1,options);
			fclose(fdSBASIono);
			if(options->SBASHourlyMaps==1) {
				//Write the remaining file of hour 23
				writeSBASIonoAvailFile(fdSBASIonoHour[23],epoch,SBASplots,totalIonoEpochsHourly,23,options);
				fclose(fdSBASIonoHour[23]);
			}

		}

		//Free memory
		freeSBASPlotsData(SBASplots,options);
		free(SBASplots);

	} //End if (options->workMode == wmSBASPLOTS )

	if (printProgress) {
		if (options->workMode == wmSBASPLOTS ) {
			if (options->ProgressEndCharac=='\r') {
				fprintf(options->terminalStream,"Current Epoch: %d (0 epochs left) / %02d:%02d:%02d (00:00:00 left) (100%%)%10s%c",currenttime,(int)(currenttime/3600.),(int)(currenttime/60.)%60,currenttime%60,"",options->ProgressEndCharac);
			} else {
				fprintf(options->terminalStream,"Current Epoch: %5d (%5d epochs left) / %02d:%02d:%02d (00:00:00 left) (%5.1f)%10s%c",currenttime,0,(int)(currenttime/3600.),(int)(currenttime/60.)%60,currenttime%60,100.0,"",options->ProgressEndCharac);
			}
		} else if ( options->workMode != wmCOMPAREORBITS && options->workMode != wmSHOWPRODUCT ) {
			fprintf(options->terminalStream,"%.56s (100%%)%10s%c",Epochstr,"",options->ProgressEndCharac);
		}
		//The fflush_function of the terminal is to avoid flickering of the cursor due to the high output write rate
		fflush_function(options->terminalStream);
	}

	// We might have the case that the observation file has been processed but there is still data in the SBAS file.
	// If we have to print a RINEXB, or EMS or Pegasus file, then we have to read the rest of the file
	if ( options->SBAScorrections>=SBASionoOnly && (options->writeRinexBfile || options->writeEMSfile || options->writePegasusfile) ) {
		epoch->t.MJDN = -2;
		epoch->t.SoD  = 0.0;
		readSBASFile(sopt->sbasFile,&SBASdatabox,&rinexBVersion,&epoch->t,options);
	} else if (options->SBAScorrections>=SBASionoOnly) {
		//Special call to close all files in case they have not been already closed and free used memory
		readSBASFile(NULL,NULL,&rinexBVersion,&epoch->t,options);
	}

	// Close files
	if ( fdRNX != NULL)			fclose(fdRNX);
	if ( fdRNXdgnss != NULL)	fclose(fdRNXdgnss);
	if ( fdRNXNeq != NULL )		fclose(fdRNXNeq);
	if ( fdRNXKlb != NULL )		fclose(fdRNXKlb);
	if ( fdRNXBei != NULL)		fclose(fdRNXBei);
	if ( fdSP3 != NULL )		fclose(fdSP3);
	if ( fdSP3o != NULL )		fclose(fdSP3o);
	if ( fdCLK != NULL )		fclose(fdCLK);
	if ( fdRTCM != NULL )		fclose(fdRTCM);
	if ( fdRTCM2 != NULL )		fclose(fdRTCM2);
	if ( fdRTCM3 != NULL )		fclose(fdRTCM3);
	if ( fdRNXglonav != NULL )	fclose(fdRNXglonav);
	if ( fdOutRefFile !=NULL)   fclose(fdOutRefFile);
	if ( fdNoise !=NULL)		fclose(fdNoise);

	for(i=0;i<sopt->numNav;i++) {
		if ( fdRNXnav[i] != NULL) {
			fclose(fdRNXnav[i]);
		}
	}
	for(i=0;i<sopt->numNavHealth;i++) {
		if ( fdRNXHealthPPP[i] != NULL) {
			fclose(fdRNXHealthPPP[i]);
		}
	}

	if (options->stanfordesa>=3) {
		//Enable again Stanford-ESA if it had been disabled in DGNSS mode when solution is in SPP or due to no position from reference file
		options->stanfordesa=1;
	}

	if ( options->stanfordesa == 1 ) {

		// Write Stanford-ESA values
		writeStdESA(fdstdESA,&StdESA);

		fclose(fdstdESA);
		if (options->stanfordesaLOI == 1) {
			fclose(options->fdstdESALOI);
		}

		//Using 'm' to avoid warning about comparing signed integer with unsigned integer
		for ( m = 0; m < StdESA.numpixelver; m++ ) {
			free(StdESA.counthor[m]);
			free(StdESA.countver[m]);
		}
		free(StdESA.counthor);
		free(StdESA.countver);
		free(StdESA.k);
		free(StdESA.kmask);
		for(i=0;i<StdESA.numUsablesSatellites;i++) {
			free(StdESA.G[i]);
		}
		free(StdESA.G);
	}

	if(options->fdkml!=NULL) {
		//Insert XML closing tags and close file
		writeKMLtags(options->fdkml,epoch,sopt->obsFile,1,0,VERSION,options);
	}

	if(options->fdkml0!=NULL) {
		//Insert XML closing tags and close file
		writeKMLtags(options->fdkml0,epoch,sopt->obsFile,1,1,VERSION,options);
	}

	//Free memory for KML data
	if (options->fdkml!=NULL || options->fdkml0!=NULL) {
		for(i=0;i<epoch->numKMLData;i++) {
			free(epoch->KMLData[i]);
		}

		free(epoch->KMLData);
		free(epoch->KMLTime);

		if(options->fdkml!=NULL) {
			fclose(options->fdkml);
		}
		if(options->fdkml0!=NULL) {
			fclose(options->fdkml0);
		}
	}

	if(fdOutSP3!=NULL) {
		//Insert EOF at the end and close file
		writeSP3file(fdOutSP3,epoch, solution,&prevUnkinfo,1,VERSION,options);
		fclose(fdOutSP3);
	}

	// Print summary
	if (options->useDatasummary == 1 || (options->printSummary==1 && Summary==1)) {
		summaryPrinted=1;
		if (printProgress) {
			if (options->ProgressEndCharac=='\r') {		
				//Print message of computing summary only if we are printing to screen
				fprintf(options->terminalStream,"RINEX data processing finished. Computing Summary...%40s%c","",options->ProgressEndCharac);
				fflush_function(options->terminalStream);
			}
		}
	   	if (options->SBAScorrections>=SBAS1Fused) {
			printSBASSummary(StartTimeRealPCTime,&ProcTimeLength,&PosProcTime,epoch,&SBASdatabox,&StdESA,options);
			free(SBASdatabox.HPL);
			free(SBASdatabox.VPL);
			free(SBASdatabox.HIR);
			free(SBASdatabox.VIR);
		} else if (options->DGNSS==1) {
			printDGNSSSummary(StartTimeRealPCTime,&ProcTimeLength,&PosProcTime,epoch,epochDGNSS,&StdESA,options);
		} else {
			printSummary(StartTimeRealPCTime,&ProcTimeLength,&PosProcTime,epoch,&StdESA,options);
		}
		//Free memory
		free(epoch->NError);
		free(epoch->EError);
		free(epoch->HError);
		free(epoch->VError);
		free(epoch->Error3D);
		free(epoch->HDOP);
		free(epoch->PDOP);
		free(epoch->GDOP);
		free(epoch->TDOP);
		free(epoch->VDOP);
		for(i=0;i<MAX_GNSS;i++) {
			free(epoch->NumSatUsedGNSS[i]);
			free(epoch->NumSatNotUsedGNSS[i]);
		}
		for(m=0;m<epoch->numconstCombUsed;m++) {
			free(epoch->constCombinationText[m]);
		}
		for(m=0;m<epoch->numconstCombNotUsed;m++) {
			free(epoch->constNotUsedCombinationText[m]);
		}
		free(epoch->constCombinationText);
		free(epoch->constCombination);
		free(epoch->numEpochsconstCombination);
		free(epoch->constNotUsedCombinationText);
		free(epoch->constNotUsedCombination);
		free(epoch->numEpochsconstNotUsedCombination);
		free(epoch->NumSatUsed);
		free(epoch->NumSatNotUsed);
		free(epoch->NumConstUsed);
		free(epoch->NumConstNotUsed);
	}
	//Free SBASdatabox data
	if (SBASdatabox.numlinesmissing!=NULL) {
		free(SBASdatabox.numlinesmissing);
	}
	if (SBASdatabox.missingmessagesvector!=NULL) {
		free(SBASdatabox.missingmessagesvector);
	}
	if (SBASdatabox.sbasblock!=NULL) {
		free(SBASdatabox.sbasblock);
	}
	if (SBASdatabox.ionobuffer!=NULL) {
		for(m=0;m<MAX_SBAS_PRN;m++) {
			for(i=0;i<11;i++) {
				/*for(j=0;j<14;j++) {
					for(k=0;k<15;k++) {
						free(SBASdatabox.ionobuffer[m][i][j].ionodelayparameters[k]);
					}
					free(SBASdatabox.ionobuffer[m][i][j].ionodelayparameters);
				}*/
				free(SBASdatabox.ionobuffer[m][i]);
			}
			free(SBASdatabox.ionobuffer[m]);
		}
		free(SBASdatabox.ionobuffer);
	}

	for(i=0;i<MAX_LINES_BUFFERED_SBAS_MESSAGES;i++) {
		free(SBASdatabox.bufferlines[i]);
	}
	free(SBASdatabox.SBASdata);
	//Free memory used for EPOCHSAT message printing order
	if (options->printSatellites==1 && options->workMode!=wmSBASPLOTS && options->workMode!=wmCOMPAREORBITS && options->workMode!=wmSHOWPRODUCT) {
		for(i=0;i<epoch->numMeasAllGNSSIndexed;i++) {
			free(epoch->SmoothMeasCodeAllGNSSIndexed[i]);
			free(epoch->PosSmoothCodeAllGNSS2Index[i]);
		}
		free(epoch->SmoothMeasCodeAllGNSSIndexed);
		free(epoch->PosSmoothCodeAllGNSS2Index);
		free(epoch->numMeasSmoothAllGNSSIndexed);
		free(epoch->MeasCodeAllGNSSIndexed);
		free(epoch->MeasStrAllGNSSIndexed);
		free(epoch->MeasStrSmoothAllGNSSIndexed);
		free(epoch->printTypeAllGNSSAllIndexed);
	}
	//Free ANTEX data
	if(sopt->antFile[0] != '\0'|| sopt->conFile[0] != '\0') {
		freeANTEXdata(&constellation,&antennaList);
	}
	if ( sopt->antsatblockFile[0] != '\0' ) {
		freeANTEXdata(&constellationSatBlock,&antennaListSatBlock);
	}

	//Free SP3 data
	if (products.SP3==nextSP3Prod.SP3) {
		nextSP3Prod.SP3=NULL;
	}
	if (products.SP3==pastSP3Prod.SP3) {
		pastSP3Prod.SP3=NULL;
	}
	freeSP3data(&pastSP3Prod);
	freeSP3data(&nextSP3Prod);
	freeSP3data(&products);

	//Free GLONASS data for frequency factors
	if (productsGLO.BRDC!=NULL) {
		freeBRDCproducts(FREEALLNAV,&productsGLO);
		free(productsGLO.BRDC);
	}
	//Free broadcast products for health for PPP
	if (productsHealthforPPP.BRDC!=NULL) {
		freeBRDCproducts(FREEALLNAV,&productsHealthforPPP);
		free(productsHealthforPPP.BRDC);
	}

	//Free BRDC data
	if(products.BRDC!=NULL) {
		freeBRDCproducts(FREEALLNAV,&products);
		free(products.BRDC);
	}
	//Free Klobuchar products data
	if (productsKlb.BRDC==products.BRDC) {
		productsKlb.BRDC=NULL;
	} else {
		freeBRDCproducts(FREEALLNAV,&productsKlb);
		free(productsKlb.BRDC);
	}
	//Free Nequick products data
	if (productsNeq.BRDC==products.BRDC) {
		productsNeq.BRDC=NULL;
	} else {
		freeBRDCproducts(FREEALLNAV,&productsNeq);
		free(productsNeq.BRDC);
	}
	//Free BeiDou products data
	if (productsBei.BRDC==products.BRDC) {
		productsBei.BRDC=NULL;
	} else {
		freeBRDCproducts(FREEALLNAV,&productsBei);
		free(productsBei.BRDC);
	}

	//Free broadcast TGD products data
	if (productsTgd.BRDC!=NULL) {
		freeBRDCproducts(FREEALLNAV,&productsTgd);
		free(productsTgd.BRDC);
	}
	if (tgdData.BRDC==products.BRDC) {
		tgdData.BRDC=NULL;
	} else if (tgdData.BRDC==productsTgd.BRDC) {
		tgdData.BRDC=NULL;
	} else {
		//Function freeBRDCproducts expects a TGNSS structure, but TGD is inside a TTGDdata structure
		//We will assign the pointer from tgdData.BRDC to products.BRDC so it can be freed (products.BRDC has been already freed)
		products.BRDC=tgdData.BRDC;
		freeBRDCproducts(FREEALLNAV,&products);
		free(tgdData.BRDC);
	}
	//Free CODE DCB TGD
	if (tgdData.DCB!=NULL) {
		free(tgdData.DCB);
	}
	//Free SINEX BIAS data
	freeSINEXBIASData(&tgdData.SNXBias);

	//Free IONEX data
	if (ionex.map!=NULL) {
		for (i=0;i<ionex.numMaps;i++) {
			free(ionex.map[i].TEC);
			free(ionex.map[i].RMS);
			free(ionex.map[i].HGT);
		}
		if (ionex.ionexStation!=NULL) {
			free(ionex.ionexStation);
		}
		free(ionex.map);
	}
	if (productsIonex.map==ionex.map) {
		productsIonex.map=NULL;
	} else {
		for (i=0;i<productsIonex.numMaps;i++) {
			free(productsIonex.map[i].TEC);
			free(productsIonex.map[i].RMS);
			free(productsIonex.map[i].HGT);
		}
		if (productsIonex.ionexStation!=NULL) {
			free(productsIonex.ionexStation);
		}
		free(productsIonex.map);
	}
	//Free Fast-PPP iono file data
	if(fppp.map!=NULL) {
		for (i=0;i<fppp.numMapsAlloc;i++) {
			free(fppp.map[i].TEC);
			free(fppp.map[i].SIGMA);
		}
		free(fppp.map);
	}
	if (productsFppp.map==fppp.map) {
		productsFppp.map=NULL;
	} else {
		for (i=0;i<productsFppp.numMapsAlloc;i++) {
			free(productsFppp.map[i].TEC);
			free(productsFppp.map[i].SIGMA);
		}
		free(productsFppp.map);
	}
	//Free reference position data
	freeSP3data(&ReferencePos);

	//Free user added error data
	if (UserError.totalactiveErrors>0) {
		for (i=0;i<NUMERRORFUNCTIONS;i++) {
			if (UserError.activeErrorsStart[i]==NULL) continue;
			free(UserError.activeErrorsStart[i]);
			free(UserError.activeErrorsEnd[i]);
			free(UserError.measType[i]);
			free(UserError.measFreq[i]);
			free(UserError.System[i]);
			free(UserError.PRN[i]);
			for(j=0;j<UserError.numactiveErrors[i];j++) {
				free(UserError.ErrorParam[i][j]);
			}
			free(UserError.ErrorParam[i]);
		}
	}


	//Free SINEX data
	if(stationList.station!=NULL) {
		free(stationList.station);
	}

	//Free GPS receiver types file
	if (recList.rec!=NULL) {
		free(recList.rec);
	}


	//Free data por EPOCHSAT print
	if (options->printSatellites==1) {
		for(i=0;i<epoch->maxNumMeasAllGNSSIndexed;i++) {
			for(j=0;j<MAX_GNSS;j++) {
				free(epoch->PRNMeasUsed[i][j]);
				free(epoch->PRNMeasUnused[i][j]);
			}
			free(epoch->PRNMeasUsed[i]);
			free(epoch->PRNMeasUnused[i]);
			free(epoch->numSatsMeasUsed[i]);
			free(epoch->numSatsMeasUnused[i]);
		}
		free(epoch->PRNMeasUsed);
		free(epoch->PRNMeasUnused);
		free(epoch->numSatsMeasUsed);
		free(epoch->numSatsMeasUnused);
	}

	//Free epoch structures
	if ( options->DGNSS ) {
		if (epoch->receiver.RecStationCoord!=NULL) {
			for(i=0;i<epoch->receiver.numRecStation;i++) {
				free(epoch->receiver.RecStationCoord[i]);
			}
			free(epoch->receiver.RecStationCoord);
			free(epoch->receiver.ChangedStaEpoch);
		}
		free(epochDGNSS);
	}
	freeDataforGEOselection(epoch);
	free(epoch->epochReadFilePos);
	free(epoch);
	//Free rtcm struct
	free(rtcm2);
	free(rtcm3);
	//Free solution struct
	free(solution);

	if (options->workMode!=wmDOPROCESSING && options->printInfo==1) {
		//Print processing time for SBAS plots, wmSHOWINPUT, wmSHOWPRODUCT and wmCOMPAREORBITS modes
		computeProcessingTime(StartTimeRealPCTime,&totalprocessingTime,1,options);
	} else if (summaryPrinted==1) {
		//Print processing time for wmDOPROCESSING mode (SPP,PPP,SBAS,DGNSS). The processing time and
		//last line of summary are printed here so the processing time for freeing is captured
		computeProcessingTime(StartTimeRealPCTime,&totalprocessingTime,1,options);
		if (options->printV5format==0) {
			sprintf(&messagestr[PosProcTime],"%*.3f",ProcTimeLength,(double)(totalprocessingTime)/1.0E6);
			messagestr[PosProcTime+ProcTimeLength]=' '; //To remove null character introduced by the sprint above
		}
		fprintf(options->outFileStream,"%s",messagestr);
	}
	if (printProgress) {
		if (options->ProgressEndCharac=='\r') {		
			//This is to clear terminal for characters after finishing (in Windows is not necessary as it adds a newline when the process finishes)
			fprintf(options->terminalStream,"%95s%c","",options->ProgressEndCharac); 
		}
		#if !defined (__WIN32__)
			//Enable cursor if necessary
			if (sopt->disableCursor==1) {
				fprintf(options->terminalStream,"%s",enableCursor);
			}
			fflush_function(options->terminalStream);
		#endif
	}
	//Close terminal stream if it had been manually opened
	if (printProgress!=0 && options->OutputToTerminal==0 && options->terminalStream!=NULL) {
		fclose(options->terminalStream);
	}

	//Free memory used for reading parameters
	freeInputMeasString(sopt);
	//Free sopt struct
	free(sopt);
	//Free options structure
	freeOptions(options);
	free(options);

	return 0;
}
